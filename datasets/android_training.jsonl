{"instruction": "Write a Kotlin class for Android that implements `SensorEventListener` to listen for Accelerometer data and log the X, Y, and Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerLogger(context: Context) : SensorEventListener {\n\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        \n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = (Math.min(width, height) / 2f) * 0.8f\n\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Create a Kotlin Flow that emits location updates using the Android `FusedLocationProviderClient` within a `callbackFlow`.", "output": "import android.annotation.SuppressLint\nimport android.location.Location\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.Priority\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.callbackFlow\n\n@SuppressLint(\"MissingPermission\") // Assume permissions handled externally\nfun getLocationFlow(client: FusedLocationProviderClient): Flow<Location> = callbackFlow {\n    val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n        .build()\n\n    val callback = object : LocationCallback() {\n        override fun onLocationResult(result: LocationResult) {\n            result.lastLocation?.let { trySend(it) }\n        }\n    }\n\n    client.requestLocationUpdates(locationRequest, callback, null)\n\n    awaitClose {\n        client.removeLocationUpdates(callback)\n    }\n}"}
{"instruction": "Implement a basic CameraX preview setup in an Android Activity using Kotlin.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\n\nclass CameraActivity : AppCompatActivity() {\n    private lateinit var viewFinder: PreviewView\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        viewFinder = PreviewView(this)\n        setContentView(viewFinder)\n        startCamera()\n    }\n\n    private fun startCamera() {\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\n\n        cameraProviderFuture.addListener({\n            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n            val preview = Preview.Builder().build().also {\n                it.setSurfaceProvider(viewFinder.surfaceProvider)\n            }\n            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n            try {\n                cameraProvider.unbindAll()\n                cameraProvider.bindToLifecycle(this, cameraSelector, preview)\n            } catch(exc: Exception) {\n                exc.printStackTrace()\n            }\n        }, ContextCompat.getMainExecutor(this))\n    }\n}"}
{"instruction": "Create a Kotlin class that implements SensorEventListener to read Accelerometer data on Android.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass AccelerometerHandler(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                println(\"Accelerometer: x=$x, y=$y, z=$z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin function to get the last known location using the FusedLocationProviderClient.", "output": "import android.Manifest\nimport android.content.Context\nimport android.content.pm.PackageManager\nimport android.location.Location\nimport androidx.core.app.ActivityCompat\nimport com.google.android.gms.location.LocationServices\n\nfun getLastKnownLocation(context: Context, onSuccess: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    \n    if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && \n        ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n        // Permissions not granted, handle accordingly\n        return\n    }\n\n    fusedLocationClient.lastLocation.addOnSuccessListener { location: Location? ->\n        // Got last known location. In some rare situations this can be null.\n        onSuccess(location)\n    }\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Ambient Light Sensor and log the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current Lux: $lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin Lifecycle component in Kotlin that displays a Toast when the plugin is loaded.", "output": "package com.atakmap.android.plugin.hello\n\nimport android.content.Context\nimport android.widget.Toast\nimport com.atakmap.android.maps.MapCore\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.app.preferences.ToolsPreferenceFragment\nimport com.atakmap.coremap.log.Log\nimport is.arontibo.library.ElasticDownloadView\nimport com.atakmap.android.dropdown.DropDownMapComponent\n\nclass HelloLifecycle : DropDownMapComponent() {\n\n    private var context: Context? = null\n    private var mapView: MapView? = null\n\n    override fun onCreate(context: Context, intent: android.content.Intent, view: MapView) {\n        super.onCreate(context, intent, view)\n        this.context = context\n        this.mapView = view\n        \n        Toast.makeText(context, \"Hello ATAK Plugin Loaded\", Toast.LENGTH_LONG).show()\n        Log.d(\"HelloLifecycle\", \"Plugin created\")\n    }\n\n    override fun onDestroyImpl(context: Context, view: MapView) {\n        super.onDestroyImpl(context, view)\n        Log.d(\"HelloLifecycle\", \"Plugin destroyed\")\n    }\n}"}
{"instruction": "Write a Kotlin snippet for Android to retrieve the battery percentage using `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\nimport android.os.Build\n\nfun getBatteryPercentage(context: Context): Int {\n    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n}"}
{"instruction": "Write an ATAK Kotlin snippet to add a custom Map Widget (text label) to the top-left corner of the MapView.", "output": "import android.graphics.Color\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.widgets.TextWidget\nimport com.atakmap.android.widgets.RootLayoutWidget\n\nfun addStatusWidget(mapView: MapView) {\n    val textWidget = TextWidget(\"Status: Active\", 1)\n    textWidget.color = Color.GREEN\n    textWidget.setTextSize(32f)\n    \n    // Get the root layout of the map\n    val rootLayout = mapView.componentExtra as? RootLayoutWidget\n    \n    // Add widget to top left (x=10, y=10)\n    rootLayout?.let {\n        it.addWidget(textWidget)\n        it.positionWidget(textWidget, 10f, 10f, RootLayoutWidget.TopLeft)\n    }\n}"}
{"instruction": "Write a Kotlin Android function to check if the device supports Biometric Authentication (Fingerprint/Face).", "output": "import android.content.Context\nimport androidx.biometric.BiometricManager\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> true\n        else -> false\n    }\n}"}
{"instruction": "Implement an ATAK BroadcastReceiver in Kotlin to listen for a specific 'SHOW_PLUGIN_PANE' intent.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.atakmap.android.ipc.AtakBroadcast\n\nclass PluginReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.plugin.SHOW_PLUGIN_PANE\") {\n            Log.d(\"PluginReceiver\", \"Received request to show plugin pane\")\n            // Logic to open DropDownReceiver or Toggle Tool would go here\n        }\n    }\n\n    fun register() {\n        AtakBroadcast.DocumentedIntentFilter(\"com.atakmap.android.plugin.SHOW_PLUGIN_PANE\")\n            .also { filter ->\n                AtakBroadcast.getInstance().registerReceiver(this, filter)\n            }\n    }\n\n    fun unregister() {\n        AtakBroadcast.getInstance().unregisterReceiver(this)\n    }\n}"}
{"instruction": "Implement a Jetpack Compose Composable in Kotlin that displays a live camera preview using CameraX.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\n\n@Composable\nfun CameraPreview() {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val context = LocalContext.current\n    val cameraProviderFuture = remember { ProcessCameraProvider.getInstance(context) }\n\n    AndroidView(\n        factory = { ctx ->\n            val previewView = PreviewView(ctx)\n            val executor = ContextCompat.getMainExecutor(ctx)\n            cameraProviderFuture.addListener({\n                val cameraProvider = cameraProviderFuture.get()\n                val preview = Preview.Builder().build().also {\n                    it.setSurfaceProvider(previewView.surfaceProvider)\n                }\n                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n                try {\n                    cameraProvider.unbindAll()\n                    cameraProvider.bindToLifecycle(\n                        lifecycleOwner,\n                        cameraSelector,\n                        preview\n                    )\n                } catch (e: Exception) {\n                    e.printStackTrace()\n                }\n            }, executor)\n            previewView\n        }\n    )\n}"}
{"instruction": "Write a Kotlin snippet for an ATAK plugin to programmatically add a red marker to the map at specific coordinates.", "output": "import com.atakmap.android.maps.Marker\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.android.maps.MapGroup\n\nfun addRedMarker(mapView: MapView, lat: Double, lon: Double, title: String) {\n    // Create the point\n    val point = GeoPoint(lat, lon)\n    \n    // Create the marker\n    val marker = Marker(point, java.util.UUID.randomUUID().toString())\n    marker.title = title\n    marker.type = \"a-u-G\" // Atom, unit, Ground\n    marker.setMetaString(\"color\", \"-65536\") // Red integer color\n    marker.setMetaBoolean(\"readiness\", true)\n    marker.setMetaBoolean(\"archive\", true)\n    \n    // Add to the Root Group (displays immediately)\n    val rootGroup = mapView.rootGroup\n    rootGroup.addItem(marker)\n}"}
{"instruction": "Write a Kotlin function using the Android FusedLocationProviderClient to retrieve the device's last known location.", "output": "import android.annotation.SuppressLint\nimport android.content.Context\nimport android.location.Location\nimport com.google.android.gms.location.LocationServices\n\n// Requires ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION permission\n@SuppressLint(\"MissingPermission\")\nfun getLastKnownLocation(context: Context, onSuccess: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    \n    fusedLocationClient.lastLocation\n        .addOnSuccessListener { location: Location? ->\n            // Got last known location. In some rare situations this can be null.\n            onSuccess(location)\n        }\n        .addOnFailureListener {\n            // Handle failure\n            onSuccess(null)\n        }\n}"}
{"instruction": "Write a Kotlin snippet to start a low-latency Bluetooth LE scan looking for devices with a specific service UUID.", "output": "import android.bluetooth.BluetoothAdapter\nimport android.bluetooth.le.ScanCallback\nimport android.bluetooth.le.ScanFilter\nimport android.bluetooth.le.ScanResult\nimport android.bluetooth.le.ScanSettings\nimport android.os.ParcelUuid\nimport java.util.UUID\n\nfun startBleScan(serviceUuid: UUID, callback: ScanCallback) {\n    val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()\n    val scanner = bluetoothAdapter.bluetoothLeScanner\n\n    val filter = ScanFilter.Builder()\n        .setServiceUuid(ParcelUuid(serviceUuid))\n        .build()\n\n    val settings = ScanSettings.Builder()\n        .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n        .build()\n\n    try {\n        scanner.startScan(listOf(filter), settings, callback)\n    } catch (e: SecurityException) {\n        // Handle missing BLUETOOTH_SCAN permission\n    }\n}"}
{"instruction": "Write a Kotlin function for an ATAK plugin to generate and dispatch a 'hostile' CoT (Cursor on Target) event at the user's self-location.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.android.cot.CotMapComponent\nimport com.atakmap.android.maps.MapView\n\nfun dispatchHostileCot(mapView: MapView) {\n    // Get Self Location\n    val selfMarker = mapView.selfMarker\n    val point = selfMarker.point\n\n    // Create Event\n    val cotEvent = CotEvent()\n    cotEvent.uid = java.util.UUID.randomUUID().toString()\n    cotEvent.type = \"a-h-G\" // Atom, Hostile, Ground\n    cotEvent.time = com.atakmap.coremap.maps.time.CoordinatedTime()\n    cotEvent.start = cotEvent.time\n    cotEvent.stale = cotEvent.time.addMinutes(10)\n    cotEvent.how = \"h-g-i-g-o\" // Human, GPS, Ins, GPS, Other\n    \n    // Set Point\n    cotEvent.point = CotPoint(point.latitude, point.longitude, point.hae, point.ce, point.le)\n\n    // Dispatch\n    CotMapComponent.getDispatcher().dispatch(cotEvent)\n}"}
{"instruction": "Implement a Kotlin function using Android CameraX to start a camera preview inside a PreviewView.", "output": "import androidx.camera.core.Preview\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch(exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Create a Kotlin function for an ATAK (Android Team Awareness Kit) plugin that places a Marker (Red Icon) on the map at a specific coordinate.", "output": "import com.atakmap.android.maps.Marker\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.android.icons.UserIcon\n\nfun addRedMarker(mapView: MapView, lat: Double, lon: Double, uid: String) {\n    val point = GeoPoint(lat, lon)\n    val marker = Marker(point, uid)\n    \n    // Set standard red icon path (internal ATAK resource)\n    marker.setMetaString(\"iconUri\", UserIcon.GetIconBitmapPath(UserIcon.IconColor.RED))\n    marker.type = \"a-u-G\"\n    marker.title = \"Plugin Marker\"\n    marker.setMetaBoolean(\"readiness\", true)\n    marker.setMetaBoolean(\"archive\", true)\n\n    // Add to the root group of the map\n    mapView.rootGroup.addItem(marker)\n}"}
{"instruction": "Implement a Kotlin class that implements SensorEventListener to read the Ambient Light Sensor on Android.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorListener : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin BroadcastReceiver for an ATAK plugin that listens for internal CoT (Cursor on Target) events.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport com.atakmap.coremap.cot.event.CotEvent\nimport android.util.Log\n\nclass CotEventListener : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.cot.COT_EVENT\") {\n            val cotEvent = intent.getParcelableExtra<CotEvent>(\"com.atakmap.coremap.cot.event.CotEvent\")\n            if (cotEvent != null) {\n                Log.d(\"ATAK_PLUGIN\", \"Received CoT Event: ${cotEvent.type} from ${cotEvent.uid}\")\n                // Process the event (e.g., check if it is a hostile track)\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Kotlin function to authenticate a user using Android BiometricPrompt (Fingerprint/Face).", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\nimport java.util.concurrent.Executor\n\nfun authenticateUser(activity: FragmentActivity, onSuccess: () -> Unit) {\n    val executor: Executor = ContextCompat.getMainExecutor(activity)\n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                // Handle error\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric Login\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create a Kotlin layout inflater for an ATAK Plugin Tool that includes a Spinner (Dropdown).", "output": "import android.content.Context\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.widget.ArrayAdapter\nimport android.widget.Spinner\nimport com.atakmap.android.maps.MapView\n\nfun createPluginToolView(context: Context, mapView: MapView): View {\n    // Assuming a layout file named 'plugin_tool_layout.xml' exists with a Spinner id 'layerSpinner'\n    val inflater = LayoutInflater.from(context)\n    val view = inflater.inflate(com.atakmap.android.plugin.R.layout.plugin_tool_layout, null)\n\n    val spinner: Spinner = view.findViewById(com.atakmap.android.plugin.R.id.layerSpinner)\n    val options = listOf(\"Layer A\", \"Layer B\", \"Layer C\")\n    \n    // Use ATAK context for styling if available, otherwise plugin context\n    val adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, options)\n    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\n    spinner.adapter = adapter\n\n    return view\n}"}
{"instruction": "Implement a Kotlin class `CompassSensor` that uses Android's `SensorManager` to read the device's azimuth (compass heading) using the accelerometer and magnetometer.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass CompassSensor(context: Context, private val onAzimuthChanged: (Float) -> Unit) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n    private val magnetometer = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)\n\n    private var gravity: FloatArray? = null\n    private var geomagnetic: FloatArray? = null\n\n    fun start() {\n        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)\n        sensorManager.registerListener(this, magnetometer, SensorManager.SENSOR_DELAY_UI)\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) gravity = it.values\n            if (it.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) geomagnetic = it.values\n\n            if (gravity != null && geomagnetic != null) {\n                val R = FloatArray(9)\n                val I = FloatArray(9)\n                if (SensorManager.getRotationMatrix(R, I, gravity, geomagnetic)) {\n                    val orientation = FloatArray(3)\n                    SensorManager.getOrientation(R, orientation)\n                    // orientation[0] is azimuth in radians\n                    val azimuth = Math.toDegrees(orientation[0].toDouble()).toFloat()\n                    onAzimuthChanged((azimuth + 360) % 360)\n                }\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n}"}
{"instruction": "Create a Kotlin function using `BiometricPrompt` to authenticate a user on Android.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\n\nfun authenticateUser(activity: FragmentActivity, onSuccess: () -> Unit, onError: (String) -> Unit) {\n    val executor = ContextCompat.getMainExecutor(activity)\n    \n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                onError(errString.toString())\n            }\n\n            override fun onAuthenticationFailed() {\n                super.onAuthenticationFailed()\n                onError(\"Authentication failed\")\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric Login\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create a BroadcastReceiver in Kotlin to listen for battery level changes and determine if the device is charging.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\n\nclass BatteryLevelReceiver(private val onBatteryStatusChanged: (Boolean, Float) -> Unit) : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        val isCharging: Boolean = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                                  status == BatteryManager.BATTERY_STATUS_FULL\n\n        val level: Int = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n        val scale: Int = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        val batteryPct: Float = level / scale.toFloat()\n\n        onBatteryStatusChanged(isCharging, batteryPct)\n    }\n}"}
{"instruction": "Write a Kotlin class for an Android application that implements `SensorEventListener` to log changes from the Ambient Light sensor.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorListener(private val sensorManager: SensorManager) : SensorEventListener {\n\n    fun startListening() {\n        val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a Kotlin function to programmatically add a `SpotMapItem` (a marker) to the ATAK MapView at a specific coordinate.", "output": "import com.atakmap.android.maps.MapView\nimport com.atakmap.android.maps.SpotMapItem\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.coremap.maps.coords.GeoPointMetaData\nimport java.util.UUID\n\nfun addMarkerToMap(mapView: MapView, lat: Double, lon: Double, title: String) {\n    val point = GeoPoint(lat, lon)\n    val item = SpotMapItem(UUID.randomUUID().toString(), null, title)\n    \n    // Set the location\n    val geoPointMetaData = GeoPointMetaData.wrap(point)\n    item.point = geoPointMetaData\n    \n    // Set type (e.g., neutral point of interest)\n    item.type = \"u-d-p\"\n    item.visible = true\n    \n    // Add to the map's root group\n    mapView.rootGroup.addItem(item)\n}"}
{"instruction": "Create a minimal Android RecyclerView Adapter in Kotlin for a list of Strings.", "output": "import android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.TextView\nimport androidx.recyclerview.widget.RecyclerView\n\nclass SimpleAdapter(private val dataSet: List<String>) :\n    RecyclerView.Adapter<SimpleAdapter.ViewHolder>() {\n\n    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val textView: TextView = view.findViewById(android.R.id.text1)\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(android.R.layout.simple_list_item_1, parent, false)\n        return ViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.textView.text = dataSet[position]\n    }\n\n    override fun getItemCount() = dataSet.size\n}"}
{"instruction": "Write a Kotlin function for an Android app to register a listener for the Proximity sensor and log changes.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nfun registerProximityListener(sensorManager: SensorManager) {\n    val proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY)\n    \n    val sensorEventListener = object : SensorEventListener {\n        override fun onSensorChanged(event: SensorEvent) {\n            if (event.sensor.type == Sensor.TYPE_PROXIMITY) {\n                val distance = event.values[0]\n                Log.d(\"SensorApp\", \"Proximity distance: $distance\")\n            }\n        }\n\n        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n            // Handle accuracy changes if necessary\n        }\n    }\n\n    sensorManager.registerListener(sensorEventListener, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL)\n}"}
{"instruction": "Write a Kotlin code snippet to programmatically add a `Marker` (CoT item) to the ATAK map at a specific coordinate.", "output": "import com.atakmap.android.maps.MapView\nimport com.atakmap.android.maps.Marker\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.coremap.maps.assets.Icon\nimport java.util.UUID\n\nfun addMarkerToMap(mapView: MapView, lat: Double, lon: Double, title: String) {\n    val point = GeoPoint(lat, lon)\n    val uid = UUID.randomUUID().toString()\n    \n    val marker = Marker(point, uid)\n    marker.title = title\n    marker.type = \"a-u-G\" // Atom, unit, Ground\n    marker.setMetaString(\"how\", \"h-g-i-g-o\")\n    \n    // Refresh the map group to display the marker\n    mapView.rootGroup.addItem(marker)\n}"}
{"instruction": "Create a custom native Android View in Kotlin that draws a red circle on a canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val radius = (Math.min(width, height) / 2).toFloat()\n        canvas.drawCircle((width / 2).toFloat(), (height / 2).toFloat(), radius, paint)\n    }\n}"}
{"instruction": "Create a Jetpack Compose (Kotlin) Composable that displays the current battery level using the Android `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.material.Text\n\n@Composable\nfun BatteryLevelDisplay() {\n    val context = LocalContext.current\n    var batteryLevel by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n        batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n    }\n\n    Text(text = \"Battery Level: $batteryLevel%\")\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Ambient Light sensor and log the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current Light Level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin Lifecycle class in Kotlin that logs when the plugin is loaded and unloaded.", "output": "package com.atakmap.android.helloworld.plugin\n\nimport com.atakmap.android.maps.MapActivity\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\nimport com.atakmap.app.system.SystemComponent\nimport android.content.Context\n\nclass HelloWorldLifecycle(private val context: Context) : SystemComponent {\n\n    private var mapView: MapView? = null\n\n    override fun onCreate(context: Context, intent: android.content.Intent, view: MapView, args: android.os.Bundle?) {\n        // Called when the plugin is initialized\n        this.mapView = view\n        Log.d(TAG, \"HelloWorld Plugin Loaded\")\n        \n        // Initialize tools, overlays, or receivers here\n    }\n\n    override fun onDestroy(context: Context, view: MapView) {\n        // Called when the plugin is unloaded\n        Log.d(TAG, \"HelloWorld Plugin Unloaded\")\n        \n        // Clean up resources\n        this.mapView = null\n    }\n\n    override fun onStart(context: Context, view: MapView) {}\n    override fun onStop(context: Context, view: MapView) {}\n    override fun onPause(context: Context, view: MapView) {}\n    override fun onResume(context: Context, view: MapView) {}\n\n    companion object {\n        private const val TAG = \"HelloWorldLifecycle\"\n    }\n}"}
{"instruction": "Write a Kotlin Android custom View that draws a simple red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(width, height) / 4f\n        \n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Create a function in ATAK (Kotlin) to construct and broadcast a basic 'Friendly' Cursor on Target (CoT) event at a specific lat/lon.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.comms.CommsMapComponent\nimport com.atakmap.coremap.maps.time.CoordinatedTime\n\nfun broadcastFriendlyCoT(lat: Double, lon: Double, uid: String) {\n    val event = CotEvent()\n    val time = CoordinatedTime()\n    \n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-f-G-U-C\" // Atom, Friendly, Ground, Unit, Combat\n    event.time = time\n    event.start = time\n    event.stale = time.addMinutes(10)\n    event.how = \"h-g-i-g-o\" // Human input\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    if (CommsMapComponent.getDispatcher() != null) {\n        CommsMapComponent.getDispatcher().dispatch(event)\n    }\n}"}
{"instruction": "Write a Kotlin Android BroadcastReceiver to detect when the device battery is low.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport android.widget.Toast\n\nclass BatteryLowReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (Intent.ACTION_BATTERY_LOW == intent.action) {\n            Log.w(\"BatteryMonitor\", \"Battery is critically low!\")\n            Toast.makeText(context, \"Battery Low! Save your work.\", Toast.LENGTH_LONG).show()\n        }\n    }\n}"}
{"instruction": "Create an ATAK DropDownReceiver in Kotlin to show a custom view when a specific tool is activated from the toolbar.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport android.view.LayoutInflater\nimport com.atakmap.android.dropdown.DropDownReceiver\nimport com.atakmap.android.maps.MapView\n\nclass MyPluginDropDown(mapView: MapView, private val context: Context) : \n    DropDownReceiver(mapView) {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (!isClosed) {\n            closeDropDown()\n            return\n        }\n        \n        // Inflate your custom layout\n        // Ensure you have a layout file named plugin_layout.xml\n        // val view = LayoutInflater.from(this.context).inflate(R.layout.plugin_layout, null)\n        \n        // For demo, we just use a generic View if layout isn't present in this snippet\n        val view = View(this.context)\n        \n        showDropDown(view, 0.5, true, -1.0, -1.0)\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n}"}
{"instruction": "Implement a Kotlin class in Android that implements SensorEventListener to log Accelerometer data (X, Y, Z coordinates).", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.util.Log\n\nclass AccelerometerLogger : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a Kotlin function to display a BiometricPrompt (Fingerprint/FaceID) for authentication in an Android Fragment.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.Fragment\n\nfun Fragment.authenticateUser(onSuccess: () -> Unit) {\n    val executor = ContextCompat.getMainExecutor(requireContext())\n    val biometricPrompt = BiometricPrompt(this, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create an Android Kotlin Activity snippet that reads the ambient Light Sensor (Lux) value.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current Light Level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n}"}
{"instruction": "Implement a Kotlin Android Activity that uses the SensorManager to listen to the Light Sensor. Update the background color of the screen to black if the lux value is below 10, and white otherwise.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport android.graphics.Color\nimport androidx.appcompat.app.AppCompatActivity\nimport android.view.View\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n    private lateinit var rootLayout: View\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        rootLayout = View(this)\n        setContentView(rootLayout)\n\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            if (lux < 10) {\n                rootLayout.setBackgroundColor(Color.BLACK)\n            } else {\n                rootLayout.setBackgroundColor(Color.WHITE)\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // No action needed\n    }\n}"}
{"instruction": "Create a simple Android Service in Kotlin that tracks location in the background using FusedLocationProviderClient and logs the coordinates.", "output": "import android.app.Service\nimport android.content.Intent\nimport android.os.IBinder\nimport android.util.Log\nimport com.google.android.gms.location.*\n\nclass LocationService : Service() {\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\n    private lateinit var locationCallback: LocationCallback\n\n    override fun onCreate() {\n        super.onCreate()\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\n        \n        locationCallback = object : LocationCallback() {\n            override fun onLocationResult(locationResult: LocationResult) {\n                for (location in locationResult.locations) {\n                    Log.d(\"LocService\", \"Lat: ${location.latitude}, Lon: ${location.longitude}\")\n                }\n            }\n        }\n\n        startLocationUpdates()\n    }\n\n    private fun startLocationUpdates() {\n        try {\n            val locationRequest = LocationRequest.create().apply {\n                interval = 10000\n                fastestInterval = 5000\n                priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n            }\n            fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, null)\n        } catch (e: SecurityException) {\n            Log.e(\"LocService\", \"Permission missing\")\n        }\n    }\n\n    override fun onBind(intent: Intent?): IBinder? = null\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        fusedLocationClient.removeLocationUpdates(locationCallback)\n    }\n}"}
{"instruction": "Write a Kotlin function for an Android app that sets up a `SensorEventListener` to detect the Ambient Light sensor values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorManager(context: Context) : SensorEventListener {\n    private var sensorManager: SensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private var lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startListening() {\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin code snippet to check and request the `ACCESS_FINE_LOCATION` permission in Android using the Activity Result API.", "output": "import android.Manifest\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.result.contract.ActivityResultContracts\n\nclass LocationPermissionHelper(private val activity: ComponentActivity) {\n\n    private val requestPermissionLauncher = activity.registerForActivityResult(\n        ActivityResultContracts.RequestPermission()\n    ) { isGranted: Boolean ->\n        if (isGranted) {\n            Toast.makeText(activity, \"Location permission granted\", Toast.LENGTH_SHORT).show()\n            // Proceed with location logic\n        } else {\n            Toast.makeText(activity, \"Permission denied\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    fun checkAndRequestPermission() {\n        requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n    }\n}"}
{"instruction": "Write a Kotlin Android `BroadcastReceiver` that detects when the device is connected to power (charging).", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\nimport android.util.Log\n\nclass PowerConnectionReceiver : BroadcastReceiver() {\n\n    override fun onReceive(context: Context, intent: Intent) {\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        val isCharging: Boolean = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                                  status == BatteryManager.BATTERY_STATUS_FULL\n\n        if (isCharging) {\n            val chargePlug: Int = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1)\n            val usbCharge: Boolean = chargePlug == BatteryManager.BATTERY_PLUGGED_USB\n            val acCharge: Boolean = chargePlug == BatteryManager.BATTERY_PLUGGED_AC\n            \n            Log.d(\"PowerReceiver\", \"Device is charging via: ${if (usbCharge) \"USB\" else if (acCharge) \"AC\" else \"Other\"}\")\n        } else {\n            Log.d(\"PowerReceiver\", \"Device is not charging\")\n        }\n    }\n}"}
{"instruction": "Write a Kotlin snippet using Android CameraX to start a camera preview within a PreviewView.", "output": "import androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.core.content.ContextCompat\nimport kotlinx.android.synthetic.main.activity_main.* // Assuming view binding or synthetics\n\nfun startCamera() {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder()\n            .build()\n            .also {\n                it.setSurfaceProvider(viewFinder.surfaceProvider)\n            }\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(this, androidx.camera.core.CameraSelector.DEFAULT_BACK_CAMERA, preview)\n        } catch(exc: Exception) {\n            Log.e(\"CameraX\", \"Use case binding failed\", exc)\n        }\n    }, ContextCompat.getMainExecutor(this))\n}"}
{"instruction": "Write a Kotlin function to display an Android Biometric Authentication prompt.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\nfun showBiometricPrompt(activity: androidx.fragment.app.FragmentActivity) {\n    val executor = ContextCompat.getMainExecutor(activity)\n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                // Handle success\n            }\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                // Handle error\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Use account password\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Implement an Android SensorEventListener in Kotlin to read Ambient Light levels (Lux).", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorListener(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startListening() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val luxValue = event.values[0]\n            println(\"Current Light Level: $luxValue lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Kotlin function in Android to check if the device supports Biometric authentication (Fingerprint/Face).", "output": "import android.content.Context\nimport androidx.biometric.BiometricManager\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG or BiometricManager.Authenticators.DEVICE_CREDENTIAL)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> true\n        else -> false\n    }\n}"}
{"instruction": "Write an Android Kotlin Activity snippet that registers a listener for the Ambient Light Sensor.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin function using Android CameraX to bind the camera preview to a `PreviewView`.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch (exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Write a Kotlin function for Android that uses the SensorManager to listen to the Ambient Light Sensor and logs the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val luxValue = event.values[0]\n            Log.d(\"LightSensor\", \"Current Lux: $luxValue\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Kotlin snippet using Android's CameraX library to bind a camera preview to a `PreviewView`.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        // Used to bind the lifecycle of cameras to the lifecycle owner\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n\n        // Preview\n        val preview = Preview.Builder()\n            .build()\n            .also {\n                it.setSurfaceProvider(previewView.surfaceProvider)\n            }\n\n        // Select back camera as a default\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            // Unbind use cases before rebinding\n            cameraProvider.unbindAll()\n\n            // Bind use cases to camera\n            cameraProvider.bindToLifecycle(\n                lifecycleOwner, cameraSelector, preview)\n\n        } catch(exc: Exception) {\n            exc.printStackTrace()\n        }\n\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Implement a Kotlin Android BroadcastReceiver that listens for battery low events and executes a callback.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\n\nclass BatteryLevelReceiver(private val onLowBattery: () -> Unit) : BroadcastReceiver() {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == Intent.ACTION_BATTERY_LOW) {\n            onLowBattery()\n        }\n    }\n\n    fun register(context: Context) {\n        val filter = IntentFilter(Intent.ACTION_BATTERY_LOW)\n        context.registerReceiver(this, filter)\n    }\n\n    fun unregister(context: Context) {\n        context.unregisterReceiver(this)\n    }\n}"}
{"instruction": "Android (Kotlin): Implement a `SensorEventListener` to read Accelerometer data and log the X, Y, Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerTracker(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if needed\n    }\n}"}
{"instruction": "Android (Kotlin): Create a custom View that draws a pulsating circle using `Canvas` and `onDraw`.", "output": "import android.animation.ValueAnimator\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\nimport android.view.animation.LinearInterpolator\n\nclass PulsatingCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n    private var radius = 0f\n    private var maxRadius = 100f\n\n    init {\n        val animator = ValueAnimator.ofFloat(0f, maxRadius)\n        animator.duration = 1000\n        animator.repeatCount = ValueAnimator.INFINITE\n        animator.interpolator = LinearInterpolator()\n        animator.addUpdateListener { animation ->\n            radius = animation.animatedValue as Float\n            invalidate()\n        }\n        animator.start()\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "ATAK Plugin (Kotlin): Implement a Dropdown Receiver to show a native Android View within the ATAK Dropdown interface.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport android.widget.TextView\nimport com.atakmap.android.dropdown.Dropdown.OnStateListener\nimport com.atakmap.android.dropdown.DropdownReceiver\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\n\nclass MyPluginDropdown(mapView: MapView, private val pluginContext: Context) : \n    DropdownReceiver(mapView), OnStateListener {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (!isClosed) {\n            closeDropDown()\n        } else {\n            showDropDown(createView(), 0.5, -1.0, -1.0, 0.5)\n        }\n    }\n\n    private fun createView(): View {\n        val textView = TextView(pluginContext)\n        textView.text = \"Hello from ATAK Plugin\"\n        textView.textSize = 20f\n        return textView\n    }\n\n    override fun onDropdownClosed() {\n        Log.d(\"MyPlugin\", \"Dropdown closed\")\n    }\n\n    override fun disposeImpl() {}\n}"}
{"instruction": "Android (Kotlin): Authenticate a user using the BiometricPrompt API (Fingerprint/Face).", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\nimport java.util.concurrent.Executor\n\nfun authenticateUser(activity: FragmentActivity) {\n    val executor: Executor = ContextCompat.getMainExecutor(activity)\n    \n    val callback = object : BiometricPrompt.AuthenticationCallback() {\n        override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n            super.onAuthenticationError(errorCode, errString)\n            // Handle error\n        }\n\n        override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n            super.onAuthenticationSucceeded(result)\n            // Handle success\n        }\n    }\n\n    val biometricPrompt = BiometricPrompt(activity, executor, callback)\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Write a Kotlin snippet for an Android Activity to register a listener for the Ambient Light sensor.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor?\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin function using Jetpack's BiometricManager to check if the device hardware supports biometric authentication.", "output": "import androidx.biometric.BiometricManager\nimport android.content.Context\nimport android.util.Log\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> {\n            Log.d(\"BioAuth\", \"App can authenticate using biometrics.\")\n            true\n        }\n        BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {\n            Log.e(\"BioAuth\", \"No biometric features available on this device.\")\n            false\n        }\n        BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE -> {\n            Log.e(\"BioAuth\", \"Biometric features are currently unavailable.\")\n            false\n        }\n        BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {\n            Log.e(\"BioAuth\", \"The user hasn't associated any biometric credentials.\")\n            false\n        }\n        else -> false\n    }\n}"}
{"instruction": "Generate a programmatic 'Cursor on Target' (CoT) Event for a hostile unit at a specific Lat/Lon in ATAK using Kotlin.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.maps.time.CoTPoint\n\nfun createHostileCotEvent(lat: Double, lon: Double, uid: String): CotEvent {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-h-G\" // Atom - Hostile - Ground\n    event.time = CoTPoint(System.currentTimeMillis())\n    event.start = CoTPoint(System.currentTimeMillis())\n    event.stale = CoTPoint(System.currentTimeMillis() + 60000) // 1 minute stale\n    event.how = \"h-g-i-g-o\" // Human input\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n    \n    return event\n}"}
{"instruction": "Create a Kotlin BroadcastReceiver to detect when the device battery is low.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.widget.Toast\n\nclass BatteryLowReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (Intent.ACTION_BATTERY_LOW == intent.action) {\n            Toast.makeText(context, \"Battery is critically low!\", Toast.LENGTH_LONG).show()\n            // Perform power saving operations here\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Proximity Sensor and log when an object is 'NEAR'.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass ProximityDetector(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val proximitySensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY)\n\n    fun start() {\n        proximitySensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.values[0] < (proximitySensor?.maximumRange ?: 0f)) {\n                Log.d(\"Sensor\", \"Object is NEAR\")\n            } else {\n                Log.d(\"Sensor\", \"Object is FAR\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin `MapComponent` in Kotlin that logs a message when the plugin is added to the map.", "output": "package com.atakmap.android.plugintemplate\n\nimport android.content.Context\nimport android.content.Intent\nimport com.atakmap.android.maps.MapComponent\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\n\nclass PluginMapComponent : MapComponent {\n    private var context: Context? = null\n\n    override fun onCreate(context: Context, intent: Intent, view: MapView) {\n        this.context = context\n        Log.d(\"PluginMapComponent\", \"Plugin created and added to MapView\")\n        \n        // Initialize custom tools or overlays here\n    }\n\n    override fun onDestroy(context: Context, view: MapView) {\n        Log.d(\"PluginMapComponent\", \"Plugin destroyed\")\n        // Cleanup resources\n    }\n\n    override fun onStart(context: Context, view: MapView) {}\n    override fun onStop(context: Context, view: MapView) {}\n    override fun onPause(context: Context, view: MapView) {}\n    override fun onResume(context: Context, view: MapView) {}\n}"}
{"instruction": "Write a Kotlin function to programmatically generate a basic 'Cursor on Target' (CoT) event for ATAK.", "output": "import com.atakmap.coremap.cot.event.CotDetail\nimport com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.maps.time.CoTPointData\n\nfun createSelfCotEvent(lat: Double, lon: Double, uid: String): CotEvent {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-f-G-U-C\" // Friendly Ground Unit Combatant\n    event.time = CoTPointData.now()\n    event.start = CoTPointData.now()\n    event.stale = CoTPointData.now() + (10 * 60 * 1000) // 10 minutes from now\n    event.how = \"h-e\" // Human entered\n\n    // Set location\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    // Add details\n    val detail = CotDetail(\"detail\")\n    val contact = CotDetail(\"contact\")\n    contact.setAttribute(\"callsign\", \"Alpha-1\")\n    detail.addChild(contact)\n    event.detail = detail\n\n    return event\n}"}
{"instruction": "Write a Kotlin Activity snippet that checks for Biometric authentication availability and prompts the user to authenticate.", "output": "import androidx.biometric.BiometricManager\nimport androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\nfun authenticateUser() {\n    val executor = ContextCompat.getMainExecutor(this)\n    val biometricManager = BiometricManager.from(this)\n\n    if (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG) == BiometricManager.BIOMETRIC_SUCCESS) {\n        \n        val promptInfo = BiometricPrompt.PromptInfo.Builder()\n            .setTitle(\"Biometric Login\")\n            .setSubtitle(\"Log in using your credential\")\n            .setNegativeButtonText(\"Cancel\")\n            .build()\n\n        val biometricPrompt = BiometricPrompt(this, executor,\n            object : BiometricPrompt.AuthenticationCallback() {\n                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                    super.onAuthenticationSucceeded(result)\n                    // Handle success\n                }\n                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                    super.onAuthenticationError(errorCode, errString)\n                    // Handle error\n                }\n            })\n\n        biometricPrompt.authenticate(promptInfo)\n    }\n}"}
{"instruction": "Implement an ATAK `DropDownReceiver` in Kotlin to handle a tool interaction when a specific intent is broadcast.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport com.atakmap.android.dropdown.DropDownReceiver\nimport com.atakmap.android.maps.MapView\n\nclass MyPluginDropDownReceiver(mapView: MapView, context: Context) : \n    DropDownReceiver(mapView) {\n\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == \"com.atakmap.android.myplugin.SHOW_DROPDOWN\") {\n            if (!isClosed) {\n                // Already open\n                return\n            }\n            // Create your view content here\n            // val myView = ... \n            // showDropDown(myView, HALF_WIDTH, FULL_HEIGHT, FULL_WIDTH, HALF_HEIGHT)\n        }\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n\n    override fun onStateRequested(state: Int) {\n        if (state == DropDownReceiver.DROPDOWN_STATE_FULLSCREEN) {\n            // Handle resize request\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Android Service that reads the Ambient Light Sensor (Lux) in the background.", "output": "import android.app.Service\nimport android.content.Context\nimport android.content.Intent\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.IBinder\nimport android.util.Log\n\nclass LightSensorService : Service(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate() {\n        super.onCreate()\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensorService\", \"Current Lux: $lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n\n    override fun onDestroy() {\n        super.onDestroy()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onBind(intent: Intent?): IBinder? = null\n}"}
{"instruction": "Create a simple custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(cx, cy) / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Implement a basic ATAK MapComponent in Kotlin to register a tool in the overflow menu.", "output": "import android.content.Context\nimport android.content.Intent\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.ipc.AtakBroadcast\nimport com.atakmap.android.dropdown.DropDownMapComponent\nimport com.atakmap.app.preferences.ToolsPreferenceFragment\n\nclass PluginMapComponent : DropDownMapComponent() {\n    private var context: Context? = null\n\n    override fun onCreate(context: Context, intent: Intent, view: MapView) {\n        super.onCreate(context, intent, view)\n        this.context = context\n        \n        // Register a tool (icon) in the ATAK tool menu\n        ToolsPreferenceFragment.register(\n            ToolsPreferenceFragment.ToolPreference(\n                \"My Plugin Tool\",\n                \"Description of my tool\",\n                \"my.plugin.action\",\n                context.resources.getDrawable(R.drawable.ic_launcher),\n                null\n            )\n        )\n    }\n\n    override fun onDestroyImpl(context: Context, view: MapView) {\n        super.onDestroyImpl(context, view)\n    }\n}"}
{"instruction": "Implement an Android Activity method in Kotlin to listen to the ambient light sensor.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin class for Android that implements `SensorEventListener` to read data from the Accelerometer. It should have start and stop methods to manage battery life.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass AccelerometerReader(context: Context, private val onUpdate: (Float, Float, Float) -> Unit) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            onUpdate(x, y, z)\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Jetpack Compose function in Kotlin that uses `AndroidView` to display a CameraX `PreviewView`. This bridges the native Android View system with Compose.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\n\n@Composable\nfun CameraXPreview(modifier: Modifier = Modifier) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val context = LocalContext.current\n\n    AndroidView(\n        factory = { ctx ->\n            PreviewView(ctx).apply {\n                scaleType = PreviewView.ScaleType.FILL_CENTER\n                val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)\n                cameraProviderFuture.addListener({\n                    val cameraProvider = cameraProviderFuture.get()\n                    val preview = Preview.Builder().build().also {\n                        it.setSurfaceProvider(this.surfaceProvider)\n                    }\n                    try {\n                        cameraProvider.unbindAll()\n                        cameraProvider.bindToLifecycle(\n                            lifecycleOwner,\n                            CameraSelector.DEFAULT_BACK_CAMERA,\n                            preview\n                        )\n                    } catch (e: Exception) {\n                        // Handle binding errors\n                    }\n                }, ContextCompat.getMainExecutor(ctx))\n            }\n        },\n        modifier = modifier\n    )\n}"}
{"instruction": "Write a custom Android View in Kotlin that overrides `onDraw` to draw a pulsating circle. This demonstrates creating custom native UI components.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass PulsatingCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n    private var radius = 50f\n    private var expanding = true\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n\n        if (expanding) radius += 2 else radius -= 2\n        if (radius > 100f) expanding = false\n        if (radius < 50f) expanding = true\n\n        postInvalidateOnAnimation() // Trigger next frame\n    }\n}"}
{"instruction": "Create a Kotlin BroadcastReceiver to monitor the device's battery level and charging status. This is a system sensor task often used for optimizing app performance based on power state.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\n\nclass BatteryLevelReceiver(private val onBatteryUpdate: (Int, Boolean) -> Unit) : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val level: Int = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n        val scale: Int = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        \n        val batteryPct = if (level != -1 && scale != -1) {\n            (level * 100 / scale.toFloat()).toInt()\n        } else {\n            -1\n        }\n        \n        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                         status == BatteryManager.BATTERY_STATUS_FULL\n\n        onBatteryUpdate(batteryPct, isCharging)\n    }\n}\n\n// Register with: registerReceiver(batteryReceiver, IntentFilter(Intent.ACTION_BATTERY_CHANGED))"}
{"instruction": "Implement a Jetpack Compose Composable in Kotlin that displays a live camera preview using CameraX.", "output": "@Composable\nfun CameraPreview() {\n    val context = LocalContext.current\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val cameraProviderFuture = remember { ProcessCameraProvider.getInstance(context) }\n\n    AndroidView(\n        factory = { ctx ->\n            val previewView = PreviewView(ctx)\n            val executor = ContextCompat.getMainExecutor(ctx)\n            cameraProviderFuture.addListener({\n                val cameraProvider = cameraProviderFuture.get()\n                val preview = Preview.Builder().build().also {\n                    it.setSurfaceProvider(previewView.surfaceProvider)\n                }\n                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n                try {\n                    cameraProvider.unbindAll()\n                    cameraProvider.bindToLifecycle(\n                        lifecycleOwner,\n                        cameraSelector,\n                        preview\n                    )\n                } catch (e: Exception) {\n                    Log.e(\"CameraPreview\", \"Use case binding failed\", e)\n                }\n            }, executor)\n            previewView\n        },\n        modifier = Modifier.fillMaxSize()\n    )\n}"}
{"instruction": "Implement an Android BroadcastReceiver in Kotlin that listens for changes in battery status and logs the current percentage.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\nimport android.util.Log\n\nclass BatteryLevelReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == Intent.ACTION_BATTERY_CHANGED) {\n            val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n            val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n            \n            if (level != -1 && scale != -1) {\n                val batteryPct = (level / scale.toFloat()) * 100\n                Log.d(\"BatterySensor\", \"Current Battery Level: $batteryPct%\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Kotlin function using the Android SensorManager to listen for Ambient Light changes.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorListener(private val sensorManager: SensorManager) : SensorEventListener {\n    \n    fun startListening() {\n        val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Ambient light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin snippet for an ATAK plugin that constructs and broadcasts a 'GeoChat' CoT (Cursor on Target) message.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.cot.event.CotDetail\nimport com.atakmap.android.cot.CotMapComponent\nimport com.atakmap.coremap.maps.time.CoTPointData\n\nfun sendGeoChatMessage(message: String, lat: Double, lon: Double, uid: String) {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = java.util.UUID.randomUUID().toString()\n    event.type = \"b-t-f\" // Basic Chat Type\n    event.time = CoTPointData.now()\n    event.start = CoTPointData.now()\n    event.stale = CoTPointData.now() + (1000 * 60 * 5) // 5 mins stale\n    event.how = \"h-g-i-g-o\"\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    val detail = CotDetail(\"detail\")\n    val remarks = CotDetail(\"remarks\")\n    remarks.innerText = message\n    remarks.setAttribute(\"source\", uid)\n    detail.addChild(remarks)\n    \n    // ATAK specific chat structure usually requires a __chat parent, simplified here\n    val chatNode = CotDetail(\"__chat\")\n    chatNode.setAttribute(\"parent\", \"Root\")\n    chatNode.setAttribute(\"chatroom\", \"All Chat Rooms\")\n    chatNode.setAttribute(\"id\", uid)\n    chatNode.setAttribute(\"senderCallsign\", \"MyPlugin\")\n    detail.addChild(chatNode)\n\n    event.detail = detail\n\n    // Dispatch\n    CotMapComponent.getInternalDispatcher().dispatch(event)\n}"}
{"instruction": "Write a Kotlin class for Android that listens to the Accelerometer sensor and logs the X, Y, and Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerListener(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun start() {\n        accelerometer?.also { sensor ->\n            sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                Log.d(\"Accelerometer\", \"X: ${it.values[0]}, Y: ${it.values[1]}, Z: ${it.values[2]}\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(width, height) / 4f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Implement a Kotlin function using Android CameraX to bind a camera preview to a PreviewView.", "output": "import android.content.Context\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch (exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Create an ATAK DropDownReceiver class (Kotlin) used to handle UI interactions when a tool is activated.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.dropdown.DropDownReceiver\n\nclass MyPluginDropDownReceiver(mapView: MapView, context: Context) : \n    DropDownReceiver(mapView) {\n\n    private val pluginContext: Context = context\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.myplugin.SHOW_TOOL\") {\n            if (!isClosed) {\n                 // Already open, close it or toggle\n                closeDropDown()\n            } else {\n                setRetain(true)\n                // Inflate your custom view here\n                // val v = LayoutInflater.from(pluginContext).inflate(R.layout.my_view, null)\n                // showDropDown(v, HALF_WIDTH, FULL_HEIGHT, FULL_WIDTH, HALF_HEIGHT)\n            }\n        }\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n}"}
{"instruction": "Write a Kotlin class in Android that implements `SensorEventListener` to log accelerometer data (X, Y, Z) to the console.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerLogger : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK MapWidget in Kotlin that displays a red text label saying \"Status: Active\" at the top left of the map.", "output": "import com.atakmap.android.widgets.MapWidget\nimport com.atakmap.android.widgets.TextWidget\nimport android.graphics.Color\n\nclass StatusMapWidget : MapWidget() {\n    init {\n        name = \"Status Widget\"\n        val textWidget = TextWidget(\"Status: Active\", _face)\n        textWidget.color = Color.RED\n        // Set position relative to top-left\n        textWidget.point.set(10f, 10f)\n        this.addWidget(textWidget)\n    }\n}"}
{"instruction": "Create a Kotlin function to retrieve the current battery percentage on an Android device using `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\n\nfun getBatteryPercentage(context: Context): Int {\n    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n}"}
{"instruction": "Write an ATAK plugin snippet in Kotlin to register a listener for all incoming Cursor on Target (CoT) events.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotEventListener\nimport com.atakmap.comms.CotServiceRemote\n\nclass MyCotListener : CotEventListener {\n    override fun onCotEvent(event: CotEvent?, source: Any?) {\n        if (event != null) {\n            // Process the CoT event (e.g., check UID or type)\n            val type = event.type\n            val uid = event.uid\n        }\n    }\n}\n\n// Usage within Plugin Lifecycle\n// CotServiceRemote.getInstance().addCotEventListener(myCotListener)"}
{"instruction": "Implement a function in Kotlin using the Android Jetpack Location library to get the last known location.", "output": "import android.annotation.SuppressLint\nimport android.content.Context\nimport android.location.Location\nimport com.google.android.gms.location.LocationServices\n\n@SuppressLint(\"MissingPermission\") // Assume permissions are handled\nfun getLastKnownLocation(context: Context, callback: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    fusedLocationClient.lastLocation\n        .addOnSuccessListener { location: Location? ->\n            callback(location)\n        }\n}"}
{"instruction": "Define an ATAK `Tool` class in Kotlin that opens a custom \"Mission Planner\" view when the tool icon is clicked in the radial menu.", "output": "import com.atakmap.android.ipc.AtakBroadcast\nimport com.atakmap.android.tools.Tool\nimport android.content.Intent\nimport android.graphics.drawable.Drawable\n\nclass MissionPlannerTool(private val context: android.content.Context) : Tool {\n\n    override fun getName(): String = \"Mission Planner\"\n\n    override fun getIcon(): Drawable? {\n        // Return drawable resource here\n        return null \n    }\n\n    override fun onToolClicked() {\n        // Broadcast intent to open the specific plugin view\n        val intent = Intent(\"com.myplugin.OPEN_MISSION_PLANNER\")\n        AtakBroadcast.getInstance().sendBroadcast(intent)\n    }\n}"}
{"instruction": "Create a custom Application class configured for Hilt dependency injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here if needed\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'User' with a primary key, first name, and last name.", "output": "import androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a user and retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAll(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(user: User)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the User entity and version number.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            AppDatabase::class.java,\n            \"MyDatabase\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel that injects the UserDao and exposes a Flow of users.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users = userDao.getAll()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Set up an Android Activity using XML layouts that is injected by Hilt and retrieves the UserViewModel.", "output": "import android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Observe ViewModel data here\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that uses ViewBinding to access XML views.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentUserBinding\n\n@AndroidEntryPoint\nclass UserFragment : Fragment() {\n\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a Jetpack Compose Activity that uses Hilt to inject a ViewModel and displays a list of users.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeUserActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: UserViewModel = hiltViewModel()\n            val users = viewModel.users.collectAsState()\n\n            LazyColumn {\n                items(users.value) { user ->\n                    Text(text = \"${user.firstName} ${user.lastName}\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Repository class injected with the DAO to abstract data operations, using Hilt constructor injection.", "output": "import javax.inject.Inject\nimport javax.inject.Singleton\nimport kotlinx.coroutines.flow.Flow\n\n@Singleton\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<User>> = userDao.getAll()\n\n    suspend fun addUser(user: User) {\n        userDao.insert(user)\n    }\n}"}
{"instruction": "Create a basic Android Activity in Kotlin that uses ViewBinding to set the text of a TextView with the ID 'welcomeText' to 'Hello World'.", "output": "class MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.welcomeText.text = \"Hello World\"\n    }\n}"}
{"instruction": "Define a Room Database Entity named 'User' in Kotlin with a primary key 'id' (auto-generated) and columns for 'firstName' and 'lastName'.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface in Kotlin for the 'User' entity with methods to insert a user and get all users as a Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin, including the User entity and the abstract method to retrieve the UserDao.", "output": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide the singleton instance of the Room Database and the UserDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Setup the Application class for Hilt Dependency Injection in Kotlin.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic if needed\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a 'UserRepository' and exposes a StateFlow of users.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users: StateFlow<List<User>> = repository.getAllUsers()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            repository.insert(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin annotated with @AndroidEntryPoint that inflates a layout and observes a ViewModel.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Example observation logic\n        viewLifecycleOwner.lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.users.collect { users ->\n                    // Update UI with users list\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose Activity that displays a text 'Hello Compose' centered on the screen.", "output": "class ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Box(contentAlignment = Alignment.Center) {\n                        Text(text = \"Hello Compose\")\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Fragment code snippet that navigates to a detail fragment using Jetpack Navigation Component when a button is clicked.", "output": "class HomeFragment : Fragment(R.layout.fragment_home) {\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        val button = view.findViewById<Button>(R.id.btnGoToDetail)\n        button.setOnClickListener {\n            findNavController().navigate(R.id.action_homeFragment_to_detailFragment)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin setup for Hilt dependency injection.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Note' with a title, content, and an auto-generated ID.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Create a Data Access Object (DAO) interface for the Note entity with methods to insert a note and get all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id ASC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the Note entity and the DAO.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a Repository class that injects the DAO to abstract data access.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n    val allNotes: Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun addNote(note: Note) {\n        noteDao.insertNote(note)\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel that injects the Repository and exposes data using StateFlow.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.allNotes\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.addNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Write an XML layout file for an Activity containing a FragmentContainerView to host navigation fragments.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that uses ViewBinding to observe the ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.myapp.databinding.FragmentNoteBinding\n\n@AndroidEntryPoint\nclass NoteFragment : Fragment(R.layout.fragment_note) {\n\n    private val viewModel: NoteViewModel by viewModels()\n    private var _binding: FragmentNoteBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentNoteBinding.bind(view)\n\n        // Example observation logic\n        // lifecycleScope.launch { viewModel.notes.collect { ... } }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content view.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // AppTheme {\n            //     MainScreen()\n            // }\n        }\n    }\n}"}
{"instruction": "Create a simple Android Activity in Kotlin using ViewBinding to set the text of a TextView defined in the XML layout.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.app.databinding.ActivityMainBinding\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // Inflate the layout using ViewBinding\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // Access views directly through the binding object\n        binding.textViewWelcome.text = \"Hello, ViewBinding!\"\n    }\n}"}
{"instruction": "Define a Room Database Entity class in Kotlin representing a 'Task' with an auto-generated ID, a title, and a completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"task_title\")\n    val title: String,\n\n    @ColumnInfo(name = \"is_completed\")\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface in Kotlin with methods to insert a task, delete a task, and observe all tasks using Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks_table ORDER BY id ASC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin, including a Singleton pattern helper (though Hilt is preferred, show the standard Room setup logic).", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Set up the Application class for Hilt Dependency Injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass TodoApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"todo_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to inject a repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val allTasks = repository.allTasks\n\n    fun addTask(task: Task) = viewModelScope.launch {\n        repository.insert(task)\n    }\n}"}
{"instruction": "Write a basic Fragment in Kotlin that is annotated for Hilt and uses the 'by viewModels()' delegate to access the TaskViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    // Hilt automatically injects the ViewModel factory\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Observe data\n        // viewModel.allTasks.observe(viewLifecycleOwner) { ... }\n    }\n}"}
{"instruction": "Create an Activity in Kotlin that hosts a Jetpack Compose UI and is annotated with @AndroidEntryPoint for Hilt support.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(text = \"Hello from Jetpack Compose with Hilt!\")\n        }\n    }\n}"}
{"instruction": "Create a simple XML layout file for a Fragment containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab_add\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_add\"\n        android:contentDescription=\"Add Item\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Book' with an auto-generated primary key, title, and author.", "output": "@Entity(tableName = \"books\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"author\") val author: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a method to insert a generic object and a method to retrieve all items as a Flow.", "output": "@Dao\ninterface BookDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertBook(book: Book)\n\n    @Query(\"SELECT * FROM books\")\n    fun getAllBooks(): Flow<List<Book>>\n}"}
{"instruction": "Set up the Hilt Application class required to initialize dependency injection in an Android app.", "output": "@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide a singleton instance of the Room Database.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideBookDao(database: AppDatabase): BookDao {\n        return database.bookDao()\n    }\n}"}
{"instruction": "Implement a ViewModel in Kotlin that uses Hilt constructor injection to receive a Repository.", "output": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val mainRepository: MainRepository\n) : ViewModel() {\n\n    private val _books = MutableStateFlow<List<Book>>(emptyList())\n    val books: StateFlow<List<Book>> = _books.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            mainRepository.getBooks().collect {\n                _books.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Fragment in Kotlin using ViewBinding and annotate it for Hilt injection.", "output": "@AndroidEntryPoint\nclass BookListFragment : Fragment() {\n\n    private var _binding: FragmentBookListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentBookListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a snippet for an Activity XML layout containing a FragmentContainerView to host a Navigation Graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a generic Room TypeConverter in Kotlin to convert a Date object to a Long timestamp and vice versa.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Implement a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets a simple greeting content.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Create a Repository class in Kotlin that injects a DAO and exposes data to the ViewModel.", "output": "class MainRepository @Inject constructor(\n    private val bookDao: BookDao\n) {\n    fun getBooks(): Flow<List<Book>> {\n        return bookDao.getAllBooks()\n            .flowOn(Dispatchers.IO)\n    }\n\n    suspend fun addBook(book: Book) {\n        withContext(Dispatchers.IO) {\n            bookDao.insertBook(book)\n        }\n    }\n}"}
{"instruction": "Create a Room Entity class in Kotlin named 'User' with an auto-generated primary key 'id', a 'firstName' column, and an 'age' column.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Long = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    val age: Int\n)"}
{"instruction": "Define a DAO interface for the User entity using Kotlin Coroutines and Flow. Include a query to get all users and a suspend function to insert a user.", "output": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of the Room 'AppDatabase' and the 'UserDao'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Write a Kotlin Fragment class that uses ViewBinding to inflate its layout and sets a TextView's text in 'onViewCreated'. Handle the binding lifecycle correctly to avoid memory leaks.", "output": "class HomeFragment : Fragment() {\n\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.welcomeText.text = \"Welcome Home\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection that accepts a UserRepository. Annotate it correctly for Hilt.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    \n    val users = userRepository.getAllUsers().asLiveData()\n\n    fun addUser(user: User) {\n        viewModelScope.launch {\n            userRepository.insertUser(user)\n        }\n    }\n}"}
{"instruction": "Write the XML layout code for an Activity that hosts a NavHostFragment constrained to fill the parent ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create the Application class required for Hilt setup in Kotlin.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize libraries here\n    }\n}"}
{"instruction": "Write a Room TypeConverter class in Kotlin to convert a Date object to a Long timestamp and vice versa.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a text 'Hello Hilt'.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface {\n                    Text(text = \"Hello Hilt\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Define the abstract RoomDatabase class in Kotlin, including the User entity and the DateConverters.", "output": "@Database(entities = [User::class], version = 1, exportSchema = false)\n@TypeConverters(DateConverters::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a custom Application class configured for Hilt dependency injection in Kotlin.", "output": "@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Task' object with an auto-generated primary key.", "output": "@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    @ColumnInfo(name = \"task_title\")\n    val title: String,\n    @ColumnInfo(name = \"is_completed\")\n    val isCompleted: Boolean = false,\n    @ColumnInfo(name = \"created_at\")\n    val createdAt: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Data Access Object (DAO) interface for the 'Task' entity using Kotlin Coroutines.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks_table ORDER BY created_at DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Write a Hilt Module object to provide the Room Database and DAO as singleton dependencies.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt Constructor Injection to inject a Repository.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    private val _tasks = MutableStateFlow<List<Task>>(emptyList())\n    val tasks: StateFlow<List<Task>> = _tasks.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllTasks().collect {\n                _tasks.value = it\n            }\n        }\n    }\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a Fragment that uses Hilt to inject the ViewModel and binds a simple View using ViewBinding.", "output": "@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentTaskListBinding.bind(view)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.tasks.collect { tasks ->\n                    // Update RecyclerView adapter here\n                }\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity that hosts a NavHostFragment and is annotated for Hilt.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val navHostFragment = supportFragmentManager\n            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment\n        val navController = navHostFragment.navController\n    }\n}"}
{"instruction": "Write a TypeConverter for Room to handle a custom Date object by converting it to a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a simple XML layout file for an Activity containing a FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Jetpack Compose Activity that is Hilt-enabled and collects a state from a ViewModel.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                val viewModel: TaskViewModel = hiltViewModel()\n                val tasks by viewModel.tasks.collectAsStateWithLifecycle()\n                \n                TaskListScreen(tasks = tasks)\n            }\n        }\n    }\n}\n\n@Composable\nfun TaskListScreen(tasks: List<Task>) {\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity class representing a 'User' with a primary key, first name, and last name in Kotlin.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val firstName: String,\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a user and retrieve all users as a Flow.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the User entity and UserDao.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module object to provide the Room Database and UserDao as singleton dependencies.", "output": "package com.example.myapp.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.example.myapp.data.local.AppDatabase\nimport com.example.myapp.data.local.UserDao\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection that accepts a Repository (or DAO) and exposes a StateFlow of users.", "output": "package com.example.myapp.ui\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.myapp.data.local.User\nimport com.example.myapp.data.local.UserDao\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users: StateFlow<List<User>> = userDao.getAllUsers()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create an XML layout file for an Activity that contains a FragmentContainerView to host a navigation graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a MainActivity in Kotlin that uses Hilt and sets the content view to the XML layout defined previously.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.myapp.R\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment using ViewBinding and Hilt, which observes the ViewModel in onViewCreated.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport com.example.myapp.R\nimport com.example.myapp.databinding.FragmentUserListBinding\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentUserListBinding.bind(view)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.users.collect { users ->\n                // Update UI/Adapter here\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that injects the Hilt ViewModel and displays the list of users.", "output": "package com.example.myapp.ui.compose\n\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport com.example.myapp.ui.UserViewModel\n\n@Composable\nfun UserListScreen(viewModel: UserViewModel = hiltViewModel()) {\n    val users by viewModel.users.collectAsState()\n\n    LazyColumn {\n        items(users) { user ->\n            Text(text = \"${user.firstName} ${user.lastName}\")\n        }\n    }\n}"}
{"instruction": "Define a Room Entity class representing a 'User' with a primary key and a DAO interface with a suspend function to insert a user and a function to observe all users as a Flow.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of a Room Database named 'AppDatabase'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Implement a standard Android Application class annotated to trigger Hilt code generation.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository, exposing a StateFlow for UI consumption.", "output": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            userRepository.getUsers().collect {\n                _uiState.value = UiState.Success(it)\n            }\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Fragment that uses ViewBinding to inflate its layout and sets up a click listener in `onViewCreated`.", "output": "class ProfileFragment : Fragment() {\n\n    private var _binding: FragmentProfileBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.saveButton.setOnClickListener {\n            // Handle click\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with `@AndroidEntryPoint` that injects a ViewModel and displays a simple text element.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n    private val viewModel: MainViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Greeting(viewModel)\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(viewModel: MainViewModel) {\n    Text(text = \"Hello Hilt!\")\n}"}
{"instruction": "Define a Room TypeConverter class to convert a `Date` object to a `Long` timestamp and vice versa for database storage.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Write the XML layout code for a `FragmentContainerView` acting as a NavHost for the Navigation Component.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement code inside an Activity to programmatically replace a Fragment using the `supportFragmentManager`.", "output": "val newFragment = DetailsFragment()\nval transaction = supportFragmentManager.beginTransaction()\ntransaction.replace(R.id.fragment_container, newFragment)\ntransaction.addToBackStack(null) // Optional: Add to back stack\ntransaction.commit()"}
{"instruction": "Create an abstract RoomDatabase class that includes the defined entities and the TypeConverter.", "output": "@Database(entities = [User::class, Product::class], version = 1, exportSchema = false)\n@TypeConverters(DateConverters::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    abstract fun productDao(): ProductDao\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is initialized automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks ORDER BY id DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Create the abstract RoomDatabase class that includes the Task entity and the TaskDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write a Hilt Module to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"todo_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection that accepts the TaskDao and exposes a Flow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a basic XML layout file (activity_main.xml) containing a FragmentContainerView for navigation.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a Fragment class annotated with @AndroidEntryPoint that injects the TaskViewModel and sets up ViewBinding.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a simple Greeting composable.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Write a Room TypeConverter class to handle conversion between Date objects and Long timestamps.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin necessary to initialize Hilt dependency injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initialization happens automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Task' with an auto-generated ID, a title, and a completion status.", "output": "import androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface with methods to insert a task and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database instance and the DAO as singleton dependencies.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection to accept a repository and expose a StateFlow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = repository.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Write a simple XML layout file (fragment_task_list.xml) containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create an Android Fragment annotated with @AndroidEntryPoint that inflates a binding and observes a ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentTaskListBinding.bind(view)\n        \n        // Setup logic here\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a custom theme.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                // Screen content goes here\n            }\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a list of tasks using LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun TaskListScreen(tasks: List<Task>) {\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Define a Room Database abstract class including the entities and the abstract DAO method.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a custom Application class in Kotlin required to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a completion boolean.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface with a suspend function to insert a Task and a function to return a Flow of all tasks.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Write a Hilt Module to provide a singleton instance of the Room Database.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository, annotated with @HiltViewModel.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Set up a basic Android Activity that hosts a Jetpack Compose UI and is annotated for Hilt injection.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // Your Compose Theme and Content here\n            MainScreen()\n        }\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that inflates a ViewBinding layout in onCreateView.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define the abstract Room Database class including the entity and version number.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write an XML layout file for a Fragment containing a RecyclerView constrained to the parent edges.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a safe coroutine collection of a Flow in a Fragment using repeatOnLifecycle.", "output": "import androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.lifecycleScope\nimport androidx.lifecycle.repeatOnLifecycle\nimport kotlinx.coroutines.launch\n\n// Inside onViewCreated\nviewLifecycleOwner.lifecycleScope.launch {\n    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n        viewModel.tasks.collect { taskList ->\n            // Update UI adapter with new list\n            adapter.submitList(taskList)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin configured for Hilt Dependency Injection.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Task' item with an auto-generated primary key.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class TaskEntity(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val description: String,\n    val isCompleted: Boolean = false,\n    val timestamp: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a task and retrieve all tasks as a Flow.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n\n    @Query(\"SELECT * FROM tasks ORDER BY timestamp DESC\")\n    fun getAllTasks(): Flow<List<TaskEntity>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: TaskEntity)\n\n    @Query(\"DELETE FROM tasks WHERE id = :taskId\")\n    suspend fun deleteTask(taskId: Int)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the TaskEntity and TaskDao.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [TaskEntity::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "package com.example.myapp.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.example.myapp.data.local.AppDatabase\nimport com.example.myapp.data.local.TaskDao\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Repository class that uses constructor injection to access the TaskDao.", "output": "package com.example.myapp.data.repository\n\nimport com.example.myapp.data.local.TaskDao\nimport com.example.myapp.data.local.TaskEntity\nimport kotlinx.coroutines.flow.Flow\nimport javax.inject.Inject\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<TaskEntity>> = taskDao.getAllTasks()\n\n    suspend fun addTask(title: String, description: String) {\n        val task = TaskEntity(title = title, description = description)\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Implement a ViewModel using @HiltViewModel that interacts with the Repository.", "output": "package com.example.myapp.ui\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.myapp.data.local.TaskEntity\nimport com.example.myapp.data.repository.TaskRepository\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<TaskEntity>> = repository.allTasks\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNewTask(title: String, description: String) {\n        viewModelScope.launch {\n            repository.addTask(title, description)\n        }\n    }\n}"}
{"instruction": "Create a simple XML layout file for a Fragment containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAdd\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that inflates the XML layout and accesses the ViewModel.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport com.example.myapp.R\nimport com.example.myapp.databinding.FragmentTaskListBinding\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentTaskListBinding.bind(view)\n\n        // Setup RecyclerView adapter here\n        \n        binding.fabAdd.setOnClickListener {\n            viewModel.addNewTask(\"New Task\", \"Created from Fragment\")\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that collects the ViewModel state.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    \n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val tasks by viewModel.tasks.collectAsState()\n\n            LazyColumn {\n                items(tasks) { task ->\n                    Column {\n                        Text(text = task.title)\n                        Text(text = task.description)\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Room Entity class in Kotlin named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Define a Room DAO interface for the 'Task' entity including a method to insert a task and a method to retrieve all tasks as a Kotlin Flow.", "output": "@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Create the abstract RoomDatabase class named 'AppDatabase' that includes the Task entity and provides the abstract DAO getter.", "output": "@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create the Application class annotated with @HiltAndroidApp, which is required to start Hilt dependency injection.", "output": "@HiltAndroidApp\nclass TodoApplication : Application()"}
{"instruction": "Create a Hilt Object Module to provide the Room Database instance and the TaskDao as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"todo_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using @HiltViewModel that injects the TaskDao and exposes the list of tasks as a StateFlow.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = taskDao.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Write a standard Android Activity (using XML/ViewBinding) annotated with @AndroidEntryPoint that retrieves the TaskViewModel.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // Observe ViewModel data here\n    }\n}"}
{"instruction": "Create a Fragment (using XML/ViewBinding) annotated with @AndroidEntryPoint that shares the TaskViewModel with the host Activity.", "output": "@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    // activityViewModels() scopes the VM to the Activity, allowing data sharing\n    private val sharedViewModel: TaskViewModel by activityViewModels()\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Set up a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a Compose theme.", "output": "@AndroidEntryPoint\nclass ComposeTaskActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Composable function that injects the TaskViewModel using 'hiltViewModel()' and displays a list of tasks.", "output": "@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks by viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title, modifier = Modifier.padding(16.dp))\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'Note' with an auto-generated primary key, a title, and a content field.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"content\")\n    val content: String\n)"}
{"instruction": "Define a Room DAO interface for the 'Note' entity with methods to insert a note and observe all notes as a Flow.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create the abstract RoomDatabase class definition including the Note entity and the abstract DAO getter.", "output": "@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Set up the Application class required for Hilt dependency injection.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code if necessary\n    }\n}"}
{"instruction": "Create a Hilt module object to provide the Room Database and the NoteDao instance as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection that accepts a Repository (or DAO) in its constructor and exposes a StateFlow of notes.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val noteDao: NoteDao\n) : ViewModel() {\n\n    val allNotes: StateFlow<List<Note>> = noteDao.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            noteDao.insertNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Write a basic MainActivity in Kotlin that sets up an XML layout and is annotated for Hilt injection.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Fragment setup or other logic here\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that inflates an XML layout using ViewBinding.", "output": "@AndroidEntryPoint\nclass NoteFragment : Fragment() {\n\n    private var _binding: FragmentNoteBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentNoteBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a Jetpack Compose Activity that injects a Hilt ViewModel and displays a simple text list from the ViewModel state.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: NoteViewModel = hiltViewModel()\n            val notes by viewModel.allNotes.collectAsState()\n\n            LazyColumn {\n                items(notes) { note ->\n                    Text(text = note.title)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Show how to navigate from a Fragment to another Fragment using the Navigation Component and SafeArgs within a click listener.", "output": "binding.fabAddNote.setOnClickListener { view ->\n    val action = NoteListFragmentDirections.actionNoteListFragmentToAddNoteFragment()\n    view.findNavController().navigate(action)\n}"}
{"instruction": "Define a Kotlin data class annotated as a Room Entity representing a 'User' with a primary key, first name, and last name.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"user_table\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val firstName: String,\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with methods to insert a User and retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM user_table\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create an abstract RoomDatabase class in Kotlin that includes the User entity and UserDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class for Hilt Dependency Injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application()"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database and UserDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a Repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users = repository.getAllUsers()\n\n    fun addUser(user: User) {\n        viewModelScope.launch {\n            repository.insertUser(user)\n        }\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin that is annotated with @AndroidEntryPoint to allow Hilt injection and retrieves the UserViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Observe ViewModel data here\n    }\n}"}
{"instruction": "Write a Kotlin Activity that loads a specific Fragment into a FrameLayout container using the SupportFragmentManager.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, UserFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose Activity in Kotlin that displays a greeting text.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Implement a simple Repository class in Kotlin that injects the UserDao via Hilt.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val getAllUsers: Flow<List<User>> = userDao.getAllUsers()\n\n    suspend fun insertUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a custom Application class to initialize Hilt dependency injection for the Android app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Note' object with an auto-generated ID, title, and content.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String,\n    val timestamp: Long\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface with suspend functions to insert a note and return a Flow list of notes.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Query(\"SELECT * FROM notes_table ORDER BY timestamp DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Implement a ViewModel using Hilt to inject a Repository, exposing a StateFlow for UI consumption.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    private val _notes = MutableStateFlow<List<Note>>(emptyList())\n    val notes: StateFlow<List<Note>> = _notes\n\n    init {\n        viewModelScope.launch {\n            repository.getAllNotes().collect {\n                _notes.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic MainActivity that uses XML for layout and is annotated with @AndroidEntryPoint for Hilt injection.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Fragment setup or ViewBinding logic here\n    }\n}"}
{"instruction": "Define a Fragment that injects the MainViewModel using Hilt and 'by viewModels()' delegate.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment(R.layout.fragment_note_list) {\n\n    private val viewModel: MainViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Observe viewModel data here\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a Composable function.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                MainScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Write a Kotlin code snippet to safely collect a Flow in a Fragment using repeatOnLifecycle.", "output": "import androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.lifecycleScope\nimport androidx.lifecycle.repeatOnLifecycle\nimport kotlinx.coroutines.launch\n\n// Inside onViewCreated\nviewLifecycleOwner.lifecycleScope.launch {\n    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n        viewModel.notes.collect { notesList ->\n            // Update UI adapter with notesList\n        }\n    }\n}"}
{"instruction": "Define an abstract Room Database class that includes the Note entity and the DAO abstract function.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt for dependency injection.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is initialized automatically via the annotation\n    }\n}"}
{"instruction": "Define a simple Room Database Entity class named 'User' with a primary key, first name, and last name.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Create a Room DAO interface for the User entity with methods to insert a user and observe all users using Kotlin Flow.", "output": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin including the User entity and the abstract DAO getter.", "output": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and the UserDao as singleton dependencies.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a UserRepository.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    val users: LiveData<List<User>> = userRepository.getAllUsers().asLiveData()\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            userRepository.insert(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Fragment annotated with @AndroidEntryPoint that uses ViewBinding to observe data from UserViewModel.", "output": "@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentUserBinding.bind(view)\n\n        viewModel.users.observe(viewLifecycleOwner) { userList ->\n            // Update UI adapter here\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity layout XML file that acts as a container for a Fragment using FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/fragment_container\"\n        android:name=\"com.example.app.UserFragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a MainActivity class using Hilt that hosts the fragment defined in the XML layout.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity setup with Hilt that instantiates a ViewModel and displays a simple text.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                val viewModel: UserViewModel = hiltViewModel()\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(text = \"Hilt with Compose\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom Application class configured for Hilt dependency injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or analytics here\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Task' with a primary key and columns for title and completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task and get all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY id DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Write a Hilt Module object to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection that takes a repository as a dependency.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create an XML layout file for a Fragment containing a ConstraintLayout and a RecyclerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a Fragment in Kotlin that uses ViewBinding and is annotated with @AndroidEntryPoint for Hilt injection.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity that hosts a FragmentContainerView and is set up for Hilt.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.R\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // Ensure the layout contains a FragmentContainerView with id nav_host_fragment\n    }\n}"}
{"instruction": "Write a Jetpack Compose Activity that uses Hilt to inject a ViewModel and displays a simple greeting.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: TaskViewModel = hiltViewModel()\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Create a Repository class to mediate between the Room DAO and the ViewModel, using @Inject.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    fun getAllTasks(): Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun insert(task: Task) {\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Define a Room Entity class named 'Book' in Kotlin with an auto-generated primary key 'id', a 'title', and an 'author'.", "output": "@Entity(tableName = \"books\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"author\") val author: String\n)"}
{"instruction": "Create the base Application class required to initialize Hilt dependency injection in an Android app.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Implement a basic Fragment in Kotlin using ViewBinding to access a TextView with id 'tv_welcome' and set its text to 'Hello World'.", "output": "class HomeFragment : Fragment() {\n\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.tvWelcome.text = \"Hello World\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Room DAO interface for a 'Note' entity with methods to insert a note and observe all notes as a Flow list.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes ORDER BY date DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a 'UserRepository'.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    \n    private val _userData = MutableLiveData<User>()\n    val userData: LiveData<User> = _userData\n\n    fun loadUser(userId: String) {\n        viewModelScope.launch {\n            _userData.value = userRepository.getUser(userId)\n        }\n    }\n}"}
{"instruction": "Write the XML layout for an Activity that contains a FragmentContainerView to host a NavHostFragment.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Define the abstract RoomDatabase class in Kotlin, including the 'User' entity and version number.", "output": "@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module to provide a singleton instance of the Room Database.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a MainActivity that extends ComponentActivity and sets a basic 'Greeting' Composable content using Jetpack Compose.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Write the Kotlin code to navigate from 'HomeFragment' to 'DetailFragment' using Android Jetpack Navigation component and Safe Args, passing an argument 'userId'.", "output": "val userId = \"12345\"\nval action = HomeFragmentDirections.actionHomeFragmentToDetailFragment(userId)\nfindNavController().navigate(action)"}
{"instruction": "Create a Kotlin Application class setup for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Task' with an auto-generated ID, title, and isCompleted boolean.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a task and get all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Create the abstract RoomDatabase class including the Task entity and TaskDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write a Hilt Module to provide the Room Database and TaskDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a TaskRepository class that injects the TaskDao using Hilt.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun addTask(task: Task) {\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Create a HiltViewModel that uses the TaskRepository to expose data to the UI.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = repository.allTasks\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNewTask(title: String) {\n        viewModelScope.launch {\n            repository.addTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Setup a MainActivity using XML layout that is annotated with @AndroidEntryPoint to allow fragment injection.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.container, TaskFragment())\n                .commitNow()\n        }\n    }\n}"}
{"instruction": "Create a Fragment that uses Jetpack Compose via ComposeView and is annotated for Hilt.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that retrieves the TaskViewModel using Hilt and displays the list of tasks.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks = viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks.value) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'Note'. It should have an auto-generated primary key 'id', a 'title', and a 'content' field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val content: String\n)"}
{"instruction": "Define a Room DAO interface named 'NoteDao' with methods to insert a note (suspend) and observe all notes as a Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Query(\"SELECT * FROM notes ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n}"}
{"instruction": "Create the abstract RoomDatabase class connecting the 'Note' entity and 'NoteDao'.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Write a Hilt module object to provide the AppDatabase and NoteDao instances as Singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Implement the Android Application class required for Hilt dependency injection setup.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass NoteApplication : Application()"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject the 'NoteDao' and expose a list of notes converted to StateFlow.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val noteDao: NoteDao\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = noteDao.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple text greeting.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(text = \"Hello Hilt and Compose!\")\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose Composable function that displays a list of notes using LazyColumn and observes the ViewModel.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\n\n@Composable\nfun NoteListScreen(viewModel: NoteViewModel) {\n    val notes by viewModel.notes.collectAsState()\n\n    LazyColumn {\n        items(notes) { note ->\n            Text(text = note.title)\n        }\n    }\n}"}
{"instruction": "Create a standard Android Fragment that uses ViewBinding to inflate its layout and is annotated for Hilt injection.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentNoteBinding\n\n@AndroidEntryPoint\nclass NoteFragment : Fragment() {\n\n    private var _binding: FragmentNoteBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentNoteBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define an XML layout file for an Activity that contains a FragmentContainerView to host a navigation graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initialization happens automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Entity data class representing a 'User' with a primary key and columns for name and age.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val name: String,\n    val age: Int\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a user and retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users ORDER BY name ASC\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Implement the abstract Room Database class including the User entity and version number.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and UserDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Repository class that injects the UserDao and exposes data operations.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<User>> = userDao.getAllUsers()\n\n    suspend fun addUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt's @HiltViewModel annotation to inject the Repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users = repository.allUsers\n\n    fun addUser(name: String, age: Int) {\n        viewModelScope.launch {\n            repository.addUser(User(name = name, age = age))\n        }\n    }\n}"}
{"instruction": "Setup a MainActivity using Jetpack Compose that is annotated with @AndroidEntryPoint to support Hilt.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // Call your Composable screens here\n            UserScreen()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that observes the ViewModel and displays a list of users.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun UserScreen(viewModel: UserViewModel = hiltViewModel()) {\n    val users = viewModel.users.collectAsState(initial = emptyList())\n\n    LazyColumn {\n        items(users.value) { user ->\n            Text(text = \"${user.name}, Age: ${user.age}\")\n        }\n    }\n}"}
{"instruction": "Create a Fragment using XML layouts that injects the UserViewModel and sets up a binding.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Assume ViewBinding is used or findViewById\n        // Example: binding.textView.text = ...\n        // Observe LiveData/Flow from viewModel here\n    }\n}"}
{"instruction": "Create a Room Database Entity class in Kotlin representing a 'User' with an auto-generated ID, a first name, and a last name.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface in Kotlin with methods to insert a user and observe a list of all users using Kotlin Flow.", "output": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Create the abstract RoomDatabase class in Kotlin that includes the User entity and the UserDao.", "output": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class required for Hilt dependency injection in Kotlin.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Create a Hilt Dagger Module in Kotlin to provide the singleton instance of the Room Database and the UserDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Implement a Repository class in Kotlin that injects the UserDao and exposes functions to the ViewModel.", "output": "class UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<User>> = userDao.getAllUsers()\n\n    suspend fun addUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt in Kotlin that injects the UserRepository and exposes the user list as a StateFlow.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users: StateFlow<List<User>> = repository.allUsers\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            repository.addUser(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create a simple Activity in XML and Java that acts as a container for Fragments and is annotated for Hilt.", "output": "<!-- activity_main.xml -->\n<androidx.fragment.app.FragmentContainerView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/fragment_container\"\n    android:name=\"androidx.navigation.fragment.NavHostFragment\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" />\n\n// MainActivity.java\n@AndroidEntryPoint\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin annotated with @AndroidEntryPoint that inflates an XML layout and observes a ViewModel.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentUserListBinding.bind(view)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.users.collect { users ->\n                    // Update UI adapter here\n                }\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen in Kotlin that uses Hilt to obtain the ViewModel and displays a list of users.", "output": "@Composable\nfun UserListScreen(\n    viewModel: UserViewModel = hiltViewModel()\n) {\n    val users by viewModel.users.collectAsStateWithLifecycle()\n\n    LazyColumn {\n        items(users) { user ->\n            Text(text = \"${user.firstName} ${user.lastName}\")\n        }\n    }\n}"}
{"instruction": "Create a simple Android Activity in Java that loads an XML layout named 'activity_login.xml', initializes a Button and an EditText, and sets an OnClickListener on the button to show a Toast message.", "output": "import android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class LoginActivity extends AppCompatActivity {\n\n    private EditText usernameInput;\n    private Button loginButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n\n        usernameInput = findViewById(R.id.et_username);\n        loginButton = findViewById(R.id.btn_login);\n\n        loginButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                String username = usernameInput.getText().toString();\n                Toast.makeText(LoginActivity.this, \"Logging in: \" + username, Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n}"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Task' with an auto-generating primary key, a title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"task_title\")\n    val title: String,\n\n    @ColumnInfo(name = \"is_completed\")\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface in Kotlin for the 'Task' entity with methods to insert a task, delete a task, and observe all tasks using Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks_table ORDER BY id ASC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin, including a Singleton pattern to get the database instance (though Hilt is preferred, show the standard Room boilerplate for database creation).", "output": "import android.content.Context\nimport androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n\n    abstract fun taskDao(): TaskDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide the Room Database and the TaskDao as singleton dependencies.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a standard Android Fragment in Kotlin that uses ViewBinding to access a TextView in its layout and updates the text in `onViewCreated`.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport com.example.app.databinding.FragmentProfileBinding\n\nclass ProfileFragment : Fragment() {\n\n    private var _binding: FragmentProfileBinding? = null\n    // This property is only valid between onCreateView and onDestroyView.\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.tvUsername.text = \"Welcome, User!\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt (@HiltViewModel) in Kotlin that injects a Repository and exposes a StateFlow of data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<List<Task>>(emptyList())\n    val uiState: StateFlow<List<Task>> = _uiState.asStateFlow()\n\n    init {\n        loadTasks()\n    }\n\n    private fun loadTasks() {\n        viewModelScope.launch {\n            repository.getAllTasks().collect {\n                _uiState.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a list of items using LazyColumn. The function should accept a list of Strings.", "output": "import androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun NameList(names: List<String>) {\n    LazyColumn(\n        modifier = Modifier.fillMaxSize().padding(16.dp)\n    ) {\n        items(names) { name ->\n            Text(\n                text = name,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that injects a Hilt ViewModel and observes a StateFlow to display a loading spinner or content.", "output": "import androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n        if (uiState.isEmpty()) {\n            CircularProgressIndicator()\n        } else {\n            Text(text = \"Tasks loaded: ${uiState.size}\")\n        }\n    }\n}"}
{"instruction": "Demonstrate how to set up the Hilt Application class in Kotlin, which is required for Hilt dependency injection to work.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here if needed\n    }\n}"}
{"instruction": "Define a Room Entity for a 'User' with a primary key and a DAO interface to insert a user and retrieve all users using Kotlin.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of a Room Database called 'AppDatabase'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a scrollable list of strings using LazyColumn.", "output": "@Composable\nfun NameList(names: List<String>) {\n    LazyColumn(\n        contentPadding = PaddingValues(16.dp),\n        verticalArrangement = Arrangement.spacedBy(8.dp)\n    ) {\n        items(names) { name ->\n            Text(\n                text = name,\n                modifier = Modifier.fillMaxWidth().padding(8.dp),\n                style = MaterialTheme.typography.bodyLarge\n            )\n        }\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a repository dependency.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            userRepository.getUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Fragment in Java that defines an interface to communicate a button click event back to its hosting Activity.", "output": "public class MyFragment extends Fragment {\n\n    public interface OnButtonClickListener {\n        void onButtonClicked(String data);\n    }\n\n    private OnButtonClickListener callback;\n\n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n        if (context instanceof OnButtonClickListener) {\n            callback = (OnButtonClickListener) context;\n        } else {\n            throw new RuntimeException(context.toString() + \" must implement OnButtonClickListener\");\n        }\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        Button button = view.findViewById(R.id.my_button);\n        button.setOnClickListener(v -> callback.onButtonClicked(\"Hello from Fragment\"));\n    }\n}"}
{"instruction": "Set up the Application class in Kotlin required to enable Hilt dependency injection in the app.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Write a Java method inside an Activity to explicitly start a 'DetailActivity' passing an integer ID as an extra.", "output": "public void openDetailActivity(int itemId) {\n    Intent intent = new Intent(this, DetailActivity.class);\n    intent.putExtra(\"ITEM_ID\", itemId);\n    startActivity(intent);\n}"}
{"instruction": "Create a simple counter UI in Jetpack Compose using state hoisting with `remember` and `mutableStateOf`.", "output": "@Composable\nfun CounterScreen() {\n    var count by remember { mutableStateOf(0) }\n\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        Text(text = \"Count: $count\")\n        Button(onClick = { count++ }) {\n            Text(\"Increment\")\n        }\n    }\n}"}
{"instruction": "Define the abstract RoomDatabase class in Kotlin including the entities and version number.", "output": "@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Write a Kotlin function to replace a Fragment inside a FrameLayout container using the FragmentManager.", "output": "fun loadFragment(fragment: Fragment) {\n    supportFragmentManager.beginTransaction()\n        .replace(R.id.fragment_container, fragment)\n        .addToBackStack(null)\n        .commit()\n}"}
{"instruction": "Create a custom Application class setup for Hilt dependency injection in Kotlin.", "output": "@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or analytics here\n    }\n}"}
{"instruction": "Define a simple Room Database Entity class representing a 'Task' with an auto-generated primary key.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false,\n    @ColumnInfo(name = \"created_at\") val createdAt: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a task and retrieve all tasks as a Flow.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks ORDER BY created_at DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the Task entity and the DAO.", "output": "@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"task_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Hilt-injected ViewModel that uses the TaskDao to fetch data and expose it as a StateFlow.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = taskDao.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that observes the ViewModel using ViewBinding.", "output": "@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentTaskListBinding.bind(view)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.tasks.collect { tasks ->\n                    // Update RecyclerView adapter here\n                }\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write an XML layout file for an Activity that hosts a Fragment using FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a MainActivity setup with Hilt that sets the content view to the XML layout defined previously.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity that injects the ViewModel and displays a simple list of tasks.", "output": "@AndroidEntryPoint\nclass ComposeTaskActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TaskScreen()\n        }\n    }\n}\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks by viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title, modifier = Modifier.padding(16.dp))\n        }\n    }\n}"}
{"instruction": "Create a Room Database Entity class in Kotlin representing a 'Note' with an auto-generated ID, a title, and a content field.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String,\n    \n    @ColumnInfo(name = \"created_at\")\n    val createdAt: Long = System.currentTimeMillis()\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface in Kotlin with methods to insert a note and observe all notes as a Flow.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Delete\n    suspend fun deleteNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY created_at DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database instance and the DAO as singleton dependencies.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): NoteDatabase {\n        return Room.databaseBuilder(\n            context,\n            NoteDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: NoteDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Implement a ViewModel in Kotlin using the @HiltViewModel annotation that injects a repository and exposes a list of notes as a StateFlow.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    private val _notes = MutableStateFlow<List<Note>>(emptyList())\n    val notes: StateFlow<List<Note>> = _notes.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllNotes().collect {\n                _notes.value = it\n            }\n        }\n    }\n\n    fun addNote(note: Note) = viewModelScope.launch {\n        repository.insert(note)\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose function that displays a list of notes using a LazyColumn.", "output": "@Composable\nfun NoteListScreen(notes: List<Note>, onNoteClick: (Note) -> Unit) {\n    LazyColumn(\n        modifier = Modifier.fillMaxSize(),\n        contentPadding = PaddingValues(16.dp)\n    ) {\n        items(notes) { note ->\n            Card(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(vertical = 8.dp)\n                    .clickable { onNoteClick(note) },\n                elevation = CardDefaults.cardElevation(4.dp)\n            ) {\n                Column(modifier = Modifier.padding(16.dp)) {\n                    Text(text = note.title, style = MaterialTheme.typography.titleMedium)\n                    Spacer(modifier = Modifier.height(4.dp))\n                    Text(text = note.content, style = MaterialTheme.typography.bodyMedium)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write the code for an Android Activity in Kotlin that is annotated with @AndroidEntryPoint and hosts a NavHostFragment for XML-based navigation.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    \n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)    \n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        val navHostFragment = supportFragmentManager\n            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment\n        val navController = navHostFragment.navController\n        \n        // Optional: Setup Action Bar with NavController\n        // setupActionBarWithNavController(navController)\n    }\n}"}
{"instruction": "Create a Room TypeConverter class in Kotlin to handle conversion between a Date object and a Long (timestamp) for database storage.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Implement a Fragment in Kotlin annotated with @AndroidEntryPoint that uses ViewBinding to access views and observes a LiveData from a ViewModel.", "output": "@AndroidEntryPoint\nclass NoteDetailFragment : Fragment(R.layout.fragment_note_detail) {\n\n    private var _binding: FragmentNoteDetailBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: NoteViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentNoteDetailBinding.bind(view)\n\n        viewModel.currentNote.observe(viewLifecycleOwner) { note ->\n            binding.tvTitle.text = note.title\n            binding.tvContent.text = note.content\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define the abstract RoomDatabase class in Kotlin, including the entities and the TypeConverters.", "output": "@Database(entities = [Note::class], version = 1, exportSchema = false)\n@TypeConverters(DateConverters::class)\nabstract class NoteDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a Jetpack Compose Activity that sets the content using a Hilt-injected theme and a surface.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyApplicationTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    MainScreen()\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Room Entity class named 'Note' in Kotlin. It should have an auto-generated primary key 'id', a 'title' string column, and a 'content' string column.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Define a Room DAO interface for the 'Note' entity. Include methods to insert a note, delete a note, and retrieve all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Delete\n    suspend fun deleteNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id ASC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database instance and the NoteDao as singleton dependencies.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create the Application class required to initialize Hilt in an Android project.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass NoteApplication : Application()"}
{"instruction": "Create a ViewModel using Hilt constructor injection. It should take a repository as a dependency and expose a StateFlow of notes.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.getAllNotes()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = emptyList()\n        )\n}"}
{"instruction": "Write a TypeConverter class for Room to handle the conversion between java.util.Date and Long (timestamp).", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a standard Android Activity (XML-based) annotated with @AndroidEntryPoint that inflates a layout.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment using ViewBinding and Hilt. Ensure the binding is properly cleaned up in onDestroyView.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentNoteListBinding\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment() {\n\n    private var _binding: FragmentNoteListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentNoteListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity setup with Hilt. Set the content to a Composable function inside a theme.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                MainScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Composable function that retrieves a HiltViewModel and observes a StateFlow as State.", "output": "import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun NoteScreen(\n    viewModel: NoteViewModel = hiltViewModel()\n) {\n    val notes by viewModel.notes.collectAsState()\n\n    // UI Implementation using 'notes' list\n    NoteList(notes = notes)\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initializes automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Note' with a primary key, title, and content fields.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String,\n    val timestamp: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a note and observe all notes using Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY timestamp DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Implement a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create the abstract RoomDatabase class configuration including the Note entity.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to access the Repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val allNotes = repository.allNotes\n\n    fun addNote(note: Note) = viewModelScope.launch {\n        repository.insert(note)\n    }\n}"}
{"instruction": "Write a standard Android Fragment annotated with @AndroidEntryPoint that inflates a layout.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment() {\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        // Assuming R.layout.fragment_note_list exists\n        return inflater.inflate(R.layout.fragment_note_list, container, false)\n    }\n}"}
{"instruction": "Create an Activity Layout XML file that hosts a FragmentContainerView for navigation.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Set up a Jetpack Compose Activity annotated with @AndroidEntryPoint.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // AppTheme and Composables go here\n            NoteAppScreen()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function to display a list of Notes using LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun NoteListScreen(notes: List<Note>) {\n    LazyColumn {\n        items(notes) { note ->\n            Text(text = note.title)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class configured to use Hilt for dependency injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Define a Room Database Entity representing a 'User' with a primary key and two columns (first name, last name) in Kotlin.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val firstName: String,\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface with a suspend function to insert a user and a Flow to observe all users.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Write a Hilt Dagger Module to provide a singleton instance of the Room Database and the UserDao.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Hilt-injected ViewModel that uses a repository to fetch data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    fun addUser(name: String) {\n        viewModelScope.launch {\n            userRepository.createUser(name)\n        }\n    }\n}"}
{"instruction": "Create a Fragment that is annotated with @AndroidEntryPoint to allow field injection.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Logic to observe ViewModel\n    }\n}"}
{"instruction": "Write a Java Activity that uses Hilt to inject a dependency.", "output": "import android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\nimport javax.inject.Inject;\nimport dagger.hilt.android.AndroidEntryPoint;\n\n@AndroidEntryPoint\npublic class MainActivity extends AppCompatActivity {\n\n    @Inject\n    AnalyticsAdapter analyticsAdapter;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        analyticsAdapter.logEvent(\"App Started\");\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose function that displays a list of User entities.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun UserList(users: List<User>) {\n    LazyColumn {\n        items(users) { user ->\n            Text(text = \"${user.firstName} ${user.lastName}\")\n        }\n    }\n}"}
{"instruction": "Define the abstract RoomDatabase class including the User entity.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a basic XML layout file for a Fragment containing a RecyclerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is initialized automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Set up a Hilt Module to provide the Room Database and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"task_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject the TaskDao and expose a Flow of tasks to the UI.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = taskDao.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create a simple XML layout for a Fragment containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab_add\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a Fragment in Kotlin that uses @AndroidEntryPoint to inject the ViewModel and setup a RecyclerView adapter.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass TaskFragment : Fragment(R.layout.fragment_task) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    // Assuming ViewBinding is enabled and 'binding' is initialized properly\n    private lateinit var adapter: TaskAdapter\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        adapter = TaskAdapter()\n        val binding = FragmentTaskBinding.bind(view)\n        \n        binding.recyclerView.layoutManager = LinearLayoutManager(context)\n        binding.recyclerView.adapter = adapter\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.tasks.collect { taskList ->\n                adapter.submitList(taskList)\n            }\n        }\n    }\n}"}
{"instruction": "Create a Room TypeConverter to handle Date objects by converting them to Long timestamps.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Set up a main Activity in Jetpack Compose annotated with @AndroidEntryPoint that hosts a simple Composable screen.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TaskScreen()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that injects a Hilt ViewModel and displays a list of tasks using LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks = viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks.value) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Define a Kotlin data class annotated as a Room Entity named 'UserProfile' with an integer primary key, a string name, and an integer age.", "output": "@Entity(tableName = \"user_profile\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"full_name\") val name: String,\n    val age: Int\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a user and a function to return a Flow list of all users.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profile\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin including the UserProfile entity and the abstract UserDao getter.", "output": "@Database(entities = [UserProfile::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create the Application class required for Hilt dependency injection setup in Kotlin.", "output": "@HiltAndroidApp\nclass MyApp : Application()"}
{"instruction": "Write a Hilt Module in Kotlin to provide the AppDatabase and UserDao as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a repository.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Write a basic MainActivity in Kotlin that extends AppCompatActivity and sets the content view to an XML layout resource.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin annotated for Hilt that injects an adapter class.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment() {\n\n    @Inject\n    lateinit var userAdapter: UserAdapter\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return inflater.inflate(R.layout.fragment_user_list, container, false)\n    }\n}"}
{"instruction": "Write a Kotlin function within an Activity to perform a Fragment transaction that replaces a container with a new Fragment instance.", "output": "fun loadFragment(fragment: Fragment) {\n    supportFragmentManager.beginTransaction()\n        .replace(R.id.fragment_container, fragment)\n        .addToBackStack(null)\n        .commit()\n}"}
{"instruction": "Create a MainActivity using Jetpack Compose that sets the content to a simple 'Hello World' text.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface {\n                    Text(text = \"Hello World\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom Application class setup for Hilt dependency injection.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    // No additional code needed here for basic setup\n}"}
{"instruction": "Define a Room Entity data class representing a 'Task' with an auto-generated ID.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false,\n    val timestamp: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Room DAO interface with a suspend insert function and a Flow query.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY timestamp DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Write a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel that injects a Repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.allTasks\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Define an Activity XML layout that includes a FragmentContainerView for Navigation Component.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment that uses @AndroidEntryPoint to inject a ViewModel and observe LiveData/Flow.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Assuming using an extension to collect flow in fragments\n        // viewModel.tasks.collect { list -> updateUI(list) }\n    }\n}"}
{"instruction": "Setup a Jetpack Compose Activity annotated with Hilt.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                // Composable content here\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create the abstract RoomDatabase class including the Entity and DAO.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Repository class that uses Constructor Injection to get the DAO.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun insert(task: Task) {\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin configured for Hilt dependency injection.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity named 'Note' with an auto-generated primary key, a title, and a content field.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Create a Room DAO interface for the 'Note' entity with methods to insert a note and observe all notes using Kotlin Flow.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Delete\n    suspend fun deleteNote(note: Note)\n}"}
{"instruction": "Implement a Hilt Module to provide the Room Database and the NoteDao as singleton dependencies.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): NoteDatabase {\n        return Room.databaseBuilder(\n            context,\n            NoteDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: NoteDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository, exposing a Flow of data to the UI.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val allNotes: StateFlow<List<Note>> = repository.allNotes\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.insert(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Write a Fragment class annotated for Hilt that uses ViewBinding to access views in 'fragment_note_list.xml'.", "output": "@AndroidEntryPoint\nclass NoteListFragment : Fragment() {\n\n    private var _binding: FragmentNoteListBinding? = null\n    private val binding get() = _binding!!\n\n    // Hilt will inject this ViewModel\n    private val viewModel: NoteViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentNoteListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Room TypeConverter to handle the conversion between a Date object and a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Implement a Repository class injected with the NoteDao to abstract data operations.", "output": "class NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n\n    val allNotes: Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun insert(note: Note) {\n        noteDao.insertNote(note)\n    }\n\n    suspend fun delete(note: Note) {\n        noteDao.deleteNote(note)\n    }\n}"}
{"instruction": "Create a MainActivity that hosts a FragmentContainerView via XML and is annotated with @AndroidEntryPoint.", "output": "<!-- activity_main.xml -->\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// MainActivity.kt\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that injects a Hilt ViewModel and displays a list of notes.", "output": "@Composable\nfun NoteScreen(\n    viewModel: NoteViewModel = hiltViewModel()\n) {\n    val notes by viewModel.allNotes.collectAsState()\n\n    LazyColumn {\n        items(notes) { note ->\n            Text(text = note.title, style = MaterialTheme.typography.h6)\n            Text(text = note.content, style = MaterialTheme.typography.body1)\n            Divider()\n        }\n    }\n}"}
{"instruction": "Create a custom Application class to initialize Hilt dependency injection for the Android app.", "output": "package com.example.app\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Entity data class named 'User' with a primary key and columns for first name and last name.", "output": "package com.example.app.data\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val firstName: String,\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a user and retrieve all users as a Flow.", "output": "package com.example.app.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the User entity.", "output": "package com.example.app.data\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Object Module to provide the Room Database and DAO instances as singletons.", "output": "package com.example.app.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.example.app.data.AppDatabase\nimport com.example.app.data.UserDao\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel that injects the UserDao and exposes a Flow of users.", "output": "package com.example.app.viewmodel\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.app.data.User\nimport com.example.app.data.UserDao\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users = userDao.getAllUsers()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            userDao.insertUser(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Write the XML layout for an Activity containing a FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a MainActivity class that is annotated with @AndroidEntryPoint to support Hilt.", "output": "package com.example.app.ui\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.app.R\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment using ViewBinding and @AndroidEntryPoint that observes the UserViewModel.", "output": "package com.example.app.ui\n\nimport android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport com.example.app.R\nimport com.example.app.databinding.FragmentUserBinding\nimport com.example.app.viewmodel.UserViewModel\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var binding: FragmentUserBinding? = null\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding = FragmentUserBinding.bind(view)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.users.collect { userList ->\n                // Update UI adapter here\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that injects the UserViewModel and displays a list of users.", "output": "package com.example.app.ui.compose\n\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport com.example.app.viewmodel.UserViewModel\n\n@Composable\nfun UserListScreen(viewModel: UserViewModel = hiltViewModel()) {\n    val users = viewModel.users.collectAsState()\n\n    LazyColumn {\n        items(users.value) { user ->\n            Text(text = \"${user.firstName} ${user.lastName}\")\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin configured for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Note' with an auto-generated primary key, title, and content.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a note and observe all notes using Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Implement a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject a Repository, exposing a StateFlow of UI data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    private val _notes = MutableStateFlow<List<Note>>(emptyList())\n    val notes: StateFlow<List<Note>> = _notes\n\n    init {\n        fetchNotes()\n    }\n\n    private fun fetchNotes() {\n        viewModelScope.launch {\n            repository.getAllNotes().collect {\n                _notes.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Create a simple XML layout file for a Fragment containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAdd\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a Fragment class annotated with @AndroidEntryPoint that uses ViewBinding to access the XML layout.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentNoteListBinding\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment() {\n\n    private var _binding: FragmentNoteListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentNoteListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple greeting text.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Define the abstract RoomDatabase class including the abstract DAO method.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a Repository class using @Inject to encapsulate data operations from the DAO.", "output": "import kotlinx.coroutines.flow.Flow\nimport javax.inject.Inject\n\nclass NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n    fun getAllNotes(): Flow<List<Note>> {\n        return noteDao.getAllNotes()\n    }\n\n    suspend fun insert(note: Note) {\n        noteDao.insertNote(note)\n    }\n}"}
{"instruction": "Create a Room Entity data class named 'User' in Kotlin. It should have a primary key 'uid' (auto-generated), a 'firstName', and a 'lastName'.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    val firstName: String,\n    val lastName: String?\n)"}
{"instruction": "Define a Room DAO interface named 'UserDao' with methods to insert a user and a query to get all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAll(): Flow<List<User>>\n\n    @Insert\n    suspend fun insert(user: User)\n}"}
{"instruction": "Create the abstract RoomDatabase class setup for the AppDatabase including the User entity.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class required for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application()"}
{"instruction": "Create a Hilt Module object to provide the AppDatabase instance as a Singleton.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n}"}
{"instruction": "Create a ViewModel class annotated for Hilt that injects a repository named 'UserRepository'.", "output": "import androidx.lifecycle.ViewModel\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Write a Kotlin code snippet for an Activity to replace a Fragment inside a FrameLayout container with ID 'fragment_container'.", "output": "val newFragment = DetailsFragment()\nsupportFragmentManager.beginTransaction()\n    .replace(R.id.fragment_container, newFragment)\n    .addToBackStack(null)\n    .commit()"}
{"instruction": "Create a basic Activity that uses Jetpack Compose to display the text \"Hello Android\" in the center of the screen.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.Text\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                Text(text = \"Hello Android\")\n            }\n        }\n    }\n}"}
{"instruction": "Annotate a Fragment to allow Hilt dependency injection and show how to retrieve the 'UserViewModel' using the 'by viewModels()' delegate.", "output": "import androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserFragment : Fragment() {\n    private val viewModel: UserViewModel by viewModels()\n    // onCreateView logic...\n}"}
{"instruction": "Create an Intent in an Activity to launch a 'SettingsActivity' and pass a boolean flag named 'IS_DARK_MODE'.", "output": "import android.content.Intent\n\nval intent = Intent(this, SettingsActivity::class.java).apply {\n    putExtra(\"IS_DARK_MODE\", true)\n}\nstartActivity(intent)"}
{"instruction": "Create a Kotlin Activity that uses ViewBinding to set the text of a TextView with ID 'tv_welcome' to 'Hello World'.", "output": "class MainActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.tvWelcome.text = \"Hello World\"\n    }\n}"}
{"instruction": "Write a Fragment in Kotlin that displays a Jetpack Compose Text element saying 'Compose inside Fragment' using ComposeView.", "output": "class ComposeFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)\n            setContent {\n                Text(text = \"Compose inside Fragment\")\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room Entity data class named 'Note' with an auto-generated primary key 'id', a 'title', and a 'content' field.", "output": "@Entity(tableName = \"notes\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"content\") val content: String\n)"}
{"instruction": "Create a Room DAO interface for the 'Note' entity with a suspend function to insert a note and a function to observe all notes as a Flow.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt singleton module to provide the Room Database instance and the NoteDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Implement a ViewModel using Hilt injection to receive a repository and expose a StateFlow of notes.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Write the code inside an Activity to programmatically replace a FrameLayout container with ID 'fragment_container' with a new instance of 'DetailFragment'.", "output": "supportFragmentManager.beginTransaction()\n    .replace(R.id.fragment_container, DetailFragment())\n    .addToBackStack(null)\n    .commit()"}
{"instruction": "Create a Room TypeConverter class to handle conversion between a Date object and a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Define the Application class required to initialize Hilt in an Android project.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Show how to annotate an Activity to allow Hilt field injection and inject a 'AnalyticsAdapter' class.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var analyticsAdapter: AnalyticsAdapter\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a completion status.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task, delete a task, and observe all tasks using Kotlin Flow.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n}"}
{"instruction": "Implement an abstract RoomDatabase class that includes the TaskDao and defines the database configuration.", "output": "package com.example.myapp.data.local\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database instance and the TaskDao as singletons.", "output": "package com.example.myapp.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.example.myapp.data.local.AppDatabase\nimport com.example.myapp.data.local.TaskDao\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject the TaskDao.", "output": "package com.example.myapp.ui.tasks\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.myapp.data.local.Task\nimport com.example.myapp.data.local.TaskDao\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val allTasks = taskDao.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Write a simple XML layout file (fragment_task_list.xml) containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAdd\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class annotated with @AndroidEntryPoint that inflates the previous XML layout using ViewBinding and initializes the ViewModel.", "output": "package com.example.myapp.ui.tasks\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport com.example.myapp.databinding.FragmentTaskListBinding\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n    \n    // Hilt automatically injects this ViewModel\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Setup RecyclerView and Observers here\n        binding.fabAdd.setOnClickListener {\n             viewModel.addTask(\"New Task\")\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity that hosts the TaskListFragment using the supportFragmentManager.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.myapp.R\nimport com.example.myapp.ui.tasks.TaskListFragment\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, TaskListFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple text using a Hilt ViewModel.", "output": "package com.example.myapp.ui.compose\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport com.example.myapp.ui.tasks.TaskViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // Obtaining ViewModel in Compose\n            val viewModel: TaskViewModel = hiltViewModel()\n            Text(text = \"This is a Hilt-injected Compose Activity\")\n        }\n    }\n}"}
{"instruction": "Create a Room Entity class named 'UserProfile' in Kotlin. It should have an auto-generating primary key 'id', a 'username' column, and an 'email' column. Annotate the class appropriately for Room.", "output": "@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"user_name\")\n    val username: String,\n    \n    @ColumnInfo(name = \"user_email\")\n    val email: String\n)"}
{"instruction": "Define a Room DAO interface named 'UserDao' with a suspend function to insert a user and a function to observe all users as a Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles ORDER BY user_name ASC\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create a Hilt module to provide the Room Database instance and the UserDao as singletons. Assume the database class is named 'AppDatabase'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Write a TypeConverter class to handle conversion between a standard Java Date object and a Long timestamp for Room storage.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a custom Application class setup for Hilt dependency injection.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Implement a ViewModel named 'UserViewModel' using Hilt Constructor Injection. It should take a 'UserRepository' as a dependency.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<UserProfile>>(emptyList())\n    val users: StateFlow<List<UserProfile>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Create a Fragment named 'UserListFragment' that uses Hilt to inject the 'UserViewModel'. Use ViewBinding to access the layout.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentUserListBinding.bind(view)\n\n        // Observe ViewModel data here\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a Repository class named 'UserRepository' that injects the 'UserDao' and exposes data operations.", "output": "class UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<UserProfile>> = userDao.getAllUsers()\n\n    suspend fun addUser(user: UserProfile) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose function that displays a list of users, observing the state from a Hilt-injected ViewModel.", "output": "@Composable\nfun UserListScreen(\n    viewModel: UserViewModel = hiltViewModel()\n) {\n    val users by viewModel.users.collectAsStateWithLifecycle()\n\n    LazyColumn {\n        items(users) { user ->\n            Text(text = user.username, modifier = Modifier.padding(16.dp))\n            Divider()\n        }\n    }\n}"}
{"instruction": "Create a MainActivity class that is annotated for Hilt and sets a generic XML layout content view.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Fragment container setup usually happens in the XML\n    }\n}"}
{"instruction": "Create a Kotlin function inside a 'MainActivity' class that launches a 'DetailActivity' using an Intent and passes a String extra named 'USER_ID'.", "output": "fun openDetailActivity(userId: String) {\n    val intent = Intent(this, DetailActivity::class.java).apply {\n        putExtra(\"USER_ID\", userId)\n    }\n    startActivity(intent)\n}"}
{"instruction": "Write a Java code snippet to replace a FrameLayout container with ID 'fragment_container' with a new instance of 'SettingsFragment' using the FragmentManager.", "output": "getSupportFragmentManager().beginTransaction()\n    .replace(R.id.fragment_container, new SettingsFragment())\n    .addToBackStack(null)\n    .commit();"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Note' with an auto-generated integer primary key, a title, and a content string.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"note_title\") val title: String,\n    @ColumnInfo(name = \"note_content\") val content: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a user and a function to return a Flow list of all users ordered by name.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM user_table ORDER BY name ASC\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Set up the Android Application class to enable Hilt Dependency Injection for the app.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initialization happens automatically via the annotation\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide a singleton instance of 'AppDatabase' using the application context.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n}"}
{"instruction": "Write a ViewModel class in Kotlin that uses Hilt constructor injection to receive a 'UserRepository'.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n    \n    val users = repository.getAllUsers().asLiveData()\n    \n    fun addUser(user: User) {\n        viewModelScope.launch {\n            repository.insert(user)\n        }\n    }\n}"}
{"instruction": "Create a basic Activity that sets its content using Jetpack Compose instead of an XML layout.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a list of text items using a LazyColumn.", "output": "@Composable\nfun NameList(names: List<String>) {\n    LazyColumn(modifier = Modifier.padding(16.dp)) {\n        items(names) { name ->\n            Text(\n                text = name,\n                style = MaterialTheme.typography.bodyLarge,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n            Divider()\n        }\n    }\n}"}
{"instruction": "Implement the onCreateView and onDestroyView methods in a Kotlin Fragment using ViewBinding to safely handle the binding lifecycle.", "output": "private var _binding: FragmentProfileBinding? = null\nprivate val binding get() = _binding!!\n\noverride fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?\n): View {\n    _binding = FragmentProfileBinding.inflate(inflater, container, false)\n    return binding.root\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n    _binding = null\n}"}
{"instruction": "Create a simple Android Activity in Java named 'LoginActivity' that sets the content view to a layout resource named 'activity_login'.", "output": "import android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class LoginActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n    }\n}"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Product' with an auto-generated primary key, a name, and a price.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"products\")\ndata class Product(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val name: String,\n    val price: Double\n)"}
{"instruction": "Create a Room DAO interface in Kotlin named 'ProductDao' with a suspend function to insert a product and a Flow to get all products.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface ProductDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertProduct(product: Product)\n\n    @Query(\"SELECT * FROM products\")\n    fun getAllProducts(): Flow<List<Product>>\n}"}
{"instruction": "Implement a Hilt Module in Kotlin to provide a singleton instance of the Room Database 'AppDatabase'.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin annotated for Hilt that injects a repository named 'MainRepository' via the constructor.", "output": "import androidx.lifecycle.ViewModel\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport javax.inject.Inject\n\n@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: MainRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Write a Kotlin Fragment named 'UserFragment' annotated with @AndroidEntryPoint to allow Hilt injection, and inflate a binding in onCreateView.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentUserBinding\n\n@AndroidEntryPoint\nclass UserFragment : Fragment() {\n\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose function named 'MessageList' that displays a list of strings using a LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun MessageList(messages: List<String>) {\n    LazyColumn {\n        items(messages) { message ->\n            Text(text = message)\n        }\n    }\n}"}
{"instruction": "Write the XML layout code for a simple Fragment containing a TextView centered within a ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tvHello\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello Fragment\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create the Application class in Kotlin required to initialize Hilt in an Android project.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic\n    }\n}"}
{"instruction": "Show how to programmatically replace a Fragment inside an Activity using Kotlin and the supportFragmentManager.", "output": "val newFragment = SettingsFragment()\n\nsupportFragmentManager.beginTransaction().apply {\n    replace(R.id.fragment_container, newFragment)\n    addToBackStack(null)\n    commit()\n}"}
{"instruction": "Create a custom Application class required to initialize Hilt dependency injection in an Android project.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity class in Kotlin representing a 'User' with a primary key.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val firstName: String,\n    val lastName: String,\n    val email: String\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface with methods to insert a user and get all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Create a Hilt Module object to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject a Repository, exposing a StateFlow for UI consumption.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users\n\n    init {\n        loadUsers()\n    }\n\n    private fun loadUsers() {\n        viewModelScope.launch {\n            userRepository.getUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Write an XML layout file (fragment_user_list.xml) containing a RecyclerView and a FloatingActionButton inside a ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAddUser\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class annotated with @AndroidEntryPoint that inflates a layout using ViewBinding.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentUserListBinding\n\n@AndroidEntryPoint\nclass UserListFragment : Fragment() {\n\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Set up a main Activity using Jetpack Compose and Hilt, defining the content view.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                // Call your Composable Screen here\n                MainScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose function to display a User card.", "output": "import androidx.compose.foundation.layout.*\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun UserCard(name: String, email: String) {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(8.dp)\n    ) {\n        Column(modifier = Modifier.padding(16.dp)) {\n            Text(text = name)\n            Spacer(modifier = Modifier.height(4.dp))\n            Text(text = email)\n        }\n    }\n}"}
{"instruction": "Create a Repository class injected via Hilt that acts as a mediator between the DAO and the ViewModel.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    fun getUsers(): Flow<List<User>> {\n        return userDao.getAllUsers()\n    }\n\n    suspend fun addUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin setup for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global setups here\n    }\n}"}
{"instruction": "Define a simple Room Database Entity class named 'User' with an auto-generated primary key, a first name, and a last name.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Create a Room DAO interface for the 'User' entity with methods to insert a user and get all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Write a Hilt Module object to provide the Room Database instance and the UserDao as singleton dependencies.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection that accepts a Repository in its constructor and exposes a StateFlow of users.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    val users: StateFlow<List<User>> = userRepository.getAllUsers()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Write a simple Repository class that injects the UserDao and provides data access methods.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    fun getAllUsers(): Flow<List<User>> = userDao.getAllUsers()\n\n    suspend fun addUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that inflates a layout using ViewBinding and accesses the UserViewModel.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentUserBinding\n\n@AndroidEntryPoint\nclass UserFragment : Fragment() {\n\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write the XML layout code for a simple Activity containing a FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/fragment_container\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple text greeting.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Implement a Room TypeConverter to handle Date objects by converting them to Long timestamps.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Kotlin function inside a MainActivity class that creates an explicit Intent to navigate to DetailsActivity, passing a string extra named 'USER_ID'.", "output": "fun navigateToDetails(userId: String) {\n    val intent = Intent(this, DetailsActivity::class.java).apply {\n        putExtra(\"USER_ID\", userId)\n    }\n    startActivity(intent)\n}"}
{"instruction": "Define a Room Entity data class in Kotlin named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean\n)"}
{"instruction": "Create a Hilt module in Kotlin that provides a singleton instance of an interface named 'AnalyticsService'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject AnalyticsModule {\n\n    @Provides\n    @Singleton\n    fun provideAnalyticsService(): AnalyticsService {\n        return AnalyticsServiceImpl()\n    }\n}"}
{"instruction": "Write a standard XML layout file for a Fragment containing a single TextView centered in a ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tv_center\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello Fragment\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a Room DAO interface in Kotlin for a 'User' entity with methods to insert a user and get all users as a Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create a basic Activity in Kotlin using Jetpack Compose that sets the content to a MaterialTheme with a simple Surface and Text.", "output": "class ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(text = \"Hello Jetpack Compose!\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Show how to annotate a Kotlin Activity to allow Hilt field injection and inject a class named 'UserRepository'.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var userRepository: UserRepository\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // userRepository is now ready to use\n    }\n}"}
{"instruction": "Define a RoomDatabase abstract class in Kotlin that includes the 'Task' entity and provides an abstract method to retrieve the TaskDao.", "output": "@Database(entities = [Task::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write a Java Fragment implementation that overrides onCreateView to inflate a layout named 'fragment_home'.", "output": "public class HomeFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_home, container, false);\n    }\n}"}
{"instruction": "Create a Hilt-compatible ViewModel in Kotlin using constructor injection to receive a 'NoteRepository'.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n    \n    val notes = repository.getAllNotes()\n    \n    fun addNote(note: Note) {\n        viewModelScope.launch {\n            repository.insert(note)\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'UserProfile' with a primary key 'id' and columns for 'name' and 'email'.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    \n    @ColumnInfo(name = \"full_name\")\n    val name: String,\n    \n    @ColumnInfo(name = \"email_address\")\n    val email: String\n)"}
{"instruction": "Write a Hilt module in Kotlin to provide a singleton instance of a Room Database named 'AppDatabase' and its DAO 'UserDao'.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a standard Android Activity in Kotlin that sets its content using Jetpack Compose and displays a simple text greeting.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android Developer\")\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}"}
{"instruction": "Define a Room DAO interface in Kotlin with methods to insert a user (suspend) and get all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles ORDER BY full_name ASC\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create a generic BaseFragment in Kotlin that handles ViewBinding setup and teardown to prevent memory leaks.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.viewbinding.ViewBinding\n\nabstract class BaseFragment<VB : ViewBinding> : Fragment() {\n\n    private var _binding: VB? = null\n    protected val binding get() = _binding!!\n\n    abstract fun inflateBinding(inflater: LayoutInflater, container: ViewGroup?): VB\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        _binding = inflateBinding(inflater, container)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Implement a ViewModel in Kotlin using Hilt to inject a Repository, with a StateFlow to expose data to the UI.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _userState = MutableStateFlow<List<User>>(emptyList())\n    val userState: StateFlow<List<User>> = _userState\n\n    init {\n        loadUsers()\n    }\n\n    private fun loadUsers() {\n        viewModelScope.launch {\n            userRepository.getUsers().collect {\n                _userState.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Setup the Application class in Kotlin for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here\n    }\n}"}
{"instruction": "Write a Room TypeConverter in Kotlin to convert a Date object to a Long timestamp and vice versa.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin annotated with @AndroidEntryPoint that observes a ViewModel LiveData/Flow.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.userState.collect { users ->\n                // Update UI with list of users\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room Database abstract class in Kotlin including the entities and the version number.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\nimport androidx.room.TypeConverters\n\n@Database(entities = [UserProfile::class], version = 1, exportSchema = false)\n@TypeConverters(DateConverters::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a simple Android Activity in Kotlin that uses ViewBinding to set the text of a TextView defined in the XML layout.", "output": "// build.gradle (Module-level): viewBinding { enabled = true }\n\n// layout/activity_main.xml\n/*\n<LinearLayout ...>\n    <TextView android:id=\"@+id/welcomeText\" ... />\n</LinearLayout>\n*/\n\n// MainActivity.kt\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.app.databinding.ActivityMainBinding\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.welcomeText.text = \"Hello, ViewBinding!\"\n    }\n}"}
{"instruction": "Define a Room Database Entity class in Kotlin representing a 'Book' with an auto-generated primary key, a title, and an author.", "output": "import androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"books_table\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"book_title\")\n    val title: String,\n\n    @ColumnInfo(name = \"book_author\")\n    val author: String\n)"}
{"instruction": "Write a Room DAO (Data Access Object) interface in Kotlin with methods to insert a list of items and query all items as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface BookDao {\n\n    @Query(\"SELECT * FROM books_table ORDER BY book_title ASC\")\n    fun getAllBooks(): Flow<List<Book>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertBooks(books: List<Book>)\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide a singleton instance of the Room Database.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideBookDao(database: AppDatabase): BookDao {\n        return database.bookDao()\n    }\n}"}
{"instruction": "Implement a Fragment in Kotlin that hosts a Jetpack Compose view using ComposeView.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.compose.material3.Text\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.fragment.app.Fragment\n\nclass ComposeFragment : Fragment() {\n\n    override fun onCreateView(\n        inflater: LayoutInflater, \n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                Text(text = \"Hello from Jetpack Compose inside a Fragment!\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin using Hilt constructor injection to inject a repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass BookViewModel @Inject constructor(\n    private val repository: BookRepository\n) : ViewModel() {\n\n    fun addBook(title: String, author: String) {\n        viewModelScope.launch {\n            repository.addNewBook(title, author)\n        }\n    }\n}"}
{"instruction": "Write a Java method inside an Activity to programmatically replace a FrameLayout container with a Fragment.", "output": "import androidx.fragment.app.Fragment;\nimport androidx.fragment.app.FragmentManager;\nimport androidx.fragment.app.FragmentTransaction;\n\npublic void loadFragment(Fragment fragment) {\n    FragmentManager fragmentManager = getSupportFragmentManager();\n    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n    \n    // R.id.fragment_container is the ID of the FrameLayout in XML\n    fragmentTransaction.replace(R.id.fragment_container, fragment);\n    fragmentTransaction.addToBackStack(null);\n    fragmentTransaction.commit();\n}"}
{"instruction": "Setup the Application class required for Hilt Dependency Injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here if needed\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that demonstrates State Hoisting with a counter button.", "output": "import androidx.compose.material3.Button\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\n\n// Stateful Composable\n@Composable\nfun CounterScreen() {\n    var count by remember { mutableStateOf(0) }\n    \n    CounterContent(\n        count = count,\n        onIncrement = { count++ }\n    )\n}\n\n// Stateless Composable (Hoisted State)\n@Composable\nfun CounterContent(count: Int, onIncrement: () -> Unit) {\n    Button(onClick = onIncrement) {\n        Text(text = \"Count is $count\")\n    }\n}"}
{"instruction": "Define a Room Database migration strategy in Kotlin to add a new column 'year_published' to an existing 'books_table'.", "output": "import androidx.room.migration.Migration\nimport androidx.sqlite.db.SupportSQLiteDatabase\n\nval MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        database.execSQL(\n            \"ALTER TABLE books_table ADD COLUMN year_published INTEGER DEFAULT 0 NOT NULL\"\n        )\n    }\n}\n\n// Usage in database builder:\n// Room.databaseBuilder(context, AppDatabase::class.java, \"db_name\")\n//     .addMigrations(MIGRATION_1_2)\n//     .build()"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity representing a 'Task' with an auto-generated primary key, a title, and a completion boolean.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Define a Room DAO interface in Kotlin with methods to insert a Task, delete a Task, and return a Flow list of all tasks ordered by ID.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY id ASC\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n}"}
{"instruction": "Create a Hilt module object in Kotlin to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Write a ViewModel class using Hilt injection to receive the TaskDao and expose a StateFlow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val tasks = taskDao.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a basic Application class annotated to setup Hilt for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass TaskApplication : Application()"}
{"instruction": "Write an Android Activity in Kotlin annotated with @AndroidEntryPoint that hosts a FragmentContainerView via XML binding.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.ActivityMainBinding\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n    }\n}"}
{"instruction": "Create a Fragment using ViewBinding and Hilt to inject the TaskViewModel, observing the task list in onViewCreated.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Assuming ViewBinding is set up or using synthetic access for simplicity in snippet\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.tasks.collectLatest { taskList ->\n                // Update UI adapter here\n            }\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a list of tasks using LazyColumn and includes a FloatingActionButton to add a new task.", "output": "import androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\n\n@Composable\nfun TaskScreen(tasks: List<Task>, onAddTask: () -> Unit) {\n    Scaffold(\n        floatingActionButton = {\n            FloatingActionButton(onClick = onAddTask) {\n                Text(\"+\")\n            }\n        }\n    ) { paddingValues ->\n        LazyColumn(\n            modifier = Modifier.fillMaxSize().padding(paddingValues)\n        ) {\n            items(tasks) { task ->\n                Text(text = task.title, modifier = Modifier.padding(16.dp))\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room TypeConverter class to handle conversion between Date objects and Long timestamps.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create an XML layout file for an Activity containing a FragmentContainerView setup for the Navigation Component.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Task' with an auto-generated ID, a title, and a completion boolean flag.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a Task and a function to return a Flow of all tasks ordered by ID.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks ORDER BY id ASC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Write a Hilt Module in Kotlin to provide a singleton instance of the Room Database.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a generic Application class annotated with @HiltAndroidApp to trigger Hilt's code generation.", "output": "@HiltAndroidApp\nclass TodoApplication : Application()"}
{"instruction": "Define a ViewModel using Hilt constructor injection to inject a repository.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Create a basic Fragment in Kotlin that inflates a layout using ViewBinding and cleans up the binding in onDestroyView.", "output": "class TaskListFragment : Fragment() {\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write an XML layout file for an Activity containing a FragmentContainerView for the Navigation Component.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Room TypeConverter class to convert a Date object to a Long timestamp and vice versa.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Set up a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple text greeting.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(text = \"Hello, Hilt and Compose!\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Kotlin function inside a Fragment to navigate to a detail screen passing an argument using Safe Args.", "output": "fun onTaskClicked(taskId: Int) {\n    val action = TaskListFragmentDirections.actionListToDetail(taskId)\n    findNavController().navigate(action)\n}"}
{"instruction": "Define a simple Room Database Entity class in Kotlin representing a 'Book' with an auto-generated primary key, a title, and an author.", "output": "@Entity(tableName = \"books\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"author\") val author: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with suspend functions to insert a Book and a function to observe all books as a Flow.", "output": "@Dao\ninterface BookDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertBook(book: Book)\n\n    @Query(\"SELECT * FROM books\")\n    fun getAllBooks(): Flow<List<Book>>\n}"}
{"instruction": "Write a Hilt module in Kotlin to provide a singleton instance of the Room Database and the BookDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"library_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideBookDao(database: AppDatabase): BookDao {\n        return database.bookDao()\n    }\n}"}
{"instruction": "Create a Repository class in Kotlin that injects the BookDao using Hilt and exposes methods to data sources.", "output": "class BookRepository @Inject constructor(\n    private val bookDao: BookDao\n) {\n    val allBooks: Flow<List<Book>> = bookDao.getAllBooks()\n\n    suspend fun addBook(book: Book) {\n        bookDao.insertBook(book)\n    }\n}"}
{"instruction": "Implement a ViewModel in Kotlin using @HiltViewModel that injects the BookRepository and exposes a Flow of books to the UI.", "output": "@HiltViewModel\nclass LibraryViewModel @Inject constructor(\n    private val repository: BookRepository\n) : ViewModel() {\n\n    val books: StateFlow<List<Book>> = repository.allBooks\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNewBook(title: String, author: String) {\n        viewModelScope.launch {\n            repository.addBook(Book(title = title, author = author))\n        }\n    }\n}"}
{"instruction": "Setup the main Application class in Kotlin to initialize Hilt.", "output": "@HiltAndroidApp\nclass LibraryApplication : Application()"}
{"instruction": "Create a Fragment in Kotlin annotated with @AndroidEntryPoint that inflates an XML layout and collects the ViewModel state using a lifecycle-aware coroutine.", "output": "@AndroidEntryPoint\nclass BookListFragment : Fragment(R.layout.fragment_book_list) {\n\n    private val viewModel: LibraryViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.books.collect { books ->\n                    // Update UI adapter here\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a standard AppCompatActivity in Kotlin that hosts a Fragment container via XML and is annotated for Hilt.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, BookListFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that instantiates a Hilt ViewModel and displays a list of books.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: LibraryViewModel = hiltViewModel()\n            val books by viewModel.books.collectAsState()\n\n            LazyColumn {\n                items(books) { book ->\n                    Text(text = book.title)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Room TypeConverter in Kotlin to handle conversion between a Date object and a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Kotlin data class representing a Room Database Entity named 'Note' with an auto-generated primary key, a title, and a content field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface in Kotlin for the 'Note' entity with methods to insert a note and observe all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create the abstract RoomDatabase class in Kotlin that includes the Note entity and the NoteDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Set up the Hilt Application class required to trigger dependency injection code generation.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or analytics here\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide the Room Database instance and the DAO as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection to inject the NoteDao and expose a Flow of notes.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val noteDao: NoteDao\n) : ViewModel() {\n\n    val allNotes = noteDao.getAllNotes()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            noteDao.insertNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Create a standard XML-based Activity that acts as an entry point for Hilt and sets up a layout using ViewBinding.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.ActivityMainBinding\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    \n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        // Fragment container setup usually goes here\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that injects the NoteViewModel and observes the data using Kotlin.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment(R.layout.fragment_note_list) {\n\n    private val viewModel: NoteViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.allNotes.collect {\n                // Update RecyclerView adapter here\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated for Hilt that sets the content to a Composable screen.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                NoteScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that retrieves the Hilt-injected ViewModel and displays the list of notes.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun NoteScreen(viewModel: NoteViewModel = hiltViewModel()) {\n    val notes by viewModel.allNotes.collectAsState()\n\n    LazyColumn {\n        items(notes) { note ->\n            Text(text = note.title)\n        }\n    }\n}"}
{"instruction": "Create a basic MainActivity in Kotlin that sets the content view to an XML layout named 'activity_main' and initializes a TextView with ID 'tv_welcome'.", "output": "import android.os.Bundle\nimport android.widget.TextView\nimport androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val tvWelcome: TextView = findViewById(R.id.tv_welcome)\n        tvWelcome.text = \"Welcome to Android\"\n    }\n}"}
{"instruction": "Define a Room Entity class named 'UserProfile' with an auto-generated primary key 'uid', a 'firstName', and a 'lastName'.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"user_profile\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Create a Hilt module in Kotlin to provide a Singleton instance of a Room Database named 'AppDatabase'.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n}"}
{"instruction": "Write a Room DAO interface with a method to insert a user and a method to retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profile\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create a ViewModel class annotated for Hilt that injects a repository named 'UserRepository' via the constructor.", "output": "import androidx.lifecycle.ViewModel\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Create a Fragment that uses Jetpack Compose inside its onCreateView method to render a simple Text element.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.compose.material.Text\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.fragment.app.Fragment\n\nclass ComposeFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                Text(text = \"Hello from Compose Fragment\")\n            }\n        }\n    }\n}"}
{"instruction": "Setup the Application class required for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic\n    }\n}"}
{"instruction": "Implement a simple Jetpack Compose screen with a Button that increments a counter state.", "output": "import androidx.compose.foundation.layout.Column\nimport androidx.compose.material.Button\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.* // get getValue and setValue imports\n\n@Composable\nfun CounterScreen() {\n    var count by remember { mutableStateOf(0) }\n\n    Column {\n        Text(text = \"Count: $count\")\n        Button(onClick = { count++ }) {\n            Text(\"Increment\")\n        }\n    }\n}"}
{"instruction": "Show how to replace a Fragment inside an Activity using the SupportFragmentManager in Kotlin.", "output": "val newFragment = DetailFragment()\nsupportFragmentManager.beginTransaction()\n    .replace(R.id.fragment_container_view, newFragment)\n    .addToBackStack(null)\n    .commit()"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint to allow field injection of a helper class.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport javax.inject.Inject\n\n@AndroidEntryPoint\nclass SettingsFragment : Fragment(R.layout.fragment_settings) {\n\n    @Inject\n    lateinit var analyticsLogger: AnalyticsLogger\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        analyticsLogger.logEvent(\"Settings Opened\")\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'Note'. It should have an auto-generated primary key 'id', a 'title' column, and a 'content' column.", "output": "import androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Write a Room DAO interface in Kotlin with a suspend function to insert a Note and a function to return a Flow of a list of all Notes.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create the abstract RoomDatabase class in Kotlin that includes the Note entity and the NoteDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Set up the Application class for Hilt Dependency Injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin using Hilt Constructor Injection to inject a repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val allNotes = repository.allNotes\n\n    fun addNote(note: Note) = viewModelScope.launch {\n        repository.insert(note)\n    }\n}"}
{"instruction": "Create a simple Fragment in Kotlin that uses ViewBinding to access a TextView and set its text in onViewCreated.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport com.example.app.databinding.FragmentExampleBinding\n\nclass ExampleFragment : Fragment(R.layout.fragment_example) {\n\n    private var _binding: FragmentExampleBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentExampleBinding.bind(view)\n        \n        binding.textViewTitle.text = \"Hello from Fragment\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that displays a LazyColumn of text items.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.layout.padding\n\n@Composable\nfun NoteList(notes: List<String>) {\n    LazyColumn {\n        items(notes) { note ->\n            Text(\n                text = note,\n                modifier = Modifier.padding(16.dp)\n            )\n        }\n    }\n}"}
{"instruction": "Create an Activity annotated with @AndroidEntryPoint that sets a Jetpack Compose layout content.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyComposeTheme {\n                MainScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Define a simple navigation graph in XML with a start destination Fragment.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/nav_graph\"\n    app:startDestination=\"@id/homeFragment\">\n\n    <fragment\n        android:id=\"@+id/homeFragment\"\n        android:name=\"com.example.app.HomeFragment\"\n        android:label=\"Home\"\n        tools:layout=\"@layout/fragment_home\" >\n        <action\n            android:id=\"@+id/action_home_to_detail\"\n            app:destination=\"@id/detailFragment\" />\n    </fragment>\n\n    <fragment\n        android:id=\"@+id/detailFragment\"\n        android:name=\"com.example.app.DetailFragment\"\n        android:label=\"Detail\" />\n</navigation>"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is initialized automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'User' in Kotlin with columns for id, name, and email.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"full_name\") val name: String,\n    @ColumnInfo(name = \"email_address\") val email: String\n)"}
{"instruction": "Create a Room DAO interface for the User entity with methods to insert a user and get all users using Kotlin Coroutines.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin that includes the User entity and the UserDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide the singleton instance of the Room Database and the UserDao.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Repository class in Kotlin that injects the UserDao and exposes data operations.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<User>> = userDao.getAllUsers()\n\n    suspend fun addUser(user: User) {\n        userDao.insertUser(user)\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt injection to manage User data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users = repository.allUsers\n\n    fun addUser(name: String, email: String) {\n        viewModelScope.launch {\n            repository.addUser(User(name = name, email = email))\n        }\n    }\n}"}
{"instruction": "Create an Android Fragment in Kotlin annotated for Hilt that injects the UserViewModel and uses ViewBinding.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentUserBinding\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentUserBinding.bind(view)\n        \n        // Observe data\n        // viewModel.users.observe(viewLifecycleOwner) { ... }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity in Kotlin using Jetpack Compose that is set up as the Hilt entry point.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // In Compose, we can get the ViewModel like this:\n            val viewModel: UserViewModel = hiltViewModel()\n            UserScreen(viewModel)\n        }\n    }\n}"}
{"instruction": "Write the XML layout code for an Activity that hosts a Fragment using FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Kotlin Activity that hosts a Fragment named 'HomeFragment' using the SupportFragmentManager inside a FrameLayout container with ID 'fragment_container'.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.app.R\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, HomeFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Define a Room Database Entity named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Implement a Hilt Module to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Repository class that injects the TaskDao using Hilt and exposes methods to get data.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun addTask(task: Task) {\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel that injects the TaskRepository and exposes the task list as a StateFlow.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = repository.allTasks\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Write a TypeConverter class for Room to handle conversion between a Date object and a Long timestamp.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Setup a Fragment using ViewBinding, ensuring the binding reference is cleared in onDestroyView to prevent memory leaks.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport com.example.app.databinding.FragmentProfileBinding\n\nclass ProfileFragment : Fragment() {\n\n    private var _binding: FragmentProfileBinding? = null\n    // This property is only valid between onCreateView and onDestroyView.\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint to allow Hilt injection.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // Call Composable functions here\n            MainScreen()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that observes a list of tasks from a ViewModel and displays them in a LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun TaskListScreen(viewModel: TaskViewModel = viewModel()) {\n    val tasks by viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class configured for Hilt dependency injection in Kotlin.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or other global configs here\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Task' item with an auto-generated primary key.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks\")\ndata class TaskEntity(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false,\n    @ColumnInfo(name = \"created_at\") val createdAt: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface with methods to insert a task and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY created_at DESC\")\n    fun getAllTasks(): Flow<List<TaskEntity>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: TaskEntity)\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and DAO instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Repository class that is injected with the DAO using Hilt.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<TaskEntity>> = taskDao.getAllTasks()\n\n    suspend fun addTask(title: String) {\n        val newTask = TaskEntity(title = title)\n        taskDao.insertTask(newTask)\n    }\n}"}
{"instruction": "Create a Hilt-aware ViewModel that uses the Repository to fetch data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.allTasks\n\n    fun addNewTask(title: String) {\n        viewModelScope.launch {\n            repository.addTask(title)\n        }\n    }\n}"}
{"instruction": "Set up a standard Android Activity that uses XML layout and is annotated for Hilt injection.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Fragment transactions or View setup go here\n    }\n}"}
{"instruction": "Create a Fragment that uses ViewBinding and injects the ViewModel using Hilt.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentTaskListBinding.bind(view)\n        \n        // Observe ViewModel data here\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity that serves as the entry point for a Hilt application.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                // Call your Composable screens here\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that observes a Flow from a Hilt ViewModel.", "output": "import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    // Collect flow as state\n    val taskList by viewModel.tasks.collectAsState(initial = emptyList())\n\n    LazyColumn {\n        items(taskList) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity representing a 'User' with a primary key, and define a DAO interface to insert a user and fetch all users.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of the Room Database (AppDatabase) and the UserDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Implement a ViewModel using Hilt to inject a Repository, expose a StateFlow of data, and use the @HiltViewModel annotation.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            userRepository.getUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Fragment implementation that uses ViewBinding to set the text of a TextView in `onViewCreated`, handling the binding lifecycle correctly.", "output": "class ProfileFragment : Fragment(R.layout.fragment_profile) {\n\n    private var _binding: FragmentProfileBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.textViewUsername.text = \"John Doe\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create the Application class required to initialize Hilt dependency injection for the Android app.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initializes automatically via the annotation\n    }\n}"}
{"instruction": "Write a Kotlin Activity annotated with @AndroidEntryPoint that injects a dependency and sets up a Jetpack Compose UI content.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n    @Inject\n    lateinit var analyticsLogger: AnalyticsLogger\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        analyticsLogger.logEvent(\"AppStarted\")\n        \n        setContent {\n            MaterialTheme {\n                Surface(color = MaterialTheme.colorScheme.background) {\n                    Text(text = \"Hello, Hilt & Compose!\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room TypeConverter in Kotlin to store a `Date` object as a `Long` timestamp in the database.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Repository class in Kotlin that is injected with a Room DAO via Hilt's constructor injection.", "output": "class ProductRepository @Inject constructor(\n    private val productDao: ProductDao\n) {\n    \n    suspend fun insertProduct(product: Product) {\n        productDao.insert(product)\n    }\n\n    fun getAllProducts(): Flow<List<Product>> {\n        return productDao.getAll()\n    }\n}"}
{"instruction": "Write the XML layout code for a Fragment containing a ConstraintLayout with a Button centered in the screen.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/btn_action\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Click Me\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Demonstrate how to navigate from one Fragment to another passing an integer argument using Android Navigation Component and SafeArgs in Kotlin.", "output": "// Assuming the navigation graph defines an action with an argument 'userId'\nfun navigateToDetail(userId: Int) {\n    val action = HomeFragmentDirections.actionHomeFragmentToDetailFragment(userId)\n    findNavController().navigate(action)\n}"}
{"instruction": "Create a custom Application class in Kotlin required to initialize Hilt Dependency Injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyBaseApplication : Application() {\n    // No extra code needed here unless initializing other libraries\n}"}
{"instruction": "Define a Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity containing a suspend function to insert a task and a function to return all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks_table ORDER BY id ASC\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Implement the abstract RoomDatabase class in Kotlin, including the 'Task' entity and the abstract DAO getter.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Hilt Module object to provide the Room Database instance and the TaskDao as Singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Hilt-enabled ViewModel using the @HiltViewModel annotation that injects the TaskDao via the constructor.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val allTasks = taskDao.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create an Activity class annotated with @AndroidEntryPoint that sets the content view to an XML layout.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Write a Fragment class annotated with @AndroidEntryPoint that uses ViewBinding to access views and injects the TaskViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n    private var binding: FragmentTaskListBinding? = null\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding = FragmentTaskListBinding.bind(view)\n        \n        // Example usage\n        binding?.fab?.setOnClickListener {\n            viewModel.addTask(\"New Task\")\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        binding = null\n    }\n}"}
{"instruction": "Demonstrate how to inject a Hilt ViewModel into a Jetpack Compose Composable function.", "output": "import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TaskScreen(\n    viewModel: TaskViewModel = hiltViewModel()\n) {\n    val tasks = viewModel.allTasks.collectAsState(initial = emptyList())\n\n    // UI implementation using tasks.value\n}"}
{"instruction": "Create an XML layout file for a Fragment that contains a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_add\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'UserProfile' with a primary key 'id', and columns for 'username' and 'email'.", "output": "@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true) val id: Long = 0,\n    @ColumnInfo(name = \"username\") val username: String,\n    @ColumnInfo(name = \"email\") val email: String\n)"}
{"instruction": "Define a Room DAO interface named 'UserDao' with methods to insert a user, delete a user, and observe all users using Kotlin Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Delete\n    suspend fun deleteUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create an abstract RoomDatabase class named 'AppDatabase' that includes the UserProfile entity and the UserDao.", "output": "@Database(entities = [UserProfile::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Write a Hilt module in Kotlin to provide the AppDatabase and UserDao instances as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a generic Hilt Application class required to trigger dependency injection code generation.", "output": "@HiltAndroidApp\nclass MyApp : Application()"}
{"instruction": "Implement a ViewModel using Hilt injection to inject a repository, exposing a StateFlow of users.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<UserProfile>>(emptyList())\n    val users: StateFlow<List<UserProfile>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Create an Android Activity annotated with @AndroidEntryPoint that hosts a simple Jetpack Compose Surface.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(text = \"Hello Hilt!\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a basic Fragment class using ViewBinding and annotated with @AndroidEntryPoint.", "output": "@AndroidEntryPoint\nclass UserFragment : Fragment() {\n\n    private var _binding: FragmentUserBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a simple XML layout file for a Fragment containing a ConstraintLayout and a centered TextView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tvMessage\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Welcome User\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a Room TypeConverter class to convert a standard Date object to a Long timestamp and vice versa.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Define a Room Entity in Kotlin representing a 'Book' with an auto-generated primary key, a title, and an author.", "output": "@Entity(tableName = \"books\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"book_title\") val title: String,\n    @ColumnInfo(name = \"book_author\") val author: String\n)"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of the Room Database using the application context.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Write a Kotlin ViewModel annotated for Hilt that injects a repository via the constructor and exposes a StateFlow.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    private val _userState = MutableStateFlow<UiState>(UiState.Loading)\n    val userState: StateFlow<UiState> = _userState.asStateFlow()\n\n    fun loadUsers() {\n        viewModelScope.launch {\n            _userState.value = UiState.Success(userRepository.getAllUsers())\n        }\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin that sets up ViewBinding, ensuring the binding reference is cleared in onDestroyView to prevent memory leaks.", "output": "@AndroidEntryPoint\nclass ProfileFragment : Fragment() {\n\n    private var _binding: FragmentProfileBinding? = null\n    // This property is only valid between onCreateView and onDestroyView.\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define a Room DAO interface in Kotlin with methods to insert a user and observe a list of users using Kotlin Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM user_table ORDER BY name ASC\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Delete\n    suspend fun deleteUser(user: User)\n}"}
{"instruction": "Create a basic abstract RoomDatabase class in Kotlin that includes a 'Task' entity and a corresponding DAO.", "output": "@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write the Application class required to initialize Hilt dependency injection in an Android app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create an XML layout file for a RecyclerView item using ConstraintLayout containing an ImageView and a TextView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"16dp\">\n\n    <ImageView\n        android:id=\"@+id/ivProfile\"\n        android:layout_width=\"50dp\"\n        android:layout_height=\"50dp\"\n        android:src=\"@mipmap/ic_launcher\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\" />\n\n    <TextView\n        android:id=\"@+id/tvName\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"16dp\"\n        android:text=\"User Name\"\n        android:textSize=\"18sp\"\n        app:layout_constraintStart_toEndOf=\"@id/ivProfile\"\n        app:layout_constraintTop_toTopOf=\"@id/ivProfile\"\n        app:layout_constraintBottom_toBottomOf=\"@id/ivProfile\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Demonstrate how to inject a Hilt ViewModel into a Jetpack Compose function using the 'hiltViewModel()' helper.", "output": "@Composable\nfun UserListScreen(\n    viewModel: UserViewModel = hiltViewModel()\n) {\n    val userState by viewModel.userState.collectAsState()\n\n    LazyColumn {\n        items(userState.users) { user ->\n            Text(text = user.name)\n        }\n    }\n}"}
{"instruction": "Set up a MainActivity in Kotlin that is annotated with @AndroidEntryPoint and hosts a FragmentContainerView for Navigation Component.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Setup NavController if needed here, usually via supportFragmentManager\n        // val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment\n        // val navController = navHostFragment.navController\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin and annotate it to trigger Hilt's code generation.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Note' with an auto-generated primary key, a title, and a content field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String,\n    val timestamp: Long\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface for the 'Note' entity with methods to insert a note and get all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY timestamp DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the Note entity and the abstract DAO getter.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a Hilt Module object to provide the Room Database and the NoteDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a Repository class that uses constructor injection to get the NoteDao and exposes data operations.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n    val allNotes: Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun addNote(note: Note) {\n        noteDao.insert(note)\n    }\n}"}
{"instruction": "Create a Hilt-aware ViewModel that injects the Repository and exposes a StateFlow of notes.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.allNotes\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.addNote(Note(title = title, content = content, timestamp = System.currentTimeMillis()))\n        }\n    }\n}"}
{"instruction": "Write a simple Activity XML layout containing a FragmentContainerView to host a navigation graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class annotated with @AndroidEntryPoint that inflates a layout and accesses the ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment(R.layout.fragment_note_list) {\n\n    private val viewModel: NoteViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Observe viewModel.notes and update UI here\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple greeting text.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android Developer\")\n        }\n    }\n}\n\n@androidx.compose.runtime.Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'Note' with a title, content, and an auto-generated primary key.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n    \n    @ColumnInfo(name = \"note_content\")\n    val content: String,\n    \n    @ColumnInfo(name = \"created_at\")\n    val timestamp: Long = System.currentTimeMillis()\n)"}
{"instruction": "Create a Data Access Object (DAO) interface for the Note entity with methods to insert a note, delete a note, and retrieve all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Delete\n    suspend fun deleteNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY created_at DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Set up the Application class required to initialize Hilt dependency injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and the NoteDao instance as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideNoteDatabase(@ApplicationContext context: Context): NoteDatabase {\n        return Room.databaseBuilder(\n            context,\n            NoteDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideNoteDao(database: NoteDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject a repository, exposing a StateFlow of notes to the UI.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val allNotes: StateFlow<List<Note>> = repository.getAllNotes()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = emptyList()\n        )\n\n    fun addNote(note: Note) {\n        // Launch coroutine to add note\n    }\n}"}
{"instruction": "Write a main Activity class annotated with @AndroidEntryPoint that sets the content view to an XML layout containing a FragmentContainerView.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment that uses @AndroidEntryPoint to inject the NoteViewModel and observes the notes data using a RecyclerView adapter.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass NoteListFragment : Fragment(R.layout.fragment_note_list) {\n\n    private val viewModel: NoteViewModel by viewModels()\n    private lateinit var adapter: NoteAdapter\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Assume binding is set up or using findViewById\n        val recyclerView = view.findViewById<androidx.recyclerview.widget.RecyclerView>(R.id.recyclerView)\n        adapter = NoteAdapter()\n        recyclerView.layoutManager = LinearLayoutManager(requireContext())\n        recyclerView.adapter = adapter\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.allNotes.collect {\n                adapter.submitList(it)\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room TypeConverter to handle the conversion between a Date object and a Long timestamp.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that retrieves the ViewModel via Hilt and displays the list of notes.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun NoteScreen(viewModel: NoteViewModel = hiltViewModel()) {\n    val notes by viewModel.allNotes.collectAsState()\n\n    LazyColumn {\n        items(notes) { note ->\n            Text(text = note.title)\n        }\n    }\n}"}
{"instruction": "Write the XML layout code for a fragment containing a RecyclerView and a FloatingActionButton anchored to the bottom right.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab_add\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_add\"\n        android:contentDescription=\"Add Note\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity representing a 'User' with an auto-generated primary key and columns for first and last name.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface with a suspended insert function and a query function that returns a Flow of a list of Users.", "output": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Create an abstract RoomDatabase class that includes the User entity and the UserDao abstract function.", "output": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Hilt Application class by creating a custom Application class annotated with @HiltAndroidApp.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Create a Hilt Module to provide the Room Database and UserDao instances as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject the UserDao.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users: Flow<List<User>> = userDao.getAllUsers()\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            userDao.insertUser(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create an Android Fragment annotated with @AndroidEntryPoint that retrieves the UserViewModel using the 'by viewModels()' delegate.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Observe viewModel.users here\n    }\n}"}
{"instruction": "Write an Activity XML layout file that contains a FragmentContainerView to host a navigation graph or specific fragment.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a Composable function.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyApplicationTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    MainScreen()\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Room TypeConverter to handle Date objects by converting them to Long timestamps.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Define a Kotlin data class annotated as a Room Entity for a 'Task' with an auto-generated ID, and create a DAO interface to insert and retrieve all tasks.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean\n)\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Create a Hilt Module in Kotlin to provide a singleton instance of the Room Database and the TaskDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Write a Kotlin Fragment class that uses ViewBinding to inflate a layout named 'fragment_user_profile.xml' and handles the binding lifecycle correctly.", "output": "class UserProfileFragment : Fragment() {\n\n    private var _binding: FragmentUserProfileBinding? = null\n    // This property is only valid between onCreateView and onDestroyView.\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserProfileBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a repository, annotated with @HiltViewModel.", "output": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val mainRepository: MainRepository\n) : ViewModel() {\n\n    private val _dataState = MutableLiveData<String>()\n    val dataState: LiveData<String> = _dataState\n\n    fun fetchData() {\n        viewModelScope.launch {\n            val result = mainRepository.getData()\n            _dataState.value = result\n        }\n    }\n}"}
{"instruction": "Write the code to programmatically replace a FrameLayout container with a specific Fragment inside an Activity's onCreate method using Kotlin.", "output": "override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    if (savedInstanceState == null) {\n        supportFragmentManager.beginTransaction()\n            .replace(R.id.fragment_container, HomeFragment())\n            .commit()\n    }\n}"}
{"instruction": "Implement a Room TypeConverter in Kotlin to convert a Date object to a Long timestamp and vice versa.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Set up a basic Android Activity using Jetpack Compose in Kotlin. The activity should set the content to a Composable function named 'MyApp'.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    MyApp()\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Repository class in Kotlin that is injected with a DAO via Hilt constructor injection.", "output": "class TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    \n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun insert(task: Task) {\n        taskDao.insertTask(task)\n    }\n}"}
{"instruction": "Define the Application class in Kotlin required to initialize Hilt dependency injection.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize other libraries here if needed\n    }\n}"}
{"instruction": "Write a Java method inside an Activity to start a SecondActivity and pass a string message using an Intent.", "output": "public void openSecondActivity(String message) {\n    Intent intent = new Intent(this, SecondActivity.class);\n    intent.putExtra(\"EXTRA_MESSAGE\", message);\n    startActivity(intent);\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'Task' with an auto-generating primary key, a title, and a boolean completion status.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Define a Room DAO interface in Kotlin with methods to insert a task (suspend) and retrieve all tasks as a Flow.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks ORDER BY id DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Create a Hilt module object in Kotlin to provide the Room Database instance as a Singleton.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Write a ViewModel in Kotlin that uses Hilt Constructor Injection to inject a 'TaskRepository' and exposes a StateFlow of tasks.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = repository.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a simple XML layout file (item_user.xml) using ConstraintLayout containing a TextView for a name and an ImageView for an avatar.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"16dp\">\n\n    <ImageView\n        android:id=\"@+id/ivAvatar\"\n        android:layout_width=\"50dp\"\n        android:layout_height=\"50dp\"\n        android:src=\"@mipmap/ic_launcher\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <TextView\n        android:id=\"@+id/tvName\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"16dp\"\n        android:text=\"User Name\"\n        android:textSize=\"18sp\"\n        app:layout_constraintBottom_toBottomOf=\"@id/ivAvatar\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toEndOf=\"@id/ivAvatar\"\n        app:layout_constraintTop_toTopOf=\"@id/ivAvatar\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a basic Android Activity in Kotlin that is annotated with @AndroidEntryPoint to support Hilt and sets a Jetpack Compose content view.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    MainScreen()\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that displays a LazyColumn of items based on a list of Strings passed as a parameter.", "output": "@Composable\nfun ItemList(items: List<String>) {\n    LazyColumn(\n        contentPadding = PaddingValues(16dp),\n        verticalArrangement = Arrangement.spacedBy(8.dp)\n    ) {\n        items(items) { item ->\n            Text(\n                text = item,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(8.dp),\n                style = MaterialTheme.typography.bodyLarge\n            )\n        }\n    }\n}"}
{"instruction": "Write a Java Fragment class that inflates a layout in onCreateView and handles a button click in onViewCreated.", "output": "public class ExampleFragment extends Fragment {\n\n    public ExampleFragment() {\n        // Required empty public constructor\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_example, container, false);\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        Button button = view.findViewById(R.id.btnAction);\n        button.setOnClickListener(v -> {\n            Toast.makeText(getContext(), \"Clicked!\", Toast.LENGTH_SHORT).show();\n        });\n    }\n}"}
{"instruction": "Create a Room TypeConverter in Kotlin to handle conversion between a Date object and a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Implement a simple Jetpack Compose Navigation Host with two composable destinations: 'Home' and 'Details'.", "output": "@Composable\nfun AppNavigation(navController: NavHostController = rememberNavController()) {\n    NavHost(navController = navController, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(onNavigateToDetails = { navController.navigate(\"details\") })\n        }\n        composable(\"details\") {\n            DetailScreen(onBack = { navController.popBackStack() })\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'User' with a primary key 'uid', and columns for 'firstName' and 'lastName'.", "output": "import androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)"}
{"instruction": "Define a Room DAO interface named 'UserDao' with methods to get all users as a Flow, load users by IDs, and insert a user.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAll(): Flow<List<User>>\n\n    @Query(\"SELECT * FROM users WHERE uid IN (:userIds)\")\n    suspend fun loadAllByIds(userIds: IntArray): List<User>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(vararg users: User)\n}"}
{"instruction": "Create the abstract RoomDatabase class named 'AppDatabase' that includes the User entity and the UserDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class for Hilt Dependency Injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Create a Hilt Module object to provide the AppDatabase and UserDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            AppDatabase::class.java,\n            \"MyDatabase\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject the UserDao, with a function to insert a user.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val allUsers = userDao.getAll()\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            userDao.insertAll(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create a basic XML layout file 'activity_main.xml' containing a FragmentContainerView for navigation.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a MainActivity that uses the XML layout and is annotated for Hilt injection.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that injects the UserViewModel and observes the user list.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.launch\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.allUsers.collect {\n                // Update UI with list of users\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple greeting using a ViewModel.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.compose.runtime.Composable\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            UserScreen()\n        }\n    }\n}\n\n@Composable\nfun UserScreen(viewModel: UserViewModel = hiltViewModel()) {\n    Text(text = \"User Database Active\")\n}"}
{"instruction": "Define a Room Entity class named 'Note' in Kotlin with an auto-generated primary key ID, a title, and a content field.", "output": "@Entity(tableName = \"notes\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"content\") val content: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a note and a function to return a Flow list of all notes ordered by ID descending.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt module object in Kotlin to provide the Room Database instance and the DAO singleton.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Implement a Repository class in Kotlin that injects the NoteDao using Hilt and exposes the data operations.", "output": "class NoteRepository @Inject constructor(private val noteDao: NoteDao) {\n    val allNotes: Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun addNote(note: Note) {\n        noteDao.insertNote(note)\n    }\n}"}
{"instruction": "Create a Hilt-injected ViewModel in Kotlin that uses the Repository to expose a StateFlow of notes and a method to add a note.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val notes: StateFlow<List<Note>> = repository.allNotes\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.addNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Create the Android Application class required to initialize Hilt dependency injection.", "output": "@HiltAndroidApp\nclass MyApp : Application()"}
{"instruction": "Create a MainActivity in Kotlin annotated with @AndroidEntryPoint that uses Jetpack Compose to display a list of notes from the Hilt-injected ViewModel.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: NoteViewModel = hiltViewModel()\n            val notes by viewModel.notes.collectAsState()\n            \n            LazyColumn {\n                items(notes) { note ->\n                    Text(text = note.title)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a standard Android Fragment in Kotlin annotated with @AndroidEntryPoint that uses ViewBinding to access XML views.", "output": "@AndroidEntryPoint\nclass DetailFragment : Fragment(R.layout.fragment_detail) {\n    private var _binding: FragmentDetailBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentDetailBinding.bind(view)\n        \n        binding.textViewTitle.text = \"Detail View\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write a Room TypeConverter in Kotlin to convert a standard Java Date object to a Long timestamp for database storage.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create an abstract RoomDatabase class in Kotlin that includes the Note entity, the DAO, and the TypeConverter.", "output": "@Database(entities = [Note::class], version = 1)\n@TypeConverters(DateConverter::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a Room Entity class named 'Book' in Kotlin with a primary key and columns for title and author.", "output": "@Entity(tableName = \"books\")\ndata class Book(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"author\") val author: String\n)"}
{"instruction": "Define a Room DAO interface for the 'Book' entity with a method to insert a book and a method to observe all books using Kotlin Flow.", "output": "@Dao\ninterface BookDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertBook(book: Book)\n\n    @Query(\"SELECT * FROM books\")\n    fun getAllBooks(): Flow<List<Book>>\n}"}
{"instruction": "Create a Hilt Object Module to provide a singleton instance of 'AppDatabase' and 'BookDao'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideBookDao(database: AppDatabase): BookDao {\n        return database.bookDao()\n    }\n}"}
{"instruction": "Implement a ViewModel using Hilt to inject a 'BookRepository' via the constructor.", "output": "@HiltViewModel\nclass BookViewModel @Inject constructor(\n    private val repository: BookRepository\n) : ViewModel() {\n    \n    val allBooks = repository.allBooks.asLiveData()\n\n    fun addBook(book: Book) = viewModelScope.launch {\n        repository.insert(book)\n    }\n}"}
{"instruction": "Create a generic BaseFragment in Kotlin that handles ViewBinding inflation and cleanup to prevent memory leaks.", "output": "abstract class BaseFragment<VB : ViewBinding>(\n    private val bindingInflater: (LayoutInflater, ViewGroup?, Boolean) -> VB\n) : Fragment() {\n\n    private var _binding: VB? = null\n    protected val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        _binding = bindingInflater(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write the XML layout for 'MainActivity' containing a FragmentContainerView to host the Navigation Graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create the Application class required to initialize Hilt in an Android project.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic if needed\n    }\n}"}
{"instruction": "Annotate a MainActivity to allow Hilt dependency injection and set up a basic Jetpack Compose content block.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Define the abstract RoomDatabase class including the entities and version number.", "output": "@Database(entities = [Book::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun bookDao(): BookDao\n}"}
{"instruction": "Write a Kotlin function inside a Fragment to navigate to a detail screen passing an ID using Navigation Component Safe Args.", "output": "fun navigateToDetails(bookId: Int) {\n    val action = BookListFragmentDirections.actionBookListToBookDetail(bookId)\n    findNavController().navigate(action)\n}"}
{"instruction": "Create a Room Database Entity class representing a 'Task' with an auto-generated ID, a title, and a completion status boolean using Kotlin.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"task_title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean = false\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface in Kotlin with methods to insert a task, delete a task, and observe all tasks using Flow.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks ORDER BY id DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Create a Hilt module in Kotlin to provide a singleton instance of the Room Database and the TaskDao.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"task_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Write a basic Android Activity in Kotlin that is annotated for Hilt injection and sets the content view using XML layout inflation.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Create a Fragment in Kotlin that uses ViewBinding to access views safely, ensuring the binding reference is cleared in onDestroyView.", "output": "class HomeFragment : Fragment() {\n\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.textViewWelcome.text = \"Hello World\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Implement a ViewModel in Kotlin that uses Hilt constructor injection to receive a repository, annotated with @HiltViewModel.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val allTasks = repository.getAllTasks().asLiveData()\n\n    fun addTask(title: String) = viewModelScope.launch {\n        repository.insert(Task(title = title))\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that displays a LazyColumn of items based on a list of strings passed as a parameter.", "output": "@Composable\nfun TaskList(tasks: List<String>) {\n    LazyColumn(\n        contentPadding = PaddingValues(16.dp),\n        verticalArrangement = Arrangement.spacedBy(8.dp)\n    ) {\n        items(tasks) { taskName ->\n            Text(\n                text = taskName,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(8.dp),\n                style = MaterialTheme.typography.bodyLarge\n            )\n        }\n    }\n}"}
{"instruction": "Write a Room TypeConverter in Kotlin to handle conversion between a Date object and a Long timestamp for database storage.", "output": "class DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create an Application class in Kotlin annotated with @HiltAndroidApp to trigger Hilt code generation.", "output": "@HiltAndroidApp\nclass TaskApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize logging or analytics here\n    }\n}"}
{"instruction": "Demonstrate how to navigate from one Fragment to another using the Navigation Component and Safe Args in Kotlin.", "output": "binding.buttonDetails.setOnClickListener { \n    val action = HomeFragmentDirections.actionHomeFragmentToDetailFragment(taskId = 5)\n    findNavController().navigate(action)\n}"}
{"instruction": "Create a Room Entity class representing a 'Task' with an auto-generated ID, title, and isCompleted boolean, along with a DAO interface to insert a task and observe all tasks as a Flow.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide a singleton instance of the Room Database named 'AppDatabase' and its corresponding DAO.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Write a Kotlin Fragment class that uses ViewBinding to inflate a layout named 'fragment_settings.xml' and cleans up the binding reference in onDestroyView.", "output": "class SettingsFragment : Fragment() {\n\n    private var _binding: FragmentSettingsBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentSettingsBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a simple XML layout using ConstraintLayout that centers a TextView with the text 'Welcome' and places a Button labeled 'Login' attached to the bottom of the screen.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tvWelcome\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Welcome\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/btnLogin\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Login\"\n        android:layout_margin=\"16dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Define a ViewModel class using Hilt for dependency injection that accepts a repository in its constructor and exposes a StateFlow of data.", "output": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: DataRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getData().collect {\n                _uiState.value = UiState.Success(it)\n            }\n        }\n    }\n}"}
{"instruction": "Write a Room TypeConverter class in Kotlin to convert a Date object to a Long timestamp and vice versa for database storage.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Annotate an Android Activity to serve as the entry point for Hilt dependency injection and inject a helper class named 'AnalyticsAdapter'.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var analyticsAdapter: AnalyticsAdapter\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        analyticsAdapter.init()\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that sets up a basic NavHost with two composable destinations: 'Home' and 'Profile'.", "output": "@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n\n    NavHost(navController = navController, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(onNavigateToProfile = { navController.navigate(\"profile\") })\n        }\n        composable(\"profile\") {\n            ProfileScreen()\n        }\n    }\n}"}
{"instruction": "Implement a function inside an Activity that programmatically replaces a FrameLayout container with a new Fragment instance, adding the transaction to the back stack.", "output": "fun navigateToFragment(fragment: Fragment) {\n    supportFragmentManager.beginTransaction()\n        .replace(R.id.fragment_container, fragment)\n        .addToBackStack(null)\n        .commit()\n}"}
{"instruction": "Create a Repository class in Kotlin that uses @Inject to receive a local DAO and a remote API service, implementing a method to fetch data.", "output": "class ProductRepository @Inject constructor(\n    private val productDao: ProductDao,\n    private val apiService: ApiService\n) {\n\n    fun getProducts(): Flow<List<Product>> {\n        return productDao.getAllProducts()\n    }\n\n    suspend fun refreshProducts() {\n        val response = apiService.fetchProducts()\n        if (response.isSuccessful && response.body() != null) {\n            productDao.insertAll(response.body()!!)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin needed to initialize Hilt dependency injection.", "output": "@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initializes automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'User' with a primary key 'id', a 'firstName', and a 'lastName'.", "output": "@Entity(tableName = \"user_table\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    \n    @ColumnInfo(name = \"first_name\")\n    val firstName: String,\n    \n    @ColumnInfo(name = \"last_name\")\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface with a suspend function to insert a user and a Flow to observe all users.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM user_table ORDER BY id ASC\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create the abstract RoomDatabase class definition including the User entity.", "output": "@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Write a Hilt Module using Kotlin Object to provide the Room Database and DAO instances as Singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Singleton\n    @Provides\n    fun provideDatabase(\n        @ApplicationContext context: Context\n    ): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Singleton\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel annotated with @HiltViewModel that injects a Repository (assuming Repository exists) and exposes a StateFlow.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n\n    fun addUser(user: User) = viewModelScope.launch {\n        repository.insert(user)\n    }\n}"}
{"instruction": "Write a simple XML layout file (item_user.xml) containing a TextView to display a user's name.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"16dp\">\n\n    <TextView\n        android:id=\"@+id/tvUserName\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"18sp\"\n        android:textColor=\"@android:color/black\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that inflates a layout using ViewBinding.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment() {\n\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n    \n    // Injecting ViewModel example\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that displays a list of users using LazyColumn.", "output": "@Composable\nfun UserListScreen(users: List<User>) {\n    LazyColumn(\n        modifier = Modifier.fillMaxSize(),\n        contentPadding = PaddingValues(16.dp)\n    ) {\n        items(users) { user ->\n            Card(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(vertical = 4.dp),\n                elevation = CardDefaults.cardElevation(4.dp)\n            ) {\n                Text(\n                    text = \"${user.firstName} ${user.lastName}\",\n                    modifier = Modifier.padding(16.dp),\n                    style = MaterialTheme.typography.bodyLarge\n                )\n            }\n        }\n    }\n}"}
{"instruction": "Create a MainActivity annotated for Hilt that sets up a Jetpack Compose content view.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyApplicationTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    // Call your Composable screen here\n                    // val viewModel: UserViewModel = hiltViewModel()\n                    // UserListScreen(...)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt for dependency injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is initialized automatically via the annotation\n    }\n}"}
{"instruction": "Define a simple Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a completion boolean.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean\n)"}
{"instruction": "Create a Room DAO interface with a method to insert a task and a method to retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Write a Hilt Module object in Kotlin to provide a singleton instance of the Room Database and its DAO.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title, isCompleted = false))\n        }\n    }\n}"}
{"instruction": "Write an Android Fragment class annotated for Hilt that inflates a layout.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskFragment : Fragment(R.layout.fragment_task) {\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Logic to bind views or observe ViewModels goes here\n    }\n}"}
{"instruction": "Create an XML layout file for an Activity that contains a FragmentContainerView to host a navigation graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a Composable function.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TaskAppTheme {\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose screen that instantiates a Hilt ViewModel using 'hiltViewModel()' and collects a flow state.", "output": "import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks = viewModel.tasks.collectAsState(initial = emptyList())\n\n    LazyColumn {\n        items(tasks.value) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Implement a Room TypeConverter to store a Date object as a Long timestamp in the database.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Define a Kotlin data class representing a Room Entity named 'UserProfile' with a primary key 'userId' and columns for 'firstName' and 'lastName'.", "output": "@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true)\n    val userId: Long = 0,\n    @ColumnInfo(name = \"first_name\")\n    val firstName: String,\n    @ColumnInfo(name = \"last_name\")\n    val lastName: String\n)"}
{"instruction": "Create a Room DAO interface named 'UserDao' with methods to insert a user and retrieve all users as a Flow.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create the abstract RoomDatabase class named 'AppDatabase' that includes the UserProfile entity and the UserDao.", "output": "@Database(entities = [UserProfile::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Implement the Application class required to initialize Hilt dependency injection in an Android app.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Create a Hilt module to provide the 'AppDatabase' instance as a Singleton.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt that injects a repository and exposes a StateFlow of users.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _users = MutableStateFlow<List<UserProfile>>(emptyList())\n    val users: StateFlow<List<UserProfile>> = _users.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllUsers().collect {\n                _users.value = it\n            }\n        }\n    }\n}"}
{"instruction": "Write an XML layout file for an Activity that acts as a host for the Navigation Component using FragmentContainerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a basic Fragment annotated with @AndroidEntryPoint that uses ViewBinding to access a TextView.", "output": "@AndroidEntryPoint\nclass HomeFragment : Fragment() {\n\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.textViewWelcome.text = \"Welcome Home\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Room TypeConverter to handle Date objects by converting them to Long timestamps.", "output": "class Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Set up a Jetpack Compose Activity annotated with @AndroidEntryPoint that displays a simple greeting.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Greeting(\"Android Developer\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt Dependency Injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'User' with columns for id, name, and email using Kotlin data classes.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"full_name\") val name: String,\n    @ColumnInfo(name = \"email_address\") val email: String\n)"}
{"instruction": "Create a Room DAO interface for the User entity with methods to insert a user and retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n}"}
{"instruction": "Implement the abstract RoomDatabase class including the User entity and the abstract DAO getter.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Module object to provide the Room Database and UserDao instances as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt to inject the UserDao and expose a StateFlow of users.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users: StateFlow<List<User>> = userDao.getAllUsers()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create a basic XML layout file (fragment_user_list.xml) containing a RecyclerView.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Implement a Fragment annotated with @AndroidEntryPoint that inflates the XML layout and initializes the Hilt ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserListFragment : Fragment(R.layout.fragment_user_list) {\n\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Setup RecyclerView and observe viewModel.users here\n    }\n}"}
{"instruction": "Create a MainActivity annotated with @AndroidEntryPoint that sets the content view to an XML layout containing a FragmentContainerView.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // The FragmentContainerView in XML handles the fragment transaction\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that collects the user list from the Hilt ViewModel and displays it.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.collectAsState\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeUserActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            val viewModel: UserViewModel = hiltViewModel()\n            val users = viewModel.users.collectAsState().value\n\n            LazyColumn {\n                items(users) { user ->\n                    Text(text = user.name)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Java Activity named 'LoginActivity' that sets the content view to 'activity_login.xml' and initializes a login button using findViewById.", "output": "import android.os.Bundle;\nimport android.widget.Button;\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class LoginActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n\n        Button loginButton = findViewById(R.id.btn_login);\n        loginButton.setOnClickListener(v -> {\n            // Handle login logic\n        });\n    }\n}"}
{"instruction": "Write a Kotlin Fragment that renders a simple 'Hello World' text using Jetpack Compose inside 'onCreateView'.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.compose.material3.Text\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.fragment.app.Fragment\n\nclass ComposeFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                Text(text = \"Hello World\")\n            }\n        }\n    }\n}"}
{"instruction": "Define a Room Database Entity in Kotlin named 'UserProfile' with an auto-generated primary key, a name, and an email field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"user_profile\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"full_name\") val name: String,\n    @ColumnInfo(name = \"email_address\") val email: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a user and a function to return a Flow of all users.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profile\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Write a Hilt Module in Kotlin to provide a singleton instance of the Room Database.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"my_app_db\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt's @HiltViewModel annotation that receives a repository via constructor injection.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n\n    fun addUser(name: String, email: String) {\n        viewModelScope.launch {\n            userRepository.createUser(name, email)\n        }\n    }\n}"}
{"instruction": "Write the XML layout code for an Activity that acts as a container for the Navigation Component (NavHostFragment).", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create the abstract RoomDatabase class in Kotlin that includes the UserProfile entity and the UserDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [UserProfile::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class required to initialize Hilt in a Kotlin Android project.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create a Kotlin Activity annotated with @AndroidEntryPoint that sets its content to a Composable function.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                MainScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom Application class in Kotlin that is annotated to trigger Hilt's code generation.", "output": "package com.example.myapp\n\nimport android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application()"}
{"instruction": "Define a Room Database Entity class named 'User' with a primary key 'uid', a first name, and a last name.", "output": "package com.example.myapp.data\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface for the User entity with methods to get all users as a Flow and insert a user.", "output": "package com.example.myapp.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAll(): Flow<List<User>>\n\n    @Insert\n    suspend fun insert(user: User)\n}"}
{"instruction": "Define the abstract RoomDatabase class including the User entity and the abstract DAO method.", "output": "package com.example.myapp.data\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a Hilt Object Module to provide the singleton instance of the Room Database and the UserDao.", "output": "package com.example.myapp.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.example.myapp.data.AppDatabase\nimport com.example.myapp.data.UserDao\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            AppDatabase::class.java,\n            \"MyDatabase\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a Repository class that uses constructor injection via Hilt to receive the UserDao.", "output": "package com.example.myapp.data\n\nimport kotlinx.coroutines.flow.Flow\nimport javax.inject.Inject\n\nclass UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<User>> = userDao.getAll()\n\n    suspend fun addUser(user: User) {\n        userDao.insert(user)\n    }\n}"}
{"instruction": "Create a ViewModel using the @HiltViewModel annotation that injects the UserRepository.", "output": "package com.example.myapp.ui\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.myapp.data.User\nimport com.example.myapp.data.UserRepository\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n\n    val users = repository.allUsers\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            repository.addUser(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create a standard Android Activity that uses @AndroidEntryPoint to allow Hilt injection and inflates an XML layout.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.myapp.R\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // ViewModel is ready to use here\n    }\n}"}
{"instruction": "Create a Fragment annotated with @AndroidEntryPoint that accesses the shared ViewModel from the host Activity.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.activityViewModels\nimport com.example.myapp.R\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserFragment : Fragment(R.layout.fragment_user) {\n\n    // Scoped to the Activity, shared between fragments\n    private val sharedViewModel: UserViewModel by activityViewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Observe data from sharedViewModel\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity that uses @AndroidEntryPoint and retrieves a Hilt ViewModel inside the Composable content.", "output": "package com.example.myapp.ui\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            UserScreen()\n        }\n    }\n}\n\n@Composable\nfun UserScreen(viewModel: UserViewModel = hiltViewModel()) {\n    // UI logic utilizing viewModel\n    Text(text = \"User Screen\")\n}"}
{"instruction": "Create a Kotlin Activity that uses ViewBinding to set the text of a TextView with ID 'tv_welcome' to 'Hello Android'. Assume the layout file is named 'activity_main.xml'.", "output": "class MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.tvWelcome.text = \"Hello Android\"\n    }\n}"}
{"instruction": "Define a Room Entity class named 'Note' in Kotlin. It should have an auto-generated integer primary key 'id', a string 'title', and a long 'createdDate'.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"title\")\n    val title: String,\n\n    @ColumnInfo(name = \"created_date\")\n    val createdDate: Long\n)"}
{"instruction": "Create a Room DAO interface for the 'Note' entity. Include a suspend function to insert a note and a function to retrieve all notes ordered by date descending as a Kotlin Flow.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY created_date DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Implement a Hilt module named 'DatabaseModule' to provide the Room Database and the NoteDao as singletons. Assume the database class is named 'AppDatabase'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity that displays a simple text 'Welcome Home' in the center of the screen using the 'setContent' block.", "output": "@AndroidEntryPoint\nclass HomeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Box(contentAlignment = Alignment.Center) {\n                        Text(text = \"Welcome Home\")\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a ViewModel class using Hilt that injects a repository named 'MainRepository'. Include a MutableStateFlow to hold a loading state.", "output": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: MainRepository\n) : ViewModel() {\n\n    private val _isLoading = MutableStateFlow(false)\n    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()\n\n    // ViewModel logic here\n}"}
{"instruction": "Create a Fragment in Kotlin that navigates to a detail fragment (ID: nav_detail) when a button is clicked, using the Jetpack Navigation Component.", "output": "@AndroidEntryPoint\nclass ListFragment : Fragment(R.layout.fragment_list) {\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        val button = view.findViewById<Button>(R.id.btn_go_details)\n        button.setOnClickListener {\n            findNavController().navigate(R.id.nav_detail)\n        }\n    }\n}"}
{"instruction": "Define the abstract Room Database class 'AppDatabase' that includes the 'Note' entity and provides the 'NoteDao'.", "output": "@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Create a custom Application class required to initialize Hilt in an Android project.", "output": "@HiltAndroidApp\nclass MyBaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic if needed\n    }\n}"}
{"instruction": "Implement a simple Jetpack Compose Composable function named 'UserCard' that takes a name (String) and displays it inside a Card with padding.", "output": "@Composable\nfun UserCard(name: String) {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(8.dp),\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n    ) {\n        Text(\n            text = name,\n            modifier = Modifier.padding(16.dp),\n            style = MaterialTheme.typography.bodyLarge\n        )\n    }\n}"}
{"instruction": "Create a simple Android Activity in Java that sets a layout defined in 'activity_main.xml' and initializes a TextView.", "output": "public class MainActivity extends AppCompatActivity {\n    private TextView welcomeText;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        welcomeText = findViewById(R.id.tv_welcome);\n        welcomeText.setText(\"Hello from Java Activity\");\n    }\n}"}
{"instruction": "Define a Room Database Entity in Kotlin representing a 'User' with an id, first name, and last name.", "output": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val uid: Int = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String?,\n    @ColumnInfo(name = \"last_name\") val lastName: String?\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with methods to insert a user and observe all users using Kotlin Flow.", "output": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAll(): Flow<List<User>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Delete\n    suspend fun delete(user: User)\n}"}
{"instruction": "Set up a Hilt module in Kotlin to provide the Room Database and the UserDao instance as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            AppDatabase::class.java,\n            \"MyDatabase\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin using Hilt to inject the UserDao, with a function to add a user.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val allUsers: Flow<List<User>> = userDao.getAll()\n\n    fun addUser(firstName: String, lastName: String) {\n        viewModelScope.launch {\n            userDao.insertUser(User(firstName = firstName, lastName = lastName))\n        }\n    }\n}"}
{"instruction": "Create the abstract RoomDatabase class in Kotlin that includes the User entity.", "output": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Write a Kotlin Fragment code snippet that uses ViewBinding to inflate its layout and handles a button click in `onViewCreated`.", "output": "class HomeFragment : Fragment() {\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.btnSubmit.setOnClickListener {\n            Toast.makeText(requireContext(), \"Clicked!\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define the Application class in Kotlin annotated with @HiltAndroidApp to trigger Hilt code generation.", "output": "@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization code here\n    }\n}"}
{"instruction": "Create an Activity in Kotlin that uses Jetpack Compose and is annotated with @AndroidEntryPoint to allow Hilt injection in the future.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface {\n                    Text(text = \"Hello Jetpack Compose with Hilt!\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Java Fragment that defines an interface to communicate back to its hosting Activity.", "output": "public class OptionFragment extends Fragment {\n    public interface OnOptionSelectedListener {\n        void onOptionSelected(String option);\n    }\n\n    private OnOptionSelectedListener callback;\n\n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n        if (context instanceof OnOptionSelectedListener) {\n            callback = (OnOptionSelectedListener) context;\n        } else {\n            throw new ClassCastException(context.toString() + \" must implement OnOptionSelectedListener\");\n        }\n    }\n\n    // Usage example inside a method\n    private void triggerSelection() {\n        if (callback != null) {\n            callback.onOptionSelected(\"Option A\");\n        }\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'Task' with a primary key, a title, a description, and a priority level.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"task_title\")\n    val title: String,\n\n    @ColumnInfo(name = \"task_desc\")\n    val description: String,\n\n    val priority: Int\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface for the 'Task' entity with methods to insert a task, delete a task, and retrieve all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks_table ORDER BY priority DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Create the abstract Room Database class in Kotlin, including the Task entity and a companion object for migration or instance handling (though Hilt will handle the instance creation).", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Write a Hilt Module using Kotlin to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a Repository class in Kotlin that injects the TaskDao and provides clean API methods for the ViewModel.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun insert(task: Task) {\n        taskDao.insertTask(task)\n    }\n\n    suspend fun delete(task: Task) {\n        taskDao.deleteTask(task)\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt (@HiltViewModel) that injects the TaskRepository and exposes the list of tasks as a StateFlow.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = repository.allTasks\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String, desc: String, priority: Int) {\n        viewModelScope.launch {\n            repository.insert(Task(title = title, description = desc, priority = priority))\n        }\n    }\n}"}
{"instruction": "Write an XML layout file (fragment_task_list.xml) containing a RecyclerView and a FloatingActionButton within a ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerViewTasks\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAddTask\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_bottom_toBottomOf=\"parent\"\n        app:layout_end_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class in Kotlin annotated with @AndroidEntryPoint that inflates the XML layout and sets up the ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Setup RecyclerView and Observers here\n        // Example: \n        // lifecycleScope.launch {\n        //     viewModel.tasks.collect { tasks -> adapter.submitList(tasks) }\n        // }\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose function that displays a single Task item in a Card.", "output": "import androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun TaskItem(task: Task) {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(8.dp)\n    ) {\n        Column(modifier = Modifier.padding(16.dp)) {\n            Text(text = task.title, style = MaterialTheme.typography.titleMedium)\n            Text(text = task.description, style = MaterialTheme.typography.bodyMedium)\n            Text(text = \"Priority: ${task.priority}\", style = MaterialTheme.typography.labelSmall)\n        }\n    }\n}"}
{"instruction": "Create a Room TypeConverter class in Kotlin to handle conversion between a Date object and a Long timestamp.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Room Database Entity class representing a 'Task' with an auto-generated ID, title, and a boolean completion status in Kotlin.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Define a Room DAO (Data Access Object) interface for the 'Task' entity with methods to insert a task, delete a task, and observe all tasks using Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Delete\n    suspend fun deleteTask(task: Task)\n}"}
{"instruction": "Create the abstract Room Database class in Kotlin and include the Task entity and TaskDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Set up a Hilt Module to provide the Room Database and the TaskDao as singleton dependencies.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"task_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject the TaskDao and expose a Flow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val tasks: StateFlow<List<Task>> = taskDao.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create the Application class required for Hilt setup and annotate it correctly.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass TodoApplication : Application()"}
{"instruction": "Create a simple XML layout file for a Fragment containing a RecyclerView and a FloatingActionButton.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fabAdd\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class annotated with @AndroidEntryPoint that inflates the XML layout using ViewBinding and initializes a Hilt ViewModel.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a MainActivity annotated with @AndroidEntryPoint that loads the TaskListFragment into a container.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, TaskListFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Create a Jetpack Compose function that observes the ViewModel state and displays the list of tasks.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\n\n@Composable\nfun TaskScreen(viewModel: TaskViewModel) {\n    val tasks by viewModel.tasks.collectAsState()\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a custom Application class required to initialize Hilt dependency injection in an Android app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Define a Room Database Entity representing a 'Note' with an auto-generated primary key, a title, and a content field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.ColumnInfo\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"note_title\") val title: String,\n    @ColumnInfo(name = \"note_content\") val content: String\n)"}
{"instruction": "Create a Room DAO interface with methods to insert a note and retrieve all notes as a Kotlin Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id ASC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Write a Hilt Module to provide the Room Database instance and the DAO as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository, and expose a StateFlow of data.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    val allNotes: StateFlow<List<Note>> = repository.allNotes\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create an XML layout file for an Activity that contains a FragmentContainerView to host a navigation graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Write a Fragment class annotated with @AndroidEntryPoint that inflates a view binding and observes a ViewModel.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentNoteBinding\n\n@AndroidEntryPoint\nclass NoteFragment : Fragment(R.layout.fragment_note) {\n\n    private val viewModel: NoteViewModel by viewModels()\n    private var _binding: FragmentNoteBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentNoteBinding.bind(view)\n        \n        // Observe ViewModel here\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Setup a Jetpack Compose Activity that is annotated with @AndroidEntryPoint and sets the content to a simple Greeting composable.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Greeting(name = \"Android\")\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Create a Room TypeConverter to handle storing a Date object as a Long timestamp in the database.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Implement a Repository class injected via Hilt that delegates data operations to the Room DAO.", "output": "import kotlinx.coroutines.flow.Flow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass NoteRepository @Inject constructor(\n    private val noteDao: NoteDao\n) {\n\n    val allNotes: Flow<List<Note>> = noteDao.getAllNotes()\n\n    suspend fun insert(note: Note) {\n        noteDao.insert(note)\n    }\n}"}
{"instruction": "Create a basic MainActivity in Java that extends AppCompatActivity and sets the content view to a layout resource named 'activity_main.xml'.", "output": "import android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}"}
{"instruction": "Create a Kotlin Activity that uses Jetpack Compose to set the content directly without XML, displaying the text 'Hello Hilt'.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\n\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(text = \"Hello Hilt\")\n        }\n    }\n}"}
{"instruction": "Implement a basic Fragment in Kotlin that inflates a layout file named 'fragment_profile.xml' inside the onCreateView method.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\n\nclass ProfileFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return inflater.inflate(R.layout.fragment_profile, container, false)\n    }\n}"}
{"instruction": "Define a Room Entity data class in Kotlin representing a 'User' with an auto-generated ID, a name, and an email address.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val name: String,\n    val email: String\n)"}
{"instruction": "Create a Room DAO interface in Kotlin with a suspend function to insert a User and a function to retrieve all users as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n}"}
{"instruction": "Create the Application class required to initialize Hilt dependency injection in an Android app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Define a Hilt Module in Kotlin to provide a singleton instance of the Room AppDatabase.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n}"}
{"instruction": "Create a ViewModel in Kotlin that uses Hilt constructor injection to receive a repository instance.", "output": "import androidx.lifecycle.ViewModel\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport javax.inject.Inject\n\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ViewModel logic here\n}"}
{"instruction": "Demonstrate how to inject a Hilt-provided ViewModel into an Activity using the 'by viewModels()' Kotlin property delegate.", "output": "import androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass UserActivity : AppCompatActivity() {\n    \n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_user)\n        // Use userViewModel here\n    }\n}"}
{"instruction": "Define an abstract Room Database class in Kotlin that includes the User entity and provides the UserDao.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Create a `MainActivity` in Kotlin that loads a specific Fragment named `ProfileFragment` into a FrameLayout container with the ID `fragment_container` inside the `onCreate` method.", "output": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (savedInstanceState == null) {\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.fragment_container, ProfileFragment())\n                .commit()\n        }\n    }\n}"}
{"instruction": "Define a Room Entity class named `Task` in Kotlin. It should have an auto-generated integer primary key named `id`, a string column `title`, and a boolean column `isCompleted`.", "output": "@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"title\") val title: String,\n    @ColumnInfo(name = \"is_completed\") val isCompleted: Boolean\n)"}
{"instruction": "Create a Room DAO interface named `TaskDao` with methods to insert a task (suspend function) and observe all tasks as a Flow list.", "output": "@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Set up the Application class required for Hilt Dependency Injection in Kotlin using the `@HiltAndroidApp` annotation.", "output": "@HiltAndroidApp\nclass TodoApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialization logic here\n    }\n}"}
{"instruction": "Create a Hilt Module named `DatabaseModule` to provide a singleton instance of `AppDatabase` and `TaskDao`.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"todo_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel named `TaskViewModel` that uses Hilt constructor injection to receive a `TaskRepository`.", "output": "@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n    \n    val tasks = repository.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n\n    fun addTask(task: Task) {\n        viewModelScope.launch {\n            repository.insert(task)\n        }\n    }\n}"}
{"instruction": "Implement a Fragment named `DetailFragment` using ViewBinding. Ensure the binding reference is properly nulled out in `onDestroyView` to prevent memory leaks.", "output": "class DetailFragment : Fragment() {\n\n    private var _binding: FragmentDetailBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentDetailBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with `@AndroidEntryPoint` to support Hilt, which sets the content to a `TaskScreen` composable.", "output": "@AndroidEntryPoint\nclass TaskActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                TaskScreen()\n            }\n        }\n    }\n}"}
{"instruction": "Define the abstract Room Database class `AppDatabase` that includes the `Task` entity and returns the `TaskDao`.", "output": "@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Jetpack Compose function `TaskList` that takes a list of tasks and displays them in a `LazyColumn`.", "output": "@Composable\nfun TaskList(tasks: List<Task>) {\n    LazyColumn(\n        modifier = Modifier.fillMaxSize(),\n        contentPadding = PaddingValues(16.dp)\n    ) {\n        items(tasks) { task ->\n            Text(\n                text = task.title,\n                style = MaterialTheme.typography.bodyLarge,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n        }\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Note' in Kotlin. It should have an auto-generated primary key 'id', a 'title' string, and a 'content' string. Use the table name 'notes_table'.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String\n)"}
{"instruction": "Create a Data Access Object (DAO) interface for the 'Note' entity. Include a suspend function to insert a note and a function to return a Flow list of all notes ordered by ID descending.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database instance and the NoteDao. Assume the database class is named 'AppDatabase'.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Set up the Android Application class required for Hilt dependency injection.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application()"}
{"instruction": "Create a ViewModel using Hilt injection that accepts the 'NoteDao' in its constructor. Include a function to add a note using a coroutine scope.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val noteDao: NoteDao\n) : ViewModel() {\n\n    val allNotes = noteDao.getAllNotes()\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            noteDao.insertNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Create a simple Jetpack Compose Activity annotated with @AndroidEntryPoint that displays the text 'Hello Hilt'.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(text = \"Hello Hilt\")\n        }\n    }\n}"}
{"instruction": "Write an XML layout file for an Activity that contains a FragmentContainerView to host a Navigation Graph.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a Fragment class in Kotlin that uses ViewBinding to set a TextView's text to 'Fragment Loaded' in onViewCreated. The Fragment must be prepared for Hilt injection.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentExampleBinding\n\n@AndroidEntryPoint\nclass ExampleFragment : Fragment(R.layout.fragment_example) {\n\n    private var _binding: FragmentExampleBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        _binding = FragmentExampleBinding.bind(view)\n        \n        binding.textView.text = \"Fragment Loaded\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a Jetpack Compose Composable function that takes a list of Strings and displays them in a LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun NameList(names: List<String>) {\n    LazyColumn {\n        items(names) { name ->\n            Text(\n                text = name,\n                modifier = Modifier.padding(16.dp)\n            )\n        }\n    }\n}"}
{"instruction": "Create a Room TypeConverter class to convert a Date object to a Long timestamp and vice versa.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'UserProfile' with an auto-generated primary key, a first name, and a last name.", "output": "@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey(autoGenerate = true) val id: Long = 0,\n    @ColumnInfo(name = \"first_name\") val firstName: String,\n    @ColumnInfo(name = \"last_name\") val lastName: String\n)"}
{"instruction": "Write a Room DAO interface named 'UserDao' with methods to insert a user (suspend) and retrieve all users as a Flow list.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles ORDER BY first_name ASC\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Set up a Hilt module to provide a singleton instance of the 'AppDatabase' and the 'UserDao'.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to receive a repository instance.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    \n    val users = userRepository.getAllUsers().asLiveData()\n\n    fun addUser(user: UserProfile) {\n        viewModelScope.launch {\n            userRepository.insert(user)\n        }\n    }\n}"}
{"instruction": "Implement a basic Fragment using ViewBinding in Kotlin, ensuring the binding reference is cleared in onDestroyView to prevent memory leaks.", "output": "@AndroidEntryPoint\nclass UserListFragment : Fragment() {\n\n    private var _binding: FragmentUserListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUserListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Write the code for a 'MainActivity' that is annotated with @AndroidEntryPoint and sets the content view to a Jetpack Compose screen.", "output": "@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create the abstract RoomDatabase class configuration including the UserProfile entity and version number.", "output": "@Database(entities = [UserProfile::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Write a Kotlin extension function inside a Fragment to safely collect a Flow from a ViewModel when the lifecycle is in the STARTED state.", "output": "fun <T> Fragment.collectLatestLifecycleFlow(flow: Flow<T>, collect: suspend (T) -> Unit) {\n    viewLifecycleOwner.lifecycleScope.launch {\n        viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            flow.collectLatest(collect)\n        }\n    }\n}"}
{"instruction": "Define a Room TypeConverter to handle the conversion between a Date object and a Long (timestamp) for database storage.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Show how to navigate from one Fragment to another using the Navigation Component and passing a Bundle argument.", "output": "val bundle = Bundle().apply {\n    putString(\"USER_ID\", \"12345\")\n}\nfindNavController().navigate(R.id.action_listFragment_to_detailFragment, bundle)"}
{"instruction": "Create a custom Application class in Kotlin to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt code generation is triggered by the annotation\n    }\n}"}
{"instruction": "Define a Room Entity data class representing a 'Task' with an auto-generated primary key, title, and a boolean completion status.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks_table\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface with a suspend function to insert a Task and a function to return a Flow of all tasks.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n\n    @Query(\"SELECT * FROM tasks_table ORDER BY id DESC\")\n    fun getAllTasks(): Flow<List<Task>>\n}"}
{"instruction": "Define the abstract RoomDatabase class including the Task entity and a migration strategy placeholder.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Task::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n}"}
{"instruction": "Create a Hilt Module using Kotlin to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Implement a ViewModel annotated with @HiltViewModel that injects the TaskDao and exposes a Flow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val taskDao: TaskDao\n) : ViewModel() {\n\n    val allTasks: Flow<List<Task>> = taskDao.getAllTasks()\n\n    fun addTask(title: String) {\n        viewModelScope.launch {\n            taskDao.insertTask(Task(title = title))\n        }\n    }\n}"}
{"instruction": "Create a generic Activity annotated with @AndroidEntryPoint that sets the content view using Jetpack Compose.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // Call your Composable Screen here\n            MainScreen()\n        }\n    }\n}"}
{"instruction": "Write a Jetpack Compose function that observes the ViewModel's task list and displays it in a LazyColumn.", "output": "import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\n\n@Composable\nfun TaskListScreen(viewModel: TaskViewModel = hiltViewModel()) {\n    val tasks by viewModel.allTasks.collectAsState(initial = emptyList())\n\n    LazyColumn {\n        items(tasks) { task ->\n            Text(text = task.title)\n        }\n    }\n}"}
{"instruction": "Create a Fragment class annotated for Hilt that inflates a layout using XML and ViewBinding.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport dagger.hilt.android.AndroidEntryPoint\nimport com.example.app.databinding.FragmentTaskListBinding\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment() {\n\n    private var _binding: FragmentTaskListBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTaskListBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Define a simple XML layout file containing a RecyclerView and a FloatingActionButton within a ConstraintLayout.", "output": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab_add\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@android:drawable/ic_input_add\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>"}
{"instruction": "Create a basic Kotlin Activity class that inflates a layout file named 'activity_main.xml'.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Define a Room Database Entity class named 'Note' with an auto-generating primary key, a title, and a content field.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val title: String,\n    val content: String\n)"}
{"instruction": "Create a Room DAO (Data Access Object) interface for the 'Note' entity with methods to insert a note and observe all notes as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface NoteDao {\n    @Query(\"SELECT * FROM notes_table ORDER BY id ASC\")\n    fun getAllNotes(): Flow<List<Note>>\n\n    @Insert(onConflict = OnConflictStrategy.IGNORE)\n    suspend fun insert(note: Note)\n}"}
{"instruction": "Create a Hilt Module object to provide a singleton instance of the Room Database and the NoteDao.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: AppDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Write a basic Fragment class in Kotlin using ViewBinding to access a TextView with the ID 'welcomeText' and set its text.", "output": "import android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport com.example.app.databinding.FragmentHomeBinding\n\nclass HomeFragment : Fragment() {\n\n    private var _binding: FragmentHomeBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.welcomeText.text = \"Welcome to Fragments!\"\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}"}
{"instruction": "Create a ViewModel that uses Hilt constructor injection to receive a repository instance.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    fun addNote(title: String, content: String) {\n        viewModelScope.launch {\n            repository.insertNote(Note(title = title, content = content))\n        }\n    }\n}"}
{"instruction": "Set up an Activity to use Jetpack Compose by calling setContent in onCreate.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.material3.Text\n\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(text = \"Hello Jetpack Compose\")\n        }\n    }\n}"}
{"instruction": "Annotate an Activity with @AndroidEntryPoint to enable Hilt field injection.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\nimport javax.inject.Inject\n\n@AndroidEntryPoint\nclass UserActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var userAnalytics: UserAnalytics\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_user)\n        userAnalytics.logView(\"UserActivity\")\n    }\n}"}
{"instruction": "Create the abstract Room Database class connecting the Entity and the DAO.", "output": "import androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Note::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun noteDao(): NoteDao\n}"}
{"instruction": "Perform a manual Fragment transaction to replace a container layout with a new Fragment instance.", "output": "val newFragment = SettingsFragment()\n\nsupportFragmentManager.beginTransaction().apply {\n    replace(R.id.fragment_container_view, newFragment)\n    addToBackStack(null)\n    commit()\n}"}
{"instruction": "Create a custom Application class in Kotlin needed to initialize Hilt dependency injection for the app.", "output": "@HiltAndroidApp\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt initializes automatically via the annotation\n    }\n}"}
{"instruction": "Define a Room Database Entity for a 'Note' object with an auto-generated primary key, a title, and a content field.", "output": "@Entity(tableName = \"notes_table\")\ndata class Note(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n\n    @ColumnInfo(name = \"note_title\")\n    val title: String,\n\n    @ColumnInfo(name = \"note_content\")\n    val content: String\n)"}
{"instruction": "Create a Room DAO interface for the Note entity with a suspend function to insert a note and a Flow to observe all notes.", "output": "@Dao\ninterface NoteDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertNote(note: Note)\n\n    @Query(\"SELECT * FROM notes_table ORDER BY id DESC\")\n    fun getAllNotes(): Flow<List<Note>>\n}"}
{"instruction": "Create a Hilt Module object in Kotlin to provide the Room Database instance and the NoteDao as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): NoteDatabase {\n        return Room.databaseBuilder(\n            context,\n            NoteDatabase::class.java,\n            \"note_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideNoteDao(database: NoteDatabase): NoteDao {\n        return database.noteDao()\n    }\n}"}
{"instruction": "Write a ViewModel class using Hilt's @HiltViewModel annotation that injects a repository and exposes a StateFlow of notes.", "output": "@HiltViewModel\nclass NoteViewModel @Inject constructor(\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    private val _notes = MutableStateFlow<List<Note>>(emptyList())\n    val notes: StateFlow<List<Note>> = _notes.asStateFlow()\n\n    init {\n        viewModelScope.launch {\n            repository.getAllNotes().collect { listOfNotes ->\n                _notes.value = listOfNotes\n            }\n        }\n    }\n}"}
{"instruction": "Show how to annotate a standard XML-based MainActivity to support Hilt injection and inflate a layout binding.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n    }\n}"}
{"instruction": "Create a Fragment that uses Hilt to inject the NoteViewModel and observes the notes data using a lifecycle-aware collector.", "output": "@AndroidEntryPoint\nclass NoteListFragment : Fragment(R.layout.fragment_note_list) {\n\n    private val viewModel: NoteViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.notes.collect { notes ->\n                    // Update UI adapter here\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a TypeConverter class for Room to handle the conversion between a Date object and a Long timestamp.", "output": "class DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Set up a Jetpack Compose Activity annotated with Hilt that displays a simple greeting using a Composable function.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyTheme {\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\n                    Greeting(\"Android\")\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}"}
{"instruction": "Provide the Java code snippet to programmatically replace a FrameLayout container with a Fragment inside an Activity.", "output": "MyFragment fragment = new MyFragment();\nFragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\ntransaction.replace(R.id.fragment_container, fragment);\ntransaction.addToBackStack(null);\ntransaction.commit();"}
{"instruction": "Create a custom Application class in Kotlin annotated to initialize Hilt dependency injection for the app.", "output": "import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass BaseApplication : Application()"}
{"instruction": "Define a Room Database Entity class named 'Task' with an auto-generated primary key, a title, and a completion boolean.", "output": "import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tasks\")\ndata class Task(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val title: String,\n    val isCompleted: Boolean = false\n)"}
{"instruction": "Create a Room DAO interface for the 'Task' entity with methods to insert a task and observe all tasks as a Flow.", "output": "import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks\")\n    fun getAllTasks(): Flow<List<Task>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: Task)\n}"}
{"instruction": "Write a Hilt Module object to provide the Room Database instance and the TaskDao as singletons.", "output": "import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideTaskDao(database: AppDatabase): TaskDao {\n        return database.taskDao()\n    }\n}"}
{"instruction": "Create a ViewModel using Hilt constructor injection to inject a repository, exposing a Flow of tasks.", "output": "import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.stateIn\nimport javax.inject.Inject\n\n@HiltViewModel\nclass TaskViewModel @Inject constructor(\n    private val repository: TaskRepository\n) : ViewModel() {\n\n    val tasks = repository.getAllTasks()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())\n}"}
{"instruction": "Create a standard Android Activity annotated with @AndroidEntryPoint that hosts a FragmentContainerView in XML.", "output": "import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}"}
{"instruction": "Write a Fragment annotated with @AndroidEntryPoint that inflates a layout and accesses the TaskViewModel via 'by viewModels()'.", "output": "import android.os.Bundle\nimport android.view.View\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass TaskListFragment : Fragment(R.layout.fragment_task_list) {\n\n    private val viewModel: TaskViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        // Logic to observe viewModel.tasks goes here\n    }\n}"}
{"instruction": "Create a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a composable screen.", "output": "import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TaskScreen()\n        }\n    }\n}"}
{"instruction": "Write a Room TypeConverter class to convert a Date object to a Long timestamp and vice-versa.", "output": "import androidx.room.TypeConverter\nimport java.util.Date\n\nclass DateConverter {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n\n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n}"}
{"instruction": "Create a Repository class injected via Hilt that abstracts the data access from the DAO.", "output": "import javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass TaskRepository @Inject constructor(\n    private val taskDao: TaskDao\n) {\n    fun getAllTasks(): Flow<List<Task>> = taskDao.getAllTasks()\n\n    suspend fun addTask(task: Task) = taskDao.insertTask(task)\n}"}
{"instruction": "Create a Kotlin data class annotated as a Room Entity named 'UserProfile' with a primary key 'userId' and columns for 'name' and 'email'.", "output": "@Entity(tableName = \"user_profiles\")\ndata class UserProfile(\n    @PrimaryKey\n    @ColumnInfo(name = \"user_id\")\n    val userId: String,\n\n    @ColumnInfo(name = \"name\")\n    val name: String,\n\n    @ColumnInfo(name = \"email\")\n    val email: String\n)"}
{"instruction": "Define a Room DAO interface named 'UserDao' with a suspend function to insert a user and a function to return a Flow list of all users.", "output": "@Dao\ninterface UserDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: UserProfile)\n\n    @Query(\"SELECT * FROM user_profiles\")\n    fun getAllUsers(): Flow<List<UserProfile>>\n}"}
{"instruction": "Create an abstract RoomDatabase class named 'AppDatabase' that includes the UserProfile entity and provides the UserDao.", "output": "@Database(entities = [UserProfile::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"}
{"instruction": "Set up the Application class for Hilt Dependency Injection by annotating it with @HiltAndroidApp.", "output": "@HiltAndroidApp\nclass MyBaseApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}"}
{"instruction": "Create a Hilt Module using Kotlin object to provide the Room Database and the UserDao as singletons.", "output": "@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n\n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}"}
{"instruction": "Create a ViewModel using @HiltViewModel that injects the UserDao and exposes a Flow of users.", "output": "@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val userDao: UserDao\n) : ViewModel() {\n\n    val users: Flow<List<UserProfile>> = userDao.getAllUsers()\n\n    fun addUser(user: UserProfile) {\n        viewModelScope.launch {\n            userDao.insertUser(user)\n        }\n    }\n}"}
{"instruction": "Write a MainActivity class that uses XML layouts, is annotated with @AndroidEntryPoint for Hilt, and retrieves the UserViewModel.", "output": "@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Example usage\n        // userViewModel.users.collect { ... }\n    }\n}"}
{"instruction": "Create a Fragment named 'DetailFragment' annotated with @AndroidEntryPoint that inflates an XML layout in onCreateView.", "output": "@AndroidEntryPoint\nclass DetailFragment : Fragment() {\n\n    private val viewModel: UserViewModel by activityViewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return inflater.inflate(R.layout.fragment_detail, container, false)\n    }\n}"}
{"instruction": "Set up a Jetpack Compose Activity annotated with @AndroidEntryPoint that sets the content to a simple Text composable.", "output": "@AndroidEntryPoint\nclass ComposeActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme {\n                Surface {\n                    Text(text = \"Hello from Hilt & Compose\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Repository class named 'UserRepository' that is injected into a ViewModel, abstracting the data source.", "output": "class UserRepository @Inject constructor(\n    private val userDao: UserDao\n) {\n    val allUsers: Flow<List<UserProfile>> = userDao.getAllUsers()\n\n    suspend fun addNewUser(name: String, email: String) {\n        val user = UserProfile(userId = UUID.randomUUID().toString(), name = name, email = email)\n        userDao.insertUser(user)\n    }\n}"}
