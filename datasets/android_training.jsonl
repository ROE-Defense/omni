{"instruction": "Write a Kotlin class for Android that implements `SensorEventListener` to listen for Accelerometer data and log the X, Y, and Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerLogger(context: Context) : SensorEventListener {\n\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        \n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = (Math.min(width, height) / 2f) * 0.8f\n\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Create a Kotlin Flow that emits location updates using the Android `FusedLocationProviderClient` within a `callbackFlow`.", "output": "import android.annotation.SuppressLint\nimport android.location.Location\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.Priority\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.callbackFlow\n\n@SuppressLint(\"MissingPermission\") // Assume permissions handled externally\nfun getLocationFlow(client: FusedLocationProviderClient): Flow<Location> = callbackFlow {\n    val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n        .build()\n\n    val callback = object : LocationCallback() {\n        override fun onLocationResult(result: LocationResult) {\n            result.lastLocation?.let { trySend(it) }\n        }\n    }\n\n    client.requestLocationUpdates(locationRequest, callback, null)\n\n    awaitClose {\n        client.removeLocationUpdates(callback)\n    }\n}"}
{"instruction": "Implement a basic CameraX preview setup in an Android Activity using Kotlin.", "output": "import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\n\nclass CameraActivity : AppCompatActivity() {\n    private lateinit var viewFinder: PreviewView\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        viewFinder = PreviewView(this)\n        setContentView(viewFinder)\n        startCamera()\n    }\n\n    private fun startCamera() {\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\n\n        cameraProviderFuture.addListener({\n            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n            val preview = Preview.Builder().build().also {\n                it.setSurfaceProvider(viewFinder.surfaceProvider)\n            }\n            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n            try {\n                cameraProvider.unbindAll()\n                cameraProvider.bindToLifecycle(this, cameraSelector, preview)\n            } catch(exc: Exception) {\n                exc.printStackTrace()\n            }\n        }, ContextCompat.getMainExecutor(this))\n    }\n}"}
{"instruction": "Create a Kotlin class that implements SensorEventListener to read Accelerometer data on Android.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass AccelerometerHandler(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                println(\"Accelerometer: x=$x, y=$y, z=$z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin function to get the last known location using the FusedLocationProviderClient.", "output": "import android.Manifest\nimport android.content.Context\nimport android.content.pm.PackageManager\nimport android.location.Location\nimport androidx.core.app.ActivityCompat\nimport com.google.android.gms.location.LocationServices\n\nfun getLastKnownLocation(context: Context, onSuccess: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    \n    if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && \n        ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n        // Permissions not granted, handle accordingly\n        return\n    }\n\n    fusedLocationClient.lastLocation.addOnSuccessListener { location: Location? ->\n        // Got last known location. In some rare situations this can be null.\n        onSuccess(location)\n    }\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Ambient Light Sensor and log the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current Lux: $lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin Lifecycle component in Kotlin that displays a Toast when the plugin is loaded.", "output": "package com.atakmap.android.plugin.hello\n\nimport android.content.Context\nimport android.widget.Toast\nimport com.atakmap.android.maps.MapCore\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.app.preferences.ToolsPreferenceFragment\nimport com.atakmap.coremap.log.Log\nimport is.arontibo.library.ElasticDownloadView\nimport com.atakmap.android.dropdown.DropDownMapComponent\n\nclass HelloLifecycle : DropDownMapComponent() {\n\n    private var context: Context? = null\n    private var mapView: MapView? = null\n\n    override fun onCreate(context: Context, intent: android.content.Intent, view: MapView) {\n        super.onCreate(context, intent, view)\n        this.context = context\n        this.mapView = view\n        \n        Toast.makeText(context, \"Hello ATAK Plugin Loaded\", Toast.LENGTH_LONG).show()\n        Log.d(\"HelloLifecycle\", \"Plugin created\")\n    }\n\n    override fun onDestroyImpl(context: Context, view: MapView) {\n        super.onDestroyImpl(context, view)\n        Log.d(\"HelloLifecycle\", \"Plugin destroyed\")\n    }\n}"}
{"instruction": "Write a Kotlin snippet for Android to retrieve the battery percentage using `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\nimport android.os.Build\n\nfun getBatteryPercentage(context: Context): Int {\n    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n}"}
{"instruction": "Write an ATAK Kotlin snippet to add a custom Map Widget (text label) to the top-left corner of the MapView.", "output": "import android.graphics.Color\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.widgets.TextWidget\nimport com.atakmap.android.widgets.RootLayoutWidget\n\nfun addStatusWidget(mapView: MapView) {\n    val textWidget = TextWidget(\"Status: Active\", 1)\n    textWidget.color = Color.GREEN\n    textWidget.setTextSize(32f)\n    \n    // Get the root layout of the map\n    val rootLayout = mapView.componentExtra as? RootLayoutWidget\n    \n    // Add widget to top left (x=10, y=10)\n    rootLayout?.let {\n        it.addWidget(textWidget)\n        it.positionWidget(textWidget, 10f, 10f, RootLayoutWidget.TopLeft)\n    }\n}"}
{"instruction": "Write a Kotlin Android function to check if the device supports Biometric Authentication (Fingerprint/Face).", "output": "import android.content.Context\nimport androidx.biometric.BiometricManager\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> true\n        else -> false\n    }\n}"}
{"instruction": "Implement an ATAK BroadcastReceiver in Kotlin to listen for a specific 'SHOW_PLUGIN_PANE' intent.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.atakmap.android.ipc.AtakBroadcast\n\nclass PluginReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.plugin.SHOW_PLUGIN_PANE\") {\n            Log.d(\"PluginReceiver\", \"Received request to show plugin pane\")\n            // Logic to open DropDownReceiver or Toggle Tool would go here\n        }\n    }\n\n    fun register() {\n        AtakBroadcast.DocumentedIntentFilter(\"com.atakmap.android.plugin.SHOW_PLUGIN_PANE\")\n            .also { filter ->\n                AtakBroadcast.getInstance().registerReceiver(this, filter)\n            }\n    }\n\n    fun unregister() {\n        AtakBroadcast.getInstance().unregisterReceiver(this)\n    }\n}"}
{"instruction": "Implement a Jetpack Compose Composable in Kotlin that displays a live camera preview using CameraX.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\n\n@Composable\nfun CameraPreview() {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val context = LocalContext.current\n    val cameraProviderFuture = remember { ProcessCameraProvider.getInstance(context) }\n\n    AndroidView(\n        factory = { ctx ->\n            val previewView = PreviewView(ctx)\n            val executor = ContextCompat.getMainExecutor(ctx)\n            cameraProviderFuture.addListener({\n                val cameraProvider = cameraProviderFuture.get()\n                val preview = Preview.Builder().build().also {\n                    it.setSurfaceProvider(previewView.surfaceProvider)\n                }\n                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n                try {\n                    cameraProvider.unbindAll()\n                    cameraProvider.bindToLifecycle(\n                        lifecycleOwner,\n                        cameraSelector,\n                        preview\n                    )\n                } catch (e: Exception) {\n                    e.printStackTrace()\n                }\n            }, executor)\n            previewView\n        }\n    )\n}"}
{"instruction": "Write a Kotlin snippet for an ATAK plugin to programmatically add a red marker to the map at specific coordinates.", "output": "import com.atakmap.android.maps.Marker\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.android.maps.MapGroup\n\nfun addRedMarker(mapView: MapView, lat: Double, lon: Double, title: String) {\n    // Create the point\n    val point = GeoPoint(lat, lon)\n    \n    // Create the marker\n    val marker = Marker(point, java.util.UUID.randomUUID().toString())\n    marker.title = title\n    marker.type = \"a-u-G\" // Atom, unit, Ground\n    marker.setMetaString(\"color\", \"-65536\") // Red integer color\n    marker.setMetaBoolean(\"readiness\", true)\n    marker.setMetaBoolean(\"archive\", true)\n    \n    // Add to the Root Group (displays immediately)\n    val rootGroup = mapView.rootGroup\n    rootGroup.addItem(marker)\n}"}
{"instruction": "Write a Kotlin function using the Android FusedLocationProviderClient to retrieve the device's last known location.", "output": "import android.annotation.SuppressLint\nimport android.content.Context\nimport android.location.Location\nimport com.google.android.gms.location.LocationServices\n\n// Requires ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION permission\n@SuppressLint(\"MissingPermission\")\nfun getLastKnownLocation(context: Context, onSuccess: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    \n    fusedLocationClient.lastLocation\n        .addOnSuccessListener { location: Location? ->\n            // Got last known location. In some rare situations this can be null.\n            onSuccess(location)\n        }\n        .addOnFailureListener {\n            // Handle failure\n            onSuccess(null)\n        }\n}"}
{"instruction": "Write a Kotlin snippet to start a low-latency Bluetooth LE scan looking for devices with a specific service UUID.", "output": "import android.bluetooth.BluetoothAdapter\nimport android.bluetooth.le.ScanCallback\nimport android.bluetooth.le.ScanFilter\nimport android.bluetooth.le.ScanResult\nimport android.bluetooth.le.ScanSettings\nimport android.os.ParcelUuid\nimport java.util.UUID\n\nfun startBleScan(serviceUuid: UUID, callback: ScanCallback) {\n    val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()\n    val scanner = bluetoothAdapter.bluetoothLeScanner\n\n    val filter = ScanFilter.Builder()\n        .setServiceUuid(ParcelUuid(serviceUuid))\n        .build()\n\n    val settings = ScanSettings.Builder()\n        .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n        .build()\n\n    try {\n        scanner.startScan(listOf(filter), settings, callback)\n    } catch (e: SecurityException) {\n        // Handle missing BLUETOOTH_SCAN permission\n    }\n}"}
{"instruction": "Write a Kotlin function for an ATAK plugin to generate and dispatch a 'hostile' CoT (Cursor on Target) event at the user's self-location.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.android.cot.CotMapComponent\nimport com.atakmap.android.maps.MapView\n\nfun dispatchHostileCot(mapView: MapView) {\n    // Get Self Location\n    val selfMarker = mapView.selfMarker\n    val point = selfMarker.point\n\n    // Create Event\n    val cotEvent = CotEvent()\n    cotEvent.uid = java.util.UUID.randomUUID().toString()\n    cotEvent.type = \"a-h-G\" // Atom, Hostile, Ground\n    cotEvent.time = com.atakmap.coremap.maps.time.CoordinatedTime()\n    cotEvent.start = cotEvent.time\n    cotEvent.stale = cotEvent.time.addMinutes(10)\n    cotEvent.how = \"h-g-i-g-o\" // Human, GPS, Ins, GPS, Other\n    \n    // Set Point\n    cotEvent.point = CotPoint(point.latitude, point.longitude, point.hae, point.ce, point.le)\n\n    // Dispatch\n    CotMapComponent.getDispatcher().dispatch(cotEvent)\n}"}
{"instruction": "Implement a Kotlin function using Android CameraX to start a camera preview inside a PreviewView.", "output": "import androidx.camera.core.Preview\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch(exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Create a Kotlin function for an ATAK (Android Team Awareness Kit) plugin that places a Marker (Red Icon) on the map at a specific coordinate.", "output": "import com.atakmap.android.maps.Marker\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.android.icons.UserIcon\n\nfun addRedMarker(mapView: MapView, lat: Double, lon: Double, uid: String) {\n    val point = GeoPoint(lat, lon)\n    val marker = Marker(point, uid)\n    \n    // Set standard red icon path (internal ATAK resource)\n    marker.setMetaString(\"iconUri\", UserIcon.GetIconBitmapPath(UserIcon.IconColor.RED))\n    marker.type = \"a-u-G\"\n    marker.title = \"Plugin Marker\"\n    marker.setMetaBoolean(\"readiness\", true)\n    marker.setMetaBoolean(\"archive\", true)\n\n    // Add to the root group of the map\n    mapView.rootGroup.addItem(marker)\n}"}
{"instruction": "Implement a Kotlin class that implements SensorEventListener to read the Ambient Light Sensor on Android.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorListener : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin BroadcastReceiver for an ATAK plugin that listens for internal CoT (Cursor on Target) events.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport com.atakmap.coremap.cot.event.CotEvent\nimport android.util.Log\n\nclass CotEventListener : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.cot.COT_EVENT\") {\n            val cotEvent = intent.getParcelableExtra<CotEvent>(\"com.atakmap.coremap.cot.event.CotEvent\")\n            if (cotEvent != null) {\n                Log.d(\"ATAK_PLUGIN\", \"Received CoT Event: ${cotEvent.type} from ${cotEvent.uid}\")\n                // Process the event (e.g., check if it is a hostile track)\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Kotlin function to authenticate a user using Android BiometricPrompt (Fingerprint/Face).", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\nimport java.util.concurrent.Executor\n\nfun authenticateUser(activity: FragmentActivity, onSuccess: () -> Unit) {\n    val executor: Executor = ContextCompat.getMainExecutor(activity)\n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                // Handle error\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric Login\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create a Kotlin layout inflater for an ATAK Plugin Tool that includes a Spinner (Dropdown).", "output": "import android.content.Context\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.widget.ArrayAdapter\nimport android.widget.Spinner\nimport com.atakmap.android.maps.MapView\n\nfun createPluginToolView(context: Context, mapView: MapView): View {\n    // Assuming a layout file named 'plugin_tool_layout.xml' exists with a Spinner id 'layerSpinner'\n    val inflater = LayoutInflater.from(context)\n    val view = inflater.inflate(com.atakmap.android.plugin.R.layout.plugin_tool_layout, null)\n\n    val spinner: Spinner = view.findViewById(com.atakmap.android.plugin.R.id.layerSpinner)\n    val options = listOf(\"Layer A\", \"Layer B\", \"Layer C\")\n    \n    // Use ATAK context for styling if available, otherwise plugin context\n    val adapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, options)\n    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\n    spinner.adapter = adapter\n\n    return view\n}"}
{"instruction": "Implement a Kotlin class `CompassSensor` that uses Android's `SensorManager` to read the device's azimuth (compass heading) using the accelerometer and magnetometer.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass CompassSensor(context: Context, private val onAzimuthChanged: (Float) -> Unit) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n    private val magnetometer = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)\n\n    private var gravity: FloatArray? = null\n    private var geomagnetic: FloatArray? = null\n\n    fun start() {\n        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)\n        sensorManager.registerListener(this, magnetometer, SensorManager.SENSOR_DELAY_UI)\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) gravity = it.values\n            if (it.sensor.type == Sensor.TYPE_MAGNETIC_FIELD) geomagnetic = it.values\n\n            if (gravity != null && geomagnetic != null) {\n                val R = FloatArray(9)\n                val I = FloatArray(9)\n                if (SensorManager.getRotationMatrix(R, I, gravity, geomagnetic)) {\n                    val orientation = FloatArray(3)\n                    SensorManager.getOrientation(R, orientation)\n                    // orientation[0] is azimuth in radians\n                    val azimuth = Math.toDegrees(orientation[0].toDouble()).toFloat()\n                    onAzimuthChanged((azimuth + 360) % 360)\n                }\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n}"}
{"instruction": "Create a Kotlin function using `BiometricPrompt` to authenticate a user on Android.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\n\nfun authenticateUser(activity: FragmentActivity, onSuccess: () -> Unit, onError: (String) -> Unit) {\n    val executor = ContextCompat.getMainExecutor(activity)\n    \n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                onError(errString.toString())\n            }\n\n            override fun onAuthenticationFailed() {\n                super.onAuthenticationFailed()\n                onError(\"Authentication failed\")\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric Login\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create a BroadcastReceiver in Kotlin to listen for battery level changes and determine if the device is charging.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\n\nclass BatteryLevelReceiver(private val onBatteryStatusChanged: (Boolean, Float) -> Unit) : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        val isCharging: Boolean = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                                  status == BatteryManager.BATTERY_STATUS_FULL\n\n        val level: Int = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n        val scale: Int = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        val batteryPct: Float = level / scale.toFloat()\n\n        onBatteryStatusChanged(isCharging, batteryPct)\n    }\n}"}
{"instruction": "Write a Kotlin class for an Android application that implements `SensorEventListener` to log changes from the Ambient Light sensor.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorListener(private val sensorManager: SensorManager) : SensorEventListener {\n\n    fun startListening() {\n        val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a Kotlin function to programmatically add a `SpotMapItem` (a marker) to the ATAK MapView at a specific coordinate.", "output": "import com.atakmap.android.maps.MapView\nimport com.atakmap.android.maps.SpotMapItem\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.coremap.maps.coords.GeoPointMetaData\nimport java.util.UUID\n\nfun addMarkerToMap(mapView: MapView, lat: Double, lon: Double, title: String) {\n    val point = GeoPoint(lat, lon)\n    val item = SpotMapItem(UUID.randomUUID().toString(), null, title)\n    \n    // Set the location\n    val geoPointMetaData = GeoPointMetaData.wrap(point)\n    item.point = geoPointMetaData\n    \n    // Set type (e.g., neutral point of interest)\n    item.type = \"u-d-p\"\n    item.visible = true\n    \n    // Add to the map's root group\n    mapView.rootGroup.addItem(item)\n}"}
{"instruction": "Create a minimal Android RecyclerView Adapter in Kotlin for a list of Strings.", "output": "import android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.TextView\nimport androidx.recyclerview.widget.RecyclerView\n\nclass SimpleAdapter(private val dataSet: List<String>) :\n    RecyclerView.Adapter<SimpleAdapter.ViewHolder>() {\n\n    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val textView: TextView = view.findViewById(android.R.id.text1)\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(android.R.layout.simple_list_item_1, parent, false)\n        return ViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.textView.text = dataSet[position]\n    }\n\n    override fun getItemCount() = dataSet.size\n}"}
{"instruction": "Write a Kotlin function for an Android app to register a listener for the Proximity sensor and log changes.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nfun registerProximityListener(sensorManager: SensorManager) {\n    val proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY)\n    \n    val sensorEventListener = object : SensorEventListener {\n        override fun onSensorChanged(event: SensorEvent) {\n            if (event.sensor.type == Sensor.TYPE_PROXIMITY) {\n                val distance = event.values[0]\n                Log.d(\"SensorApp\", \"Proximity distance: $distance\")\n            }\n        }\n\n        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n            // Handle accuracy changes if necessary\n        }\n    }\n\n    sensorManager.registerListener(sensorEventListener, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL)\n}"}
{"instruction": "Write a Kotlin code snippet to programmatically add a `Marker` (CoT item) to the ATAK map at a specific coordinate.", "output": "import com.atakmap.android.maps.MapView\nimport com.atakmap.android.maps.Marker\nimport com.atakmap.coremap.maps.coords.GeoPoint\nimport com.atakmap.coremap.maps.assets.Icon\nimport java.util.UUID\n\nfun addMarkerToMap(mapView: MapView, lat: Double, lon: Double, title: String) {\n    val point = GeoPoint(lat, lon)\n    val uid = UUID.randomUUID().toString()\n    \n    val marker = Marker(point, uid)\n    marker.title = title\n    marker.type = \"a-u-G\" // Atom, unit, Ground\n    marker.setMetaString(\"how\", \"h-g-i-g-o\")\n    \n    // Refresh the map group to display the marker\n    mapView.rootGroup.addItem(marker)\n}"}
{"instruction": "Create a custom native Android View in Kotlin that draws a red circle on a canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val radius = (Math.min(width, height) / 2).toFloat()\n        canvas.drawCircle((width / 2).toFloat(), (height / 2).toFloat(), radius, paint)\n    }\n}"}
{"instruction": "Create a Jetpack Compose (Kotlin) Composable that displays the current battery level using the Android `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.material.Text\n\n@Composable\nfun BatteryLevelDisplay() {\n    val context = LocalContext.current\n    var batteryLevel by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n        batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n    }\n\n    Text(text = \"Battery Level: $batteryLevel%\")\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Ambient Light sensor and log the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current Light Level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin Lifecycle class in Kotlin that logs when the plugin is loaded and unloaded.", "output": "package com.atakmap.android.helloworld.plugin\n\nimport com.atakmap.android.maps.MapActivity\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\nimport com.atakmap.app.system.SystemComponent\nimport android.content.Context\n\nclass HelloWorldLifecycle(private val context: Context) : SystemComponent {\n\n    private var mapView: MapView? = null\n\n    override fun onCreate(context: Context, intent: android.content.Intent, view: MapView, args: android.os.Bundle?) {\n        // Called when the plugin is initialized\n        this.mapView = view\n        Log.d(TAG, \"HelloWorld Plugin Loaded\")\n        \n        // Initialize tools, overlays, or receivers here\n    }\n\n    override fun onDestroy(context: Context, view: MapView) {\n        // Called when the plugin is unloaded\n        Log.d(TAG, \"HelloWorld Plugin Unloaded\")\n        \n        // Clean up resources\n        this.mapView = null\n    }\n\n    override fun onStart(context: Context, view: MapView) {}\n    override fun onStop(context: Context, view: MapView) {}\n    override fun onPause(context: Context, view: MapView) {}\n    override fun onResume(context: Context, view: MapView) {}\n\n    companion object {\n        private const val TAG = \"HelloWorldLifecycle\"\n    }\n}"}
{"instruction": "Write a Kotlin Android custom View that draws a simple red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(width, height) / 4f\n        \n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Create a function in ATAK (Kotlin) to construct and broadcast a basic 'Friendly' Cursor on Target (CoT) event at a specific lat/lon.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.comms.CommsMapComponent\nimport com.atakmap.coremap.maps.time.CoordinatedTime\n\nfun broadcastFriendlyCoT(lat: Double, lon: Double, uid: String) {\n    val event = CotEvent()\n    val time = CoordinatedTime()\n    \n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-f-G-U-C\" // Atom, Friendly, Ground, Unit, Combat\n    event.time = time\n    event.start = time\n    event.stale = time.addMinutes(10)\n    event.how = \"h-g-i-g-o\" // Human input\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    if (CommsMapComponent.getDispatcher() != null) {\n        CommsMapComponent.getDispatcher().dispatch(event)\n    }\n}"}
{"instruction": "Write a Kotlin Android BroadcastReceiver to detect when the device battery is low.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport android.widget.Toast\n\nclass BatteryLowReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (Intent.ACTION_BATTERY_LOW == intent.action) {\n            Log.w(\"BatteryMonitor\", \"Battery is critically low!\")\n            Toast.makeText(context, \"Battery Low! Save your work.\", Toast.LENGTH_LONG).show()\n        }\n    }\n}"}
{"instruction": "Create an ATAK DropDownReceiver in Kotlin to show a custom view when a specific tool is activated from the toolbar.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport android.view.LayoutInflater\nimport com.atakmap.android.dropdown.DropDownReceiver\nimport com.atakmap.android.maps.MapView\n\nclass MyPluginDropDown(mapView: MapView, private val context: Context) : \n    DropDownReceiver(mapView) {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (!isClosed) {\n            closeDropDown()\n            return\n        }\n        \n        // Inflate your custom layout\n        // Ensure you have a layout file named plugin_layout.xml\n        // val view = LayoutInflater.from(this.context).inflate(R.layout.plugin_layout, null)\n        \n        // For demo, we just use a generic View if layout isn't present in this snippet\n        val view = View(this.context)\n        \n        showDropDown(view, 0.5, true, -1.0, -1.0)\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n}"}
{"instruction": "Implement a Kotlin class in Android that implements SensorEventListener to log Accelerometer data (X, Y, Z coordinates).", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.util.Log\n\nclass AccelerometerLogger : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a Kotlin function to display a BiometricPrompt (Fingerprint/FaceID) for authentication in an Android Fragment.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.Fragment\n\nfun Fragment.authenticateUser(onSuccess: () -> Unit) {\n    val executor = ContextCompat.getMainExecutor(requireContext())\n    val biometricPrompt = BiometricPrompt(this, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                onSuccess()\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Create an Android Kotlin Activity snippet that reads the ambient Light Sensor (Lux) value.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current Light Level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n}"}
{"instruction": "Implement a Kotlin Android Activity that uses the SensorManager to listen to the Light Sensor. Update the background color of the screen to black if the lux value is below 10, and white otherwise.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport android.graphics.Color\nimport androidx.appcompat.app.AppCompatActivity\nimport android.view.View\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n    private lateinit var rootLayout: View\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        rootLayout = View(this)\n        setContentView(rootLayout)\n\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            if (lux < 10) {\n                rootLayout.setBackgroundColor(Color.BLACK)\n            } else {\n                rootLayout.setBackgroundColor(Color.WHITE)\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // No action needed\n    }\n}"}
{"instruction": "Create a simple Android Service in Kotlin that tracks location in the background using FusedLocationProviderClient and logs the coordinates.", "output": "import android.app.Service\nimport android.content.Intent\nimport android.os.IBinder\nimport android.util.Log\nimport com.google.android.gms.location.*\n\nclass LocationService : Service() {\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\n    private lateinit var locationCallback: LocationCallback\n\n    override fun onCreate() {\n        super.onCreate()\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\n        \n        locationCallback = object : LocationCallback() {\n            override fun onLocationResult(locationResult: LocationResult) {\n                for (location in locationResult.locations) {\n                    Log.d(\"LocService\", \"Lat: ${location.latitude}, Lon: ${location.longitude}\")\n                }\n            }\n        }\n\n        startLocationUpdates()\n    }\n\n    private fun startLocationUpdates() {\n        try {\n            val locationRequest = LocationRequest.create().apply {\n                interval = 10000\n                fastestInterval = 5000\n                priority = LocationRequest.PRIORITY_HIGH_ACCURACY\n            }\n            fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, null)\n        } catch (e: SecurityException) {\n            Log.e(\"LocService\", \"Permission missing\")\n        }\n    }\n\n    override fun onBind(intent: Intent?): IBinder? = null\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        fusedLocationClient.removeLocationUpdates(locationCallback)\n    }\n}"}
{"instruction": "Write a Kotlin function for an Android app that sets up a `SensorEventListener` to detect the Ambient Light sensor values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorManager(context: Context) : SensorEventListener {\n    private var sensorManager: SensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private var lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startListening() {\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensor\", \"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin code snippet to check and request the `ACCESS_FINE_LOCATION` permission in Android using the Activity Result API.", "output": "import android.Manifest\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.result.contract.ActivityResultContracts\n\nclass LocationPermissionHelper(private val activity: ComponentActivity) {\n\n    private val requestPermissionLauncher = activity.registerForActivityResult(\n        ActivityResultContracts.RequestPermission()\n    ) { isGranted: Boolean ->\n        if (isGranted) {\n            Toast.makeText(activity, \"Location permission granted\", Toast.LENGTH_SHORT).show()\n            // Proceed with location logic\n        } else {\n            Toast.makeText(activity, \"Permission denied\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    fun checkAndRequestPermission() {\n        requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n    }\n}"}
{"instruction": "Write a Kotlin Android `BroadcastReceiver` that detects when the device is connected to power (charging).", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\nimport android.util.Log\n\nclass PowerConnectionReceiver : BroadcastReceiver() {\n\n    override fun onReceive(context: Context, intent: Intent) {\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        val isCharging: Boolean = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                                  status == BatteryManager.BATTERY_STATUS_FULL\n\n        if (isCharging) {\n            val chargePlug: Int = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1)\n            val usbCharge: Boolean = chargePlug == BatteryManager.BATTERY_PLUGGED_USB\n            val acCharge: Boolean = chargePlug == BatteryManager.BATTERY_PLUGGED_AC\n            \n            Log.d(\"PowerReceiver\", \"Device is charging via: ${if (usbCharge) \"USB\" else if (acCharge) \"AC\" else \"Other\"}\")\n        } else {\n            Log.d(\"PowerReceiver\", \"Device is not charging\")\n        }\n    }\n}"}
{"instruction": "Write a Kotlin snippet using Android CameraX to start a camera preview within a PreviewView.", "output": "import androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.core.content.ContextCompat\nimport kotlinx.android.synthetic.main.activity_main.* // Assuming view binding or synthetics\n\nfun startCamera() {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder()\n            .build()\n            .also {\n                it.setSurfaceProvider(viewFinder.surfaceProvider)\n            }\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(this, androidx.camera.core.CameraSelector.DEFAULT_BACK_CAMERA, preview)\n        } catch(exc: Exception) {\n            Log.e(\"CameraX\", \"Use case binding failed\", exc)\n        }\n    }, ContextCompat.getMainExecutor(this))\n}"}
{"instruction": "Write a Kotlin function to display an Android Biometric Authentication prompt.", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\nfun showBiometricPrompt(activity: androidx.fragment.app.FragmentActivity) {\n    val executor = ContextCompat.getMainExecutor(activity)\n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                super.onAuthenticationSucceeded(result)\n                // Handle success\n            }\n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                // Handle error\n            }\n        })\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Use account password\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Implement an Android SensorEventListener in Kotlin to read Ambient Light levels (Lux).", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorListener(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startListening() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val luxValue = event.values[0]\n            println(\"Current Light Level: $luxValue lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Kotlin function in Android to check if the device supports Biometric authentication (Fingerprint/Face).", "output": "import android.content.Context\nimport androidx.biometric.BiometricManager\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG or BiometricManager.Authenticators.DEVICE_CREDENTIAL)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> true\n        else -> false\n    }\n}"}
{"instruction": "Write an Android Kotlin Activity snippet that registers a listener for the Ambient Light Sensor.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin function using Android CameraX to bind the camera preview to a `PreviewView`.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch (exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Write a Kotlin function for Android that uses the SensorManager to listen to the Ambient Light Sensor and logs the lux value.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass LightSensorMonitor(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n\n    fun startMonitoring() {\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopMonitoring() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val luxValue = event.values[0]\n            Log.d(\"LightSensor\", \"Current Lux: $luxValue\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Kotlin snippet using Android's CameraX library to bind a camera preview to a `PreviewView`.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\nimport android.content.Context\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        // Used to bind the lifecycle of cameras to the lifecycle owner\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n\n        // Preview\n        val preview = Preview.Builder()\n            .build()\n            .also {\n                it.setSurfaceProvider(previewView.surfaceProvider)\n            }\n\n        // Select back camera as a default\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            // Unbind use cases before rebinding\n            cameraProvider.unbindAll()\n\n            // Bind use cases to camera\n            cameraProvider.bindToLifecycle(\n                lifecycleOwner, cameraSelector, preview)\n\n        } catch(exc: Exception) {\n            exc.printStackTrace()\n        }\n\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Implement a Kotlin Android BroadcastReceiver that listens for battery low events and executes a callback.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\n\nclass BatteryLevelReceiver(private val onLowBattery: () -> Unit) : BroadcastReceiver() {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == Intent.ACTION_BATTERY_LOW) {\n            onLowBattery()\n        }\n    }\n\n    fun register(context: Context) {\n        val filter = IntentFilter(Intent.ACTION_BATTERY_LOW)\n        context.registerReceiver(this, filter)\n    }\n\n    fun unregister(context: Context) {\n        context.unregisterReceiver(this)\n    }\n}"}
{"instruction": "Android (Kotlin): Implement a `SensorEventListener` to read Accelerometer data and log the X, Y, Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerTracker(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                val x = it.values[0]\n                val y = it.values[1]\n                val z = it.values[2]\n                Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if needed\n    }\n}"}
{"instruction": "Android (Kotlin): Create a custom View that draws a pulsating circle using `Canvas` and `onDraw`.", "output": "import android.animation.ValueAnimator\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\nimport android.view.animation.LinearInterpolator\n\nclass PulsatingCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n    private var radius = 0f\n    private var maxRadius = 100f\n\n    init {\n        val animator = ValueAnimator.ofFloat(0f, maxRadius)\n        animator.duration = 1000\n        animator.repeatCount = ValueAnimator.INFINITE\n        animator.interpolator = LinearInterpolator()\n        animator.addUpdateListener { animation ->\n            radius = animation.animatedValue as Float\n            invalidate()\n        }\n        animator.start()\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "ATAK Plugin (Kotlin): Implement a Dropdown Receiver to show a native Android View within the ATAK Dropdown interface.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport android.widget.TextView\nimport com.atakmap.android.dropdown.Dropdown.OnStateListener\nimport com.atakmap.android.dropdown.DropdownReceiver\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\n\nclass MyPluginDropdown(mapView: MapView, private val pluginContext: Context) : \n    DropdownReceiver(mapView), OnStateListener {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (!isClosed) {\n            closeDropDown()\n        } else {\n            showDropDown(createView(), 0.5, -1.0, -1.0, 0.5)\n        }\n    }\n\n    private fun createView(): View {\n        val textView = TextView(pluginContext)\n        textView.text = \"Hello from ATAK Plugin\"\n        textView.textSize = 20f\n        return textView\n    }\n\n    override fun onDropdownClosed() {\n        Log.d(\"MyPlugin\", \"Dropdown closed\")\n    }\n\n    override fun disposeImpl() {}\n}"}
{"instruction": "Android (Kotlin): Authenticate a user using the BiometricPrompt API (Fingerprint/Face).", "output": "import androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\nimport androidx.fragment.app.FragmentActivity\nimport java.util.concurrent.Executor\n\nfun authenticateUser(activity: FragmentActivity) {\n    val executor: Executor = ContextCompat.getMainExecutor(activity)\n    \n    val callback = object : BiometricPrompt.AuthenticationCallback() {\n        override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n            super.onAuthenticationError(errorCode, errString)\n            // Handle error\n        }\n\n        override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n            super.onAuthenticationSucceeded(result)\n            // Handle success\n        }\n    }\n\n    val biometricPrompt = BiometricPrompt(activity, executor, callback)\n\n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric login for my app\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Cancel\")\n        .build()\n\n    biometricPrompt.authenticate(promptInfo)\n}"}
{"instruction": "Write a Kotlin snippet for an Android Activity to register a listener for the Ambient Light sensor.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor?\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin function using Jetpack's BiometricManager to check if the device hardware supports biometric authentication.", "output": "import androidx.biometric.BiometricManager\nimport android.content.Context\nimport android.util.Log\n\nfun checkBiometricSupport(context: Context): Boolean {\n    val biometricManager = BiometricManager.from(context)\n    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {\n        BiometricManager.BIOMETRIC_SUCCESS -> {\n            Log.d(\"BioAuth\", \"App can authenticate using biometrics.\")\n            true\n        }\n        BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {\n            Log.e(\"BioAuth\", \"No biometric features available on this device.\")\n            false\n        }\n        BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE -> {\n            Log.e(\"BioAuth\", \"Biometric features are currently unavailable.\")\n            false\n        }\n        BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {\n            Log.e(\"BioAuth\", \"The user hasn't associated any biometric credentials.\")\n            false\n        }\n        else -> false\n    }\n}"}
{"instruction": "Generate a programmatic 'Cursor on Target' (CoT) Event for a hostile unit at a specific Lat/Lon in ATAK using Kotlin.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.maps.time.CoTPoint\n\nfun createHostileCotEvent(lat: Double, lon: Double, uid: String): CotEvent {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-h-G\" // Atom - Hostile - Ground\n    event.time = CoTPoint(System.currentTimeMillis())\n    event.start = CoTPoint(System.currentTimeMillis())\n    event.stale = CoTPoint(System.currentTimeMillis() + 60000) // 1 minute stale\n    event.how = \"h-g-i-g-o\" // Human input\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n    \n    return event\n}"}
{"instruction": "Create a Kotlin BroadcastReceiver to detect when the device battery is low.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.widget.Toast\n\nclass BatteryLowReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (Intent.ACTION_BATTERY_LOW == intent.action) {\n            Toast.makeText(context, \"Battery is critically low!\", Toast.LENGTH_LONG).show()\n            // Perform power saving operations here\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Android function to register a listener for the Proximity Sensor and log when an object is 'NEAR'.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass ProximityDetector(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val proximitySensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY)\n\n    fun start() {\n        proximitySensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.values[0] < (proximitySensor?.maximumRange ?: 0f)) {\n                Log.d(\"Sensor\", \"Object is NEAR\")\n            } else {\n                Log.d(\"Sensor\", \"Object is FAR\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK (Android Team Awareness Kit) Plugin `MapComponent` in Kotlin that logs a message when the plugin is added to the map.", "output": "package com.atakmap.android.plugintemplate\n\nimport android.content.Context\nimport android.content.Intent\nimport com.atakmap.android.maps.MapComponent\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.coremap.log.Log\n\nclass PluginMapComponent : MapComponent {\n    private var context: Context? = null\n\n    override fun onCreate(context: Context, intent: Intent, view: MapView) {\n        this.context = context\n        Log.d(\"PluginMapComponent\", \"Plugin created and added to MapView\")\n        \n        // Initialize custom tools or overlays here\n    }\n\n    override fun onDestroy(context: Context, view: MapView) {\n        Log.d(\"PluginMapComponent\", \"Plugin destroyed\")\n        // Cleanup resources\n    }\n\n    override fun onStart(context: Context, view: MapView) {}\n    override fun onStop(context: Context, view: MapView) {}\n    override fun onPause(context: Context, view: MapView) {}\n    override fun onResume(context: Context, view: MapView) {}\n}"}
{"instruction": "Write a Kotlin function to programmatically generate a basic 'Cursor on Target' (CoT) event for ATAK.", "output": "import com.atakmap.coremap.cot.event.CotDetail\nimport com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.maps.time.CoTPointData\n\nfun createSelfCotEvent(lat: Double, lon: Double, uid: String): CotEvent {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = uid\n    event.type = \"a-f-G-U-C\" // Friendly Ground Unit Combatant\n    event.time = CoTPointData.now()\n    event.start = CoTPointData.now()\n    event.stale = CoTPointData.now() + (10 * 60 * 1000) // 10 minutes from now\n    event.how = \"h-e\" // Human entered\n\n    // Set location\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    // Add details\n    val detail = CotDetail(\"detail\")\n    val contact = CotDetail(\"contact\")\n    contact.setAttribute(\"callsign\", \"Alpha-1\")\n    detail.addChild(contact)\n    event.detail = detail\n\n    return event\n}"}
{"instruction": "Write a Kotlin Activity snippet that checks for Biometric authentication availability and prompts the user to authenticate.", "output": "import androidx.biometric.BiometricManager\nimport androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\nfun authenticateUser() {\n    val executor = ContextCompat.getMainExecutor(this)\n    val biometricManager = BiometricManager.from(this)\n\n    if (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG) == BiometricManager.BIOMETRIC_SUCCESS) {\n        \n        val promptInfo = BiometricPrompt.PromptInfo.Builder()\n            .setTitle(\"Biometric Login\")\n            .setSubtitle(\"Log in using your credential\")\n            .setNegativeButtonText(\"Cancel\")\n            .build()\n\n        val biometricPrompt = BiometricPrompt(this, executor,\n            object : BiometricPrompt.AuthenticationCallback() {\n                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                    super.onAuthenticationSucceeded(result)\n                    // Handle success\n                }\n                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                    super.onAuthenticationError(errorCode, errString)\n                    // Handle error\n                }\n            })\n\n        biometricPrompt.authenticate(promptInfo)\n    }\n}"}
{"instruction": "Implement an ATAK `DropDownReceiver` in Kotlin to handle a tool interaction when a specific intent is broadcast.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport com.atakmap.android.dropdown.DropDownReceiver\nimport com.atakmap.android.maps.MapView\n\nclass MyPluginDropDownReceiver(mapView: MapView, context: Context) : \n    DropDownReceiver(mapView) {\n\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == \"com.atakmap.android.myplugin.SHOW_DROPDOWN\") {\n            if (!isClosed) {\n                // Already open\n                return\n            }\n            // Create your view content here\n            // val myView = ... \n            // showDropDown(myView, HALF_WIDTH, FULL_HEIGHT, FULL_WIDTH, HALF_HEIGHT)\n        }\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n\n    override fun onStateRequested(state: Int) {\n        if (state == DropDownReceiver.DROPDOWN_STATE_FULLSCREEN) {\n            // Handle resize request\n        }\n    }\n}"}
{"instruction": "Write a Kotlin Android Service that reads the Ambient Light Sensor (Lux) in the background.", "output": "import android.app.Service\nimport android.content.Context\nimport android.content.Intent\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.os.IBinder\nimport android.util.Log\n\nclass LightSensorService : Service(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate() {\n        super.onCreate()\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            Log.d(\"LightSensorService\", \"Current Lux: $lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}\n\n    override fun onDestroy() {\n        super.onDestroy()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onBind(intent: Intent?): IBinder? = null\n}"}
{"instruction": "Create a simple custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(cx, cy) / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Implement a basic ATAK MapComponent in Kotlin to register a tool in the overflow menu.", "output": "import android.content.Context\nimport android.content.Intent\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.ipc.AtakBroadcast\nimport com.atakmap.android.dropdown.DropDownMapComponent\nimport com.atakmap.app.preferences.ToolsPreferenceFragment\n\nclass PluginMapComponent : DropDownMapComponent() {\n    private var context: Context? = null\n\n    override fun onCreate(context: Context, intent: Intent, view: MapView) {\n        super.onCreate(context, intent, view)\n        this.context = context\n        \n        // Register a tool (icon) in the ATAK tool menu\n        ToolsPreferenceFragment.register(\n            ToolsPreferenceFragment.ToolPreference(\n                \"My Plugin Tool\",\n                \"Description of my tool\",\n                \"my.plugin.action\",\n                context.resources.getDrawable(R.drawable.ic_launcher),\n                null\n            )\n        )\n    }\n\n    override fun onDestroyImpl(context: Context, view: MapView) {\n        super.onDestroyImpl(context, view)\n    }\n}"}
{"instruction": "Implement an Android Activity method in Kotlin to listen to the ambient light sensor.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\nclass LightSensorActivity : AppCompatActivity(), SensorEventListener {\n    private lateinit var sensorManager: SensorManager\n    private var lightSensor: Sensor? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        lightSensor?.also {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Current light level: $lux lux\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes\n    }\n}"}
{"instruction": "Write a Kotlin class for Android that implements `SensorEventListener` to read data from the Accelerometer. It should have start and stop methods to manage battery life.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass AccelerometerReader(context: Context, private val onUpdate: (Float, Float, Float) -> Unit) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun startListening() {\n        accelerometer?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            onUpdate(x, y, z)\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Implement a Jetpack Compose function in Kotlin that uses `AndroidView` to display a CameraX `PreviewView`. This bridges the native Android View system with Compose.", "output": "import androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\n\n@Composable\nfun CameraXPreview(modifier: Modifier = Modifier) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val context = LocalContext.current\n\n    AndroidView(\n        factory = { ctx ->\n            PreviewView(ctx).apply {\n                scaleType = PreviewView.ScaleType.FILL_CENTER\n                val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)\n                cameraProviderFuture.addListener({\n                    val cameraProvider = cameraProviderFuture.get()\n                    val preview = Preview.Builder().build().also {\n                        it.setSurfaceProvider(this.surfaceProvider)\n                    }\n                    try {\n                        cameraProvider.unbindAll()\n                        cameraProvider.bindToLifecycle(\n                            lifecycleOwner,\n                            CameraSelector.DEFAULT_BACK_CAMERA,\n                            preview\n                        )\n                    } catch (e: Exception) {\n                        // Handle binding errors\n                    }\n                }, ContextCompat.getMainExecutor(ctx))\n            }\n        },\n        modifier = modifier\n    )\n}"}
{"instruction": "Write a custom Android View in Kotlin that overrides `onDraw` to draw a pulsating circle. This demonstrates creating custom native UI components.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass PulsatingCircleView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n    private var radius = 50f\n    private var expanding = true\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        canvas.drawCircle(cx, cy, radius, paint)\n\n        if (expanding) radius += 2 else radius -= 2\n        if (radius > 100f) expanding = false\n        if (radius < 50f) expanding = true\n\n        postInvalidateOnAnimation() // Trigger next frame\n    }\n}"}
{"instruction": "Create a Kotlin BroadcastReceiver to monitor the device's battery level and charging status. This is a system sensor task often used for optimizing app performance based on power state.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\n\nclass BatteryLevelReceiver(private val onBatteryUpdate: (Int, Boolean) -> Unit) : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val level: Int = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n        val scale: Int = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        val status: Int = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)\n        \n        val batteryPct = if (level != -1 && scale != -1) {\n            (level * 100 / scale.toFloat()).toInt()\n        } else {\n            -1\n        }\n        \n        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                         status == BatteryManager.BATTERY_STATUS_FULL\n\n        onBatteryUpdate(batteryPct, isCharging)\n    }\n}\n\n// Register with: registerReceiver(batteryReceiver, IntentFilter(Intent.ACTION_BATTERY_CHANGED))"}
{"instruction": "Implement a Jetpack Compose Composable in Kotlin that displays a live camera preview using CameraX.", "output": "@Composable\nfun CameraPreview() {\n    val context = LocalContext.current\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val cameraProviderFuture = remember { ProcessCameraProvider.getInstance(context) }\n\n    AndroidView(\n        factory = { ctx ->\n            val previewView = PreviewView(ctx)\n            val executor = ContextCompat.getMainExecutor(ctx)\n            cameraProviderFuture.addListener({\n                val cameraProvider = cameraProviderFuture.get()\n                val preview = Preview.Builder().build().also {\n                    it.setSurfaceProvider(previewView.surfaceProvider)\n                }\n                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n                try {\n                    cameraProvider.unbindAll()\n                    cameraProvider.bindToLifecycle(\n                        lifecycleOwner,\n                        cameraSelector,\n                        preview\n                    )\n                } catch (e: Exception) {\n                    Log.e(\"CameraPreview\", \"Use case binding failed\", e)\n                }\n            }, executor)\n            previewView\n        },\n        modifier = Modifier.fillMaxSize()\n    )\n}"}
{"instruction": "Implement an Android BroadcastReceiver in Kotlin that listens for changes in battery status and logs the current percentage.", "output": "import android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.os.BatteryManager\nimport android.util.Log\n\nclass BatteryLevelReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == Intent.ACTION_BATTERY_CHANGED) {\n            val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)\n            val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n            \n            if (level != -1 && scale != -1) {\n                val batteryPct = (level / scale.toFloat()) * 100\n                Log.d(\"BatterySensor\", \"Current Battery Level: $batteryPct%\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Kotlin function using the Android SensorManager to listen for Ambient Light changes.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\n\nclass LightSensorListener(private val sensorManager: SensorManager) : SensorEventListener {\n    \n    fun startListening() {\n        val lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)\n        lightSensor?.let {\n            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stopListening() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {\n            val lux = event.values[0]\n            println(\"Ambient light level: $lux lx\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Write a Kotlin snippet for an ATAK plugin that constructs and broadcasts a 'GeoChat' CoT (Cursor on Target) message.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotPoint\nimport com.atakmap.coremap.cot.event.CotDetail\nimport com.atakmap.android.cot.CotMapComponent\nimport com.atakmap.coremap.maps.time.CoTPointData\n\nfun sendGeoChatMessage(message: String, lat: Double, lon: Double, uid: String) {\n    val event = CotEvent()\n    event.version = \"2.0\"\n    event.uid = java.util.UUID.randomUUID().toString()\n    event.type = \"b-t-f\" // Basic Chat Type\n    event.time = CoTPointData.now()\n    event.start = CoTPointData.now()\n    event.stale = CoTPointData.now() + (1000 * 60 * 5) // 5 mins stale\n    event.how = \"h-g-i-g-o\"\n    event.point = CotPoint(lat, lon, 0.0, 10.0, 10.0)\n\n    val detail = CotDetail(\"detail\")\n    val remarks = CotDetail(\"remarks\")\n    remarks.innerText = message\n    remarks.setAttribute(\"source\", uid)\n    detail.addChild(remarks)\n    \n    // ATAK specific chat structure usually requires a __chat parent, simplified here\n    val chatNode = CotDetail(\"__chat\")\n    chatNode.setAttribute(\"parent\", \"Root\")\n    chatNode.setAttribute(\"chatroom\", \"All Chat Rooms\")\n    chatNode.setAttribute(\"id\", uid)\n    chatNode.setAttribute(\"senderCallsign\", \"MyPlugin\")\n    detail.addChild(chatNode)\n\n    event.detail = detail\n\n    // Dispatch\n    CotMapComponent.getInternalDispatcher().dispatch(event)\n}"}
{"instruction": "Write a Kotlin class for Android that listens to the Accelerometer sensor and logs the X, Y, and Z values.", "output": "import android.content.Context\nimport android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerListener(context: Context) : SensorEventListener {\n    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\n\n    fun start() {\n        accelerometer?.also { sensor ->\n            sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL)\n        }\n    }\n\n    fun stop() {\n        sensorManager.unregisterListener(this)\n    }\n\n    override fun onSensorChanged(event: SensorEvent?) {\n        event?.let {\n            if (it.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n                Log.d(\"Accelerometer\", \"X: ${it.values[0]}, Y: ${it.values[1]}, Z: ${it.values[2]}\")\n            }\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a custom Android View in Kotlin that draws a red circle in the center of the canvas.", "output": "import android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.view.View\n\nclass RedCircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val paint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n        isAntiAlias = true\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val cx = width / 2f\n        val cy = height / 2f\n        val radius = Math.min(width, height) / 4f\n        canvas.drawCircle(cx, cy, radius, paint)\n    }\n}"}
{"instruction": "Implement a Kotlin function using Android CameraX to bind a camera preview to a PreviewView.", "output": "import android.content.Context\nimport androidx.camera.core.CameraSelector\nimport androidx.camera.core.Preview\nimport androidx.camera.lifecycle.ProcessCameraProvider\nimport androidx.camera.view.PreviewView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.LifecycleOwner\n\nfun startCamera(context: Context, lifecycleOwner: LifecycleOwner, previewView: PreviewView) {\n    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)\n\n    cameraProviderFuture.addListener({\n        val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\n        val preview = Preview.Builder().build().also {\n            it.setSurfaceProvider(previewView.surfaceProvider)\n        }\n\n        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\n        try {\n            cameraProvider.unbindAll()\n            cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, preview)\n        } catch (exc: Exception) {\n            exc.printStackTrace()\n        }\n    }, ContextCompat.getMainExecutor(context))\n}"}
{"instruction": "Create an ATAK DropDownReceiver class (Kotlin) used to handle UI interactions when a tool is activated.", "output": "import android.content.Context\nimport android.content.Intent\nimport android.view.View\nimport com.atakmap.android.maps.MapView\nimport com.atakmap.android.dropdown.DropDownReceiver\n\nclass MyPluginDropDownReceiver(mapView: MapView, context: Context) : \n    DropDownReceiver(mapView) {\n\n    private val pluginContext: Context = context\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == \"com.atakmap.android.myplugin.SHOW_TOOL\") {\n            if (!isClosed) {\n                 // Already open, close it or toggle\n                closeDropDown()\n            } else {\n                setRetain(true)\n                // Inflate your custom view here\n                // val v = LayoutInflater.from(pluginContext).inflate(R.layout.my_view, null)\n                // showDropDown(v, HALF_WIDTH, FULL_HEIGHT, FULL_WIDTH, HALF_HEIGHT)\n            }\n        }\n    }\n\n    override fun disposeImpl() {\n        // Cleanup resources\n    }\n}"}
{"instruction": "Write a Kotlin class in Android that implements `SensorEventListener` to log accelerometer data (X, Y, Z) to the console.", "output": "import android.hardware.Sensor\nimport android.hardware.SensorEvent\nimport android.hardware.SensorEventListener\nimport android.hardware.SensorManager\nimport android.util.Log\n\nclass AccelerometerLogger : SensorEventListener {\n    override fun onSensorChanged(event: SensorEvent?) {\n        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {\n            val x = event.values[0]\n            val y = event.values[1]\n            val z = event.values[2]\n            Log.d(\"Accelerometer\", \"X: $x, Y: $y, Z: $z\")\n        }\n    }\n\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\n        // Handle accuracy changes if necessary\n    }\n}"}
{"instruction": "Create a basic ATAK MapWidget in Kotlin that displays a red text label saying \"Status: Active\" at the top left of the map.", "output": "import com.atakmap.android.widgets.MapWidget\nimport com.atakmap.android.widgets.TextWidget\nimport android.graphics.Color\n\nclass StatusMapWidget : MapWidget() {\n    init {\n        name = \"Status Widget\"\n        val textWidget = TextWidget(\"Status: Active\", _face)\n        textWidget.color = Color.RED\n        // Set position relative to top-left\n        textWidget.point.set(10f, 10f)\n        this.addWidget(textWidget)\n    }\n}"}
{"instruction": "Create a Kotlin function to retrieve the current battery percentage on an Android device using `BatteryManager`.", "output": "import android.content.Context\nimport android.os.BatteryManager\n\nfun getBatteryPercentage(context: Context): Int {\n    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n}"}
{"instruction": "Write an ATAK plugin snippet in Kotlin to register a listener for all incoming Cursor on Target (CoT) events.", "output": "import com.atakmap.coremap.cot.event.CotEvent\nimport com.atakmap.coremap.cot.event.CotEventListener\nimport com.atakmap.comms.CotServiceRemote\n\nclass MyCotListener : CotEventListener {\n    override fun onCotEvent(event: CotEvent?, source: Any?) {\n        if (event != null) {\n            // Process the CoT event (e.g., check UID or type)\n            val type = event.type\n            val uid = event.uid\n        }\n    }\n}\n\n// Usage within Plugin Lifecycle\n// CotServiceRemote.getInstance().addCotEventListener(myCotListener)"}
{"instruction": "Implement a function in Kotlin using the Android Jetpack Location library to get the last known location.", "output": "import android.annotation.SuppressLint\nimport android.content.Context\nimport android.location.Location\nimport com.google.android.gms.location.LocationServices\n\n@SuppressLint(\"MissingPermission\") // Assume permissions are handled\nfun getLastKnownLocation(context: Context, callback: (Location?) -> Unit) {\n    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)\n    fusedLocationClient.lastLocation\n        .addOnSuccessListener { location: Location? ->\n            callback(location)\n        }\n}"}
{"instruction": "Define an ATAK `Tool` class in Kotlin that opens a custom \"Mission Planner\" view when the tool icon is clicked in the radial menu.", "output": "import com.atakmap.android.ipc.AtakBroadcast\nimport com.atakmap.android.tools.Tool\nimport android.content.Intent\nimport android.graphics.drawable.Drawable\n\nclass MissionPlannerTool(private val context: android.content.Context) : Tool {\n\n    override fun getName(): String = \"Mission Planner\"\n\n    override fun getIcon(): Drawable? {\n        // Return drawable resource here\n        return null \n    }\n\n    override fun onToolClicked() {\n        // Broadcast intent to open the specific plugin view\n        val intent = Intent(\"com.myplugin.OPEN_MISSION_PLANNER\")\n        AtakBroadcast.getInstance().sendBroadcast(intent)\n    }\n}"}
