{"instruction": "Create a FastAPI endpoint for user registration. It should validate the input using a Pydantic model (email, password, username) and hash the password using passlib/bcrypt before returning a success message.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n# Mock database\nfake_users_db = {}\n\n@app.post(\"/register\", status_code=201)\nasync def register_user(user: UserCreate):\n    if user.username in fake_users_db:\n        raise HTTPException(status_code=400, detail=\"Username already registered\")\n    \n    hashed_password = get_password_hash(user.password)\n    \n    # In a real app, save to DB here\n    fake_users_db[user.username] = {\n        \"username\": user.username,\n        \"email\": user.email,\n        \"hashed_password\": hashed_password\n    }\n    \n    return {\"message\": \"User created successfully\", \"username\": user.username}"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to asynchronously fetch a user profile by ID. Include error handling for database connection issues or if the user is not found.", "output": "const { Pool } = require('pg');\nconst pool = new Pool(); // assumes env vars are set\n\nasync function getUserById(userId) {\n  const client = await pool.connect();\n  try {\n    const queryText = 'SELECT id, username, email, created_at FROM users WHERE id = $1';\n    const res = await client.query(queryText, [userId]);\n    \n    if (res.rows.length === 0) {\n      throw new Error('User not found');\n    }\n    \n    return res.rows[0];\n  } catch (err) {\n    console.error('Database error stack', err.stack);\n    throw err;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a normalized SQL schema (PostgreSQL syntax) for a simple E-commerce system containing tables for 'users', 'products', and 'orders'. Ensure referential integrity using Foreign Keys.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    full_name VARCHAR(100),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n      FOREIGN KEY(user_id) \n      REFERENCES users(id)\n      ON DELETE CASCADE\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL,\n    CONSTRAINT fk_order\n      FOREIGN KEY(order_id) \n      REFERENCES orders(id)\n      ON DELETE CASCADE,\n    CONSTRAINT fk_product\n      FOREIGN KEY(product_id) \n      REFERENCES products(id)\n);\n"}
{"instruction": "Implement a FastAPI dependency that yields an asynchronous SQLAlchemy database session. Then, create a GET route that uses this dependency to fetch all items from a hypothetical 'Item' model.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import select\n# Assuming models.Item is defined elsewhere\n# from models import Item, Base\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\napp = FastAPI()\n\n# Dependency\nasync def get_db():\n    async with async_session() as session:\n        yield session\n\n@app.get(\"/items\")\nasync def read_items(db: AsyncSession = Depends(get_db)):\n    # Example query execution\n    # result = await db.execute(select(Item))\n    # items = result.scalars().all()\n    # return items\n    return {\"status\": \"This code demonstrates the dependency injection pattern\"}"}
{"instruction": "Create an Express.js middleware function named 'authenticateToken' that verifies a JSON Web Token (JWT) from the Authorization header. If valid, attach the user to the request object; otherwise, return 401 or 403.", "output": "const jwt = require('jsonwebtoken');\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <TOKEN>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) return res.sendStatus(401); // No token present\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403); // Invalid token\n    \n    req.user = user;\n    next();\n  });\n}"}
{"instruction": "Write a SQL query to calculate the monthly revenue for the current year. The output should contain the month and the total revenue, ordered by month.", "output": "SELECT \n    EXTRACT(MONTH FROM created_at) AS month,\n    SUM(total_amount) AS total_revenue\nFROM \n    orders\nWHERE \n    EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY \n    EXTRACT(MONTH FROM created_at)\nORDER BY \n    month ASC;"}
{"instruction": "Using Python and Celery, define a background task that simulates sending an email (by sleeping for 5 seconds). Show how to define the task and how to call it asynchronously.", "output": "from celery import Celery\nimport time\n\n# Setup Celery\napp = Celery('tasks', broker='redis://localhost:6379/0')\n\n@app.task\ndef send_welcome_email(email_address):\n    # Simulate expensive I/O operation\n    print(f\"Sending email to {email_address}...\")\n    time.sleep(5)\n    print(f\"Email sent to {email_address}!\")\n    return \"Done\"\n\n# How to call it in application logic:\n# result = send_welcome_email.delay('user@example.com')"}
{"instruction": "Write a Node.js script using the 'readline' and 'fs' modules to process a large CSV file line-by-line. The goal is to log the number of lines without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine() {\n  const fileStream = fs.createReadStream('large_data.csv');\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n  \n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Process line here if needed\n    lineCount++;\n  }\n\n  console.log(`Total lines processed: ${lineCount}`);\n}\n\nprocessLineByLine();"}
{"instruction": "Create a WebSocket endpoint using FastAPI that accepts connections, receives text messages, and echoes them back to the client with a prefix.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL migration script to add a 'status' column to an existing 'tasks' table. The column should default to 'active' and not allow NULL values. Also, create an index on this column for faster filtering.", "output": "-- Add the column with a default value\nALTER TABLE tasks \nADD COLUMN status VARCHAR(20) DEFAULT 'active' NOT NULL;\n\n-- Create an index to optimize queries like \"WHERE status = 'active'\"\nCREATE INDEX idx_tasks_status ON tasks(status);"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should validate that the email is valid, the username is alphanumeric, and the password is at least 8 characters long. Mock the database save operation.", "output": "from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\napp = FastAPI()\n\nclass UserRegister(BaseModel):\n    username: str = Field(..., min_length=3, max_length=30)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\n    @validator('username')\n    def username_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        return v\n\n@app.post(\"/register\", status_code=status.HTTP_201_CREATED)\nasync def register_user(user: UserRegister):\n    # Mock Database Check\n    if user.username == \"admin\":\n        raise HTTPException(status_code=400, detail=\"Username taken\")\n    \n    # Mock Save\n    return {\"message\": \"User created successfully\", \"username\": user.username}"}
{"instruction": "Write a raw SQL schema (PostgreSQL dialect) for a simple library system. Create tables for 'authors' and 'books' with a one-to-many relationship. Include a foreign key constraint and an index on the book title.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(20) UNIQUE,\n    published_date DATE,\n    author_id INT NOT NULL,\n    CONSTRAINT fk_author\n      FOREIGN KEY(author_id) \n      REFERENCES authors(author_id)\n      ON DELETE CASCADE\n);\n\nCREATE INDEX idx_books_title ON books(title);"}
{"instruction": "Using Node.js and Express, create an asynchronous route handler that fetches user details and their recent orders in parallel using `Promise.all` to optimize performance. Return a combined JSON object.", "output": "const express = require('express');\nconst router = express.Router();\n\n// Mock async DB functions\nconst getUser = async (id) => new Promise(resolve => setTimeout(() => resolve({ id, name: 'John Doe' }), 100));\nconst getOrders = async (id) => new Promise(resolve => setTimeout(() => resolve([{ orderId: 1, amount: 50 }, { orderId: 2, amount: 20 }]), 150));\n\nrouter.get('/user-dashboard/:id', async (req, res) => {\n  try {\n    const userId = req.params.id;\n    \n    // Execute queries in parallel\n    const [user, orders] = await Promise.all([\n      getUser(userId),\n      getOrders(userId)\n    ]);\n\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      user,\n      recentOrders: orders,\n      totalSpent: orders.reduce((acc, curr) => acc + curr.amount, 0)\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Internal Server Error' });\n  }\n});\n\nmodule.exports = router;"}
{"instruction": "Implement a FastAPI dependency that manages a database session. It should create a session before the request and close it after the request is finished, handling exceptions by rolling back the transaction.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming 'SessionLocal' is defined elsewhere in database.py\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Session active\"}"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) and a Window Function to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM RankedSalaries\nWHERE rank <= 3\nORDER BY department_id, salary DESC;"}
{"instruction": "Create a Node.js middleware function for Express that verifies a JSON Web Token (JWT) from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid or expired token' });\n    }\n    \n    // Attach user to request\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Demonstrate how to use FastAPI's `BackgroundTasks` to send a welcome email after a user successfully registers, ensuring the HTTP response is not blocked by the email sending process.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running email process\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    # Add task to queue\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    \n    # Return response immediately\n    return {\"message\": \"Signup successful. Check your email shortly.\"}"}
{"instruction": "Write a SQL transaction block that safely transfers $100 from Account A to Account B. Ensure that the transaction fails if Account A has insufficient funds.", "output": "BEGIN;\n\n-- Deduct from Sender\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 'A' AND balance >= 100;\n\n-- Check if the update actually happened (row count check logic varies by DB driver, generic SQL logic implies checking state)\n-- In a stored procedure, we would check ROW_COUNT. Here is the logic flow:\n\n-- Add to Receiver\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 'B';\n\n-- Commit if successful, otherwise Rollback (handled by application logic usually, but strict SQL constraint prevents negative balance if defined)\nCOMMIT;"}
{"instruction": "Using Node.js and Mongoose, define a Schema for a 'Product' that includes a virtual property 'inStock' (boolean) based on the 'quantity' field, and an instance method to apply a discount.", "output": "const mongoose = require('mongoose');\n\nconst productSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  quantity: { type: Number, default: 0 },\n  category: String\n}, { toJSON: { virtuals: true }, toObject: { virtuals: true } });\n\n// Virtual Property\nproductSchema.virtual('inStock').get(function() {\n  return this.quantity > 0;\n});\n\n// Instance Method\nproductSchema.methods.applyDiscount = function(percent) {\n  this.price = this.price - (this.price * (percent / 100));\n  return this.save();\n};\n\nconst Product = mongoose.model('Product', productSchema);\nmodule.exports = Product;"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload. The endpoint should read the file content asynchronously and return the file size and filename.", "output": "from fastapi import FastAPI, UploadFile, File\n\napp = FastAPI()\n\n@app.post(\"/uploadfile/\")\nasync def create_upload_file(file: UploadFile = File(...)):\n    # Read file content asynchronously\n    content = await file.read()\n    size = len(content)\n    \n    return {\n        \"filename\": file.filename,\n        \"content_type\": file.content_type,\n        \"size_in_bytes\": size\n    }"}
{"instruction": "Create a FastAPI asynchronous endpoint that fetches data from an external API using `httpx` and returns a summarized JSON response.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-data/{user_id}\")\nasync def get_external_data(user_id: int):\n    url = f\"https://jsonplaceholder.typicode.com/users/{user_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        \n    if response.status_code != 200:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n        \n    data = response.json()\n    return {\n        \"id\": data[\"id\"],\n        \"name\": data[\"name\"],\n        \"email\": data[\"email\"],\n        \"website\": data[\"website\"]\n    }"}
{"instruction": "Write a SQL schema creation script (PostgreSQL dialect) for a simple blog system containing `users` and `posts` tables with a foreign key relationship.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js (Express) middleware function that logs the HTTP method, URL, and timestamp for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\n// Middleware definition\nconst requestLogger = (req, res, next) => {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] ${req.method} ${req.url}`);\n    next();\n};\n\n// Apply middleware\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n    res.send('Hello World');\n});\n\napp.listen(3000);"}
{"instruction": "Define SQLAlchemy (Async) models for a Many-to-Many relationship between `Student` and `Course`.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', ForeignKey('students.id'), primary_key=True),\n    Column('course_id', ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Write a Node.js function using `fs/promises` to asynchronously read a JSON file, add a new key-value pair, and write it back to the disk.", "output": "const fs = require('fs/promises');\nconst path = require('path');\n\nasync function updateConfig(filePath) {\n    try {\n        // Read file\n        const data = await fs.readFile(filePath, 'utf8');\n        const json = JSON.parse(data);\n\n        // Update object\n        json.lastUpdated = new Date().toISOString();\n\n        // Write back\n        await fs.writeFile(filePath, JSON.stringify(json, null, 2));\n        console.log('Config updated successfully.');\n    } catch (error) {\n        console.error('Error updating config:', error);\n    }\n}"}
{"instruction": "Create a SQL query to calculate the total order value per customer, filtering only for customers who have spent more than $500.", "output": "SELECT \n    c.customer_id,\n    c.customer_name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.customer_id = o.customer_id\nGROUP BY \n    c.customer_id, c.customer_name\nHAVING \n    SUM(o.total_amount) > 500.00\nORDER BY \n    total_spent DESC;"}
{"instruction": "Implement a FastAPI dependency that yields a database session and ensures the session is closed after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Node.js script that executes three asynchronous tasks in parallel using `Promise.all` and handles potential errors.", "output": "const task = (id, duration) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        if (Math.random() > 0.9) reject(`Task ${id} failed`);\n        else resolve(`Task ${id} completed`);\n    }, duration);\n});\n\nasync function runTasks() {\n    try {\n        console.log(\"Starting tasks...\");\n        const results = await Promise.all([\n            task(1, 1000),\n            task(2, 500),\n            task(3, 1500)\n        ]);\n        console.log(\"All tasks finished:\", results);\n    } catch (error) {\n        console.error(\"One of the tasks failed:\", error);\n    }\n}\n\nrunTasks();"}
{"instruction": "Create a Pydantic model for User Registration that validates the email format and ensures the password is at least 8 characters long.", "output": "from pydantic import BaseModel, EmailStr, field_validator\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        return v"}
{"instruction": "Write a SQL transaction to transfer funds between two accounts, ensuring atomicity.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100.00 \nWHERE account_id = 1 AND balance >= 100.00;\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100.00 \nWHERE account_id = 2;\n\n-- Commit if no errors, otherwise Rollback would happen automatically on error in many drivers, or explicit ROLLBACK can be called.\nCOMMIT;"}
{"instruction": "Create a FastAPI endpoint using Python that registers a user. It should validate the input using Pydantic, hash the password using passlib, and simulate saving to a database.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nfake_users_db = {}\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n@app.post(\"/register/\")\nasync def register_user(user: UserCreate):\n    if user.email in fake_users_db:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = get_password_hash(user.password)\n    user_entry = {\n        \"username\": user.username,\n        \"email\": user.email,\n        \"hashed_password\": hashed_password\n    }\n    fake_users_db[user.email] = user_entry\n    return {\"msg\": \"User created successfully\", \"username\": user.username}"}
{"instruction": "Write a Node.js function using async/await and a hypothetical PostgreSQL client (pg) to fetch a paginated list of products. The function accepts 'page' and 'limit' arguments.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function getPaginatedProducts(page = 1, limit = 10) {\n  const offset = (page - 1) * limit;\n  \n  const query = `\n    SELECT id, name, price \n    FROM products \n    ORDER BY created_at DESC \n    LIMIT $1 OFFSET $2\n  `;\n  \n  try {\n    const res = await pool.query(query, [limit, offset]);\n    return res.rows;\n  } catch (err) {\n    console.error('Error executing query', err.stack);\n    throw err;\n  }\n}"}
{"instruction": "Design a SQL schema (PostgreSQL dialect) for a Many-to-Many relationship between 'Authors' and 'Books'. Include the necessary foreign key constraints.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    published_date DATE\n);\n\nCREATE TABLE book_authors (\n    book_id INT NOT NULL,\n    author_id INT NOT NULL,\n    PRIMARY KEY (book_id, author_id),\n    CONSTRAINT fk_book\n      FOREIGN KEY(book_id) \n      REFERENCES books(book_id) \n      ON DELETE CASCADE,\n    CONSTRAINT fk_author\n      FOREIGN KEY(author_id) \n      REFERENCES authors(author_id) \n      ON DELETE CASCADE\n);"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user logs in, ensuring the API response is not blocked by the email sending process.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/login/{email}\")\nasync def login(email: str, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_email_notification, email)\n    return {\"message\": \"Login successful. Notification will be sent shortly.\"}"}
{"instruction": "Write a Node.js script that fetches data from three different third-party APIs concurrently using Promise.all to optimize performance.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData() {\n  try {\n    const [userResponse, statsResponse, newsResponse] = await Promise.all([\n      axios.get('https://api.example.com/user/profile'),\n      axios.get('https://api.example.com/system/stats'),\n      axios.get('https://api.example.com/news/latest')\n    ]);\n\n    return {\n      user: userResponse.data,\n      stats: statsResponse.data,\n      news: newsResponse.data\n    };\n  } catch (error) {\n    console.error('Failed to fetch dashboard data:', error.message);\n    throw error;\n  }\n}\n\n// Usage\nfetchDashboardData().then(data => console.log(data));"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Create a Python/FastAPI dependency that manages a database session, ensuring the session is closed after the request is processed (Context Manager pattern).", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming 'SessionLocal' is already configured in a database module\n# from .database import SessionLocal\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Session active\"}"}
{"instruction": "Write a Node.js function using Streams to read a large CSV file line-by-line and log each line, avoiding high memory consumption.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line individually\n    console.log(`Line content: ${line}`);\n  }\n}\n\nprocessLargeFile('./large_dataset.csv');"}
{"instruction": "Define a complex Pydantic schema in Python for an E-commerce Order, which includes a list of nested items and validates that the quantity of items is positive.", "output": "from pydantic import BaseModel, Field, validator\nfrom typing import List\n\nclass OrderItem(BaseModel):\n    product_id: int\n    name: str\n    quantity: int = Field(..., gt=0, description=\"Quantity must be greater than zero\")\n    price_per_unit: float\n\nclass Order(BaseModel):\n    order_id: int\n    customer_email: str\n    items: List[OrderItem]\n    \n    @validator('items')\n    def check_items_not_empty(cls, v):\n        if not v:\n            raise ValueError('Order must contain at least one item')\n        return v\n\n    @property\n    def total_price(self):\n        return sum(item.quantity * item.price_per_unit for item in self.items)"}
{"instruction": "Write a Recursive Common Table Expression (CTE) in SQL to fetch a category tree (adjacency list model) starting from a root category.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: select the root category\n    SELECT \n        category_id, \n        name, \n        parent_id, \n        1 as level\n    FROM categories\n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: join with the previous result\n    SELECT \n        c.category_id, \n        c.name, \n        c.parent_id, \n        cp.level + 1\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.parent_id = cp.category_id\n)\nSELECT * FROM CategoryPath;"}
{"instruction": "Create a FastAPI asynchronous endpoint using Python that fetches data from an external public API (e.g., a currency converter) using `httpx` and returns a transformed response. Ensure proper error handling for the external request.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\nEXTERNAL_API_URL = \"https://api.exchangerate-api.com/v4/latest/USD\"\n\n@app.get(\"/convert/{currency}\")\nasync def get_exchange_rate(currency: str):\n    currency = currency.upper()\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(EXTERNAL_API_URL)\n            response.raise_for_status()\n            data = response.json()\n            \n            rates = data.get(\"rates\", {})\n            if currency not in rates:\n                raise HTTPException(status_code=404, detail=\"Currency not found\")\n            \n            return {\n                \"base\": \"USD\",\n                \"target\": currency,\n                \"rate\": rates[currency]\n            }\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=503, detail=\"External service unavailable\")\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=str(e))"}
{"instruction": "Write a SQL query (PostgreSQL flavor) to calculate the total revenue generated by each user for the current month. Assume two tables: `users` (id, name) and `orders` (id, user_id, amount, created_at). Return the user's name and total revenue, ordered by revenue descending.", "output": "SELECT \n    u.name,\n    SUM(o.amount) as total_revenue\nFROM \n    users u\nJOIN \n    orders o ON u.id = o.user_id\nWHERE \n    o.created_at >= DATE_TRUNC('month', CURRENT_DATE)\n    AND o.created_at < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'\nGROUP BY \n    u.id, u.name\nORDER BY \n    total_revenue DESC;"}
{"instruction": "Implement a simple custom middleware in Node.js (Express) that logs the HTTP method, URL, and the time taken to process the request (latency) in milliseconds.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} - ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Define a Pydantic v2 model in Python for a User Registration payload. It must include an email, a username, and a password. Add a custom validator to ensure the password is at least 8 characters long and contains at least one number.", "output": "from pydantic import BaseModel, EmailStr, field_validator\nimport re\n\nclass UserRegister(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Design a SQL schema (DDL) for a many-to-many relationship between `students` and `classes`. Include the necessary foreign keys and a composite primary key for the join table to prevent duplicate enrollments.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE classes (\n    class_id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT NOT NULL,\n    class_id INT NOT NULL,\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (student_id, class_id),\n    FOREIGN KEY (student_id) REFERENCES students(student_id) ON DELETE CASCADE,\n    FOREIGN KEY (class_id) REFERENCES classes(class_id) ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js script using the `fs` and `readline` modules to process a massive CSV file line-by-line asynchronously without loading the whole file into memory. Log the line count at the end.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Simulate processing logic here\n    // const columns = line.split(',');\n    lineCount++;\n  }\n\n  console.log(`Processed ${lineCount} lines.`);\n}\n\n// Usage: processLargeFile('./large_data.csv');"}
{"instruction": "Using Python and FastAPI, implement a dependency injection function to manage a database session. The session should be yielded to the endpoint and closed automatically after the request is finished.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # db is ready to use here\n    return {\"message\": \"Database session established\"}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department. The output should include employee name, department, salary, and their rank (1 being highest salary).", "output": "SELECT \n    name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Create a Mongoose (Node.js/MongoDB) schema for a `Product`. Include a static method `findByCategory` that returns products sorted by price, and a virtual property `isInStock` based on a `quantity` field.", "output": "const mongoose = require('mongoose');\n\nconst productSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  category: { type: String, required: true },\n  quantity: { type: Number, default: 0 }\n});\n\n// Virtual property\nproductSchema.virtual('isInStock').get(function() {\n  return this.quantity > 0;\n});\n\n// Static method\nproductSchema.statics.findByCategory = function(category) {\n  return this.find({ category: category }).sort({ price: 1 });\n};\n\nconst Product = mongoose.model('Product', productSchema);"}
{"instruction": "Implement a FastAPI endpoint that accepts a payload and triggers a background task (e.g., sending an email) so the API returns a response immediately while the task runs in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our service!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Create a FastAPI async endpoint using Pydantic models to create a new user. The endpoint should validate the email format and ensure the password is at least 8 characters long before returning a success message.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n# Mock database\nfake_users_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate):\n    # Simulate async database check for existing email\n    for existing_user in fake_users_db:\n        if existing_user['email'] == user.email:\n            raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Simulate async insertion\n    new_user_id = len(fake_users_db) + 1\n    user_dict = user.dict()\n    user_dict['id'] = new_user_id\n    # Remove password from response/storage simulation logic for safety\n    response_data = {k: v for k, v in user_dict.items() if k != 'password'}\n    \n    fake_users_db.append(user_dict)\n    \n    return response_data"}
{"instruction": "Write a PostgreSQL SQL schema definition for a simple E-commerce system with 'users', 'products', and 'orders'. Include foreign keys and a timestamp for when the order was placed.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL,\n    CONSTRAINT fk_order\n        FOREIGN KEY(order_id) \n        REFERENCES orders(id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_product\n        FOREIGN KEY(product_id) \n        REFERENCES products(id)\n);\n"}
{"instruction": "Implement a Node.js Express middleware function that validates a JSON Web Token (JWT) from the 'Authorization' header. If valid, attach the user to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer <TOKEN>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) {\n    return res.status(401).json({ message: 'No token provided' });\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid token' });\n    }\n    \n    // Attach decoded user payload to request object\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Create a Python function using SQLAlchemy (AsyncIO) to fetch a user by ID. It should handle the database session context properly.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom models import User  # Assuming User model exists\n\nasync def get_user_by_id(session: AsyncSession, user_id: int):\n    try:\n        # Create the query\n        query = select(User).where(User.id == user_id)\n        \n        # Execute the query asynchronously\n        result = await session.execute(query)\n        \n        # Return the scalar result (first match or None)\n        return result.scalars().first()\n    except Exception as e:\n        # Log error in production\n        print(f\"Error fetching user: {e}\")\n        return None"}
{"instruction": "Write a complex SQL query to calculate the monthly revenue for the current year, grouped by month, only including months where revenue exceeded $10,000.", "output": "SELECT \n    TO_CHAR(created_at, 'YYYY-MM') AS month,\n    SUM(total_amount) AS total_revenue\nFROM \n    orders\nWHERE \n    created_at >= DATE_TRUNC('year', CURRENT_DATE)\n    AND status = 'completed'\nGROUP BY \n    TO_CHAR(created_at, 'YYYY-MM')\nHAVING \n    SUM(total_amount) > 10000\nORDER BY \n    month ASC;"}
{"instruction": "Implement a Node.js function that uses `Promise.all` to concurrently fetch user details and their recent posts from two different mock API endpoints, returning a combined object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function getUserDashboard(userId) {\n  const userUrl = `https://api.example.com/users/${userId}`;\n  const postsUrl = `https://api.example.com/users/${userId}/posts`;\n\n  try {\n    // Initiate both requests concurrently\n    const [userRes, postsRes] = await Promise.all([\n      fetch(userUrl),\n      fetch(postsUrl)\n    ]);\n\n    if (!userRes.ok || !postsRes.ok) {\n      throw new Error('Failed to fetch data from one or more services');\n    }\n\n    const userData = await userRes.json();\n    const postsData = await postsRes.json();\n\n    return {\n      user: userData,\n      recentPosts: postsData,\n      fetchedAt: new Date().toISOString()\n    };\n  } catch (error) {\n    console.error('Dashboard aggregation error:', error);\n    throw error;\n  }\n}"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and processes it in the background using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_file_logic(file_location: str):\n    # Simulate expensive processing (e.g., image resizing, CSV parsing)\n    import time\n    time.sleep(5)\n    print(f\"Finished processing file at {file_location}\")\n\n@app.post(\"/upload/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file to disk asynchronously (or synchronously depending on IO library)\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule the expensive task to run after the response is sent\n    background_tasks.add_task(process_file_logic, file_location)\n    \n    return {\"message\": \"File uploaded successfully, processing started.\", \"filename\": file.filename}"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 products in each category based on sales volume.", "output": "WITH ProductSales AS (\n    SELECT \n        p.category_id,\n        p.id AS product_id,\n        p.name,\n        SUM(oi.quantity) AS total_sold\n    FROM \n        products p\n    JOIN \n        order_items oi ON p.id = oi.product_id\n    GROUP BY \n        p.category_id, p.id, p.name\n),\nRankedSales AS (\n    SELECT \n        category_id,\n        product_id,\n        name,\n        total_sold,\n        RANK() OVER (PARTITION BY category_id ORDER BY total_sold DESC) as rank\n    FROM \n        ProductSales\n)\nSELECT \n    category_id,\n    product_id,\n    name,\n    total_sold\nFROM \n    RankedSales\nWHERE \n    rank <= 3;"}
{"instruction": "Implement a Python async context manager class that manages a Redis connection pool, ensuring connections are closed/released after use.", "output": "import redis.asyncio as redis\n\nclass AsyncRedisManager:\n    def __init__(self, url: str):\n        self.url = url\n        self.redis = None\n\n    async def __aenter__(self):\n        # Initialize connection\n        self.redis = redis.from_url(self.url, decode_responses=True)\n        return self.redis\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        # Close connection upon exit\n        if self.redis:\n            await self.redis.close()\n\n# Usage Example:\n# async def main():\n#     async with AsyncRedisManager(\"redis://localhost\") as r:\n#         await r.set(\"key\", \"value\")\n#         print(await r.get(\"key\"))"}
{"instruction": "Write a Node.js script using Streams to read a massive log file line-by-line and write only lines containing the word 'ERROR' to a new file, preventing memory overflow.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nconst inputFile = 'application.log';\nconst outputFile = 'errors_only.log';\n\nconst inputStream = fs.createReadStream(inputFile);\nconst outputStream = fs.createWriteStream(outputFile);\n\nconst rl = readline.createInterface({\n  input: inputStream,\n  crlfDelay: Infinity // Handle all CR LF as single line breaks\n});\n\nrl.on('line', (line) => {\n  if (line.includes('ERROR')) {\n    // Write the line to the output stream with a newline character\n    const canWrite = outputStream.write(line + '\\n');\n    \n    // Handle backpressure if the buffer is full\n    if (!canWrite) {\n      rl.pause();\n      outputStream.once('drain', () => rl.resume());\n    }\n  }\n});\n\nrl.on('close', () => {\n  console.log('Finished processing log file.');\n  outputStream.end();\n});"}
{"instruction": "Create a FastAPI endpoint `GET /users/{user_id}/enrich` that asynchronously fetches additional profile data from an external service `https://api.external.com/profiles/{user_id}` using `httpx` and merges it with a local dictionary response.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\nasync def fetch_external_profile(user_id: int):\n    async with httpx.AsyncClient() as client:\n        resp = await client.get(f\"https://api.external.com/profiles/{user_id}\")\n        if resp.status_code != 200:\n            return None\n        return resp.json()\n\n@app.get(\"/users/{user_id}/enrich\")\nasync def get_enriched_user(user_id: int):\n    # Simulated local DB data\n    local_data = {\"user_id\": user_id, \"role\": \"admin\", \"status\": \"active\"}\n    \n    external_data = await fetch_external_profile(user_id)\n    \n    if not external_data:\n        raise HTTPException(status_code=404, detail=\"External profile not found\")\n        \n    return {**local_data, \"external_info\": external_data}"}
{"instruction": "Write a PostgreSQL SQL script to define a schema for a library system. Create tables for `authors`, `books`, and a junction table `book_authors` to handle a many-to-many relationship, including appropriate foreign keys and cascading deletes.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE NOT NULL,\n    published_date DATE\n);\n\nCREATE TABLE book_authors (\n    book_id INT NOT NULL,\n    author_id INT NOT NULL,\n    PRIMARY KEY (book_id, author_id),\n    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,\n    FOREIGN KEY (author_id) REFERENCES authors(id) ON DELETE CASCADE\n);"}
{"instruction": "Implement an Express.js middleware function named `authenticateToken` that verifies a JWT from the `Authorization` header (Bearer schema). If valid, attach the user to the request object; otherwise, return 401 or 403.", "output": "const jwt = require('jsonwebtoken');\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  // Bearer TOKEN\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}"}
{"instruction": "Using Python's SQLAlchemy ORM, define the models for a `User` and `Post` one-to-many relationship. A user can have many posts, but a post belongs to one user. Include the `relationship` and `back_populates` configuration.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    \n    # Relationship to Post\n    posts = relationship(\"Post\", back_populates=\"owner\", cascade=\"all, delete-orphan\")\n\nclass Post(Base):\n    __tablename__ = 'posts'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    content = Column(String)\n    user_id = Column(Integer, ForeignKey('users.id'))\n    \n    # Relationship back to User\n    owner = relationship(\"User\", back_populates=\"posts\")"}
{"instruction": "In Node.js, implement a function `processOrders` that takes an array of order IDs. It should process them sequentially (not in parallel) using `async/await` to simulate a database update for each order, logging the progress.", "output": "const updateOrderInDB = (id) => new Promise(resolve => setTimeout(() => resolve(`Updated ${id}`), 500));\n\nasync function processOrders(orderIds) {\n  console.log('Starting batch processing...');\n  \n  for (const id of orderIds) {\n    try {\n      const result = await updateOrderInDB(id);\n      console.log(result);\n    } catch (error) {\n      console.error(`Failed to update order ${id}:`, error);\n    }\n  }\n  \n  console.log('All orders processed.');\n}"}
{"instruction": "Write a FastAPI dependency function `get_db` that manages a database session. It should yield the session to the route handler and ensure the session is closed after the request is finished.", "output": "from sqlalchemy.orm import Session\nfrom db_setup import SessionLocal # Assuming SessionLocal is configured elsewhere\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL query using a Window Function to retrieve the top 3 highest-paid employees from each department. Assume a table `employees` with columns `id`, `name`, `salary`, and `department_id`.", "output": "WITH RankedSalaries AS (\n    SELECT \n        id, \n        name, \n        salary, \n        department_id,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT id, name, salary, department_id\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Create a Node.js script using the `fs` module to read a large CSV file via a read stream, transform the headers to lowercase, and pipe it to a write stream.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst readStream = fs.createReadStream('input.csv', { encoding: 'utf8' });\nconst writeStream = fs.createWriteStream('output.csv');\n\nlet isHeader = true;\n\nconst transformStream = new Transform({\n  transform(chunk, encoding, callback) {\n    let data = chunk.toString();\n    if (isHeader) {\n      // Simple heuristic for first line transformation\n      const parts = data.split('\\n');\n      parts[0] = parts[0].toLowerCase();\n      data = parts.join('\\n');\n      isHeader = false;\n    }\n    this.push(data);\n    callback();\n  }\n});\n\nreadStream.pipe(transformStream).pipe(writeStream)\n  .on('finish', () => console.log('CSV processing complete.'));"}
{"instruction": "Define a Pydantic model `Event` in Python with fields `start_time` (datetime) and `end_time` (datetime). Implement a model validator (after) to ensure `end_time` is strictly after `start_time`.", "output": "from datetime import datetime\nfrom pydantic import BaseModel, model_validator, ValidationError\n\nclass Event(BaseModel):\n    start_time: datetime\n    end_time: datetime\n\n    @model_validator(mode='after')\n    def check_times(self):\n        if self.end_time <= self.start_time:\n            raise ValueError('end_time must be after start_time')\n        return self"}
{"instruction": "Implement a Node.js function `getCachedUser(userId)` that attempts to retrieve data from Redis. If it's a cache miss, fetch from a mock DB, store in Redis with a 60s TTL, and return the data.", "output": "const redis = require('redis');\nconst client = redis.createClient();\nawait client.connect();\n\n// Mock DB function\nconst fetchFromDb = async (id) => ({ id, name: 'John Doe' });\n\nasync function getCachedUser(userId) {\n  const cacheKey = `user:${userId}`;\n  \n  try {\n    const cachedData = await client.get(cacheKey);\n    if (cachedData) {\n      console.log('Cache Hit');\n      return JSON.parse(cachedData);\n    }\n\n    console.log('Cache Miss');\n    const dbData = await fetchFromDb(userId);\n    \n    // Store in Redis with 60s expiration\n    await client.set(cacheKey, JSON.stringify(dbData), { EX: 60 });\n    \n    return dbData;\n  } catch (err) {\n    console.error('Redis error', err);\n    return fetchFromDb(userId); // Fallback\n  }\n}"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a list of image URLs, fetches them asynchronously using `httpx`, and returns the HTTP status code for each URL.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\nclass UrlList(BaseModel):\n    urls: List[str]\n\nasync def fetch_status(client, url):\n    try:\n        resp = await client.get(url)\n        return {\"url\": url, \"status\": resp.status_code}\n    except Exception as e:\n        return {\"url\": url, \"status\": \"error\", \"detail\": str(e)}\n\n@app.post(\"/check-images\")\nasync def check_images(data: UrlList):\n    async with httpx.AsyncClient() as client:\n        tasks = [fetch_status(client, url) for url in data.urls]\n        results = await asyncio.gather(*tasks)\n    return results"}
{"instruction": "Write a PostgreSQL SQL script to create a schema for a Role-Based Access Control (RBAC) system. It should include `users`, `roles`, and a many-to-many junction table `user_roles`.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE roles (\n    id SERIAL PRIMARY KEY,\n    role_name VARCHAR(20) UNIQUE NOT NULL,\n    description TEXT\n);\n\nCREATE TABLE user_roles (\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    role_id INT REFERENCES roles(id) ON DELETE CASCADE,\n    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, role_id)\n);"}
{"instruction": "Create a Node.js Express middleware function that validates a JSON Web Token (JWT) from the 'Authorization' header (Bearer scheme).", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Using FastAPI and SQLAlchemy, define a database model for a 'Book' and a Pydantic model for input validation, then write a POST endpoint to create a new book.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass BookDB(Base):\n    __tablename__ = \"books\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    author = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Model\nclass BookCreate(BaseModel):\n    title: str\n    author: str\n\napp = FastAPI()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/books/\")\ndef create_book(book: BookCreate, db: Session = Depends(get_db)):\n    db_book = BookDB(title=book.title, author=book.author)\n    db.add(db_book)\n    db.commit()\n    db.refresh(db_book)\n    return db_book"}
{"instruction": "Write a Node.js function using `async/await` that takes an array of user IDs, fetches user details from a mock database function concurrently using `Promise.all`, and filters out any null results.", "output": "// Mock database function\nconst getUserById = async (id) => {\n  // Simulating async DB call\n  if (id % 2 === 0) return { id, name: `User ${id}` };\n  return null;\n};\n\nasync function fetchActiveUsers(userIds) {\n  try {\n    const userPromises = userIds.map(id => getUserById(id));\n    const results = await Promise.all(userPromises);\n    \n    // Filter out nulls (users not found)\n    const activeUsers = results.filter(user => user !== null);\n    return activeUsers;\n  } catch (error) {\n    console.error(\"Error fetching users\", error);\n    throw error;\n  }\n}"}
{"instruction": "Write a SQL query using Window Functions to rank employees by salary within their specific department. The output should show the employee name, department, salary, and their rank.", "output": "SELECT \n    employee_name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank\nFROM \n    employees;\n-- This will assign a rank of 1 to the highest paid employee in each department."}
{"instruction": "Implement a basic WebSocket endpoint in FastAPI that accepts a connection, receives text messages, and echoes them back with a prefix 'Echo: '.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Define a Mongoose (Node.js/MongoDB) schema for an 'Order' collection. It should have a customer name, a list of items (each with name and price), a total price, and an enum status (pending, shipped, delivered).", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst OrderSchema = new Schema({\n  customerName: {\n    type: String,\n    required: true,\n    trim: true\n  },\n  items: [{\n    name: String,\n    price: {\n      type: Number,\n      min: 0\n    }\n  }],\n  totalPrice: {\n    type: Number,\n    required: true\n  },\n  status: {\n    type: String,\n    enum: ['pending', 'shipped', 'delivered'],\n    default: 'pending'\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nmodule.exports = mongoose.model('Order', OrderSchema);"}
{"instruction": "Create a FastAPI endpoint that triggers a background task (simulating sending an email) so the API response is returned immediately to the client without waiting for the task to finish.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(5) \n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our service!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a SQL transaction block (PostgreSQL syntax) to safely transfer $100 from Account A (id=1) to Account B (id=2), ensuring atomic execution.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE id = 1;\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE id = 2;\n\n-- Commit the transaction if both succeed\nCOMMIT;\n\n-- Note: In a real app, you would check if Account A has sufficient funds before committing."}
{"instruction": "Create a FastAPI async endpoint that registers a new user using SQLAlchemy with an asynchronous session. The solution should include the Pydantic model, the SQLAlchemy model, and the route handler.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom sqlalchemy import Column, Integer, String, select\nfrom pydantic import BaseModel\n\n# Database Setup\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Pydantic Model\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check existing\n    result = await db.execute(select(User).where(User.email == user.email))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Create new user\n    new_user = User(email=user.email, hashed_password=user.password + \"not_secure\")\n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    return {\"id\": new_user.id, \"email\": new_user.email}"}
{"instruction": "Write a raw SQL schema for a normalized e-commerce database containing Users, Products, and Orders. Include a Many-to-Many relationship between Orders and Products via an OrderItems table.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,\n    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(50) DEFAULT 'pending'\n);\n\nCREATE TABLE order_items (\n    order_item_id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(product_id) ON DELETE SET NULL,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    unit_price DECIMAL(10, 2) NOT NULL -- Price at time of purchase\n);"}
{"instruction": "Implement a Node.js function using the `pg` library (node-postgres) to perform an atomic bank transfer between two accounts using SQL transactions (BEGIN, COMMIT, ROLLBACK).", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n\n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true, message: 'Transfer complete' };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    return { success: false, error: e.message };\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and triggers a simulated long-running background task (e.g., image processing) without blocking the response.", "output": "from fastapi import FastAPI, BackgroundTasks, UploadFile, File\nimport asyncio\n\napp = FastAPI()\n\nasync def process_image_task(filename: str):\n    # Simulate long blocking I/O operation\n    await asyncio.sleep(5)\n    print(f\"Finished processing image: {filename}\")\n    # Logic to update DB status to 'completed' would go here\n\n@app.post(\"/upload-image/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # In a real app, save file to disk/S3 first\n    filename = file.filename\n    \n    # Enqueue the task\n    background_tasks.add_task(process_image_task, filename)\n    \n    return {\"message\": \"Image received, processing in background\", \"filename\": filename}"}
{"instruction": "Write a SQL query using a Window Function to calculate the running total of revenue per day for a sales table.", "output": "SELECT \n    sale_date,\n    amount,\n    SUM(amount) OVER (ORDER BY sale_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as running_total\nFROM \n    sales\nORDER BY \n    sale_date;"}
{"instruction": "Create a Node.js (Express) middleware that asynchronously verifies a JWT token from the Authorization header and attaches the user data to the request object.", "output": "const jwt = require('jsonwebtoken');\nconst SECRET_KEY = process.env.JWT_SECRET;\n\nconst authMiddleware = async (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) {\n    return res.status(401).json({ message: 'No token provided' });\n  }\n\n  try {\n    // Verify asynchronously\n    const decoded = await new Promise((resolve, reject) => {\n      jwt.verify(token, SECRET_KEY, (err, user) => {\n        if (err) reject(err);\n        resolve(user);\n      });\n    });\n\n    req.user = decoded;\n    next();\n  } catch (err) {\n    return res.status(403).json({ message: 'Invalid or expired token' });\n  }\n};\n\nmodule.exports = authMiddleware;"}
{"instruction": "Write a Python function using SQLAlchemy Core (not ORM) to batch insert 1000 records into a database efficiently.", "output": "from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String\n\nengine = create_engine(\"postgresql://user:pass@localhost/db\")\nmetadata = MetaData()\nusers = Table('users', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('name', String),\n    Column('email', String)\n)\n\ndef batch_insert_users(user_list):\n    # user_list is a list of dicts: [{'name': 'A', 'email': 'a@a.com'}, ...]\n    with engine.connect() as conn:\n        # SQLAlchemy Core executes this as a single executemany operation\n        conn.execute(users.insert(), user_list)\n        conn.commit()"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to fetch a full category hierarchy (parent-child relationships) starting from a root category.", "output": "WITH RECURSIVE category_path (id, name, parent_id, path) AS (\n    -- Anchor member: select the root category (e.g., Electronics)\n    SELECT id, name, parent_id, name::TEXT\n    FROM categories\n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: join with the previous result\n    SELECT c.id, c.name, c.parent_id, cp.path || ' -> ' || c.name\n    FROM categories c\n    INNER JOIN category_path cp ON c.parent_id = cp.id\n)\nSELECT * FROM category_path;"}
{"instruction": "Implement a FastAPI dependency that implements rate limiting using a simple in-memory dictionary (Token Bucket algorithm concept).", "output": "from fastapi import FastAPI, Depends, HTTPException, Request\nimport time\n\n# In-memory store: {ip_address: [timestamp, timestamp]}\nrequest_history = {}\nLIMIT = 5  # requests\nWINDOW = 60 # seconds\n\ndef rate_limiter(request: Request):\n    client_ip = request.client.host\n    current_time = time.time()\n    \n    if client_ip not in request_history:\n        request_history[client_ip] = []\n    \n    # Filter out timestamps older than the window\n    request_history[client_ip] = [t for t in request_history[client_ip] if current_time - t < WINDOW]\n    \n    if len(request_history[client_ip]) >= LIMIT:\n        raise HTTPException(status_code=429, detail=\"Too Many Requests\")\n    \n    request_history[client_ip].append(current_time)\n    return True\n\napp = FastAPI()\n\n@app.get(\"/data\", dependencies=[Depends(rate_limiter)])\nasync def get_data():\n    return {\"data\": \"Secure Data\"}"}
{"instruction": "Create a Node.js script using `fs.createReadStream` and `csv-parser` to process a massive CSV file row-by-row and insert data into a SQL database without loading the whole file into memory.", "output": "const fs = require('fs');\nconst csv = require('csv-parser');\nconst { Pool } = require('pg');\nconst pool = new Pool({ connectionString: 'postgres://user:pass@localhost/db' });\n\nasync function processCsv() {\n  const client = await pool.connect();\n  \n  fs.createReadStream('large_data.csv')\n    .pipe(csv())\n    .on('data', async (row) => {\n      // Pause stream to handle async DB insertion\n      // Note: In production, use a writable stream or batching for better performance\n      try {\n        await client.query('INSERT INTO records (name, value) VALUES ($1, $2)', [row.name, row.value]);\n      } catch (err) {\n        console.error('Row error', err);\n      }\n    })\n    .on('end', () => {\n      console.log('CSV file successfully processed');\n      client.release();\n    });\n}\n\nprocessCsv();"}
{"instruction": "Create a FastAPI (Python) async endpoint to register a new user. The endpoint should accept a JSON body containing a username, email, and password. Use Pydantic for validation and simulate an asynchronous database call.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nimport asyncio\n\napp = FastAPI()\n\n# Pydantic Model\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n# Simulated Async DB\nfake_users_db = []\n\nasync def save_user_to_db(user_data: dict):\n    await asyncio.sleep(0.5)  # Simulate I/O delay\n    fake_users_db.append(user_data)\n    return {**user_data, \"id\": len(fake_users_db)}\n\n@app.post(\"/users/register\", status_code=201)\nasync def register_user(user: UserCreate):\n    # Check if user exists (omitted for brevity)\n    user_dict = user.dict()\n    # Hash password here in real scenario\n    saved_user = await save_user_to_db(user_dict)\n    return {\"message\": \"User created\", \"user_id\": saved_user[\"id\"]}"}
{"instruction": "Write a SQL schema for a simple library system. It should have tables for `authors` and `books`. Include a foreign key relationship where an author can have multiple books. Ensure proper data types and primary keys.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE,\n    author_id INT REFERENCES authors(author_id) ON DELETE SET NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Create a Node.js (Express) middleware function that logs the method, URL, and the time taken to process the request (latency) for every incoming API call.", "output": "const express = require('express');\nconst app = express();\n\n// Logger Middleware\nconst requestLogger = (req, res, next) => {\n    const start = Date.now();\n    const { method, url } = req;\n\n    // Hook into the response 'finish' event to calculate duration after logic runs\n    res.on('finish', () => {\n        const duration = Date.now() - start;\n        console.log(`${method} ${url} - ${res.statusCode} - ${duration}ms`);\n    });\n\n    next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n    // Simulate delay\n    setTimeout(() => res.send('Hello World'), 100);\n});"}
{"instruction": "Write a complex SQL query to find the top 3 customers who spent the most money in the last month. Assume tables: `customers` (id, name) and `orders` (id, customer_id, total_amount, order_date).", "output": "SELECT \n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.order_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')\n    AND o.order_date < DATE_TRUNC('month', CURRENT_DATE)\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 3;"}
{"instruction": "Using FastAPI, implement a dependency injection function to verify a dummy API key header. If the key is invalid, raise a 401 Unauthorized error. Apply this dependency to a protected route.", "output": "from fastapi import FastAPI, Header, HTTPException, Depends\n\napp = FastAPI()\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != \"secret-token-123\":\n        raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return x_api_key\n\n@app.get(\"/protected\")\nasync def protected_route(api_key: str = Depends(verify_api_key)):\n    return {\"message\": \"Access granted\", \"key_used\": api_key}"}
{"instruction": "Write a Node.js function using the `pg` (node-postgres) library to perform an atomic transaction. The function should transfer a specific amount from one account to another.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n    const client = await pool.connect();\n    try {\n        await client.query('BEGIN');\n        \n        // Deduct from sender\n        const deductRes = await client.query(\n            'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n            [amount, fromAccountId]\n        );\n        if (deductRes.rows[0].balance < 0) throw new Error('Insufficient funds');\n\n        // Add to receiver\n        await client.query(\n            'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n            [amount, toAccountId]\n        );\n\n        await client.query('COMMIT');\n        return { success: true };\n    } catch (e) {\n        await client.query('ROLLBACK');\n        throw e;\n    } finally {\n        client.release();\n    }\n}"}
{"instruction": "Using Python (FastAPI/SQLAlchemy), define a Many-to-Many relationship model for `Student` and `Course` using an association table.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_link = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_course_link, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_course_link, back_populates=\"courses\")"}
{"instruction": "Write a Node.js script that fetches data from two different external APIs concurrently using `Promise.all` and merges the results.", "output": "const axios = require('axios');\n\nasync function getUserData(userId) {\n    try {\n        const [profileReq, postsReq] = await Promise.all([\n            axios.get(`https://api.example.com/users/${userId}`),\n            axios.get(`https://api.example.com/users/${userId}/posts`)\n        ]);\n\n        const mergedData = {\n            user: profileReq.data,\n            recent_posts: postsReq.data.slice(0, 5) // Top 5 posts\n        };\n        \n        return mergedData;\n    } catch (error) {\n        console.error(\"Error fetching data\", error);\n        throw error;\n    }\n}"}
{"instruction": "Write a SQL statement to create a composite index on a `products` table to optimize queries filtering by `category` and sorting by `price`.", "output": "CREATE INDEX idx_products_category_price \nON products (category, price DESC);\n\n-- Explanation: This optimizes queries like:\n-- SELECT * FROM products WHERE category = 'Electronics' ORDER BY price DESC;"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload, validates that it is an image (JPEG/PNG), and returns the file size asynchronously.", "output": "from fastapi import FastAPI, File, UploadFile, HTTPException\n\napp = FastAPI()\n\n@app.post(\"/upload/image\")\nasync def upload_image(file: UploadFile = File(...)):\n    if file.content_type not in [\"image/jpeg\", \"image/png\"]:\n        raise HTTPException(status_code=400, detail=\"Invalid file type. Only JPEG or PNG allowed.\")\n    \n    # Move cursor to end to get size without reading into memory if possible, \n    # or read chunks. Here we read content for simplicity.\n    content = await file.read()\n    size = len(content)\n    \n    return {\n        \"filename\": file.filename,\n        \"content_type\": file.content_type,\n        \"size_bytes\": size\n    }"}
{"instruction": "Create a FastAPI (Python) async endpoint that accepts a list of URLs, fetches them concurrently using `httpx`, and returns the status code for each.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\nfrom typing import List, Dict\n\napp = FastAPI()\n\nasync def fetch_url(client: httpx.AsyncClient, url: str) -> Dict[str, int]:\n    try:\n        resp = await client.get(url)\n        return {url: resp.status_code}\n    except Exception:\n        return {url: 500}\n\n@app.post(\"/check-status\")\nasync def check_urls(urls: List[str]):\n    async with httpx.AsyncClient() as client:\n        tasks = [fetch_url(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    return results"}
{"instruction": "Write a Node.js (Express) route handler that registers a user. It must hash the password using `bcrypt` asynchronously and insert the user into a PostgreSQL database using the `pg` library.", "output": "const bcrypt = require('bcrypt');\nconst db = require('./db'); // assumed pg pool instance\n\nconst registerUser = async (req, res) => {\n  const { email, password } = req.body;\n\n  try {\n    // Check if user exists\n    const existing = await db.query('SELECT id FROM users WHERE email = $1', [email]);\n    if (existing.rows.length > 0) {\n      return res.status(409).json({ error: 'User already exists' });\n    }\n\n    // Hash password\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n\n    // Insert user\n    const result = await db.query(\n      'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email',\n      [email, hashedPassword]\n    );\n\n    res.status(201).json(result.rows[0]);\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Internal Server Error' });\n  }\n};"}
{"instruction": "Design a SQL schema (PostgreSQL flavor) for a simple blog system containing Users, Posts, and Comments. Include foreign keys and timestamps.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\n    body TEXT NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Create a Pydantic model in Python for a 'Product' with validation: price must be positive, and tags must be a list of unique strings.", "output": "from pydantic import BaseModel, Field, field_validator\nfrom typing import List, Set\n\nclass Product(BaseModel):\n    name: str\n    description: str | None = None\n    price: float = Field(..., gt=0, description=\"Price must be greater than zero\")\n    tags: List[str] = []\n\n    @field_validator('tags')\n    @classmethod\n    def unique_tags(cls, v: List[str]) -> List[str]:\n        if len(v) != len(set(v)):\n            raise ValueError('Tags must be unique')\n        return v"}
{"instruction": "Write a Node.js function using the `pg` library to perform a database transaction that transfers money from Account A to Account B. Rollback if any step fails.", "output": "const transferFunds = async (client, fromAccountId, toAccountId, amount) => {\n  try {\n    await client.query('BEGIN');\n\n    const res = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromAccountId]\n    );\n    \n    if (res.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  }\n};"}
{"instruction": "Implement a FastAPI WebSocket endpoint that echoes messages back to the client, but reverses the text string.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money in the last 30 days. Assume tables: `orders` (id, user_id, total_amount, created_at) and `users` (id, name).", "output": "SELECT u.id, u.name, SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Node.js Express middleware that asynchronously checks if a user's API key (in headers) is valid by querying a database, attaching the user to the request object if valid.", "output": "const db = require('./db');\n\nconst apiKeyAuth = async (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n\n  if (!apiKey) {\n    return res.status(401).json({ error: 'Missing API Key' });\n  }\n\n  try {\n    const result = await db.query('SELECT * FROM users WHERE api_key = $1', [apiKey]);\n    \n    if (result.rows.length === 0) {\n      return res.status(403).json({ error: 'Invalid API Key' });\n    }\n\n    req.user = result.rows[0];\n    next();\n  } catch (err) {\n    next(err);\n  }\n};\n\nmodule.exports = apiKeyAuth;"}
{"instruction": "Implement a FastAPI dependency that yields a database session and closes it after the request is finished (Context Manager pattern).", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal, engine, Base\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    # db is available here and auto-closes after return\n    return db.query(models.User).offset(skip).limit(limit).all()"}
{"instruction": "Write a Node.js script using Streams to read a massive CSV file (`data.csv`) and log the number of rows processed, without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine() {\n  const fileStream = fs.createReadStream('data.csv');\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let count = 0;\n  for await (const line of rl) {\n    // Process line here (e.g., parse CSV logic)\n    count++;\n  }\n\n  console.log(`Total rows processed: ${count}`);\n}\n\nprocessLineByLine();"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new user (username, email, password), validates it using Pydantic, and returns the user data without the password. Include email format validation.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n\n@app.post(\"/users/\", response_model=UserResponse)\nasync def create_user(user: UserCreate):\n    # Simulate database logic here\n    if user.username == \"admin\":\n        raise HTTPException(status_code=400, detail=\"Username taken\")\n    \n    # Return data matching UserResponse (password is excluded automatically)\n    return user"}
{"instruction": "Write a Node.js (Express) middleware function to verify a JWT (JSON Web Token) from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Write a SQL schema creation script (PostgreSQL) for a 'Products' table and a 'Categories' table with a many-to-many relationship managed by a junction table 'ProductCategories'. Include foreign key constraints.", "output": "CREATE TABLE Categories (\n    category_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL UNIQUE\n);\n\nCREATE TABLE Products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE ProductCategories (\n    product_id INT,\n    category_id INT,\n    PRIMARY KEY (product_id, category_id),\n    CONSTRAINT fk_product\n      FOREIGN KEY(product_id) \n      REFERENCES Products(product_id)\n      ON DELETE CASCADE,\n    CONSTRAINT fk_category\n      FOREIGN KEY(category_id) \n      REFERENCES Categories(category_id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Implement a FastAPI background task. Create an endpoint that accepts a generic message, returns a confirmation immediately, and processes the message (e.g., simulates writing to a log) in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef write_log(message: str):\n    time.sleep(2) # Simulate blocking I/O\n    with open(\"log.txt\", \"a\") as log:\n        log.write(f\"Processed: {message}\\n\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(message: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_log, message)\n    return {\"status\": \"Message accepted for processing\"}"}
{"instruction": "Using Node.js and the 'pg' library, write an asynchronous function to execute a database transaction that transfers money between two accounts. Rollback if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferMoney(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING *',\n      [amount, fromAccountId]\n    );\n    \n    if (deductRes.rowCount === 0) throw new Error('Sender not found');\n\n    const addRes = await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2 RETURNING *',\n      [amount, toAccountId]\n    );\n    \n    if (addRes.rowCount === 0) throw new Error('Receiver not found');\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query to fetch the top 3 users who have spent the most money, based on an 'Orders' table (user_id, total_amount).", "output": "SELECT user_id, SUM(total_amount) as total_spent\nFROM Orders\nGROUP BY user_id\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Create a FastAPI WebSocket endpoint that echoes received messages back to the client, but prepends 'Server received: ' to the text.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Server received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js script using the 'fs/promises' module to read a JSON file asynchronously, parse it, update a specific field, and write it back to disk.", "output": "const fs = require('fs/promises');\n\nasync function updateConfig(filePath, key, value) {\n  try {\n    const data = await fs.readFile(filePath, 'utf8');\n    const json = JSON.parse(data);\n    \n    json[key] = value;\n    \n    await fs.writeFile(filePath, JSON.stringify(json, null, 2));\n    console.log('Config updated');\n  } catch (error) {\n    console.error('Error updating config:', error);\n  }\n}"}
{"instruction": "Design a SQL table for storing 'Events' with a requirement that the 'end_time' must always be greater than the 'start_time'. Use a CHECK constraint.", "output": "CREATE TABLE Events (\n    event_id INT PRIMARY KEY,\n    event_name VARCHAR(255) NOT NULL,\n    start_time TIMESTAMP NOT NULL,\n    end_time TIMESTAMP NOT NULL,\n    CONSTRAINT check_dates CHECK (end_time > start_time)\n);"}
{"instruction": "Implement a FastAPI dependency that connects to a database, yields the session to the path operation, and ensures the session is closed after the request is finished.", "output": "from fastapi import Depends, FastAPI\n# Assuming SQLAlchemy usage\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Database session active\"}"}
{"instruction": "Create a FastAPI endpoint that asynchronously fetches data from two external APIs (Service A and Service B) concurrently and returns a combined result. Use 'aiohttp' for the requests.", "output": "import asyncio\nimport aiohttp\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        if response.status != 200:\n            raise HTTPException(status_code=502, detail=f\"Error fetching {url}\")\n        return await response.json()\n\n@app.get(\"/combined-data\")\nasync def get_combined_data():\n    url_a = \"https://api.service-a.com/data\"\n    url_b = \"https://api.service-b.com/info\"\n\n    async with aiohttp.ClientSession() as session:\n        # Run requests concurrently\n        task_a = fetch_url(session, url_a)\n        task_b = fetch_url(session, url_b)\n        \n        data_a, data_b = await asyncio.gather(task_a, task_b)\n\n    return {\n        \"service_a\": data_a,\n        \"service_b\": data_b,\n        \"status\": \"success\"\n    }"}
{"instruction": "Design a PostgreSQL schema for a simple E-commerce system with 'users', 'orders', and 'order_items'. Ensure referential integrity and include a timestamp for when records are created.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INTEGER NOT NULL,\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\n    price_at_purchase DECIMAL(10, 2) NOT NULL\n);\n\nCREATE INDEX idx_orders_user_id ON orders(user_id);"}
{"instruction": "Write a Node.js Express middleware function that verifies a JWT (JSON Web Token) from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid or expired token' });\n    }\n    // Attach user payload to request\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Using SQLAlchemy (Async), define a Many-to-Many relationship between 'Students' and 'Courses' using an association table.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\n\nclass Base(AsyncAttrs, DeclarativeBase):\n    pass\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', ForeignKey('students.id'), primary_key=True),\n    Column('course_id', ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    # Relationship\n    courses: Mapped[list['Course']] = relationship(\n        secondary=student_course_association, \n        back_populates='students'\n    )\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str] = mapped_column(String(100))\n    # Relationship\n    students: Mapped[list['Student']] = relationship(\n        secondary=student_course_association, \n        back_populates='courses'\n    )"}
{"instruction": "Write a SQL query using a recursive CTE (Common Table Expression) to retrieve a full category hierarchy (parent-child) starting from a specific root category ID.", "output": "WITH RECURSIVE CategoryTree AS (\n    -- Anchor member: select the root category\n    SELECT \n        id, \n        name, \n        parent_id, \n        1 AS level\n    FROM categories\n    WHERE id = 1  -- Assuming root ID is 1\n\n    UNION ALL\n\n    -- Recursive member: join the CTE with the table\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        ct.level + 1\n    FROM categories c\n    INNER JOIN CategoryTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CategoryTree ORDER BY level, id;"}
{"instruction": "Create a Node.js script using Streams to read a massive CSV file ('input.csv'), convert a 'name' column to uppercase, and write the result to 'output.csv' to ensure low memory usage.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst readStream = fs.createReadStream('input.csv', { encoding: 'utf8' });\nconst writeStream = fs.createWriteStream('output.csv');\n\nconst uppercaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // Convert chunk to string, process lines (simplified logic)\n    // In production, use a CSV parser library for robust handling\n    const data = chunk.toString();\n    const transformed = data.toUpperCase(); \n    this.push(transformed);\n    callback();\n  }\n});\n\nreadStream\n  .pipe(uppercaseTransform)\n  .pipe(writeStream)\n  .on('finish', () => console.log('Processing complete.'))\n  .on('error', (err) => console.error('Error:', err));"}
{"instruction": "Using Pydantic v2, define a model for a 'UserRegistration' that validates the password contains at least 8 characters and includes a number.", "output": "from pydantic import BaseModel, Field, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3)\n    email: str\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Write a MongoDB aggregation pipeline using Mongoose (Node.js) to calculate the total sales revenue per product category for orders completed in 2023.", "output": "const getRevenueByCategory = async () => {\n  return await Order.aggregate([\n    { \n      $match: { \n        status: 'completed',\n        createdAt: { \n          $gte: new Date('2023-01-01'), \n          $lt: new Date('2024-01-01') \n        }\n      } \n    },\n    { $unwind: '$items' },\n    {\n      $group: {\n        _id: '$items.category',\n        totalRevenue: { $sum: { $multiply: ['$items.price', '$items.quantity'] } }\n      }\n    },\n    { $sort: { totalRevenue: -1 } }\n  ]);\n};"}
{"instruction": "Create a FastAPI dependency that yields an asynchronous database session using SQLAlchemy, ensuring the session is closed after the request is finished.", "output": "from fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine\n\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = async_sessionmaker(engine, expire_on_commit=False)\n\nasync def get_db() -> AsyncSession:\n    async with async_session() as session:\n        try:\n            yield session\n            # Commit happens here if logic requires, or manually in endpoints\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query using Window Functions to rank employees by salary within their respective departments. The highest salary should be rank 1.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM employees;"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new user (username, email, password), validates it using Pydantic, and returns a sanitized response omitting the password. Include async definition.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n    id: int\n\n# Mock database\nfake_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate):\n    # Simulate async DB operation\n    for existing_user in fake_db:\n        if existing_user[\"email\"] == user.email:\n            raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    new_user_id = len(fake_db) + 1\n    user_record = user.dict()\n    user_record[\"id\"] = new_user_id\n    fake_db.append(user_record)\n    \n    return user_record"}
{"instruction": "Write a Node.js (Express) middleware function that verifies a JWT token from the 'Authorization' header. If valid, attach the decoded user to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.sendStatus(401); // Unauthorized\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.sendStatus(403); // Forbidden\n    }\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Design a SQL schema (PostgreSQL syntax) for a simple Blog application. Create tables for 'users' and 'posts' with a one-to-many relationship, including timestamps and foreign keys.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(200) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);"}
{"instruction": "Implement a FastAPI dependency that manages a SQLAlchemy database session. It should yield the session to the path operation and ensure the session is closed after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to perform an atomic transaction. The function should transfer funds between two accounts. Use async/await.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query(\n      'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',\n      [fromAccountId]\n    );\n    \n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, fromAccountId]\n    );\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a SQL query to find the top 5 users who have spent the most money in the last 30 days. Assume tables 'users' (id, name) and 'orders' (user_id, total_amount, created_at).", "output": "SELECT \n    u.id,\n    u.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    users u\nJOIN \n    orders o ON u.id = o.user_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    u.id, u.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Python FastAPI endpoint that utilizes 'BackgroundTasks' to simulate sending a welcome email after returning a successful 202 response to the client immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef write_notification(email: str, message=\"\"):\n    # Simulate a long blocking operation (e.g., sending email)\n    time.sleep(2)\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)\n\n@app.post(\"/send-notification/{email}\", status_code=202)\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, email, message=\"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a Node.js script using native 'fs' and 'readline' modules to process a large CSV file line-by-line asynchronously without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line here\n    const columns = line.split(',');\n    console.log(`Processing ID: ${columns[0]}`);\n    // Simulate async work per line\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n}\n\nprocessLineByLine('large-data.csv');"}
{"instruction": "Construct a SQL query using a Common Table Expression (CTE) to find all direct and indirect subordinates of a specific manager in an 'employees' table (id, name, manager_id).", "output": "WITH RECURSIVE subordinates AS (\n    -- Base case: direct reports\n    SELECT \n        id, \n        name, \n        manager_id, \n        1 as level\n    FROM \n        employees\n    WHERE \n        manager_id = 5 -- Assuming Manager ID is 5\n\n    UNION ALL\n\n    -- Recursive step: reports of reports\n    SELECT \n        e.id, \n        e.name, \n        e.manager_id, \n        s.level + 1\n    FROM \n        employees e\n    INNER JOIN \n        subordinates s ON e.manager_id = s.id\n)\nSELECT * FROM subordinates;"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a connection, listens for text messages, and echoes the message back with a timestamp.", "output": "from fastapi import FastAPI, WebSocket\nfrom datetime import datetime\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            timestamp = datetime.now().isoformat()\n            response = f\"[{timestamp}] You wrote: {data}\"\n            await websocket.send_text(response)\n    except Exception as e:\n        print(f\"Connection closed: {e}\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy and Pydantic to register a new user. The implementation must hash the password before saving and handle potential unique constraint violations for the email address.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Schema\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Utils\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.post(\"/users/\")\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    existing_user = db.query(User).filter(User.email == user.email).first()\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_pw = pwd_context.hash(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_pw)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return {\"id\": db_user.id, \"email\": db_user.email}"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to perform an atomic bank transfer between two accounts using a database transaction.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const res = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, fromAccountId]\n    );\n\n    if (res.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender account');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true, message: 'Transfer complete' };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to retrieve a full comment hierarchy (id, content, parent_id) for a specific blog post, starting from top-level comments.", "output": "WITH RECURSIVE CommentTree AS (\n    -- Anchor member: Select top-level comments (those with no parent)\n    SELECT \n        id, \n        content, \n        parent_id, \n        0 AS level\n    FROM comments\n    WHERE post_id = 123 AND parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: Join the CTE with the table to find children\n    SELECT \n        c.id, \n        c.content, \n        c.parent_id, \n        ct.level + 1\n    FROM comments c\n    INNER JOIN CommentTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CommentTree;"}
{"instruction": "Implement an asynchronous FastAPI endpoint that fetches data from three different external APIs concurrently using `asyncio.gather` to reduce latency.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_url(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-stats\")\nasync def get_dashboard_stats():\n    urls = [\n        \"https://api.service.com/users/stats\",\n        \"https://api.service.com/sales/today\",\n        \"https://api.service.com/system/health\"\n    ]\n    \n    async with httpx.AsyncClient() as client:\n        # Launch requests concurrently\n        results = await asyncio.gather(\n            *[fetch_url(client, url) for url in urls],\n            return_exceptions=True\n        )\n    \n    return {\n        \"user_stats\": results[0],\n        \"sales_stats\": results[1],\n        \"system_health\": results[2]\n    }"}
{"instruction": "Create an Express.js middleware function that validates a JWT (JSON Web Token) from the Authorization header. If valid, attach the user payload to the request object; otherwise, return a 401 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token missing' });\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid token' });\n    }\n    // Attach decoded user payload to request\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Design a PostgreSQL schema for an 'Orders' table. It must include a UUID primary key, a foreign key to a Users table, an ENUM for order status, and a JSONB column to store arbitrary product attributes (color, size, etc.).", "output": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TYPE order_status AS ENUM ('pending', 'processing', 'shipped', 'delivered', 'cancelled');\n\nCREATE TABLE orders (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status order_status DEFAULT 'pending',\n    product_metadata JSONB NOT NULL DEFAULT '{}',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_orders_metadata ON orders USING gin (product_metadata);"}
{"instruction": "Implement a FastAPI WebSocket endpoint that accepts a connection, listens for messages, and broadcasts the received message to all currently connected clients (simple chat room logic).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"User says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(\"A user left the chat\")"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within each department. The output should include employee name, department, salary, and their rank.", "output": "SELECT \n    employee_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM employees\nORDER BY department_id, salary_rank;"}
{"instruction": "Create a Node.js script using the 'fs' and 'readline' modules to process a massive CSV file line-by-line efficiently (streaming) without loading the entire file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Skip header or empty lines if necessary\n    if (!line) continue;\n    \n    // Process logic here (e.g., parse CSV line)\n    const columns = line.split(',');\n    console.log(`Processing row: ${columns[0]}`);\n  }\n}\n\nprocessLineByLine('large_dataset.csv').catch(console.error);"}
{"instruction": "Implement a FastAPI dependency that connects to Redis to check if a specific rate-limit key exists. If the limit is exceeded, raise a 429 HTTPException.", "output": "from fastapi import FastAPI, Depends, HTTPException, Request\nimport redis\n\napp = FastAPI()\nr = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)\n\ndef rate_limiter(request: Request):\n    client_ip = request.client.host\n    key = f\"rate_limit:{client_ip}\"\n    \n    # Check current count\n    current_count = r.get(key)\n    \n    if current_count and int(current_count) >= 100:\n        raise HTTPException(status_code=429, detail=\"Too Many Requests\")\n    \n    # Increment or create key with 60 second expiry\n    pipe = r.pipeline()\n    pipe.incr(key)\n    if not current_count:\n        pipe.expire(key, 60)\n    pipe.execute()\n\n@app.get(\"/\", dependencies=[Depends(rate_limiter)])\nasync def root():\n    return {\"message\": \"Hello World\"}"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a user. The password must be hashed using a library like passlib before being returned or stored.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    username: str\n    email: str\n\n@app.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    # Simulate checking if user exists\n    if user.username == \"admin\":\n        raise HTTPException(status_code=400, detail=\"Username already taken\")\n    \n    hashed_password = pwd_context.hash(user.password)\n    \n    # In a real app, save 'hashed_password' to DB here\n    return {\"username\": user.username, \"email\": user.email}"}
{"instruction": "Write a SQL schema for a simple E-commerce system containing Users, Products, and an Orders table that links them via a many-to-many relationship (using an OrderItems join table).", "output": "CREATE TABLE Users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock INT DEFAULT 0\n);\n\nCREATE TABLE Orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES Users(id),\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE OrderItems (\n    order_id INT REFERENCES Orders(id) ON DELETE CASCADE,\n    product_id INT REFERENCES Products(id),\n    quantity INT NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);"}
{"instruction": "Create a Node.js (Express) middleware function that asynchronously verifies a JWT token from the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = async (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  try {\n    const user = await new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n        if (err) reject(err);\n        resolve(user);\n      });\n    });\n    req.user = user;\n    next();\n  } catch (err) {\n    return res.sendStatus(403);\n  }\n};"}
{"instruction": "Configure an asynchronous SQLAlchemy engine and session dependency for use in a FastAPI application.", "output": "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\n# Database URL must start with postgresql+asyncpg://\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\n\nAsyncSessionLocal = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\n# Dependency for FastAPI routes\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 users who spent the most money in the last 30 days.", "output": "WITH UserSpending AS (\n    SELECT \n        u.id AS user_id,\n        u.username,\n        SUM(p.price * oi.quantity) AS total_spent\n    FROM Users u\n    JOIN Orders o ON u.id = o.user_id\n    JOIN OrderItems oi ON o.id = oi.order_id\n    JOIN Products p ON oi.product_id = p.id\n    WHERE o.created_at >= NOW() - INTERVAL '30 days'\n    GROUP BY u.id, u.username\n)\nSELECT user_id, username, total_spent\nFROM UserSpending\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Implement a FastAPI endpoint that accepts a request and triggers a background task (e.g., sending an email) without blocking the response.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Create a Node.js function that streams a file from the local file system to a remote server (simulated) to avoid high memory usage.", "output": "const fs = require('fs');\nconst { pipeline } = require('stream');\nconst { promisify } = require('util');\nconst fetch = require('node-fetch'); // Assuming node-fetch v2 or similar\n\nconst streamPipeline = promisify(pipeline);\n\nasync function uploadFileStream(filePath, uploadUrl) {\n  const readStream = fs.createReadStream(filePath);\n\n  try {\n    const response = await fetch(uploadUrl, {\n      method: 'POST',\n      body: readStream,\n      headers: {\n        'Content-Type': 'application/octet-stream'\n      }\n    });\n    \n    if (!response.ok) throw new Error(`Upload failed: ${response.statusText}`);\n    return await response.json();\n  } catch (error) {\n    console.error('Streaming upload error:', error);\n    throw error;\n  }\n}"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that manages active connections and broadcasts received messages to all connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Write a raw SQL transaction to safely add a non-nullable column 'status' to a 'tasks' table that already has data, setting a default value for existing rows.", "output": "BEGIN;\n\n-- 1. Add the column as nullable first\nALTER TABLE tasks ADD COLUMN status VARCHAR(20);\n\n-- 2. Populate existing rows with a default value\nUPDATE tasks SET status = 'draft' WHERE status IS NULL;\n\n-- 3. Alter the column to enforce NOT NULL constraint\nALTER TABLE tasks ALTER COLUMN status SET NOT NULL;\n\n-- 4. Optionally set a default for future inserts\nALTER TABLE tasks ALTER COLUMN status SET DEFAULT 'draft';\n\nCOMMIT;"}
{"instruction": "Implement a simple sliding window rate limiter in a Node.js API using Redis to limit users to 10 requests per minute.", "output": "const Redis = require('ioredis');\nconst redis = new Redis();\n\nasync function rateLimiter(userId) {\n  const windowSizeInSeconds = 60;\n  const maxRequests = 10;\n  const currentTimestamp = Date.now();\n  const windowStart = currentTimestamp - (windowSizeInSeconds * 1000);\n  const key = `rate_limit:${userId}`;\n\n  try {\n    const requests = await redis.multi()\n      .zremrangebyscore(key, 0, windowStart) // Remove old requests\n      .zadd(key, currentTimestamp, currentTimestamp) // Add current request\n      .zcard(key) // Count total requests in window\n      .expire(key, windowSizeInSeconds) // Set expiry to clean up unused keys\n      .exec();\n\n    const requestCount = requests[2][1];\n\n    if (requestCount > maxRequests) {\n      return { allowed: false, count: requestCount };\n    }\n    return { allowed: true, count: requestCount };\n  } catch (err) {\n    console.error(\"Redis error\", err);\n    // Fail open or closed depending on requirements\n    return { allowed: true };\n  }\n}"}
{"instruction": "Create a FastAPI Pydantic model and an async POST endpoint to register a new user. The endpoint should validate that the email is valid and the password is at least 8 characters long. Return the user info without the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(min_length=8)\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n\n@app.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    # Simulate database check\n    if user.email == \"exists@example.com\":\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Simulate async DB insertion\n    # await db.execute(...)\n    \n    return user"}
{"instruction": "Write a raw SQL query to create a 'Library' schema. It should have an 'authors' table and a 'books' table. The 'books' table must have a foreign key referencing 'authors' and a constraint ensuring the ISBN is unique.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) NOT NULL UNIQUE,\n    author_id INTEGER REFERENCES authors(id) ON DELETE CASCADE,\n    published_date DATE\n);"}
{"instruction": "Create a Node.js Express middleware function that verifies a JWT token from the 'Authorization' header. If the token is missing or invalid, return a 401 or 403 status. If valid, attach the decoded user to the request object.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Using Python and SQLAlchemy (async), define a function that performs a database transaction. It should deduct credit from one user and add it to another. If any part fails, the transaction must roll back.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import update\nfrom models import User\n\nasync def transfer_credits(session: AsyncSession, sender_id: int, receiver_id: int, amount: float):\n    async with session.begin():\n        # Deduct from sender\n        await session.execute(\n            update(User).where(User.id == sender_id).values(credits=User.credits - amount)\n        )\n        # Add to receiver\n        await session.execute(\n            update(User).where(User.id == receiver_id).values(credits=User.credits + amount)\n        )\n    # session.begin() context manager automatically commits on exit or rolls back on exception"}
{"instruction": "Write a Node.js script using the 'pg' library to execute two asynchronous queries in parallel using Promise.all: one to fetch a user profile by ID, and another to fetch their last 5 orders.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function getUserDashboard(userId) {\n  try {\n    const userQuery = 'SELECT * FROM users WHERE id = $1';\n    const ordersQuery = 'SELECT * FROM orders WHERE user_id = $1 ORDER BY date DESC LIMIT 5';\n\n    const [userResult, ordersResult] = await Promise.all([\n      pool.query(userQuery, [userId]),\n      pool.query(ordersQuery, [userId])\n    ]);\n\n    return {\n      profile: userResult.rows[0],\n      recentOrders: ordersResult.rows\n    };\n  } catch (err) {\n    console.error('Database error', err);\n    throw err;\n  }\n}"}
{"instruction": "Create a FastAPI dependency function that validates a custom API Key header ('X-API-Key'). If the key is invalid, raise a 403 Forbidden exception. Apply it to a route.", "output": "from fastapi import FastAPI, Header, HTTPException, Depends\n\napp = FastAPI()\nAPI_KEY_CREDENTIAL = \"secret-123\"\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_KEY_CREDENTIAL:\n        raise HTTPException(status_code=403, detail=\"Could not validate credentials\")\n    return x_api_key\n\n@app.get(\"/secure-data\")\nasync def get_secure_data(api_key: str = Depends(verify_api_key)):\n    return {\"msg\": \"Secure data access granted\"}"}
{"instruction": "Write a SQL query using a Window Function to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT * \nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Implement a Python FastAPI WebSocket endpoint that echoes received messages back to the client, but reverses the text string.", "output": "from fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        reversed_text = data[::-1]\n        await websocket.send_text(f\"Reversed: {reversed_text}\")"}
{"instruction": "In Node.js, create a function that reads a large CSV file using streams and pipes it through a transform stream that converts the data to JSON strings before writing to an output file.", "output": "const fs = require('fs');\nconst { Transform, pipeline } = require('stream');\n\nconst csvToJson = new Transform({\n  readableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    // Assuming chunk is a line or buffer\n    const line = chunk.toString().trim();\n    const [id, name, value] = line.split(',');\n    const json = JSON.stringify({ id, name, value }) + '\\n';\n    this.push(json);\n    callback();\n  }\n});\n\nconst source = fs.createReadStream('input.csv');\nconst dest = fs.createWriteStream('output.jsonl');\n\npipeline(source, csvToJson, dest, (err) => {\n  if (err) console.error('Pipeline failed.', err);\n  else console.log('Pipeline succeeded.');\n});"}
{"instruction": "Write a SQL command to add a composite index on the 'orders' table for columns 'customer_id' and 'order_date' to optimize queries filtering by customer and sorting by date.", "output": "CREATE INDEX idx_orders_customer_date \nON orders (customer_id, order_date DESC);"}
{"instruction": "Create a FastAPI endpoint that registers a new user. It should validate the input using Pydantic, hash the password using 'passlib' (bcrypt), and save the user to a database using a SQLAlchemy session.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom passlib.context import CryptContext\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\n# Schemas\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    email: str\n    class Config:\n        orm_mode = True\n\n# Utils\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=UserResponse)\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.email == user.email).first()\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = pwd_context.hash(user.password)\n    new_user = User(email=user.email, hashed_password=hashed_password)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return new_user"}
{"instruction": "Write a Node.js Express route handler that asynchronously retrieves a user profile by ID from a PostgreSQL database using the 'pg' library. Handle the case where the user is not found.", "output": "const express = require('express');\nconst { Pool } = require('pg');\nconst router = express.Router();\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nrouter.get('/users/:id', async (req, res) => {\n  const { id } = req.params;\n  \n  try {\n    const query = 'SELECT id, username, email, created_at FROM users WHERE id = $1';\n    const { rows } = await pool.query(query, [id]);\n\n    if (rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json(rows[0]);\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Internal Server Error' });\n  }\n});\n\nmodule.exports = router;"}
{"instruction": "Design a SQL schema for a blog application. Create tables for 'authors' and 'posts'. Posts should have a foreign key to authors, and 'posts' should include a 'status' enum (draft, published).", "output": "CREATE TYPE post_status AS ENUM ('draft', 'published', 'archived');\n\nCREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    author_id INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    status post_status DEFAULT 'draft',\n    published_at TIMESTAMP,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_author\n        FOREIGN KEY(author_id) \n        REFERENCES authors(id)\n        ON DELETE CASCADE\n);\n\nCREATE INDEX idx_posts_author ON posts(author_id);\nCREATE INDEX idx_posts_status ON posts(status);"}
{"instruction": "Implement a FastAPI endpoint using 'BackgroundTasks' to simulate sending a welcome email after a user signs up. The API should return immediately while the task runs in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_task(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(5)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_task, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Using Node.js and Mongoose, write an aggregation pipeline that groups sales by product category and calculates the total revenue for each category, sorting by highest revenue first.", "output": "const mongoose = require('mongoose');\nconst Sale = require('./models/Sale'); // Assuming schema exists\n\nasync function getRevenueByCategory() {\n  try {\n    const report = await Sale.aggregate([\n      {\n        $group: {\n          _id: \"$category\",\n          totalRevenue: { $sum: \"$amount\" },\n          count: { $sum: 1 }\n        }\n      },\n      {\n        $sort: { totalRevenue: -1 }\n      }\n    ]);\n    return report;\n  } catch (err) {\n    console.error(\"Aggregation error:\", err);\n    throw err;\n  }\n}"}
{"instruction": "Create a Python function using SQLAlchemy to perform a 'bulk insert' of 1000 records efficiently to avoid the N+1 insert problem.", "output": "from sqlalchemy.orm import Session\nfrom models import Item  # Assuming Item model exists\n\ndef bulk_create_items(db: Session, item_data_list: list[dict]):\n    # item_data_list is a list of dictionaries, e.g., [{'name': 'A', 'price': 10}, ...]\n    \n    # Use bulk_insert_mappings for high performance raw INSERTs\n    # Or db.add_all([Item(**data) for data in item_data_list]) for ORM overhead\n    \n    # Best performance for pure inserts:\n    db.bulk_insert_mappings(Item, item_data_list)\n    db.commit()"}
{"instruction": "Write a Node.js middleware for Express that implements a simple in-memory rate limiter. It should allow max 10 requests per IP per minute.", "output": "const rateLimit = {};\n\nconst simpleRateLimiter = (req, res, next) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const windowMs = 60 * 1000; // 1 minute\n  const maxRequests = 10;\n\n  if (!rateLimit[ip]) {\n    rateLimit[ip] = [];\n  }\n\n  // Filter out timestamps older than the window\n  rateLimit[ip] = rateLimit[ip].filter(timestamp => now - timestamp < windowMs);\n\n  if (rateLimit[ip].length >= maxRequests) {\n    return res.status(429).json({ error: 'Too many requests, please try again later.' });\n  }\n\n  rateLimit[ip].push(now);\n  next();\n};\n\nmodule.exports = simpleRateLimiter;"}
{"instruction": "Write a SQL query using a Window Function to find the top 3 highest paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    department_id,\n    name,\n    salary,\n    rank\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that manages multiple connections and broadcasts a received message to all connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a Node.js script using Streams to read a massive log file line-by-line and count the occurrences of the word 'ERROR' without loading the entire file into RAM.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function countErrors(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let errorCount = 0;\n\n  for await (const line of rl) {\n    if (line.includes('ERROR')) {\n      errorCount++;\n    }\n  }\n\n  console.log(`Total Errors found: ${errorCount}`);\n}\n\n// Usage: countErrors('./server.log');"}
{"instruction": "Create a FastAPI async endpoint using SQLAlchemy to register a new user. Include Pydantic models for validation and assume a utility function `get_password_hash` exists. Return the created user without the password.", "output": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom pydantic import BaseModel, EmailStr\nfrom db import get_db, User  # User is a SQLAlchemy Model\nfrom auth_utils import get_password_hash\n\nrouter = APIRouter()\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n    username: str\n\nclass UserResponse(BaseModel):\n    id: int\n    email: EmailStr\n    username: str\n\n    class Config:\n        orm_mode = True\n\n@router.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check existing user\n    result = await db.execute(select(User).where(User.email == user.email))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n\n    # Create new user\n    hashed_password = get_password_hash(user.password)\n    new_user = User(email=user.email, username=user.username, hashed_password=hashed_password)\n    \n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    \n    return new_user"}
{"instruction": "Write a Node.js function using the `pg` (node-postgres) library to perform an atomic fund transfer between two accounts using SQL transactions.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Check balance\n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromAccountId]);\n    if (res.rows.length === 0) throw new Error('Sender account not found');\n    \n    const currentBalance = res.rows[0].balance;\n    if (currentBalance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    // Deduct from sender\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromAccountId]);\n\n    // Add to receiver\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toAccountId]);\n\n    await client.query('COMMIT');\n    return { success: true, message: 'Transfer complete' };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query (PostgreSQL syntax) to find the top 3 selling products in each category based on total revenue. Use Window Functions.", "output": "WITH ProductSales AS (\n    SELECT \n        p.category_id,\n        p.product_name,\n        SUM(oi.quantity * oi.unit_price) as total_revenue\n    FROM products p\n    JOIN order_items oi ON p.id = oi.product_id\n    GROUP BY p.category_id, p.product_name\n),\nRankedSales AS (\n    SELECT\n        category_id,\n        product_name,\n        total_revenue,\n        RANK() OVER (PARTITION BY category_id ORDER BY total_revenue DESC) as rank\n    FROM ProductSales\n)\nSELECT \n    category_id,\n    product_name,\n    total_revenue\nFROM RankedSales\nWHERE rank <= 3\nORDER BY category_id, rank;"}
{"instruction": "Implement a simple WebSocket chat manager in Python/FastAPI that handles connecting, disconnecting, and broadcasting messages to all active connections.", "output": "from fastapi import WebSocket\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            try:\n                await connection.send_text(message)\n            except Exception:\n                # Handle broken pipes/closed connections gracefully if needed\n                pass\n\nmanager = ConnectionManager()\n\n# Usage in route:\n# @app.websocket(\"/ws\")\n# async def websocket_endpoint(websocket: WebSocket):\n#     await manager.connect(websocket)\n#     try:\n#         while True:\n#             data = await websocket.receive_text()\n#             await manager.broadcast(f\"Message: {data}\")\n#     except WebSocketDisconnect:\n#         manager.disconnect(websocket)"}
{"instruction": "Design a SQL schema for a Library system. Create tables for `Authors`, `Books`, and a many-to-many relationship table `Book_Authors`. Include foreign keys and indexes.", "output": "CREATE TABLE Authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Books (\n    book_id SERIAL PRIMARY KEY,\n    isbn VARCHAR(13) UNIQUE NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Book_Authors (\n    book_id INT NOT NULL,\n    author_id INT NOT NULL,\n    PRIMARY KEY (book_id, author_id),\n    CONSTRAINT fk_book FOREIGN KEY (book_id) REFERENCES Books(book_id) ON DELETE CASCADE,\n    CONSTRAINT fk_author FOREIGN KEY (author_id) REFERENCES Authors(author_id) ON DELETE CASCADE\n);\n\n-- Indexes for performance on joins\nCREATE INDEX idx_book_authors_book ON Book_Authors(book_id);\nCREATE INDEX idx_book_authors_author ON Book_Authors(author_id);"}
{"instruction": "Create a Node.js middleware function using Redis to implement basic caching for an API route. If the key exists, return the cached JSON; otherwise, proceed to the controller and cache the response.", "output": "const redis = require('redis');\nconst client = redis.createClient();\nclient.connect();\n\nconst cacheMiddleware = (keyPrefix) => {\n  return async (req, res, next) => {\n    const key = `${keyPrefix}:${req.originalUrl}`;\n    \n    try {\n      const cachedData = await client.get(key);\n      if (cachedData) {\n        return res.json(JSON.parse(cachedData));\n      }\n      \n      // Override res.json to capture the response\n      const originalJson = res.json;\n      res.json = (body) => {\n        client.setEx(key, 3600, JSON.stringify(body)); // Cache for 1 hour\n        return originalJson.call(res, body);\n      };\n      \n      next();\n    } catch (err) {\n      console.error('Redis error', err);\n      next(); // Proceed even if cache fails\n    }\n  };\n};\n\n// Usage: app.get('/api/data', cacheMiddleware('api_data'), controller);"}
{"instruction": "Using FastAPI, create a dependency that verifies a JWT token from the Authorization header and retrieves the current user from the database asynchronously.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom db import get_db, User\nfrom settings import SECRET_KEY, ALGORITHM\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n        \n    result = await db.execute(select(User).where(User.username == username))\n    user = result.scalars().first()\n    \n    if user is None:\n        raise credentials_exception\n    return user"}
{"instruction": "Write a raw SQL query to update the 'status' of all orders placed older than 30 days to 'archived', but only if they are currently 'delivered'. Return the count of updated rows.", "output": "WITH updated_rows AS (\n    UPDATE orders\n    SET status = 'archived'\n    WHERE status = 'delivered'\n      AND created_at < NOW() - INTERVAL '30 days'\n    RETURNING id\n)\nSELECT count(*) FROM updated_rows;"}
{"instruction": "Create a Node.js script using `fs` streams and an async iterator to process a large CSV file line-by-line, transform the data, and batch insert it into a SQL database (pseudo-code for DB insert).", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let batch = [];\n  const BATCH_SIZE = 1000;\n\n  for await (const line of rl) {\n    const [id, name, value] = line.split(',');\n    \n    // Transform\n    const record = {\n      id: parseInt(id),\n      name: name.trim().toUpperCase(),\n      value: parseFloat(value)\n    };\n\n    batch.push(record);\n\n    if (batch.length >= BATCH_SIZE) {\n      await insertBatchToDb(batch);\n      batch = [];\n    }\n  }\n\n  // Insert remaining\n  if (batch.length > 0) {\n    await insertBatchToDb(batch);\n  }\n}\n\nasync function insertBatchToDb(data) {\n  // Pseudo-code for SQL insert\n  console.log(`Inserting ${data.length} records...`);\n}"}
{"instruction": "Using FastAPI, implement a background task that sends a welcome email after a user successfully signs up, ensuring the API response is not blocked by the email sending process.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate blocking email operation\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    # Add task to queue\n    background_tasks.add_task(send_welcome_email, email)\n    \n    # Return immediately\n    return {\"message\": \"User created. Email will be sent shortly.\"}"}
{"instruction": "Create an asynchronous FastAPI endpoint that retrieves a user by ID from a database using SQLAlchemy's async session. Include the necessary imports and the route definition.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom db import get_db, User  # Assuming db setup exists\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\")\nasync def read_user(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalars().first()\n    \n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n        \n    return user"}
{"instruction": "Write a Node.js Express middleware function that logs the HTTP method, URL, and the time taken to process the request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} - ${res.statusCode} [${duration}ms]`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Design a SQL schema (PostgreSQL dialect) for a simple E-commerce system containing tables for 'users', 'products', and 'orders'. Include foreign keys and timestamps.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock INT DEFAULT 0,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(id),\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL\n);"}
{"instruction": "Implement a FastAPI endpoint that accepts a user registration payload and triggers a background task to send a welcome email, returning a response immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass UserIn(BaseModel):\n    email: str\n    username: str\n\ndef send_welcome_email(email: str):\n    # Simulation of a long-running email sending process\n    print(f\"Sending email to {email}...\")\n    # smtp.send(...) logic here\n\n@app.post(\"/register\")\nasync def register_user(user: UserIn, background_tasks: BackgroundTasks):\n    # Logic to save user to DB would go here\n    \n    # Add task to background queue\n    background_tasks.add_task(send_welcome_email, user.email)\n    \n    return {\"message\": \"Registration successful. Confirmation email sent.\"}"}
{"instruction": "Write a raw SQL query using a Window Function to find the top 3 highest-paid employees in every department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\n    FROM employees\n)\nSELECT \n    employee_id,\n    name,\n    department_id,\n    salary\nFROM RankedSalaries\nWHERE salary_rank <= 3;"}
{"instruction": "Create a Node.js function using `fs/promises` to asynchronously read a large JSON file, parse it, and return a specific property from the data.", "output": "const fs = require('fs/promises');\n\nasync function getConfigProperty(filePath, propertyKey) {\n  try {\n    const data = await fs.readFile(filePath, 'utf8');\n    const json = JSON.parse(data);\n    \n    if (json.hasOwnProperty(propertyKey)) {\n      return json[propertyKey];\n    } else {\n      throw new Error(`Key '${propertyKey}' not found.`);\n    }\n  } catch (error) {\n    console.error('Error reading config:', error.message);\n    throw error;\n  }\n}"}
{"instruction": "Define a Pydantic model for a 'BlogPost' with nested validation for tags, and a FastAPI endpoint to create a post.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List\n\napp = FastAPI()\n\nclass BlogPost(BaseModel):\n    title: str = Field(..., min_length=5, max_length=100)\n    content: str\n    tags: List[str] = []\n    published: bool = False\n\n    @validator('tags')\n    def validate_tags(cls, v):\n        if len(v) > 5:\n            raise ValueError('Max 5 tags allowed')\n        return [tag.lower() for tag in v]\n\n@app.post(\"/posts/\")\nasync def create_post(post: BlogPost):\n    return {\"status\": \"created\", \"data\": post}"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to get a full organizational hierarchy (manager-subordinate relationship) starting from a specific manager ID.", "output": "WITH RECURSIVE Subordinates AS (\n    -- Anchor member: select the manager\n    SELECT \n        employee_id, \n        manager_id, \n        name, \n        0 as level\n    FROM employees\n    WHERE employee_id = 101 -- Starting Manager ID\n\n    UNION ALL\n\n    -- Recursive member: select subordinates of the previous level\n    SELECT \n        e.employee_id, \n        e.manager_id, \n        e.name, \n        s.level + 1\n    FROM employees e\n    INNER JOIN Subordinates s ON e.manager_id = s.employee_id\n)\nSELECT * FROM Subordinates;"}
{"instruction": "Implement a FastAPI WebSocket endpoint that accepts connections and echoes received text messages back to the client until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a Node.js function that makes three API calls concurrently using `Promise.all` and aggregates the results into a single object.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData(userId) {\n  try {\n    const [userReq, ordersReq, notificationsReq] = await Promise.all([\n      axios.get(`/api/users/${userId}`),\n      axios.get(`/api/users/${userId}/orders`),\n      axios.get(`/api/users/${userId}/notifications`)\n    ]);\n\n    return {\n      user: userReq.data,\n      recentOrders: ordersReq.data,\n      unreadNotifications: notificationsReq.data\n    };\n  } catch (error) {\n    console.error(\"Failed to fetch dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Create a Python FastAPI async endpoint that retrieves a user by ID using an asynchronous SQLAlchemy session. Include the Pydantic response model.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\nfrom db import get_db, UserModel  # Assuming these exist\n\napp = FastAPI()\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\n    class Config:\n        orm_mode = True\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def read_user(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(UserModel).where(UserModel.id == user_id))\n    user = result.scalars().first()\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user"}
{"instruction": "Write a PostgreSQL SQL schema definition for a 'Library' system containing two tables: 'authors' and 'books'. Include a foreign key relationship where a book belongs to an author.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Implement a Node.js Express middleware function that logs the HTTP method, URL, and timestamp for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.url}`);\n  next();\n};\n\napp.use(requestLogger);\n\n// Example route\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Define a Pydantic model in Python for a product creation API. It must validate that the price is positive and the name is at least 3 characters long.", "output": "from pydantic import BaseModel, Field, validator\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=3, description=\"Name of the product\")\n    description: str | None = None\n    price: float\n\n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than zero')\n        return v"}
{"instruction": "Write a raw SQL query to find the top 5 customers who have spent the most money, based on an 'orders' table with 'customer_id' and 'total_amount' columns.", "output": "SELECT \n    customer_id,\n    SUM(total_amount) as total_spent\nFROM \n    orders\nGROUP BY \n    customer_id\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Node.js function using 'fs/promises' to asynchronously read a JSON file and parse its content. Handle errors appropriately.", "output": "const fs = require('fs/promises');\n\nasync function loadConfig(filePath) {\n  try {\n    const data = await fs.readFile(filePath, 'utf8');\n    const config = JSON.parse(data);\n    return config;\n  } catch (error) {\n    console.error('Error reading or parsing file:', error.message);\n    throw error;\n  }\n}"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload and saves it to disk asynchronously.", "output": "from fastapi import FastAPI, UploadFile, File\nimport aiofiles\n\napp = FastAPI()\n\n@app.post(\"/uploadfile/\")\nasync def create_upload_file(file: UploadFile = File(...)):\n    destination_file = f\"./uploads/{file.filename}\"\n    async with aiofiles.open(destination_file, 'wb') as out_file:\n        while content := await file.read(1024):  # Read in chunks\n            await out_file.write(content)\n    return {\"filename\": file.filename, \"status\": \"saved\"}"}
{"instruction": "Define a Mongoose (Node.js) schema for a 'BlogPost' which includes a title, body, an array of tags, and a nested array of comments with their own timestamps.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst commentSchema = new Schema({\n  username: String,\n  content: String,\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst blogPostSchema = new Schema({\n  title: { type: String, required: true },\n  body: String,\n  tags: [String],\n  comments: [commentSchema],\n  published: { type: Boolean, default: false },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);"}
{"instruction": "Write a SQL transaction block to transfer $100 from Account A to Account B. Ensure the transaction rolls back if an error occurs.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 'A' AND balance >= 100;\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 'B';\n\n-- Commit if successful, otherwise the system (or app logic) triggers ROLLBACK\nCOMMIT;"}
{"instruction": "Create a FastAPI background task that simulates sending a welcome email after a user successfully registers.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate a long-running sync operation\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register/{email}\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    # Logic to save user to DB would go here\n    background_tasks.add_task(send_welcome_email, email)\n    return {\"message\": \"User registered. Email will be sent in the background.\"}"}
{"instruction": "Create a FastAPI async endpoint that fetches a user by ID and their associated items from a PostgreSQL database using SQLAlchemy (asyncio extension). Include the Pydantic response model.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base, relationship\nfrom sqlalchemy import Column, Integer, String, ForeignKey, select\nfrom pydantic import BaseModel\nfrom typing import List\n\n# Database Setup\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\nBase = declarative_base()\n\n# SQLAlchemy Models\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    items = relationship(\"Item\", back_populates=\"owner\", lazy=\"selectin\")\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    owner = relationship(\"User\", back_populates=\"items\")\n\n# Pydantic Models\nclass ItemSchema(BaseModel):\n    title: str\n    class Config:\n        orm_mode = True\n\nclass UserSchema(BaseModel):\n    id: int\n    email: str\n    items: List[ItemSchema] = []\n    class Config:\n        orm_mode = True\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\", response_model=UserSchema)\nasync def read_user(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalars().first()\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user"}
{"instruction": "Write a Node.js function using the `pg` library to perform a bank transfer transaction. It must ensure ACID properties by using BEGIN, COMMIT, and ROLLBACK.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    \n    // Check balance\n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromAccountId]);\n    if (res.rows.length === 0) throw new Error('Account not found');\n    \n    const currentBalance = res.rows[0].balance;\n    if (currentBalance < amount) {\n      throw new Error('Insufficient funds');\n    }\n    \n    // Deduct from sender\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromAccountId]);\n    \n    // Add to receiver\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toAccountId]);\n    \n    await client.query('COMMIT');\n    return { success: true, message: 'Transfer complete' };\n    \n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transaction failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a PostgreSQL schema for a simplified E-commerce system containing Users, Orders, and OrderItems. Include Foreign Keys, Primary Keys, and an Index on the order date.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);\n\nCREATE INDEX idx_orders_created_at ON orders(created_at);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    unit_price DECIMAL(10, 2) NOT NULL,\n    CONSTRAINT fk_order\n        FOREIGN KEY(order_id) \n        REFERENCES orders(id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_product\n        FOREIGN KEY(product_id) \n        REFERENCES products(id)\n);\n"}
{"instruction": "Implement a FastAPI endpoint using `BackgroundTasks` to simulate processing a CSV file upload asynchronously after returning a response to the client.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_csv_file(filename: str):\n    # Simulate long running task\n    print(f\"Starting processing for {filename}...\")\n    time.sleep(5) \n    # Logic to parse CSV and insert into DB would go here\n    print(f\"Finished processing {filename}.\")\n\n@app.post(\"/upload-csv/\")\nasync def upload_csv(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Save file temporarily or stream it (simplified here for brevity)\n    filename = file.filename\n    \n    # Enqueue the task\n    background_tasks.add_task(process_csv_file, filename)\n    \n    return {\n        \"message\": \"File received. Processing started in background.\",\n        \"filename\": filename\n    }"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to fetch a full category tree (breadcrumbs) for a specific category ID.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: select the specific category\n    SELECT \n        id, \n        name, \n        parent_id, \n        1 as level\n    FROM categories \n    WHERE id = 5  -- Target Category ID\n\n    UNION ALL\n\n    -- Recursive member: join with parent\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        cp.level + 1\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath ORDER BY level DESC;"}
{"instruction": "Create a Node.js Express middleware that handles rate limiting using a conceptual in-memory store (Map). It should block requests if a specific IP exceeds 10 requests per minute.", "output": "const rateLimit = new Map();\n\nconst rateLimiterMiddleware = (req, res, next) => {\n  const ip = req.ip;\n  const currentTime = Date.now();\n  const windowSize = 60 * 1000; // 1 minute\n  const limit = 10;\n\n  if (!rateLimit.has(ip)) {\n    rateLimit.set(ip, []);\n  }\n\n  const timestamps = rateLimit.get(ip);\n  \n  // Filter out timestamps older than the window\n  const validTimestamps = timestamps.filter(time => currentTime - time < windowSize);\n  \n  if (validTimestamps.length >= limit) {\n    rateLimit.set(ip, validTimestamps); // Update cleanup\n    return res.status(429).json({ error: 'Too many requests. Please try again later.' });\n  }\n\n  validTimestamps.push(currentTime);\n  rateLimit.set(ip, validTimestamps);\n  \n  next();\n};\n\n// Usage: app.use(rateLimiterMiddleware);"}
{"instruction": "Write a Python function using Pydantic to validate a complex configuration object containing nested lists and optional fields. The validator should ensure that if `enable_ssl` is True, `port` must be 443.", "output": "from pydantic import BaseModel, validator, Field\nfrom typing import List, Optional\n\nclass ServerConfig(BaseModel):\n    host: str\n    port: int\n    enable_ssl: bool = False\n    allowed_ips: List[str] = []\n    \n    @validator('port')\n    def check_port_ssl(cls, v, values):\n        if values.get('enable_ssl') is True and v != 443:\n            raise ValueError('Port must be 443 when SSL is enabled')\n        return v\n\nclass AppConfig(BaseModel):\n    app_name: str\n    version: str\n    servers: List[ServerConfig]\n\n# Example Usage\ntry:\n    config = AppConfig(\n        app_name=\"MyAPI\",\n        version=\"1.0.0\",\n        servers=[{\"host\": \"localhost\", \"port\": 8080, \"enable_ssl\": True}] # This will fail\n    )\nexcept ValueError as e:\n    print(e)"}
{"instruction": "Create a SQL query to find the top 3 highest-paid employees in each department using Window Functions.", "output": "SELECT \n    department_id,\n    employee_name,\n    salary,\n    rank\nFROM (\n    SELECT \n        department_id,\n        employee_name,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n) ranked_salaries\nWHERE rank <= 3;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that accepts messages from a client and broadcasts them to all other connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str, sender: WebSocket):\n        for connection in self.active_connections:\n            if connection != sender:\n                await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client says: {data}\", websocket)\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(\"A client left the chat\", websocket)"}
{"instruction": "Write a Node.js script using Streams to read a massive JSONL (JSON Lines) file, parse each line, filter for users over age 18, and write the results to a new file.", "output": "const fs = require('fs');\nconst readline = require('readline');\nconst { once } = require('events');\n\nasync function processLargeFile(inputFile, outputFile) {\n  const fileStream = fs.createReadStream(inputFile);\n  const outputStream = fs.createWriteStream(outputFile);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    if (!line) continue;\n    try {\n      const user = JSON.parse(line);\n      if (user.age >= 18) {\n        const canWrite = outputStream.write(JSON.stringify(user) + '\\n');\n        if (!canWrite) {\n            // Handle backpressure\n            await once(outputStream, 'drain');\n        }\n      }\n    } catch (err) {\n      console.error('Error parsing line:', err);\n    }\n  }\n\n  outputStream.end();\n}\n\nprocessLargeFile('users.jsonl', 'adults.jsonl');"}
{"instruction": "Create a FastAPI Pydantic model and an SQLAlchemy ORM model for a 'Product' entity. The entity should have a UUID primary key, a name, a price (decimal), a JSON field for metadata, and a relationship to a 'Category' model.", "output": "from sqlalchemy import Column, String, Numeric, ForeignKey, JSON\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel, UUID4, Field\nfrom typing import Optional, Dict, Any\nimport uuid\n\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass Product(Base):\n    __tablename__ = 'products'\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(String, index=True, nullable=False)\n    price = Column(Numeric(10, 2), nullable=False)\n    meta_data = Column(JSON, nullable=True)\n    category_id = Column(UUID(as_uuid=True), ForeignKey('categories.id'))\n\n    category = relationship(\"Category\", back_populates=\"products\")\n\n# Pydantic Schema\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    price: float = Field(..., gt=0)\n    meta_data: Optional[Dict[str, Any]] = None\n    category_id: UUID4\n\n    class Config:\n        orm_mode = True"}
{"instruction": "Write a raw SQL query to create a PostgreSQL table named 'users' and a 'subscriptions' table. Users have many subscriptions. Include foreign keys, a CHECK constraint for email format, and a default timestamp.", "output": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    email VARCHAR(255) NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')\n);\n\nCREATE TABLE subscriptions (\n    id SERIAL PRIMARY KEY,\n    user_id UUID NOT NULL,\n    plan_name VARCHAR(50) NOT NULL,\n    is_active BOOLEAN DEFAULT TRUE,\n    start_date DATE DEFAULT CURRENT_DATE,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js function using the 'pg' (node-postgres) library to perform a database transaction. The function should transfer funds between two accounts. If any step fails, roll back the transaction.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n\n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transaction failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency that validates a JWT token from the Authorization header and returns the decoded user payload. Raise an HTTP 401 exception if invalid.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"supersecret\"\nALGORITHM = \"HS256\"\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        return payload\n    except JWTError:\n        raise credentials_exception"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary,\n    rank\nFROM \n    RankedSalaries\nWHERE \n    rank <= 3\nORDER BY \n    department_id, rank;"}
{"instruction": "Create an async Node.js Express route that fetches data from three different external APIs concurrently using Promise.all and aggregates the results.", "output": "const express = require('express');\nconst axios = require('axios');\nconst router = express.Router();\n\nrouter.get('/dashboard-stats', async (req, res, next) => {\n  try {\n    const [usersReq, ordersReq, productsReq] = await Promise.all([\n      axios.get('https://api.example.com/users/count'),\n      axios.get('https://api.example.com/orders/revenue'),\n      axios.get('https://api.example.com/products/stock')\n    ]);\n\n    const responseData = {\n      totalUsers: usersReq.data.count,\n      totalRevenue: ordersReq.data.amount,\n      lowStockAlerts: productsReq.data.low_stock_items\n    };\n\n    res.json(responseData);\n  } catch (error) {\n    next(error);\n  }\n});\n\nmodule.exports = router;"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload, saves it to disk asynchronously, and triggers a background task to process the file.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport aiofiles\nimport os\n\napp = FastAPI()\n\ndef process_file_task(file_path: str):\n    # Simulate heavy processing\n    print(f\"Processing {file_path}...\")\n    # Logic to parse CSV/Image processing goes here\n\n@app.post(\"/upload/\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Async write to disk\n    async with aiofiles.open(file_location, 'wb') as out_file:\n        content = await file.read()\n        await out_file.write(content)\n    \n    # Add background task\n    background_tasks.add_task(process_file_task, file_location)\n    \n    return {\"info\": f\"file '{file.filename}' saved at '{file_location}' and processing started\"}"}
{"instruction": "Write a SQL schema for a Many-to-Many relationship between 'Students' and 'Courses', including a join table 'Enrollments' that tracks the grade and enrollment date.", "output": "CREATE TABLE students (\n    student_id INT PRIMARY KEY AUTO_INCREMENT,\n    first_name VARCHAR(100),\n    last_name VARCHAR(100)\n);\n\nCREATE TABLE courses (\n    course_id INT PRIMARY KEY AUTO_INCREMENT,\n    course_name VARCHAR(100),\n    credits INT\n);\n\nCREATE TABLE enrollments (\n    student_id INT,\n    course_id INT,\n    enrollment_date DATE DEFAULT (CURRENT_DATE),\n    grade CHAR(2),\n    PRIMARY KEY (student_id, course_id),\n    FOREIGN KEY (student_id) REFERENCES students(student_id) ON DELETE CASCADE,\n    FOREIGN KEY (course_id) REFERENCES courses(course_id) ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js middleware using Redis to implement a simple rate limiter (allow 10 requests per minute per IP).", "output": "const Redis = require('ioredis');\nconst redis = new Redis();\n\nconst rateLimiter = async (req, res, next) => {\n  const ip = req.ip;\n  const key = `rate_limit:${ip}`;\n  const limit = 10;\n  const windowSeconds = 60;\n\n  try {\n    const current = await redis.incr(key);\n\n    if (current === 1) {\n      await redis.expire(key, windowSeconds);\n    }\n\n    if (current > limit) {\n      return res.status(429).json({\n        error: 'Too many requests',\n        retryAfter: await redis.ttl(key)\n      });\n    }\n\n    next();\n  } catch (err) {\n    console.error('Redis error', err);\n    // Fail open or closed depending on policy\n    next();\n  }\n};\n\nmodule.exports = rateLimiter;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that echoes messages back to the client and broadcasts to all connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new 'Item' (name, price, is_offer) using Pydantic for validation, and returns the item with an updated price including tax.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: Optional[bool] = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    item_dict = item.dict()\n    if item.price:\n        item_dict.update({\"price_with_tax\": item.price * 1.2})\n    return item_dict"}
{"instruction": "Design a SQL schema (PostgreSQL dialect) for a simple blog system containing 'users' and 'posts', where a user can have multiple posts (One-to-Many relationship). Include foreign keys and timestamps.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    title VARCHAR(200) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n      FOREIGN KEY(user_id) \n      REFERENCES users(id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Write a Node.js Express middleware function that asynchronously verifies a JWT token from the 'Authorization' header. If valid, attach the decoded user to the request object; otherwise, return a 401 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authMiddleware = async (req, res, next) => {\n  try {\n    const authHeader = req.headers.authorization;\n    if (!authHeader) return res.status(401).json({ error: 'No token provided' });\n\n    const token = authHeader.split(' ')[1];\n    const decoded = await new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {\n        if (err) reject(err);\n        resolve(decoded);\n      });\n    });\n\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n};"}
{"instruction": "Using Python's SQLAlchemy (asyncio extension), define a model for 'Order' and write an async function to fetch all orders with a total value greater than 100.", "output": "from sqlalchemy import Column, Integer, Float, select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import declarative_base\n\nBase = declarative_base()\n\nclass Order(Base):\n    __tablename__ = 'orders'\n    id = Column(Integer, primary_key=True)\n    total_value = Column(Float, nullable=False)\n\nasync def get_high_value_orders(session: AsyncSession):\n    stmt = select(Order).where(Order.total_value > 100.0)\n    result = await session.execute(stmt)\n    return result.scalars().all()"}
{"instruction": "Write a SQL query to calculate the total sales amount per product category for the current month, ordered by highest sales first.", "output": "SELECT \n    c.name AS category_name,\n    SUM(s.amount) AS total_sales\nFROM sales s\nJOIN products p ON s.product_id = p.id\nJOIN categories c ON p.category_id = c.id\nWHERE \n    s.sale_date >= DATE_TRUNC('month', CURRENT_DATE)\nGROUP BY c.name\nORDER BY total_sales DESC;"}
{"instruction": "Create a FastAPI dependency that retrieves a database session using `yield` to ensure the session is closed after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Node.js function using the `pg` library to perform a database transaction that transfers funds between two accounts. It should roll back if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const debitRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n    if (debitRes.rows[0].balance < 0) throw new Error('Insufficient funds');\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Implement a FastAPI route that triggers a background task (e.g., sending an email) so the API response is returned immediately to the user without waiting for the task to finish.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate blocking I/O operation (e.g., SMTP)\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our service!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a SQL query to find users who have placed an order in the last 30 days but have NOT logged in within the last 7 days.", "output": "SELECT DISTINCT u.id, u.username, u.last_login\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE \n    o.order_date >= NOW() - INTERVAL '30 days'\n    AND u.last_login < NOW() - INTERVAL '7 days';"}
{"instruction": "Create a Node.js Express route that streams a large dataset from a database cursor directly to the HTTP response to avoid memory overflow.", "output": "const QueryStream = require('pg-query-stream');\nconst { Pool } = require('pg');\nconst JSONStream = require('JSONStream');\nconst pool = new Pool();\n\napp.get('/large-dataset', async (req, res) => {\n  const client = await pool.connect();\n  const query = new QueryStream('SELECT * FROM large_table');\n  const stream = client.query(query);\n  \n  res.set('Content-Type', 'application/json');\n  \n  stream.on('end', () => client.release());\n  stream.on('error', (err) => {\n     client.release();\n     res.status(500).end();\n  });\n\n  // Pipe DB stream -> JSON transformer -> HTTP Response\n  stream.pipe(JSONStream.stringify()).pipe(res);\n});"}
{"instruction": "Create a FastAPI (Python) async endpoint that accepts a list of URLs, fetches them concurrently using `httpx`, and returns the status codes as a JSON object.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\nfrom typing import List, Dict\n\napp = FastAPI()\n\nasync def fetch_status(client: httpx.AsyncClient, url: str) -> tuple[str, int]:\n    try:\n        resp = await client.get(url)\n        return url, resp.status_code\n    except Exception:\n        return url, 0\n\n@app.post(\"/check-urls\", response_model=Dict[str, int])\nasync def check_urls(urls: List[str]):\n    async with httpx.AsyncClient() as client:\n        tasks = [fetch_status(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    return dict(results)"}
{"instruction": "Write a raw SQL schema definition for a Many-to-Many relationship between 'Users' and 'Groups', including foreign keys and a junction table.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE groups (\n    id SERIAL PRIMARY KEY,\n    group_name VARCHAR(50) NOT NULL,\n    description TEXT\n);\n\n-- Junction Table\nCREATE TABLE user_groups (\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    group_id INT REFERENCES groups(id) ON DELETE CASCADE,\n    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, group_id)\n);"}
{"instruction": "Implement a Node.js (Express) middleware function that verifies a JWT token from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return 401.", "output": "const jwt = require('jsonwebtoken');\n\nconst authMiddleware = (req, res, next) => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ message: 'No token provided' });\n  }\n\n  const token = authHeader.split(' ')[1];\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ message: 'Invalid token' });\n  }\n};\n\nmodule.exports = authMiddleware;"}
{"instruction": "Create a Pydantic model in Python with a custom validator that ensures a 'password' field contains at least one uppercase letter, one number, and is at least 8 characters long.", "output": "from pydantic import BaseModel, field_validator\nimport re\n\nclass UserSignup(BaseModel):\n    username: str\n    email: str\n    password: str\n\n    @field_validator('password')\n    def validate_password(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department.", "output": "SELECT \n    employee_id,\n    first_name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank\nFROM \n    employees;\n-- This will assign a rank of 1 to the highest paid employee in each department."}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that echoes received messages back to the client, but reversed.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo-reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js function using a hypothetical SQL driver (like `pg`) to perform a database transaction that transfers funds from Account A to Account B.", "output": "async function transferFunds(client, fromAccountId, toAccountId, amount) {\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromAccountId]\n    );\n    \n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  }\n}"}
{"instruction": "Define a SQLAlchemy (Python) async database dependency for FastAPI using `AsyncSession`.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\n\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session_maker = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Recursive CTE (Common Table Expression) in SQL to retrieve a full category hierarchy path (e.g., Electronics > Computers > Laptops) given a specific category ID.", "output": "WITH RECURSIVE category_path AS (\n    -- Anchor member: select the starting category\n    SELECT id, name, parent_id, name::TEXT as full_path\n    FROM categories\n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: join with the previous result\n    SELECT c.id, c.name, c.parent_id, cp.full_path || ' > ' || c.name\n    FROM categories c\n    INNER JOIN category_path cp ON c.parent_id = cp.id\n)\nSELECT * FROM category_path;"}
{"instruction": "Create a Node.js (Express) route that handles file uploads using `multer` and saves the file metadata (filename, path) to a MongoDB collection using Mongoose.", "output": "const express = require('express');\nconst multer = require('multer');\nconst mongoose = require('mongoose');\nconst router = express.Router();\n\n// Mongoose Schema\nconst FileSchema = new mongoose.Schema({ filename: String, path: String, uploadedAt: Date });\nconst FileModel = mongoose.model('File', FileSchema);\n\n// Multer Config\nconst upload = multer({ dest: 'uploads/' });\n\nrouter.post('/upload', upload.single('document'), async (req, res) => {\n  if (!req.file) return res.status(400).send('No file uploaded.');\n\n  try {\n    const newFile = new FileModel({\n      filename: req.file.originalname,\n      path: req.file.path,\n      uploadedAt: new Date()\n    });\n    await newFile.save();\n    res.json({ message: 'File uploaded successfully', id: newFile._id });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a file upload and processes it asynchronously using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(file_name: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(10)\n    print(f\"Finished processing {file_name}\")\n\n@app.post(\"/upload-image/\")\nasync def create_upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Add the processing function to the background task queue\n    background_tasks.add_task(process_image, file.filename)\n    return {\"message\": \"Image received. Processing in background.\", \"filename\": file.filename}"}
{"instruction": "Write a raw SQL query to find the top 5 users who spent the most money in the last 30 days. Assume tables `users` (id, name) and `orders` (user_id, total_amount, created_at).", "output": "SELECT u.id, u.name, SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Using Node.js and Express, create a middleware wrapper function to handle asynchronous errors and eliminate the need for try-catch blocks in every route handler.", "output": "const asyncHandler = (fn) => (req, res, next) => {\n  return Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Usage Example:\n// app.get('/users', asyncHandler(async (req, res) => {\n//   const users = await db.getUsers();\n//   res.json(users);\n// }));\n\nmodule.exports = asyncHandler;"}
{"instruction": "Define a Pydantic model in FastAPI for a complex 'Product' creation schema. It should include a nested list of 'Variant' objects (e.g., size, color) and validate that the price is positive.", "output": "from typing import List\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, Field, validator\n\nclass Variant(BaseModel):\n    name: str\n    sku: str\n    stock: int\n\nclass Product(BaseModel):\n    title: str\n    description: str | None = None\n    price: float = Field(..., gt=0, description=\"Price must be greater than zero\")\n    variants: List[Variant]\n\n    @validator('variants')\n    def check_variants_not_empty(cls, v):\n        if not v:\n            raise ValueError('Product must have at least one variant')\n        return v"}
{"instruction": "Design a SQL schema (DDL) for a Many-to-Many relationship between `students` and `courses`, including a junction table that tracks the enrollment date.", "output": "CREATE TABLE students (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT REFERENCES students(id) ON DELETE CASCADE,\n    course_id INT REFERENCES courses(id) ON DELETE CASCADE,\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (student_id, course_id)\n);"}
{"instruction": "Create a Node.js script using the `fs` module to read a large CSV file using streams and transform the data (uppercase a specific column) before piping it to a write stream.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst readStream = fs.createReadStream('./input.csv', { encoding: 'utf8' });\nconst writeStream = fs.createWriteStream('./output.csv');\n\nconst uppercaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // Convert chunk to string, uppercase it (simplified logic for demo)\n    // In production, use a CSV parser to target specific columns\n    const transformedData = chunk.toString().toUpperCase();\n    this.push(transformedData);\n    callback();\n  }\n});\n\nreadStream\n  .pipe(uppercaseTransform)\n  .pipe(writeStream)\n  .on('finish', () => console.log('Processing complete.'));"}
{"instruction": "Implement a FastAPI dependency that creates a database session, yields it to the endpoint, and ensures it is closed after the request finishes.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # db is now a valid SQLAlchemy session\n    return db.query(User).all()"}
{"instruction": "Write a SQL query to perform a 'Soft Delete'. Update a record in the `products` table to set a `deleted_at` timestamp instead of actually removing the row.", "output": "UPDATE products\nSET deleted_at = CURRENT_TIMESTAMP, is_active = false\nWHERE id = 42\nAND deleted_at IS NULL;"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that accepts connections and echoes received text messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Using Node.js and a hypothetical SQL library, write a function that uses a transaction to transfer funds between two user accounts. It must roll back if any step fails.", "output": "async function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE user_id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE user_id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return true;\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a file upload, saves it asynchronously to disk, and returns the file size and filename.", "output": "from fastapi import FastAPI, UploadFile, File\nimport aiofiles\nimport os\n\napp = FastAPI()\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile = File(...)):\n    file_path = f\"uploads/{file.filename}\"\n    async with aiofiles.open(file_path, 'wb') as out_file:\n        content = await file.read()\n        await out_file.write(content)\n    \n    return {\"filename\": file.filename, \"size\": len(content)}"}
{"instruction": "Write a PostgreSQL schema definition for a 'Library' system containing 'Authors' and 'Books' with a one-to-many relationship.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    author_id INT REFERENCES authors(id) ON DELETE CASCADE,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Implement a Node.js function using the 'pg' library to perform an atomic transaction that transfers money between two accounts.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromId, toId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromId]);\n    if (res.rows[0].balance < amount) throw new Error('Insufficient funds');\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n\n    await client.query('COMMIT');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency that parses and validates pagination parameters (page and page_size).", "output": "from fastapi import Query\n\nasync def pagination_params(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    return {\"limit\": page_size, \"offset\": (page - 1) * page_size}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department.", "output": "SELECT \n    id, \n    name, \n    department, \n    salary, \n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank\nFROM employees;"}
{"instruction": "Create a simple Node.js Express middleware that validates a 'X-API-Key' header and rejects requests if it is missing or invalid.", "output": "const validateApiKey = (req, res, next) => {\n  const apiKey = req.get('X-API-Key');\n  if (!apiKey || apiKey !== process.env.API_KEY) {\n    return res.status(401).json({ error: 'Unauthorized: Invalid or missing API Key' });\n  }\n  next();\n};\n\n// Usage: app.use(validateApiKey);"}
{"instruction": "Define a Pydantic model in Python for a 'User' registration that validates the password contains at least 8 characters.", "output": "from pydantic import BaseModel, EmailStr, field_validator\n\nclass UserRegister(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n    @field_validator('password')\n    def password_min_length(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        return v"}
{"instruction": "Write a raw SQL query to find the top 3 users who have spent the most money in the 'orders' table.", "output": "SELECT \n    u.id, \n    u.username, \n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.username\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except Exception:\n        print(\"Client disconnected\")"}
{"instruction": "Create a Node.js script using 'fs' promises to read a config.json file and parse it asynchronously.", "output": "const fs = require('fs/promises');\n\nasync function loadConfig() {\n  try {\n    const data = await fs.readFile('./config.json', 'utf8');\n    const config = JSON.parse(data);\n    console.log('Config loaded:', config);\n    return config;\n  } catch (error) {\n    console.error('Error loading config:', error);\n  }\n}\n\nloadConfig();"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy (AsyncSession) to create a new 'Item' in a PostgreSQL database. Include the Pydantic model and the SQLAlchemy model definition.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom sqlalchemy import Column, Integer, String\nfrom pydantic import BaseModel\n\n# Database Setup\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass ItemDB(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n    description = Column(String)\n\n# Pydantic Model\nclass ItemCreate(BaseModel):\n    name: str\n    description: str\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/items/\")\nasync def create_item(item: ItemCreate, db: AsyncSession = Depends(get_db)):\n    new_item = ItemDB(name=item.name, description=item.description)\n    db.add(new_item)\n    await db.commit()\n    await db.refresh(new_item)\n    return new_item"}
{"instruction": "Write a Node.js (Express) middleware function that handles asynchronous errors globally without crashing the server.", "output": "const express = require('express');\nconst app = express();\n\n// Wrapper for async routes to catch errors\nconst asyncHandler = (fn) => (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Example Route\napp.get('/users', asyncHandler(async (req, res) => {\n    const users = await someAsyncDbCall(); // potentially throws\n    res.json(users);\n}));\n\n// Global Error Handling Middleware\napp.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(500).json({\n        status: 'error',\n        message: err.message || 'Internal Server Error'\n    });\n});\n\napp.listen(3000);"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM \n    RankedSalaries\nWHERE \n    rank <= 3\nORDER BY \n    department_id, rank;"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user registers, ensuring the response returns immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(5) \n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/register/{email}\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    # Add task to be executed after the response is sent\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Registration successful. Email will be sent shortly.\"}"}
{"instruction": "Design a PostgreSQL schema for a 'Many-to-Many' relationship between Students and Courses, including a composite primary key in the join table.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    credits INT NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,\n    course_id INT REFERENCES courses(course_id) ON DELETE CASCADE,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id)\n);"}
{"instruction": "Create a Node.js function using 'pg' (node-postgres) to perform a database transaction that transfers funds between two accounts.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n    const client = await pool.connect();\n    try {\n        await client.query('BEGIN');\n        \n        const deductRes = await client.query(\n            'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n            [amount, fromAccountId]\n        );\n        \n        if (deductRes.rows[0].balance < 0) {\n            throw new Error('Insufficient funds');\n        }\n\n        await client.query(\n            'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n            [amount, toAccountId]\n        );\n\n        await client.query('COMMIT');\n        return { success: true };\n    } catch (e) {\n        await client.query('ROLLBACK');\n        throw e;\n    } finally {\n        client.release();\n    }\n}"}
{"instruction": "Implement a FastAPI WebSocket endpoint that echoes messages back to the client, handling disconnection gracefully.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n        await websocket.close()"}
{"instruction": "Write a SQL query to calculate the rolling average of sales over the last 7 days for each day using Window Functions.", "output": "SELECT \n    sale_date,\n    daily_total,\n    AVG(daily_total) OVER (\n        ORDER BY sale_date \n        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n    ) as rolling_7_day_avg\nFROM \n    daily_sales\nORDER BY \n    sale_date;"}
{"instruction": "Create a custom Pydantic validator in Python to ensure a 'password' field contains at least one uppercase letter and one number.", "output": "from pydantic import BaseModel, field_validator, ValidationError\nimport re\n\nclass UserSignup(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Using Node.js streams, write a script to read a large CSV file line-by-line and transform the data (e.g., capitalize a column) before writing to a new file, to avoid memory issues.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\nconst { pipeline } = require('stream/promises');\n\nconst transformData = new Transform({\n    transform(chunk, encoding, callback) {\n        // Convert buffer to string, capitalize, and push out\n        const str = chunk.toString();\n        const upperStr = str.toUpperCase();\n        this.push(upperStr);\n        callback();\n    }\n});\n\nasync function run() {\n    try {\n        await pipeline(\n            fs.createReadStream('input_large.csv'),\n            transformData,\n            fs.createWriteStream('output_large.csv')\n        );\n        console.log('Pipeline succeeded.');\n    } catch (err) {\n        console.error('Pipeline failed.', err);\n    }\n}\n\nrun();"}
{"instruction": "Create an async FastAPI endpoint using `httpx` to fetch data from an external API and return a filtered subset of that data.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/posts\")\nasync def get_user_posts(user_id: int):\n    url = f\"https://jsonplaceholder.typicode.com/posts?userId={user_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        \n    if response.status_code != 200:\n        raise HTTPException(status_code=502, detail=\"External API error\")\n        \n    data = response.json()\n    # Return only titles\n    return {\"user_id\": user_id, \"titles\": [post[\"title\"] for post in data]}"}
{"instruction": "Write a SQL query to find the top 5 customers who spent the most money in the year 2023, joining `users` and `orders` tables.", "output": "SELECT \n    u.id,\n    u.email,\n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= '2023-01-01' \n  AND o.created_at <= '2023-12-31'\nGROUP BY u.id, u.email\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js Express middleware that checks for a valid JWT token in the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Define a SQLAlchemy (Python) many-to-many relationship between `Student` and `Course` using an association table.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Create a Node.js function using `fs.promises` to asynchronously read a JSON config file, update a specific setting, and overwrite the file.", "output": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function updateConfig(key, value) {\n  const configPath = path.join(__dirname, 'config.json');\n  \n  try {\n    const data = await fs.readFile(configPath, 'utf8');\n    const json = JSON.parse(data);\n    \n    json[key] = value;\n    \n    await fs.writeFile(configPath, JSON.stringify(json, null, 2));\n    console.log('Config updated successfully');\n  } catch (err) {\n    console.error('Error updating config:', err);\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within each department.", "output": "SELECT \n    employee_id,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM employees;"}
{"instruction": "Create a Pydantic model in Python to validate a registration payload, ensuring the password meets complexity requirements using a custom validator.", "output": "from pydantic import BaseModel, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: str\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters')\n        if not re.search(r\"\\d\", v):\n            raise ValueError('Password must contain at least one digit')\n        if not re.search(r\"[A-Z]\", v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        return v"}
{"instruction": "Write a Node.js script using Mongoose to define a schema with a virtual property that computes a user's full name from first and last names.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst userSchema = new Schema({\n  firstName: String,\n  lastName: String,\n  email: String\n}, {\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\nuserSchema.virtual('fullName').get(function() {\n  return `${this.firstName} ${this.lastName}`;\n});\n\nconst User = mongoose.model('User', userSchema);"}
{"instruction": "Create a Python FastAPI dependency that yields a database session and ensures it closes after the request is finished.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage in endpoint\n# @app.get(\"/items/\")\n# def read_items(db: Session = Depends(get_db)):\n#     ..."}
{"instruction": "Write a SQL command to create a recursive CTE (Common Table Expression) to traverse a category tree (adjacency list model).", "output": "WITH RECURSIVE category_path (id, name, path) AS (\n  SELECT id, name, CAST(name AS CHAR(200))\n  FROM categories\n  WHERE parent_id IS NULL\n  UNION ALL\n  SELECT c.id, c.name, CONCAT(cp.path, ' > ', c.name)\n  FROM categories c\n  INNER JOIN category_path cp ON cp.id = c.parent_id\n)\nSELECT * FROM category_path;"}
{"instruction": "Create a FastAPI setup with SQLAlchemy. Define a 'User' model with id, email, and hashed_password. Create a Pydantic schema for registration and an endpoint '/register' that hashes the password using passlib before saving.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/register\")\ndef register(user: UserCreate, db: Session = Depends(get_db)):\n    hashed_pw = pwd_context.hash(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_pw)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return {\"id\": db_user.id, \"email\": db_user.email}"}
{"instruction": "Write a Node.js function using the 'pg' library to perform a database transaction. The function should transfer a specified amount from one account ID to another, rolling back if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromAccountId]\n    );\n    \n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transaction failed', e);\n    return { success: false, error: e.message };\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query to find the top 3 products by sales revenue in the last 30 days. Assume tables: 'products' (id, name), 'order_items' (product_id, quantity, price_at_purchase), and 'orders' (id, created_at).", "output": "SELECT \n    p.name,\n    SUM(oi.quantity * oi.price_at_purchase) as total_revenue\nFROM products p\nJOIN order_items oi ON p.id = oi.product_id\nJOIN orders o ON oi.order_id = o.id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY p.id, p.name\nORDER BY total_revenue DESC\nLIMIT 3;"}
{"instruction": "Implement a FastAPI dependency that validates a custom header 'X-API-Key'. If the key is missing or invalid, raise a 401 Unauthorized exception.", "output": "from fastapi import Header, HTTPException, FastAPI, Depends\n\napp = FastAPI()\nVALID_API_KEY = \"secret-token-123\"\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != VALID_API_KEY:\n        raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return x_api_key\n\n@app.get(\"/secure-data\")\nasync def get_secure_data(api_key: str = Depends(verify_api_key)):\n    return {\"message\": \"Authorized access\", \"key_used\": api_key}"}
{"instruction": "Create a Node.js Express middleware that implements simple rate limiting using an in-memory Map. Limit requests to 5 per minute per IP address.", "output": "const express = require('express');\nconst app = express();\n\nconst rateLimitMap = new Map();\n\nconst rateLimiter = (req, res, next) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const windowMs = 60 * 1000;\n  const limit = 5;\n\n  if (!rateLimitMap.has(ip)) {\n    rateLimitMap.set(ip, []);\n  }\n\n  const timestamps = rateLimitMap.get(ip).filter(time => now - time < windowMs);\n  \n  if (timestamps.length >= limit) {\n    return res.status(429).json({ error: 'Too many requests' });\n  }\n\n  timestamps.push(now);\n  rateLimitMap.set(ip, timestamps);\n  next();\n};\n\napp.use(rateLimiter);"}
{"instruction": "Define a SQL DDL schema for a Blog system. Include tables for 'users', 'posts', and 'comments'. Ensure 'posts' reference 'users', and 'comments' reference both 'posts' and 'users'. Include foreign key constraints and cascading deletes.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL,\n    user_id INTEGER NOT NULL,\n    comment_text TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_post FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,\n    CONSTRAINT fk_comment_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);"}
{"instruction": "Using FastAPI, create an endpoint that accepts a file upload and triggers a background task to simulate image processing, ensuring the user gets an immediate response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(filename: str):\n    # Simulate long running task\n    time.sleep(5)\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    background_tasks.add_task(process_image, file.filename)\n    return {\"message\": \"Image received, processing in background\", \"filename\": file.filename}"}
{"instruction": "Write a Node.js script using 'fs.promises' to asynchronously read a JSON file, parse it, modify a specific key, and write it back to the file system.", "output": "const fs = require('fs').promises;\nconst path = './data.json';\n\nasync function updateConfig() {\n  try {\n    const data = await fs.readFile(path, 'utf8');\n    const json = JSON.parse(data);\n    \n    // Modify data\n    json.lastUpdated = new Date().toISOString();\n    json.active = true;\n\n    await fs.writeFile(path, JSON.stringify(json, null, 2));\n    console.log('File updated successfully');\n  } catch (error) {\n    console.error('Error processing file:', error);\n  }\n}\n\nupdateConfig();"}
{"instruction": "Write a SQL query to fetch a list of users who have not placed an order in the last year (or have never placed an order). Assume tables 'users' (id) and 'orders' (user_id, order_date).", "output": "SELECT u.id, u.username\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id AND o.order_date >= NOW() - INTERVAL '1 year'\nWHERE o.id IS NULL;"}
{"instruction": "Create a Pydantic model in FastAPI for a complex 'Product' object. It should have a name (string), price (positive float), tags (list of strings), and an optional dimensions object (height, width, depth).", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field, PositiveFloat\nfrom typing import List, Optional\n\nclass Dimensions(BaseModel):\n    height: float\n    width: float\n    depth: float\n\nclass Product(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    price: PositiveFloat\n    tags: List[str] = []\n    dimensions: Optional[Dimensions] = None\n\napp = FastAPI()\n\n@app.post(\"/products\")\nasync def create_product(product: Product):\n    return product"}
{"instruction": "Create a FastAPI endpoint for user registration. It must use Pydantic for schema validation (email and password) and Passlib to hash the password before returning a success message.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n@app.post(\"/register\")\nasync def register_user(user: UserCreate):\n    # Simulate checking if user exists\n    if user.email == \"exists@example.com\":\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = pwd_context.hash(user.password)\n    \n    # In a real app, save 'user.email' and 'hashed_password' to DB here\n    \n    return {\n        \"message\": \"User created successfully\",\n        \"email\": user.email,\n        \"hashed_password_preview\": hashed_password[:10] + \"...\"\n    }"}
{"instruction": "Write a Node.js function using the 'pg' library to asynchronously fetch a user's profile by ID from a PostgreSQL database, handling potential connection errors or missing records.", "output": "const { Pool } = require('pg');\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\n\nasync function getUserProfile(userId) {\n  try {\n    const query = 'SELECT id, username, email, created_at FROM users WHERE id = $1';\n    const { rows } = await pool.query(query, [userId]);\n\n    if (rows.length === 0) {\n      return { error: 'User not found', status: 404 };\n    }\n\n    return { data: rows[0], status: 200 };\n  } catch (err) {\n    console.error('Database error:', err.message);\n    return { error: 'Internal Server Error', status: 500 };\n  }\n}"}
{"instruction": "Design a normalized SQL schema (DDL) for a simple Blog system containing Users, Posts, and a Many-to-Many relationship for Tags.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    post_id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP\n);\n\nCREATE TABLE tags (\n    tag_id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(post_id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(tag_id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Implement a FastAPI route that accepts an image file upload and triggers a background task to process the image, returning a response immediately.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(file_name: str):\n    # Simulate a long-running CPU bound task\n    time.sleep(5)\n    print(f\"Finished processing image: {file_name}\")\n\n@app.post(\"/upload-image\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # In reality, save the file to disk/S3 first, then pass the path to the task\n    background_tasks.add_task(process_image, file.filename)\n    return {\"message\": \"Image received. Processing started in background.\", \"filename\": file.filename}"}
{"instruction": "Create a Node.js Express middleware that logs the HTTP method, URL, and the time taken (duration) for every request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  \n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} [${duration}ms]`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Write a SQL query to calculate the monthly revenue for the current year, grouped by month, from an 'orders' table.", "output": "SELECT \n    EXTRACT(MONTH FROM order_date) AS month,\n    SUM(total_amount) AS monthly_revenue\nFROM \n    orders\nWHERE \n    EXTRACT(YEAR FROM order_date) = EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY \n    EXTRACT(MONTH FROM order_date)\nORDER BY \n    month ASC;"}
{"instruction": "Create a FastAPI dependency `get_db` for SQLAlchemy that creates a new database session for a request and closes it after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a Node.js script using the 'fs' and 'readline' modules to process a massive CSV file line-by-line using streams to prevent memory leaks.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine() {\n  const fileStream = fs.createReadStream('massive_data.csv');\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line individually here\n    const columns = line.split(',');\n    console.log(`Processing row: ${columns[0]}`);\n  }\n}\n\nprocessLineByLine();"}
{"instruction": "Write a SQL transaction that safely transfers $100 from Account A to Account B, ensuring ACID compliance.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 'A' AND balance >= 100;\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 'B';\n\n-- Commit the transaction if no errors occurred\nCOMMIT;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that accepts connections and broadcasts a message to all connected clients (naive implementation).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a FastAPI endpoint using `BackgroundTasks` to simulate sending a welcome email after a user registers, ensuring the response is returned immediately while the email sends in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_welcome_email, email)\n    return {\"status\": \"User registered\", \"message\": \"Email will be sent in the background\"}"}
{"instruction": "Write a SQL schema script to create a relational database structure for a simple library system containing `authors`, `books`, and a many-to-many relationship table `book_authors`.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    birth_date DATE\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE NOT NULL,\n    published_year INT\n);\n\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Implement a Node.js function using the `pg` (node-postgres) library to perform an atomic transaction that transfers funds between two user accounts.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromAccountId]);\n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromAccountId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toAccountId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Define a Pydantic model in Python for a 'Product' that validates the price is positive and the name is not empty, to be used in a FastAPI POST request.", "output": "from pydantic import BaseModel, Field, validator\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, description=\"Name of the product\")\n    description: str | None = None\n    price: float\n\n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than zero')\n        return v"}
{"instruction": "Write a complex SQL query to find the top 3 customers who have spent the most money in the year 2023, assuming tables `customers`, `orders`, and `order_items`.", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(oi.quantity * oi.unit_price) AS total_spent\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN order_items oi ON o.id = oi.order_id\nWHERE o.order_date >= '2023-01-01' AND o.order_date <= '2023-12-31'\nGROUP BY c.id, c.name\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Create a simple Express.js middleware that validates an API Key present in the request headers and rejects the request with a 401 status if invalid.", "output": "const express = require('express');\nconst app = express();\n\nconst apiKeyMiddleware = (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n  const VALID_KEY = process.env.API_KEY || 'secret123';\n\n  if (!apiKey || apiKey !== VALID_KEY) {\n    return res.status(401).json({ error: 'Unauthorized: Invalid API Key' });\n  }\n  next();\n};\n\napp.use(apiKeyMiddleware);"}
{"instruction": "Implement a FastAPI dependency that creates a database session, yields it to the path operation, and ensures it is closed after the request is finished.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage example\n# @app.get(\"/users/\")\n# def read_users(db: Session = Depends(get_db)):\n#     return crud.get_users(db)"}
{"instruction": "Write a Node.js script using the `fs` module and `readline` to process a large CSV file line-by-line asynchronously to avoid loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Simulate processing logic, e.g., parsing CSV\n    const columns = line.split(',');\n    console.log(`Processing row: ${columns[0]}`);\n    // await databaseInsert(columns);\n  }\n}"}
{"instruction": "Define SQLAlchemy ORM models for a User and Post relationship where a User has many Posts (One-to-Many).", "output": "from sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    # Relationship to Post\n    posts = relationship(\"Post\", back_populates=\"owner\")\n\nclass Post(Base):\n    __tablename__ = 'posts'\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    body = Column(String)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    # Relationship back to User\n    owner = relationship(\"User\", back_populates=\"posts\")"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts connections and echoes received text messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously fetches data from an external URL ('https://api.thirdparty.com/status') using the 'httpx' library and returns the result to the client.", "output": "import httpx\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/external-status\")\nasync def get_external_status():\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(\"https://api.thirdparty.com/status\")\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n        except httpx.RequestError:\n            raise HTTPException(status_code=503, detail=\"External service unavailable\")"}
{"instruction": "Write a SQL schema script (PostgreSQL flavor) to create a many-to-many relationship between 'Students' and 'Courses'. Include the necessary join table 'Enrollments' with foreign keys and a composite primary key.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(150) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    credits INT CHECK (credits > 0)\n);\n\nCREATE TABLE enrollments (\n    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,\n    course_id INT REFERENCES courses(course_id) ON DELETE CASCADE,\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (student_id, course_id)\n);"}
{"instruction": "Using Node.js and Express, create a middleware function that logs the HTTP method, URL, and the time taken to process the request (in milliseconds) for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} - ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Define a Pydantic model in Python for a 'UserRegistration' payload. It should include a username (string), email (valid email format), age (integer, optional, must be 18+), and a password (string, minimum 8 characters).", "output": "from pydantic import BaseModel, EmailStr, Field, validator\nfrom typing import Optional\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n    age: Optional[int] = None\n\n    @validator('age')\n    def check_age(cls, v):\n        if v is not None and v < 18:\n            raise ValueError('User must be at least 18 years old')\n        return v"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within each department. The output should include Department, Employee Name, Salary, and Rank.", "output": "SELECT \n    department_id,\n    employee_name,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, \n    salary_rank;"}
{"instruction": "Create a Node.js function using `fs.promises` to asynchronously read a JSON configuration file, update a specific key 'lastRun' to the current timestamp, and write the file back to disk.", "output": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function updateConfigTimestamp(filePath) {\n  try {\n    const data = await fs.readFile(filePath, 'utf8');\n    const config = JSON.parse(data);\n    \n    config.lastRun = new Date().toISOString();\n    \n    await fs.writeFile(filePath, JSON.stringify(config, null, 2));\n    console.log('Config updated successfully.');\n  } catch (error) {\n    console.error('Error updating config:', error);\n  }\n}"}
{"instruction": "Using Python and SQLAlchemy (Async), define a database model for an 'Order' that includes an ID, a relationship to a 'User', a total amount, and a status enum.", "output": "import enum\nfrom sqlalchemy import Column, Integer, ForeignKey, Float, Enum\nfrom sqlalchemy.orm import relationship, declarative_base\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\n\nBase = declarative_base()\n\nclass OrderStatus(str, enum.Enum):\n    PENDING = \"pending\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n\nclass Order(AsyncAttrs, Base):\n    __tablename__ = 'orders'\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    total_amount = Column(Float, nullable=False)\n    status = Column(Enum(OrderStatus), default=OrderStatus.PENDING)\n\n    user = relationship(\"User\", back_populates=\"orders\")"}
{"instruction": "Write a Node.js script using the `pg` library to perform a database transaction. The script should transfer $100 from Account A to Account B, rolling back if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    console.log('Transfer successful');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed:', e);\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency that connects to a database, yields the session to the path operation, and closes the session afterwards (Context Manager pattern).", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage in route\n# @app.get(\"/users/\")\n# def read_users(db: Session = Depends(get_db)):\n#     return crud.get_users(db)"}
{"instruction": "Write a SQL query to calculate the monthly revenue for the current year. The result should group by month and sum the 'total' column from the 'orders' table.", "output": "SELECT \n    DATE_TRUNC('month', created_at) AS revenue_month,\n    SUM(total) AS total_revenue\nFROM \n    orders\nWHERE \n    created_at >= DATE_TRUNC('year', CURRENT_DATE)\nGROUP BY \n    revenue_month\nORDER BY \n    revenue_month;"}
{"instruction": "Create a FastAPI endpoint using Pydantic that registers a user. It must validate that the email is valid and the password is at least 8 characters long. Hash the password using a placeholder hashing logic before returning the user info (excluding the password).", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\nfrom typing import Any\n\napp = FastAPI()\n\n# Mock database\nfake_users_db = []\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(min_length=8)\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n\ndef fake_hash_password(password: str) -> str:\n    return f\"hashed_{password}\"\n\n@app.post(\"/register\", response_model=UserResponse, status_code=201)\nasync def register_user(user: UserCreate) -> Any:\n    # Check if email exists\n    if any(u['email'] == user.email for u in fake_users_db):\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_pw = fake_hash_password(user.password)\n    \n    user_obj = {\n        \"username\": user.username,\n        \"email\": user.email,\n        \"hashed_password\": hashed_pw\n    }\n    \n    fake_users_db.append(user_obj)\n    return user_obj"}
{"instruction": "Write a Node.js function using async/await to fetch data from two different API endpoints concurrently using `Promise.all` and merge the results into a single object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function getUserData(userId) {\n  const userUrl = `https://api.example.com/users/${userId}`;\n  const postsUrl = `https://api.example.com/users/${userId}/posts`;\n\n  try {\n    const [userRes, postsRes] = await Promise.all([\n      fetch(userUrl),\n      fetch(postsUrl)\n    ]);\n\n    if (!userRes.ok || !postsRes.ok) {\n      throw new Error('Failed to fetch data');\n    }\n\n    const user = await userRes.json();\n    const posts = await postsRes.json();\n\n    return {\n      ...user,\n      posts: posts\n    };\n  } catch (error) {\n    console.error('Error aggregating user data:', error);\n    throw error;\n  }\n}"}
{"instruction": "Design a SQL schema (PostgreSQL compatible) for a simple library system. Create tables for `authors`, `books`, and a many-to-many relationship table `book_authors`.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Create a FastAPI dependency that manages a database session. It should yield the session and ensure it is closed after the request is finished.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Session active\"}"}
{"instruction": "Write a SQL query to find the top 5 users who have spent the most money in the last 30 days. Assume tables: `users` (id, name) and `orders` (id, user_id, total_amount, created_at).", "output": "SELECT \n    u.id,\n    u.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    users u\nJOIN \n    orders o ON u.id = o.user_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    u.id, u.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message text was: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js Express middleware that checks for a specific API key in the headers. If missing or invalid, return 401 Unauthorized; otherwise call `next()`.", "output": "const express = require('express');\nconst app = express();\n\nconst API_KEY = \"secret-123\";\n\nconst apiKeyMiddleware = (req, res, next) => {\n  const clientKey = req.headers['x-api-key'];\n\n  if (!clientKey || clientKey !== API_KEY) {\n    return res.status(401).json({ error: 'Unauthorized: Invalid or missing API Key' });\n  }\n\n  next();\n};\n\napp.use('/protected', apiKeyMiddleware);\n\napp.get('/protected/resource', (req, res) => {\n  res.json({ message: 'You have access!' });\n});"}
{"instruction": "Write a SQL query using a Recursive CTE to get a full category path (e.g., Electronics > Computers > Laptops) given a category ID. Assume table `categories` (id, name, parent_id).", "output": "WITH RECURSIVE category_path AS (\n    -- Anchor member: start with the specific category\n    SELECT id, name, parent_id, name::TEXT as full_path\n    FROM categories\n    WHERE id = 5 -- Example Target ID\n    \n    UNION ALL\n    \n    -- Recursive member: join with parent\n    SELECT c.id, c.name, c.parent_id, c.name || ' > ' || cp.full_path\n    FROM categories c\n    INNER JOIN category_path cp ON cp.parent_id = c.id\n)\nSELECT full_path \nFROM category_path \nWHERE parent_id IS NULL;"}
{"instruction": "Create a FastAPI background task that simulates sending an email after a user submits a form, allowing the response to be returned immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long blocking operation\n    time.sleep(5)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a Node.js script using Streams to read a large text file line-by-line and log lines containing the word 'ERROR'. Use the `readline` module.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLogFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    if (line.includes('ERROR')) {\n      console.log(`Found error: ${line}`);\n    }\n  }\n}\n\n// Usage: processLogFile('./server.log');"}
{"instruction": "Create a FastAPI endpoint that accepts a user registration payload, saves the user to the database, and triggers a background task to send a welcome email without blocking the HTTP response.", "output": "from fastapi import FastAPI, BackgroundTasks, HTTPException\nfrom pydantic import BaseModel\nimport asyncio\n\napp = FastAPI()\n\nclass UserIn(BaseModel):\n    email: str\n    username: str\n\n# Mock database save function\nasync def save_user_to_db(user: UserIn):\n    await asyncio.sleep(0.1) # Simulate I/O\n    return {\"id\": 1, **user.dict()}\n\n# Background task function\ndef send_welcome_email(email: str):\n    # Simulate sending email (blocking or async)\n    print(f\"Sending email to {email}...\")\n    # In a real app, use an async email library or celery\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register\")\nasync def register_user(user: UserIn, background_tasks: BackgroundTasks):\n    # 1. Save user to DB (awaitable)\n    saved_user = await save_user_to_db(user)\n    \n    # 2. Add background task\n    background_tasks.add_task(send_welcome_email, user.email)\n    \n    # 3. Return response immediately\n    return {\"message\": \"User registered\", \"user_id\": saved_user[\"id\"]}"}
{"instruction": "Write the SQL DDL statements to create a Many-to-Many relationship between 'Students' and 'Courses', including the junction table with foreign key constraints.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(150) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    description TEXT,\n    credits INT CHECK (credits > 0)\n);\n\n-- Junction Table\nCREATE TABLE student_courses (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    CONSTRAINT fk_student\n        FOREIGN KEY (student_id) \n        REFERENCES students(student_id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_course\n        FOREIGN KEY (course_id) \n        REFERENCES courses(course_id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js function using the 'pg' (node-postgres) library that performs a bank transfer between two accounts within a database transaction to ensure ACID compliance.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    // Start Transaction\n    await client.query('BEGIN');\n\n    // 1. Check sender balance\n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [senderId]);\n    if (res.rows.length === 0) throw new Error('Sender not found');\n    \n    const senderBalance = parseFloat(res.rows[0].balance);\n    if (senderBalance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    // 2. Deduct from sender\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, senderId]);\n\n    // 3. Add to receiver\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, receiverId]);\n\n    // Commit Transaction\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    // Rollback on error\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a Pydantic model in Python to validate a configuration object. It must check that 'host' is a valid IP, 'port' is within range, and 'retry_policy' is a nested object with defaults.", "output": "from pydantic import BaseModel, IPvAnyAddress, Field, field_validator\nfrom typing import Optional\n\nclass RetryPolicy(BaseModel):\n    max_attempts: int = Field(default=3, ge=1, le=10)\n    backoff_factor: float = Field(default=0.5, gt=0)\n\nclass ServiceConfig(BaseModel):\n    service_name: str\n    host: IPvAnyAddress\n    port: int\n    retry_policy: RetryPolicy = Field(default_factory=RetryPolicy)\n\n    @field_validator('port')\n    @classmethod\n    def port_must_be_valid(cls, v: int) -> int:\n        if not (1 <= v <= 65535):\n            raise ValueError('Port must be between 1 and 65535')\n        return v\n\n# Usage Example\n# try:\n#     config = ServiceConfig(service_name=\"db\", host=\"192.168.1.1\", port=5432)\n#     print(config.model_dump_json())\n# catch ValidationError as e:\n#     print(e)"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the 'Management Hierarchy' (recursive relationship) for a specific employee ID, retrieving all their managers up to the CEO.", "output": "WITH RECURSIVE ManagerPath AS (\n    -- Anchor member: Start with the specific employee\n    SELECT \n        employee_id, \n        name, \n        manager_id, \n        0 AS level\n    FROM employees\n    WHERE employee_id = 105 -- Target Employee ID\n\n    UNION ALL\n\n    -- Recursive member: Join with the manager\n    SELECT \n        e.employee_id, \n        e.name, \n        e.manager_id, \n        mp.level + 1\n    FROM employees e\n    INNER JOIN ManagerPath mp ON e.employee_id = mp.manager_id\n)\nSELECT * FROM ManagerPath ORDER BY level;"}
{"instruction": "Create a Node.js Express middleware that generates a correlation ID (UUID) for every incoming request if one doesn't exist, attaches it to the request object, and ensures it is included in the response headers.", "output": "const express = require('express');\nconst { v4: uuidv4 } = require('uuid');\nconst app = express();\n\nconst correlationIdMiddleware = (req, res, next) => {\n    // Check if header exists, else generate new UUID\n    const correlationId = req.get('X-Correlation-ID') || uuidv4();\n    \n    // Attach to request object for use in controllers/logs\n    req.correlationId = correlationId;\n    \n    // Set header on the response\n    res.set('X-Correlation-ID', correlationId);\n    \n    next();\n};\n\napp.use(correlationIdMiddleware);\n\napp.get('/', (req, res) => {\n    res.json({ \n        message: 'Request processed', \n        id: req.correlationId \n    });\n});"}
{"instruction": "Using Python's SQLAlchemy (Async), define a 'User' model and write an asynchronous function to fetch the top 5 users by reputation score.", "output": "from sqlalchemy import Column, Integer, String, select\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    username = Column(String)\n    reputation = Column(Integer)\n\n# Setup Async Engine (Example with SQLite)\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_top_users(session: AsyncSession, limit: int = 5):\n    stmt = select(User).order_by(User.reputation.desc()).limit(limit)\n    result = await session.execute(stmt)\n    return result.scalars().all()"}
{"instruction": "Write a SQL Window Function query to calculate the running total of sales for each salesperson, ordered by the sale date.", "output": "SELECT \n    salesperson_id,\n    sale_date,\n    sale_amount,\n    SUM(sale_amount) OVER (\n        PARTITION BY salesperson_id \n        ORDER BY sale_date\n    ) as running_total\nFROM sales\nORDER BY salesperson_id, sale_date;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that accepts connections, receives text messages, and broadcasts the message to all currently connected clients (Chat Room logic).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a Node.js script using the 'fs' and 'readline' modules to process a massive CSV file line-by-line asynchronously without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Skip header\n    if (lineCount === 0) {\n        lineCount++;\n        continue;\n    }\n\n    // Process line logic here\n    const columns = line.split(',');\n    const userId = columns[0];\n    const value = columns[1];\n    \n    // Simulate async operation (e.g., db insert)\n    // await db.insert(userId, value);\n    \n    lineCount++;\n  }\n\n  console.log(`Finished processing ${lineCount} lines.`);\n}\n\n// Usage: processLargeFile('./huge_data.csv');"}
{"instruction": "Create a FastAPI async endpoint using Pydantic models to accept user registration data (username, email, password). The endpoint should return the created user without the password field.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n# Mock database\nfake_users_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate):\n    # Simulate async DB operation\n    for existing_user in fake_users_db:\n        if existing_user[\"email\"] == user.email:\n            raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    new_user = user.dict()\n    new_user[\"id\"] = len(fake_users_db) + 1\n    fake_users_db.append(new_user)\n    \n    return new_user"}
{"instruction": "Write a PostgreSQL SQL schema definition for a simple E-commerce system with two tables: 'orders' and 'order_items'. Ensure referential integrity and include a timestamp for when the order was placed.", "output": "CREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INTEGER NOT NULL,\n    product_id INTEGER NOT NULL,\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\n    price_per_unit DECIMAL(10, 2) NOT NULL,\n    CONSTRAINT fk_order\n        FOREIGN KEY(order_id) \n        REFERENCES orders(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js Express middleware function that checks for a custom header 'X-API-Key'. If the header is missing or invalid, return a 403 Forbidden error; otherwise, allow the request to proceed.", "output": "const express = require('express');\nconst app = express();\n\nconst VALID_API_KEY = 'secret-key-123';\n\nconst apiKeyMiddleware = (req, res, next) => {\n  const apiKey = req.get('X-API-Key');\n\n  if (!apiKey || apiKey !== VALID_API_KEY) {\n    return res.status(403).json({\n      error: 'Forbidden',\n      message: 'Invalid or missing API Key'\n    });\n  }\n\n  next();\n};\n\napp.use(apiKeyMiddleware);\n\napp.get('/protected', (req, res) => {\n  res.json({ message: 'Access granted' });\n});"}
{"instruction": "Using Python and SQLAlchemy (AsyncIO), write a function that fetches a user by ID and eagerly loads their related 'posts' to prevent N+1 query issues.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom sqlalchemy.orm import selectinload\nfrom models import User  # Assuming User model exists with a relationship to Post\n\nasync def get_user_with_posts(session: AsyncSession, user_id: int):\n    stmt = (\n        select(User)\n        .options(selectinload(User.posts))\n        .where(User.id == user_id)\n    )\n    result = await session.execute(stmt)\n    return result.scalars().first()"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money in the current year. Assume tables 'users' (id, name) and 'orders' (user_id, total_amount, created_at).", "output": "SELECT \n    u.id,\n    u.name,\n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= DATE_TRUNC('year', CURRENT_DATE)\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js function using `Promise.all` to fetch data from three different API endpoints concurrently and return the combined result as an object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function getDashboardData() {\n  try {\n    const [usersRes, productsRes, statsRes] = await Promise.all([\n      fetch('https://api.example.com/users'),\n      fetch('https://api.example.com/products'),\n      fetch('https://api.example.com/stats')\n    ]);\n\n    if (!usersRes.ok || !productsRes.ok || !statsRes.ok) {\n      throw new Error('One or more requests failed');\n    }\n\n    const users = await usersRes.json();\n    const products = await productsRes.json();\n    const stats = await statsRes.json();\n\n    return { users, products, stats };\n  } catch (error) {\n    console.error('Error fetching dashboard data:', error);\n    throw error;\n  }\n}"}
{"instruction": "Create a FastAPI endpoint that handles file uploads and triggers a background task to process the file (e.g., resize an image) so the user gets an immediate response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_image(file_path: str):\n    # Simulate expensive image processing\n    print(f\"Processing image at {file_path}...\")\n    # ... logic to resize image ...\n    print(f\"Finished processing {file_path}\")\n\n@app.post(\"/upload/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file to disk asynchronously usually, simplified here\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n\n    # Add processing to background tasks\n    background_tasks.add_task(process_image, file_location)\n\n    return {\"message\": \"Image received, processing in background\", \"filename\": file.filename}"}
{"instruction": "Write a raw SQL query to add a 'last_login' column to an existing 'users' table and update it to the current timestamp for all users who have logged in within the last 30 days (based on a separate 'audit_logs' table).", "output": "-- Step 1: Add the column\nALTER TABLE users ADD COLUMN last_login TIMESTAMP;\n\n-- Step 2: Update the column based on join with audit_logs\nUPDATE users\nSET last_login = (\n    SELECT MAX(login_time)\n    FROM audit_logs\n    WHERE audit_logs.user_id = users.id\n)\nWHERE EXISTS (\n    SELECT 1 \n    FROM audit_logs \n    WHERE audit_logs.user_id = users.id \n    AND audit_logs.login_time > NOW() - INTERVAL '30 days'\n);"}
{"instruction": "Using Node.js 'fs' and 'readline' modules, write a script to process a massive CSV file line-by-line using streams to avoid loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let header = null;\n\n  for await (const line of rl) {\n    if (!header) {\n      header = line.split(',');\n      continue;\n    }\n\n    const columns = line.split(',');\n    // Process row logic here (e.g., insert to DB)\n    console.log(`Processing row: ${columns[0]}`);\n  }\n}\n\nprocessLargeCsv('./large_data.csv');"}
{"instruction": "Create a Python function using the `databases` library (common in FastAPI async contexts) to perform a database transaction that inserts a user and a profile record, rolling back if either fails.", "output": "import databases\nimport sqlalchemy\n\n# Setup (usually in a config file)\ndatabase = databases.Database(\"postgresql://user:pass@localhost/db\")\nmetadata = sqlalchemy.MetaData()\nusers = sqlalchemy.Table(\"users\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"email\", sqlalchemy.String))\nprofiles = sqlalchemy.Table(\"profiles\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"user_id\", sqlalchemy.Integer), sqlalchemy.Column(\"bio\", sqlalchemy.String))\n\nasync def register_user_with_profile(email: str, bio: str):\n    try:\n        async with database.transaction():\n            # Insert User\n            query_user = users.insert().values(email=email)\n            user_id = await database.execute(query_user)\n\n            # Insert Profile\n            query_profile = profiles.insert().values(user_id=user_id, bio=bio)\n            await database.execute(query_profile)\n            \n            return user_id\n    except Exception as e:\n        print(f\"Transaction failed: {e}\")\n        # Transaction is auto-rolled back by the context manager\n        return None"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to validate an incoming JSON payload for a new 'Product'. The product must have a name (string), price (positive float), and an optional list of tags.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field, PositiveFloat\nfrom typing import List, Optional\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str\n    price: PositiveFloat\n    tags: Optional[List[str]] = []\n\n@app.post(\"/products/\", status_code=201)\nasync def create_product(product: ProductSchema):\n    # Simulate database insertion\n    product_data = product.dict()\n    product_data[\"id\"] = 101  # Mock ID\n    return product_data"}
{"instruction": "Write SQL DDL statements to create a normalized schema for a Blog system containing 'users', 'posts', and 'comments'. Ensure referential integrity with foreign keys.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    post_id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_author FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE\n);\n\nCREATE TABLE comments (\n    comment_id SERIAL PRIMARY KEY,\n    post_id INT NOT NULL,\n    user_id INT NOT NULL,\n    comment_text TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_post FOREIGN KEY (post_id) REFERENCES posts(post_id) ON DELETE CASCADE,\n    CONSTRAINT fk_commenter FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL\n);"}
{"instruction": "Implement a Node.js function using `Promise.all` to fetch data from three different API endpoints concurrently and return a combined result object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or built-in in Node 18+\n\nasync function getDashboardData() {\n  try {\n    const [userRes, statsRes, notifsRes] = await Promise.all([\n      fetch('https://api.example.com/user/profile'),\n      fetch('https://api.example.com/user/stats'),\n      fetch('https://api.example.com/user/notifications')\n    ]);\n\n    const user = await userRes.json();\n    const stats = await statsRes.json();\n    const notifications = await notifsRes.json();\n\n    return {\n      user,\n      stats,\n      notifications,\n      timestamp: new Date()\n    };\n  } catch (error) {\n    console.error('Failed to fetch dashboard data', error);\n    throw error;\n  }\n}"}
{"instruction": "Create a FastAPI dependency that checks for a valid 'X-API-Key' header. If invalid, raise a 401 Unauthorized exception.", "output": "from fastapi import Header, HTTPException, Depends, FastAPI\n\napp = FastAPI()\n\nAPI_TOKEN = \"secret-123\"\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_TOKEN:\n        raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return x_api_key\n\n@app.get(\"/secure-data\")\nasync def get_secure_data(api_key: str = Depends(verify_api_key)):\n    return {\"message\": \"Authorized access\", \"key_used\": api_key}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a Node.js Express middleware that logs the HTTP method, URL, and the time taken to process the request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Using FastAPI, create an endpoint that accepts an uploaded file and triggers a background task to process it, returning a response immediately.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\n\napp = FastAPI()\n\ndef process_file_logic(filename: str):\n    # Simulate long running CPU bound task\n    print(f\"Started processing {filename}...\")\n    import time\n    time.sleep(5)\n    print(f\"Finished processing {filename}.\")\n\n@app.post(\"/upload/\")\nasync def upload_document(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Add the processing function to background tasks\n    background_tasks.add_task(process_file_logic, file.filename)\n    return {\"message\": \"File received, processing in background\", \"filename\": file.filename}"}
{"instruction": "Write a Node.js script using the `stream` module to read a large CSV file and pipe it through a Gzip transform stream to a destination file.", "output": "const fs = require('fs');\nconst zlib = require('zlib');\nconst { pipeline } = require('stream');\n\nconst source = fs.createReadStream('large_dataset.csv');\nconst destination = fs.createWriteStream('large_dataset.csv.gz');\nconst gzip = zlib.createGzip();\n\npipeline(source, gzip, destination, (err) => {\n  if (err) {\n    console.error('Pipeline failed.', err);\n  } else {\n    console.log('Compression succeeded.');\n  }\n});"}
{"instruction": "Write a SQL transaction that safely transfers $100 from Account A to Account B. Include rollback logic (conceptual SQL script).", "output": "BEGIN;\n\n-- Deduct from sender\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 1 AND balance >= 100;\n\n-- Check if update affected a row (pseudo-code check depending on DB driver)\n-- If row_count == 0, ROLLBACK and exit;\n\n-- Add to receiver\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 2;\n\nCOMMIT;"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a simple FastAPI application with an asynchronous endpoint that simulates a long-running database query using asyncio.sleep.", "output": "from fastapi import FastAPI\nimport asyncio\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    # Simulate a DB query taking 1 second\n    await asyncio.sleep(1)\n    return {\"item_id\": item_id, \"status\": \"fetched_asynchronously\"}"}
{"instruction": "Write a PostgreSQL SQL script to create a schema for a simple E-commerce system with 'users', 'products', and 'orders' tables, ensuring referential integrity.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(id),\n    quantity INT DEFAULT 1,\n    ordered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Create a Node.js Express middleware function that logs the HTTP method, request URL, and the timestamp for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.originalUrl}`);\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Define SQLAlchemy (2.0 style) Python models for a Many-to-Many relationship between 'Students' and 'Courses' using a declarative base.", "output": "from typing import List\nfrom sqlalchemy import ForeignKey, String, Column, Table\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\nclass Base(DeclarativeBase):\n    pass\n\n# Association Table\nstudent_course_association = Table(\n    \"student_course\",\n    Base.metadata,\n    Column(\"student_id\", ForeignKey(\"students.id\"), primary_key=True),\n    Column(\"course_id\", ForeignKey(\"courses.id\"), primary_key=True),\n)\n\nclass Student(Base):\n    __tablename__ = \"students\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(50))\n    courses: Mapped[List[\"Course\"]] = relationship(secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = \"courses\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str] = mapped_column(String(100))\n    students: Mapped[List[\"Student\"]] = relationship(secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Implement a FastAPI dependency that validates a custom header 'X-API-Key'. If the key is invalid, raise an HTTP 401 Unauthorized exception.", "output": "from fastapi import Header, HTTPException, Depends, FastAPI\n\napp = FastAPI()\nFAKE_SECRET_TOKEN = \"supersecrettoken\"\n\nasync def verify_token(x_api_key: str = Header(...)):\n    if x_api_key != FAKE_SECRET_TOKEN:\n        raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return x_api_key\n\n@app.get(\"/protected\")\nasync def protected_route(token: str = Depends(verify_token)):\n    return {\"message\": \"Access granted\", \"token\": token}"}
{"instruction": "Write a SQL query to calculate the total revenue generated per customer, ordered by the highest revenue first. Assume tables 'customers' (id, name) and 'orders' (customer_id, total_amount).", "output": "SELECT \n    c.name,\n    SUM(o.total_amount) as total_revenue\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_revenue DESC;"}
{"instruction": "Create a Node.js script using fs.promises to asynchronously read a JSON configuration file, update a 'port' value, and write it back to the file.", "output": "const fs = require('fs').promises;\nconst path = './config.json';\n\nasync function updateConfigPort(newPort) {\n  try {\n    const data = await fs.readFile(path, 'utf8');\n    const config = JSON.parse(data);\n    \n    config.port = newPort;\n    \n    await fs.writeFile(path, JSON.stringify(config, null, 2));\n    console.log('Config updated successfully');\n  } catch (err) {\n    console.error('Error processing file:', err);\n  }\n}\n\nupdateConfigPort(8080);"}
{"instruction": "Define a Pydantic model in Python for a user registration request that validates the email format and ensures the password is at least 8 characters long.", "output": "from pydantic import BaseModel, EmailStr, Field, field_validator\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if \" \" in v:\n            raise ValueError('Password must not contain spaces')\n        return v"}
{"instruction": "Create a Mongoose (Node.js) schema for a 'Book' that includes a virtual property 'info' which combines the title and author, and ensure virtuals are included in JSON output.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst bookSchema = new Schema({\n  title: { type: String, required: true },\n  author: { type: String, required: true },\n  publishedDate: Date\n}, {\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\nbookSchema.virtual('info').get(function() {\n  return `${this.title} by ${this.author}`;\n});\n\nconst Book = mongoose.model('Book', bookSchema);"}
{"instruction": "Write a Python async context manager class that simulates opening and closing a database connection.", "output": "import asyncio\n\nclass AsyncDBConnection:\n    def __init__(self, db_url):\n        self.db_url = db_url\n\n    async def __aenter__(self):\n        print(f\"Connecting to {self.db_url}...\")\n        await asyncio.sleep(0.5)  # Simulate connection time\n        print(\"Connected.\")\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        print(\"Closing connection...\")\n        await asyncio.sleep(0.2)\n        print(\"Connection closed.\")\n\n    async def query(self, sql):\n        return f\"Result for {sql}\"\n\n# Usage example:\n# async def main():\n#     async with AsyncDBConnection(\"postgres://localhost:5432\") as db:\n#         print(await db.query(\"SELECT * FROM users\"))"}
{"instruction": "Create a FastAPI endpoint to register a new user. The solution should use Pydantic for validation, SQLAlchemy for the database model, and Passlib for password hashing.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom passlib.context import CryptContext\n\n# Setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\napp = FastAPI()\n\n# DB Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Pydantic Schema\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/register/\")\ndef register(user: UserCreate, db: Session = Depends(get_db)):\n    existing_user = db.query(User).filter(User.email == user.email).first()\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_pw = pwd_context.hash(user.password)\n    new_user = User(email=user.email, hashed_password=hashed_pw)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return {\"id\": new_user.id, \"email\": new_user.email}"}
{"instruction": "Write a Node.js/Express route handler using Mongoose (MongoDB) to fetch a list of products with asynchronous pagination (limit and offset).", "output": "const express = require('express');\nconst router = express.Router();\nconst Product = require('./models/Product'); // Assuming Mongoose model exists\n\nrouter.get('/products', async (req, res) => {\n  try {\n    // Parse query params with defaults\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 10;\n    const skip = (page - 1) * limit;\n\n    // Execute query and count in parallel for performance\n    const [products, total] = await Promise.all([\n      Product.find().skip(skip).limit(limit).exec(),\n      Product.countDocuments()\n    ]);\n\n    res.json({\n      data: products,\n      meta: {\n        total,\n        page,\n        totalPages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nmodule.exports = router;"}
{"instruction": "Write SQL DDL statements to define a Many-to-Many relationship between 'Students' and 'Courses', including the necessary junction table and foreign key constraints.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    enrollment_date DATE DEFAULT CURRENT_DATE\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    credits INT CHECK (credits > 0)\n);\n\nCREATE TABLE student_courses (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (student_id, course_id),\n    CONSTRAINT fk_student\n        FOREIGN KEY(student_id) \n        REFERENCES students(student_id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_course\n        FOREIGN KEY(course_id) \n        REFERENCES courses(course_id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Implement a FastAPI endpoint that accepts an order and uses 'BackgroundTasks' to simulate sending a confirmation email asynchronously so the user gets an immediate response.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom pydantic import BaseModel\nimport time\n\napp = FastAPI()\n\nclass Order(BaseModel):\n    item_id: int\n    email: str\n\ndef send_confirmation_email(email: str, item_id: int):\n    # Simulate a long-running blocking I/O task\n    time.sleep(5)\n    print(f\"Email sent to {email} for item {item_id}\")\n\n@app.post(\"/order/\")\nasync def create_order(order: Order, background_tasks: BackgroundTasks):\n    # Logic to save order to DB would go here\n    \n    # Enqueue the background task\n    background_tasks.add_task(send_confirmation_email, order.email, order.item_id)\n    \n    return {\"message\": \"Order received. Confirmation email will be sent shortly.\"}"}
{"instruction": "Create a raw SQL query using PostgreSQL syntax to find the top 3 highest-paid employees in each department using a Window Function.", "output": "WITH RankedEmployees AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary,\n    rank\nFROM \n    RankedEmployees\nWHERE \n    rank <= 3\nORDER BY \n    department_id, rank;"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to perform an atomic bank transfer between two accounts using SQL transactions.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const senderRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n\n    if (senderRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Define a set of Pydantic models in Python for a 'BlogPost' API. It should include a nested list of 'Comment' objects and validation ensuring the list of tags has between 1 and 5 items.", "output": "from pydantic import BaseModel, Field, constr, conlist\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass Comment(BaseModel):\n    user: str\n    content: constr(min_length=1, max_length=500)\n    timestamp: datetime = Field(default_factory=datetime.now)\n\nclass BlogPost(BaseModel):\n    title: constr(min_length=5, max_length=100)\n    body: str\n    # Validate list length: min 1 item, max 5 items\n    tags: conlist(item_type=str, min_length=1, max_length=5)\n    is_published: bool = False\n    comments: List[Comment] = []"}
{"instruction": "Implement a custom async middleware in Express.js that checks for a specific 'X-API-Key' header. If missing or invalid, return a 401 Unauthorized response.", "output": "const validateApiKey = async (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n  \n  // Assume fetchValidKeys() is an async function calling a DB/Cache\n  // const validKeys = await fetchValidKeys(); \n  const validKeys = ['secret-key-1', 'secret-key-2']; // Mock data\n\n  if (!apiKey || !validKeys.includes(apiKey)) {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Missing or invalid X-API-Key header'\n    });\n  }\n\n  next();\n};\n\n// Usage: app.use('/api', validateApiKey);"}
{"instruction": "Create a MongoDB aggregation pipeline using Node.js to calculate the average rating and total number of reviews for each product category.", "output": "const getCategoryStats = async (db) => {\n  return await db.collection('products').aggregate([\n    {\n      $group: {\n        _id: \"$category\",\n        averageRating: { $avg: \"$rating\" },\n        totalReviews: { $sum: \"$reviewCount\" },\n        productCount: { $sum: 1 }\n      }\n    },\n    {\n      $sort: { averageRating: -1 }\n    }\n  ]).toArray();\n};"}
{"instruction": "Implement a FastAPI dependency that handles database session management. It should yield a session and ensure it is closed even if an exception occurs during the request.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine\n\n# Configuration\nDATABASE_URL = \"sqlite:///./app.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# The Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    except Exception:\n        # Optional: Rollback on error if not handled automatically\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\n# Usage Example\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"ok\"}"}
{"instruction": "Create an asynchronous FastAPI endpoint that fetches data from an external API using the 'httpx' library and returns a summarized JSON response.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-data\")\nasync def get_external_data():\n    url = \"https://api.example.com/items\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            data = response.json()\n            # Summarize: return count of items\n            return {\n                \"status\": \"success\",\n                \"item_count\": len(data),\n                \"source\": url\n            }\n        except httpx.RequestError as exc:\n            raise HTTPException(status_code=503, detail=f\"External API error: {exc}\")"}
{"instruction": "Write a SQL schema (PostgreSQL dialect) for a simple Project Management tool with tables for 'Users', 'Projects', and a many-to-many relationship table 'ProjectMembers'.", "output": "CREATE TABLE Users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Projects (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    description TEXT,\n    owner_id INT REFERENCES Users(id) ON DELETE CASCADE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE ProjectMembers (\n    project_id INT REFERENCES Projects(id) ON DELETE CASCADE,\n    user_id INT REFERENCES Users(id) ON DELETE CASCADE,\n    role VARCHAR(20) DEFAULT 'member',\n    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (project_id, user_id)\n);"}
{"instruction": "Write a Node.js (Express) route handler that performs two asynchronous database queries in parallel using Promise.all to reduce latency.", "output": "const express = require('express');\nconst router = express.Router();\nconst db = require('./db'); // Hypothetical DB module\n\nrouter.get('/dashboard/:userId', async (req, res, next) => {\n  const { userId } = req.params;\n\n  try {\n    // Execute queries concurrently\n    const [userProfile, recentOrders] = await Promise.all([\n      db.collection('users').findOne({ id: userId }),\n      db.collection('orders').find({ userId: userId }).limit(5).toArray()\n    ]);\n\n    if (!userProfile) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      user: userProfile,\n      orders: recentOrders\n    });\n  } catch (error) {\n    next(error);\n  }\n});"}
{"instruction": "Create a Pydantic model in Python for a User Registration request that validates the password contains at least 8 characters and includes a number.", "output": "from pydantic import BaseModel, EmailStr, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Write a SQL query to find the top 5 customers by total spending amount, joining a 'Customers' table with an 'Orders' table.", "output": "SELECT \n    c.customer_id,\n    c.name,\n    SUM(o.total_amount) AS total_spent\nFROM \n    Customers c\nJOIN \n    Orders o ON c.customer_id = o.customer_id\nGROUP BY \n    c.customer_id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js middleware function that verifies a JWT (JSON Web Token) from the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token missing' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid token' });\n    }\n    // Attach decoded user to request object\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Create a FastAPI dependency that yields a database session and ensures the session is closed after the request is processed.", "output": "from typing import Generator\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal # Hypothetical session factory\n\ndef get_db() -> Generator[Session, None, None]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL transaction script to transfer $100 from Account A to Account B, ensuring ACID properties.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE Accounts\nSET balance = balance - 100.00\nWHERE account_id = 'A' AND balance >= 100.00;\n\n-- Add to Account B\nUPDATE Accounts\nSET balance = balance + 100.00\nWHERE account_id = 'B';\n\n-- Check if the deduction actually happened (row count check logic usually handled in app code, but SQL commits if no errors)\nCOMMIT;"}
{"instruction": "Write a Node.js function using the 'fs' module promises API to read a JSON file, modify a key, and write it back to disk asynchronously.", "output": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function updateConfig(filePath, key, value) {\n  try {\n    const rawData = await fs.readFile(filePath, 'utf8');\n    const config = JSON.parse(rawData);\n    \n    config[key] = value;\n    \n    await fs.writeFile(filePath, JSON.stringify(config, null, 2));\n    console.log('Config updated successfully');\n  } catch (error) {\n    console.error('Error updating config:', error);\n  }\n}"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a connection and echoes back any message received from the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should accept a JSON body with username, email, and password, hash the password (mocked), and return the user info without the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n# Mock database\nfake_users_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate):\n    # Check if user exists\n    if any(u['username'] == user.username for u in fake_users_db):\n        raise HTTPException(status_code=400, detail=\"Username already registered\")\n    \n    # Mock hashing\n    hashed_password = user.password + \"notreallyhashed\"\n    \n    new_user = {\n        \"id\": len(fake_users_db) + 1,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"password\": hashed_password\n    }\n    fake_users_db.append(new_user)\n    return new_user"}
{"instruction": "Write a Node.js Express middleware that logs the HTTP method, URL, and the time taken to process the request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Design a SQL schema (PostgreSQL) for a simple E-commerce system containing 'users', 'products', and 'orders' tables, ensuring referential integrity.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL,\n    CONSTRAINT fk_order\n        FOREIGN KEY(order_id)\n        REFERENCES orders(id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_product\n        FOREIGN KEY(product_id)\n        REFERENCES products(id)\n);\n"}
{"instruction": "Implement a FastAPI dependency that connects to a database session and yields it, ensuring the session is closed after the request is processed.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # db is available here and will close automatically after return\n    return {\"status\": \"Database session active\"}"}
{"instruction": "Write an async Node.js function using the 'pg' library to fetch a user profile and their recent posts in parallel using Promise.all.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function getUserDashboard(userId) {\n  const userQuery = 'SELECT id, name, email FROM users WHERE id = $1';\n  const postsQuery = 'SELECT id, title, content FROM posts WHERE user_id = $1 ORDER BY created_at DESC LIMIT 5';\n\n  try {\n    // Execute queries in parallel for performance\n    const [userResult, postsResult] = await Promise.all([\n      pool.query(userQuery, [userId]),\n      pool.query(postsQuery, [userId])\n    ]);\n\n    if (userResult.rows.length === 0) {\n      return null;\n    }\n\n    return {\n      profile: userResult.rows[0],\n      recentPosts: postsResult.rows\n    };\n  } catch (err) {\n    console.error('Database error', err);\n    throw err;\n  }\n}"}
{"instruction": "Write a SQL query to find the top 5 product categories by total revenue generated in the current year.", "output": "SELECT \n    c.name AS category_name,\n    SUM(oi.quantity * oi.price_at_purchase) AS total_revenue\nFROM order_items oi\nJOIN products p ON oi.product_id = p.id\nJOIN categories c ON p.category_id = c.id\nJOIN orders o ON oi.order_id = o.id\nWHERE \n    EXTRACT(YEAR FROM o.created_at) = EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY c.id, c.name\nORDER BY total_revenue DESC\nLIMIT 5;"}
{"instruction": "Implement a FastAPI endpoint that handles a file upload and triggers a background task to process the file (e.g., resize an image) so the user gets an immediate response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(filename: str):\n    # Simulate a long-running CPU bound task\n    time.sleep(5)\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload-image/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Save file logic would go here\n    file_location = f\"files/{file.filename}\"\n    with open(file_location, \"wb+\") as file_object:\n        file_object.write(file.file.read())\n    \n    # Add task to background queue\n    background_tasks.add_task(process_image, file.filename)\n    \n    return {\"message\": \"Image received. Processing started in background.\"}"}
{"instruction": "Create a Node.js script using Streams to read a massive CSV file line-by-line and insert data into a database, avoiding high memory usage.", "output": "const fs = require('fs');\nconst readline = require('readline');\nconst { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function processCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Assuming CSV format: name,email,age\n    const [name, email, age] = line.split(',');\n    \n    if (name === 'name') continue; // Skip header\n\n    try {\n      await pool.query(\n        'INSERT INTO users (name, email, age) VALUES ($1, $2, $3)',\n        [name, email, parseInt(age)]\n      );\n    } catch (err) {\n      console.error(`Failed to insert line: ${line}`, err);\n    }\n  }\n  console.log('CSV processing complete.');\n}"}
{"instruction": "Write a SQL transaction to safely transfer $100 from Account A to Account B, ensuring ACID properties.", "output": "BEGIN;\n\n-- Deduct from Sender\nUPDATE accounts \nSET balance = balance - 100.00 \nWHERE id = 1 AND balance >= 100.00;\n\n-- Check if deduction was successful (row count check logic usually in app code, \n-- but SQL constraints prevent negative balance if defined).\n\n-- Add to Receiver\nUPDATE accounts \nSET balance = balance + 100.00 \nWHERE id = 2;\n\nCOMMIT;"}
{"instruction": "Create a FastAPI WebSocket endpoint that manages active connections and broadcasts a received message to all connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy (async) to register a new user. The solution should include the Pydantic model for input, the SQLAlchemy model for the database, and the route logic to hash the password and save the user.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel, EmailStr\nfrom sqlalchemy import Column, Integer, String, select\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase\nfrom passlib.context import CryptContext\n\n# Database Setup\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL)\nAsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\n# SQLAlchemy Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Pydantic Model\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n# Utils\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check existing\n    result = await db.execute(select(User).where(User.email == user.email))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Hash password\n    hashed_pw = pwd_context.hash(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_pw)\n    \n    db.add(db_user)\n    await db.commit()\n    await db.refresh(db_user)\n    return {\"id\": db_user.id, \"email\": db_user.email}"}
{"instruction": "Write a Node.js function using the `pg` library to perform a database transaction. The function should transfer a specified amount from one account ID to another, rolling back if any step fails.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromId, toId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Check balance\n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromId]);\n    if (res.rows.length === 0) throw new Error('Sender not found');\n    \n    const currentBalance = res.rows[0].balance;\n    if (currentBalance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    // Deduct from sender\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n\n    // Add to receiver\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transaction failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a raw SQL query to create a schema for a simple E-commerce system involving `orders` and `products` with a Many-to-Many relationship using a junction table.", "output": "CREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(50) DEFAULT 'pending'\n);\n\nCREATE TABLE order_items (\n    order_id INT REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(id) ON DELETE RESTRICT,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    unit_price DECIMAL(10, 2) NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);"}
{"instruction": "Create a FastAPI endpoint that aggregates data from two external APIs concurrently using `asyncio.gather` to improve performance compared to sequential requests.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_data(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-stats\")\nasync def get_dashboard_stats():\n    url_users = \"https://api.example.com/stats/users\"\n    url_sales = \"https://api.example.com/stats/sales\"\n    \n    async with httpx.AsyncClient() as client:\n        # Fire both requests simultaneously\n        users_task = fetch_data(client, url_users)\n        sales_task = fetch_data(client, url_sales)\n        \n        # Wait for both to complete\n        users_data, sales_data = await asyncio.gather(users_task, sales_task)\n    \n    return {\n        \"user_count\": users_data.get(\"count\"),\n        \"total_revenue\": sales_data.get(\"revenue\"),\n        \"combined_timestamp\": users_data.get(\"timestamp\")\n    }"}
{"instruction": "Implement a Node.js Express middleware that validates a JWT token from the Authorization header asynchronously. If valid, attach the user to the request object; otherwise, return 401.", "output": "const jwt = require('jsonwebtoken');\nconst SECRET_KEY = process.env.JWT_SECRET;\n\nconst authMiddleware = async (req, res, next) => {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ message: 'Missing or invalid authorization header' });\n  }\n\n  const token = authHeader.split(' ')[1];\n\n  try {\n    // Verify token asynchronously\n    const decoded = await new Promise((resolve, reject) => {\n      jwt.verify(token, SECRET_KEY, (err, decoded) => {\n        if (err) reject(err);\n        else resolve(decoded);\n      });\n    });\n\n    // Attach user payload to request\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ message: 'Invalid or expired token' });\n  }\n};\n\nmodule.exports = authMiddleware;"}
{"instruction": "Define a Pydantic model in Python with a custom validator that ensures a start_date is before an end_date and that the 'status' field is one of a specific set of allowed strings.", "output": "from pydantic import BaseModel, field_validator, model_validator\nfrom datetime import datetime\nfrom typing import Optional\n\nclass ProjectSchema(BaseModel):\n    name: str\n    status: str\n    start_date: datetime\n    end_date: datetime\n\n    @field_validator('status')\n    @classmethod\n    def validate_status(cls, v: str) -> str:\n        allowed = {'planned', 'active', 'completed', 'archived'}\n        if v.lower() not in allowed:\n            raise ValueError(f'Status must be one of {allowed}')\n        return v.lower()\n\n    @model_validator(mode='after')\n    def check_dates(self) -> 'ProjectSchema':\n        if self.start_date >= self.end_date:\n            raise ValueError('start_date must be before end_date')\n        return self"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, \n    salary_rank;"}
{"instruction": "Create a Node.js function using Mongoose to find a blog post by ID and populate its 'comments' array, where 'comments' is a reference to another collection.", "output": "const mongoose = require('mongoose');\nconst Post = require('./models/Post'); // Assuming model exists\n\nasync function getPostWithComments(postId) {\n  try {\n    const post = await Post.findById(postId)\n      .populate({\n        path: 'comments',\n        select: 'content author createdAt', // Select specific fields\n        populate: { path: 'author', select: 'username' } // Nested populate for comment author\n      })\n      .exec();\n\n    if (!post) {\n      throw new Error('Post not found');\n    }\n\n    return post;\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw error;\n  }\n}"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload and processes it in the background using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_file_task(filename: str):\n    # Simulate long running CPU bound task (e.g., image resizing, parsing CSV)\n    print(f\"Starting processing for {filename}...\")\n    import time\n    time.sleep(5)\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload/\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file to disk first\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule processing after response is sent\n    background_tasks.add_task(process_file_task, file.filename)\n    \n    return {\"message\": \"File received. Processing started in background.\", \"filename\": file.filename}"}
{"instruction": "Write a recursive SQL query (CTE) to retrieve a full category tree (breadcrumbs) for a specific category ID, given a table `categories` with columns `id`, `name`, and `parent_id`.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: start with the specific category\n    SELECT \n        id, \n        name, \n        parent_id, \n        0 as level\n    FROM \n        categories\n    WHERE \n        id = 5  -- Example Target ID\n\n    UNION ALL\n\n    -- Recursive member: join with parent\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        cp.level + 1\n    FROM \n        categories c\n    INNER JOIN \n        CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath ORDER BY level DESC;"}
{"instruction": "Using FastAPI and SQLAlchemy, define a 'User' database model and a Pydantic schema for user registration. Then, create an async endpoint '/register' that hashes the password using passlib before saving the user to the database.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Security\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schema\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.post(\"/register\")\nasync def register(user: UserCreate, db: Session = Depends(get_db)):\n    fake_hashed_password = pwd_context.hash(user.password)\n    db_user = User(email=user.email, hashed_password=fake_hashed_password)\n    try:\n        db.add(db_user)\n        db.commit()\n        db.refresh(db_user)\n        return {\"id\": db_user.id, \"email\": db_user.email}\n    except Exception:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=\"Email already registered\")"}
{"instruction": "Write a raw SQL query (PostgreSQL dialect) to create a 'products' table. It should have an auto-incrementing primary key, a name, a price (decimal), a JSONB column for attributes, and a 'created_at' timestamp defaulting to now.", "output": "CREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),\n    attributes JSONB DEFAULT '{}'::jsonb,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Using Node.js and Express, create a middleware function that authenticates a user via a JWT token found in the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return a 401 status.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) {\n    return res.sendStatus(401);\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.sendStatus(403);\n    }\n    // Attach user payload to request\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "In FastAPI, implement an endpoint that performs two external API calls concurrently using `asyncio` and `httpx` to reduce latency, then combines the results.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_data(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-data\")\nasync def get_dashboard_data():\n    url_users = \"https://api.example.com/users/stats\"\n    url_sales = \"https://api.example.com/sales/stats\"\n\n    async with httpx.AsyncClient() as client:\n        # Run both requests in parallel\n        users_task = fetch_data(client, url_users)\n        sales_task = fetch_data(client, url_sales)\n        \n        users_data, sales_data = await asyncio.gather(users_task, sales_task)\n\n    return {\n        \"user_stats\": users_data,\n        \"sales_stats\": sales_data,\n        \"status\": \"aggregated\"\n    }"}
{"instruction": "Write a SQL query to find the top 5 customers by total spending amount. Assume two tables: `customers` (id, name) and `orders` (id, customer_id, total_amount).", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Using Node.js (Mongoose), define a schema for a 'BlogPost' that includes a title, body, and an array of nested 'Comment' sub-documents. Include a virtual property to count the number of comments.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst commentSchema = new Schema({\n  body: String,\n  date: { type: Date, default: Date.now }\n});\n\nconst blogPostSchema = new Schema({\n  title:  String,\n  author: String,\n  body:   String,\n  comments: [commentSchema],\n  date: { type: Date, default: Date.now },\n  hidden: Boolean,\n  meta: {\n    votes: Number,\n    favs:  Number\n  }\n}, { toJSON: { virtuals: true } });\n\n// Virtual for comment count\nblogPostSchema.virtual('commentCount').get(function() {\n  return this.comments.length;\n});\n\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);"}
{"instruction": "Create a FastAPI WebSocket endpoint that manages active connections and broadcasts a received message to all connected clients (Chat Room logic).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Message: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(\"A user left the chat\")"}
{"instruction": "Using Node.js, implement a function that wraps a database operation in a retry logic loop. It should retry up to 3 times if the operation fails, with an exponential backoff delay.", "output": "const wait = (ms) => new Promise(res => setTimeout(res, ms));\n\nasync function withRetry(operation, maxRetries = 3) {\n  let attempt = 0;\n  while (attempt < maxRetries) {\n    try {\n      return await operation();\n    } catch (error) {\n      attempt++;\n      if (attempt >= maxRetries) {\n        throw error;\n      }\n      // Exponential backoff: 100ms, 200ms, 400ms...\n      const delay = 100 * Math.pow(2, attempt - 1);\n      console.log(`Attempt ${attempt} failed. Retrying in ${delay}ms...`);\n      await wait(delay);\n    }\n  }\n}\n\n// Usage Example:\n// const result = await withRetry(() => db.query('SELECT * FROM risky_table'));"}
{"instruction": "Design a SQL schema for a Many-to-Many relationship between 'Students' and 'Courses'. Provide the CREATE TABLE statements for the three necessary tables.", "output": "CREATE TABLE students (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrolled_at DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,\n    FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE\n);"}
{"instruction": "In FastAPI, implement a dependency that handles pagination parameters (skip and limit) and returns them as a dictionary. Apply this dependency to an endpoint returning a list of items.", "output": "from fastapi import FastAPI, Depends, Query\n\napp = FastAPI()\n\n# Pagination Dependency\ndef pagination_params(skip: int = Query(0, ge=0), limit: int = Query(10, le=100)):\n    return {\"skip\": skip, \"limit\": limit}\n\nfake_items_db = [{\"item_name\": f\"Item {i}\"} for i in range(100)]\n\n@app.get(\"/items/\")\nasync def read_items(pagination: dict = Depends(pagination_params)):\n    skip = pagination[\"skip\"]\n    limit = pagination[\"limit\"]\n    return fake_items_db[skip : skip + limit]"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a new user registration via a Pydantic model, hashes the password using bcrypt (passlib), and returns the user info without the password. Assume an async database function 'create_user_in_db' exists.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: str\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\nasync def create_user_in_db(user_data: dict):\n    # Mock DB call returning created user with ID\n    return {**user_data, \"id\": 1}\n\n@app.post(\"/users/\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    hashed_password = pwd_context.hash(user.password)\n    user_dict = user.dict()\n    user_dict[\"password\"] = hashed_password\n    \n    new_user = await create_user_in_db(user_dict)\n    return new_user"}
{"instruction": "Write a raw SQL schema for a simple blogging system. Create tables for 'authors' and 'posts'. Ensure 'posts' has a foreign key linking to 'authors' and includes a timestamp for creation.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    author_id INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_author\n      FOREIGN KEY(author_id) \n      REFERENCES authors(id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js Express middleware function that asynchronously verifies a JWT token from the 'Authorization' header. If valid, attach the user to the request object; otherwise, return a 401 status.", "output": "const jwt = require('jsonwebtoken');\nconst secretKey = process.env.JWT_SECRET;\n\nconst authMiddleware = async (req, res, next) => {\n  try {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ message: 'No token provided' });\n    }\n\n    const token = authHeader.split(' ')[1];\n    \n    // Verify token asynchronously\n    const decoded = await new Promise((resolve, reject) => {\n      jwt.verify(token, secretKey, (err, decoded) => {\n        if (err) reject(err);\n        else resolve(decoded);\n      });\n    });\n\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ message: 'Invalid or expired token' });\n  }\n};"}
{"instruction": "Implement a FastAPI dependency that provides an asynchronous database session using SQLAlchemy. The dependency should yield the session and ensure it is closed after the request is processed.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom fastapi import Depends\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 highest-paid employees in each department. Assume a table 'employees' with columns 'id', 'name', 'department_id', and 'salary'.", "output": "WITH RankedSalaries AS (\n    SELECT \n        name, \n        department_id, \n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    name, \n    department_id, \n    salary\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Create a Node.js function using the 'pg' library to perform a database transaction. The function should transfer funds between two accounts. Rollback if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return 'Transfer successful';\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Implement a FastAPI endpoint that triggers a background task (e.g., sending an email) after returning a 202 Accepted response to the client instantly.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate blocking I/O operation (e.g., SMTP)\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\", status_code=202)\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification queued\"}"}
{"instruction": "Write a Node.js script using the 'fs' and 'readline' modules to process a large CSV file line-by-line asynchronously without loading the entire file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Simulate processing logic\n    const columns = line.split(',');\n    if (columns.length > 0) {\n        console.log(`Processing ID: ${columns[0]}`);\n    }\n  }\n}\n\nprocessLargeFile('./large_data.csv').catch(console.error);"}
{"instruction": "Write a SQL query to fetch 'orders' that were placed in the last 7 days. The table 'orders' has a 'created_at' TIMESTAMP column.", "output": "-- PostgreSQL syntax\nSELECT * \nFROM orders \nWHERE created_at >= NOW() - INTERVAL '7 days';\n\n-- MySQL syntax\n-- SELECT * FROM orders WHERE created_at >= NOW() - INTERVAL 7 DAY;"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a connection, listens for text messages, and echoes them back to the client with a 'Received: ' prefix until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy that registers a new user. The solution must include a Pydantic model for input validation, hash the password using 'passlib', and save the user to the database asynchronously.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom passlib.context import CryptContext\nfrom db import get_db, User  # Assumed db setup\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n    email: str\n\n@app.post(\"/register\", status_code=201)\nasync def register_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check if user exists\n    result = await db.execute(select(User).where(User.username == user.username))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Username already registered\")\n\n    # Hash password\n    hashed_password = pwd_context.hash(user.password)\n\n    # Create user instance\n    new_user = User(username=user.username, email=user.email, hashed_password=hashed_password)\n    \n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    \n    return {\"id\": new_user.id, \"username\": new_user.username}"}
{"instruction": "Write a Node.js function using the 'pg' library to perform a bank transfer between two accounts. The operation must use a SQL transaction (BEGIN, COMMIT, ROLLBACK) to ensure data integrity.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n\n    if (deductRes.rows.length === 0 || deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema for a simple E-commerce system. Write the CREATE TABLE statements for 'users', 'products', and 'orders', including a many-to-many relationship between orders and products via an 'order_items' table.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(user_id),\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    order_item_id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(product_id),\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL\n);"}
{"instruction": "Create a FastAPI endpoint that aggregates data from two external APIs asynchronously using 'httpx'. The endpoint should fetch weather data and news data concurrently to minimize latency.", "output": "import httpx\nimport asyncio\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_url(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-summary\")\nasync def get_dashboard_summary():\n    weather_url = \"https://api.example.com/weather\"\n    news_url = \"https://api.example.com/news\"\n\n    async with httpx.AsyncClient() as client:\n        # Run requests concurrently\n        weather_task = fetch_url(client, weather_url)\n        news_task = fetch_url(client, news_url)\n        \n        weather_data, news_data = await asyncio.gather(weather_task, news_task)\n\n    return {\n        \"weather\": weather_data,\n        \"news\": news_data\n    }"}
{"instruction": "Write a SQL query using a Window Function to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    employee_id,\n    name,\n    department_id,\n    salary\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Implement a Node.js Express middleware that handles rate limiting using Redis. The middleware should limit users to 100 requests per 15 minutes based on their IP address.", "output": "const redis = require('redis');\nconst client = redis.createClient();\n\nconst rateLimiter = async (req, res, next) => {\n  const ip = req.ip;\n  const key = `rate_limit:${ip}`;\n  const limit = 100;\n  const windowSeconds = 15 * 60;\n\n  try {\n    const requests = await client.incr(key);\n    \n    if (requests === 1) {\n      await client.expire(key, windowSeconds);\n    }\n\n    if (requests > limit) {\n      return res.status(429).json({ error: 'Too many requests' });\n    }\n\n    next();\n  } catch (err) {\n    next(err);\n  }\n};\n\n// Usage: app.use(rateLimiter);"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a client connection, listens for text messages, and echoes them back in reverse order until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo-reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js script using Sequelize to define a One-to-Many relationship between 'Authors' and 'Books'. Include a query to fetch all authors and their associated books eagerly.", "output": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('sqlite::memory:');\n\nconst Author = sequelize.define('Author', { name: DataTypes.STRING });\nconst Book = sequelize.define('Book', { title: DataTypes.STRING });\n\n// Associations\nAuthor.hasMany(Book, { foreignKey: 'authorId' });\nBook.belongsTo(Author, { foreignKey: 'authorId' });\n\nasync function getAuthorsWithBooks() {\n  await sequelize.sync();\n  \n  // Example Query\n  const results = await Author.findAll({\n    include: [{\n      model: Book,\n      required: false // Left join\n    }]\n  });\n  \n  return results;\n}"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to fetch a full category hierarchy (breadcrumbs) for a specific category ID, assuming an adjacency list schema with 'id', 'name', and 'parent_id'.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: start with the specific category\n    SELECT id, name, parent_id, 1 as level\n    FROM categories\n    WHERE id = 5 -- Example Target ID\n\n    UNION ALL\n\n    -- Recursive member: join with parent\n    SELECT c.id, c.name, c.parent_id, cp.level + 1\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath ORDER BY level DESC;"}
{"instruction": "Implement a FastAPI dependency that verifies a JWT token from the Authorization header. It should decode the token, check expiration, and return the user ID or raise a 401 error.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n        return user_id\n    except JWTError:\n        raise credentials_exception"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should validate that the email is valid and the password is at least 8 characters long. Return a success message with the user's email, excluding the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n\n@app.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    # Simulate DB check for existing user\n    if user.email == \"exists@example.com\":\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Simulate saving to DB (hashing omitted for brevity)\n    return UserResponse(username=user.username, email=user.email)"}
{"instruction": "Write a Node.js function using the `pg` (node-postgres) library to execute a database transaction. The function should transfer an amount from one account to another asynchronously, rolling back if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING *',\n      [amount, fromAccountId]\n    );\n    \n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema (DDL) for a Many-to-Many relationship between `Students` and `Courses`. Include the necessary foreign keys and a composite primary key for the join table.", "output": "CREATE TABLE Students (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE Courses (\n    course_id INT PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    credits INT CHECK (credits > 0)\n);\n\nCREATE TABLE Enrollments (\n    student_id INT,\n    course_id INT,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    FOREIGN KEY (student_id) REFERENCES Students(student_id) ON DELETE CASCADE,\n    FOREIGN KEY (course_id) REFERENCES Courses(course_id) ON DELETE CASCADE\n);"}
{"instruction": "Implement a Python function using `asyncio` and `aiohttp` to fetch data from three different public APIs concurrently and aggregate the results.", "output": "import asyncio\nimport aiohttp\n\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.json()\n\nasync def aggregate_data():\n    urls = [\n        \"https://api.example.com/users\",\n        \"https://api.example.com/posts\",\n        \"https://api.example.com/comments\"\n    ]\n    \n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        \n    return {\n        \"users\": results[0],\n        \"posts\": results[1],\n        \"comments\": results[2]\n    }"}
{"instruction": "Write a SQL query using a recursive Common Table Expression (CTE) to retrieve a category hierarchy (category tree) starting from a root category with `id = 1`.", "output": "WITH RECURSIVE CategoryTree AS (\n    -- Anchor member: select the root category\n    SELECT id, name, parent_id, 0 as level\n    FROM Categories\n    WHERE id = 1\n    \n    UNION ALL\n    \n    -- Recursive member: join with the previous level\n    SELECT c.id, c.name, c.parent_id, ct.level + 1\n    FROM Categories c\n    INNER JOIN CategoryTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CategoryTree ORDER BY level, id;"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a connection, listens for text messages, and echoes them back reversed until the client sends 'disconnect'.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo-reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            if data == \"disconnect\":\n                await websocket.send_text(\"Bye!\")\n                await websocket.close()\n                break\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js Express middleware function that verifies a JWT (JSON Web Token) from the `Authorization` header. If valid, attach the user payload to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer <TOKEN>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money in the last 30 days. Assume tables `Customers` (id, name) and `Orders` (id, customer_id, total_amount, created_at).", "output": "SELECT c.id, c.name, SUM(o.total_amount) as total_spent\nFROM Customers c\nJOIN Orders o ON c.id = o.customer_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY c.id, c.name\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Using FastAPI, create a dependency function that connects to a database, yields the session to the path operation, and ensures the session is closed after the request is finished.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # db is now a valid session object\n    return {\"message\": \"Database session active\"}"}
{"instruction": "Implement a Node.js stream pipeline to read a large CSV file, transform the data (convert column names to lowercase), and write it to a new JSON line file, handling backpressure automatically.", "output": "const fs = require('fs');\nconst { Transform, pipeline } = require('stream');\nconst csv = require('csv-parser'); // Assuming csv-parser is installed\n\nconst readStream = fs.createReadStream('input.csv');\nconst writeStream = fs.createWriteStream('output.jsonl');\n\nconst transformStream = new Transform({\n  objectMode: true,\n  transform(chunk, encoding, callback) {\n    const lowercased = {};\n    for (const key in chunk) {\n      lowercased[key.toLowerCase()] = chunk[key];\n    }\n    this.push(JSON.stringify(lowercased) + '\\n');\n    callback();\n  }\n});\n\npipeline(\n  readStream,\n  csv(),\n  transformStream,\n  writeStream,\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new product, validates it using Pydantic, and simulates an asynchronous database save operation.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nimport asyncio\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str = Field(..., min_length=3)\n    price: float = Field(..., gt=0)\n    in_stock: bool = True\n\n# Simulated async DB call\nasync def save_to_db(product: dict):\n    await asyncio.sleep(0.5)  # Simulate I/O delay\n    return {**product, \"id\": 101}\n\n@app.post(\"/products/\", status_code=201)\nasync def create_product(product: ProductSchema):\n    try:\n        saved_product = await save_to_db(product.dict())\n        return {\"message\": \"Product created\", \"data\": saved_product}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))"}
{"instruction": "Write a raw SQL schema (PostgreSQL dialect) to create a 'users' table and an 'orders' table. The orders table must have a foreign key referencing users and a check constraint to ensure the total amount is positive.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status VARCHAR(20) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(user_id)\n        ON DELETE CASCADE,\n    CONSTRAINT check_positive_amount\n        CHECK (total_amount > 0)\n);"}
{"instruction": "Implement a Node.js (Express) async middleware function that logs the time taken for a request to complete.", "output": "const requestLogger = async (req, res, next) => {\n  const start = Date.now();\n  \n  // Hook into the response 'finish' event to calculate duration after the route handler is done\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`[${req.method}] ${req.originalUrl} - ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\n// Usage in app\n// app.use(requestLogger);"}
{"instruction": "Define SQLAlchemy (Async) models in Python for a Many-to-Many relationship between 'Students' and 'Courses' using an association table.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    # Relationship\n    courses = relationship(\n        'Course', \n        secondary=student_course_association, \n        back_populates='students'\n    )\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    # Reverse relationship\n    students = relationship(\n        'Student', \n        secondary=student_course_association, \n        back_populates='courses'\n    )"}
{"instruction": "Create a FastAPI dependency that yields an asynchronous database session and ensures the session is closed after the request is processed.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom fastapi import Depends\n\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session_maker = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\n# Dependency\nasync def get_db():\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Node.js function using the 'pg' library to perform a database transaction. It should transfer funds from one account to another.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n    if (deductRes.rows[0].balance < 0) throw new Error('Insufficient funds');\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return true;\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees;"}
{"instruction": "Create a FastAPI route that triggers a background task (e.g., sending an email) so the user gets an immediate response without waiting for the email to send.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport asyncio\n\napp = FastAPI()\n\nasync def send_email_notification(email: str, message: str):\n    # Simulate long-running task\n    await asyncio.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification scheduled\"}"}
{"instruction": "Write a Python Async Context Manager class that manages a connection to a Redis cache.", "output": "import redis.asyncio as redis\n\nclass AsyncRedisManager:\n    def __init__(self, url):\n        self.url = url\n        self.redis = None\n\n    async def __aenter__(self):\n        self.redis = redis.from_url(self.url)\n        # Ensure connection is established\n        await self.redis.ping()\n        return self.redis\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        if self.redis:\n            await self.redis.close()\n\n# Usage:\n# async with AsyncRedisManager(\"redis://localhost\") as r:\n#     await r.set(\"key\", \"value\")"}
{"instruction": "Create a Node.js Express route that fetches user details and their recent posts in parallel using Promise.all to optimize performance.", "output": "const express = require('express');\nconst router = express.Router();\nconst db = require('./db'); // Hypothetical DB module\n\nrouter.get('/user-dashboard/:id', async (req, res) => {\n  const userId = req.params.id;\n\n  try {\n    // Execute queries in parallel rather than sequentially\n    const [user, posts] = await Promise.all([\n      db.query('SELECT * FROM users WHERE id = $1', [userId]),\n      db.query('SELECT * FROM posts WHERE user_id = $1 LIMIT 5', [userId])\n    ]);\n\n    if (user.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      profile: user.rows[0],\n      recentPosts: posts.rows\n    });\n  } catch (err) {\n    res.status(500).json({ error: 'Database error' });\n  }\n});"}
{"instruction": "Define a SQLAlchemy ORM model for a 'User' and a corresponding Pydantic schema for input validation in a FastAPI application.", "output": "from sqlalchemy import Column, Integer, String, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel, EmailStr\n\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n\n# Pydantic Schema\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: String\n\nclass UserResponse(BaseModel):\n    id: int\n    email: EmailStr\n    is_active: bool\n\n    class Config:\n        orm_mode = True"}
{"instruction": "Write an asynchronous Node.js Express route handler that fetches data from a third-party API using 'axios' and handles potential errors gracefully.", "output": "const express = require('express');\nconst axios = require('axios');\nconst router = express.Router();\n\nrouter.get('/external-data', async (req, res) => {\n  try {\n    const response = await axios.get('https://api.example.com/data');\n    // Process data asynchronously\n    const processedData = response.data.map(item => ({\n      id: item.id,\n      name: item.name.toUpperCase()\n    }));\n    res.json(processedData);\n  } catch (error) {\n    console.error('API Error:', error.message);\n    if (error.response) {\n      res.status(error.response.status).json({ error: 'External API error' });\n    } else {\n      res.status(500).json({ error: 'Internal Server Error' });\n    }\n  }\n});\n\nmodule.exports = router;"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) and a Window Function to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary,\n    rank\nFROM \n    RankedSalaries\nWHERE \n    rank <= 3\nORDER BY \n    department_id, rank;"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and triggers a background task to process the file, returning an immediate response to the client.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\n\napp = FastAPI()\n\ndef process_file(filename: str):\n    # Simulate a long-running blocking I/O operation\n    with open(f\"processed_{filename}\", \"w\") as f:\n        f.write(\"Processed content\")\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload/\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Add the processing function to background tasks\n    background_tasks.add_task(process_file, file.filename)\n    return {\"message\": \"File received. Processing started in background.\", \"filename\": file.filename}"}
{"instruction": "Implement a Node.js script using the 'stream' module to pipe a read stream from a large file to a write stream using gzip compression to prevent memory leaks.", "output": "const fs = require('fs');\nconst zlib = require('zlib');\nconst { pipeline } = require('stream');\n\nconst source = fs.createReadStream('large_input.txt');\nconst destination = fs.createWriteStream('input.txt.gz');\nconst gzip = zlib.createGzip();\n\n// Use pipeline for better error handling and cleanup than standard .pipe()\npipeline(source, gzip, destination, (err) => {\n  if (err) {\n    console.error('Pipeline failed:', err);\n  } else {\n    console.log('Compression finished successfully.');\n  }\n});"}
{"instruction": "Design a PostgreSQL schema DDL for a 'Library' system involving Books and Authors with a Many-to-Many relationship.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_year INT\n);\n\n-- Junction table for Many-to-Many relationship\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);\n\n-- Optional: Index for faster lookups\nCREATE INDEX idx_book_authors_author ON book_authors(author_id);"}
{"instruction": "Implement a FastAPI dependency that verifies a custom API Key header and raises an HTTPException if invalid.", "output": "from fastapi import Header, HTTPException, Depends, FastAPI\n\napp = FastAPI()\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != \"my_secret_token\":\n        raise HTTPException(status_code=403, detail=\"Could not validate credentials\")\n    return x_api_key\n\n@app.get(\"/secure-data\")\nasync def get_secure_data(api_key: str = Depends(verify_api_key)):\n    return {\"message\": \"Authorized access\", \"key_used\": api_key}"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to insert a new user into a database and return the generated ID using raw SQL.", "output": "const { Pool } = require('pg');\nconst pool = new Pool(); // assumes env vars are set\n\nasync function createUser(username, email) {\n  const client = await pool.connect();\n  try {\n    const queryText = 'INSERT INTO users(username, email) VALUES($1, $2) RETURNING id';\n    const values = [username, email];\n    \n    const res = await client.query(queryText, values);\n    return res.rows[0].id;\n  } catch (err) {\n    console.error('Database insert error', err.stack);\n    throw err;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL transaction block to safely transfer $100 from Account A to Account B, ensuring atomicity.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100.00 \nWHERE account_id = 'A' AND balance >= 100.00;\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100.00 \nWHERE account_id = 'B';\n\n-- Check if the deduction actually happened (row count check logic usually handled in app code, but SQL logic follows)\n-- If successful:\nCOMMIT;\n\n-- If error occurs or insufficient funds:\n-- ROLLBACK;"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that accepts connections and echoes received text messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a user registration payload, triggers a simulated background email task (without blocking the response), and returns a success message.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom pydantic import BaseModel\nimport asyncio\n\napp = FastAPI()\n\nclass UserEmail(BaseModel):\n    email: str\n    username: str\n\nasync def send_welcome_email(email: str, username: str):\n    # Simulate a long-running I/O task\n    await asyncio.sleep(2)\n    print(f\"Email sent to {email} for user {username}\")\n\n@app.post(\"/register\")\nasync def register_user(user: UserEmail, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_welcome_email, user.email, user.username)\n    return {\"message\": \"Registration successful. Check email shortly.\"}"}
{"instruction": "Write SQL DDL statements (PostgreSQL compatible) to design a schema for a 'Blog' application involving 'Users', 'Posts', and a many-to-many relationship for 'Tags'. Include foreign keys and constraints.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT NOT NULL,\n    tag_id INT NOT NULL,\n    PRIMARY KEY (post_id, tag_id),\n    CONSTRAINT fk_post FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,\n    CONSTRAINT fk_tag FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js Express middleware that calculates the time taken for a request to process and logs the method, URL, and duration in milliseconds.", "output": "const express = require('express');\nconst app = express();\n\n// Request Logger Middleware\nconst requestLogger = (req, res, next) => {\n    const start = process.hrtime();\n\n    res.on('finish', () => {\n        const duration = process.hrtime(start);\n        // Convert [seconds, nanoseconds] to milliseconds\n        const durationInMs = (duration[0] * 1000 + duration[1] / 1e6).toFixed(2);\n        console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} [${durationInMs}ms]`);\n    });\n\n    next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n    // Simulate delay\n    setTimeout(() => res.send('Hello World'), 100);\n});"}
{"instruction": "Create a Pydantic model in Python for validating a Product update request. The price must be positive, and if the 'tags' list is provided, it must not be empty.", "output": "from pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n    price: Optional[float] = None\n    tags: Optional[List[str]] = None\n\n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v is not None and v <= 0:\n            raise ValueError('Price must be greater than zero')\n        return v\n\n    @validator('tags')\n    def tags_must_not_be_empty(cls, v):\n        if v is not None and len(v) == 0:\n            raise ValueError('Tags list cannot be empty if provided')\n        return v"}
{"instruction": "Write a SQL query to fetch the top 3 users who have spent the most money, based on an 'orders' table with columns 'user_id' and 'total_amount'.", "output": "SELECT \n    user_id,\n    SUM(total_amount) as total_spent\nFROM \n    orders\nGROUP BY \n    user_id\nORDER BY \n    total_spent DESC\nLIMIT 3;"}
{"instruction": "Using Node.js and the `fs/promises` module, write an asynchronous function that reads a JSON file named 'data.json', parses it, adds a timestamp field, and writes it back to a new file 'data_processed.json'.", "output": "const fs = require('fs/promises');\n\nasync function processDataFile() {\n    try {\n        // Read file\n        const rawData = await fs.readFile('data.json', 'utf8');\n        const data = JSON.parse(rawData);\n\n        // Modify data\n        data.processed_at = new Date().toISOString();\n\n        // Write to new file\n        await fs.writeFile('data_processed.json', JSON.stringify(data, null, 2));\n        console.log('File processed successfully.');\n    } catch (error) {\n        console.error('Error processing file:', error);\n    }\n}\n\nprocessDataFile();"}
{"instruction": "Implement a database dependency in FastAPI using SQLAlchemy. Create a `get_db` generator function that creates a session, yields it to the route, and ensures it is closed after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL transaction script to transfer $100 from Account A (id=1) to Account B (id=2). Ensure atomic execution so money is not lost if the second update fails.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE id = 1 AND balance >= 100;\n\n-- Check if the previous update actually affected a row (sufficient funds)\n-- (Logic depends on specific SQL dialect procedural extensions, \n-- but conceptually we assume success for this pure SQL block or rollback on error)\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE id = 2;\n\nCOMMIT;"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that echoes any message sent by the client back to them.", "output": "from fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except Exception as e:\n        print(f\"Connection closed: {e}\")"}
{"instruction": "Write a Node.js function using `async/await` that fetches data from two different APIs concurrently using `Promise.all` and combines the results.", "output": "const axios = require('axios'); // Assuming axios is installed\n\nasync function getUserDashboardData(userId) {\n    try {\n        const [profileRes, postsRes] = await Promise.all([\n            axios.get(`https://api.example.com/users/${userId}`),\n            axios.get(`https://api.example.com/users/${userId}/posts`)\n        ]);\n\n        return {\n            user: profileRes.data,\n            recentPosts: postsRes.data,\n            timestamp: new Date()\n        };\n    } catch (error) {\n        console.error(\"Failed to fetch dashboard data\", error);\n        throw error;\n    }\n}"}
{"instruction": "Create a Python FastAPI endpoint that asynchronously fetches data from an external public API (e.g., https://api.publicapis.org/entries) using the `httpx` library and returns a filtered list of entries where the category is 'Animals'.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/animals\")\nasync def get_animals():\n    url = \"https://api.publicapis.org/entries\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            data = response.json()\n            \n            # Filter entries where Category is 'Animals'\n            animals = [\n                entry for entry in data.get(\"entries\", []) \n                if entry.get(\"Category\") == \"Animals\"\n            ]\n            return {\"count\": len(animals), \"data\": animals}\n        except httpx.HTTPError as e:\n            raise HTTPException(status_code=503, detail=f\"External API error: {str(e)}\")"}
{"instruction": "Write a SQL schema (PostgreSQL compatible) for a simple Blog system. It should include a `users` table and a `posts` table. The `posts` table must have a foreign key linking to `users` with `ON DELETE CASCADE`, and include a `created_at` timestamp that defaults to the current time.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    title VARCHAR(200) NOT NULL,\n    content TEXT NOT NULL,\n    is_published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js Express middleware function named `authenticateToken` that extracts a Bearer token from the Authorization header and verifies it using `jsonwebtoken`.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) {\n    return res.sendStatus(401); // Unauthorized\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.sendStatus(403); // Forbidden\n    }\n    // Attach user payload to request object\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Using Python and Pydantic (v2), define a UserRegistration model that validates the password. The password must be at least 8 characters long and contain at least one uppercase letter. Use the `@field_validator` decorator.", "output": "from pydantic import BaseModel, EmailStr, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        return v"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money. Assume tables `customers` (id, name) and `orders` (id, customer_id, total_amount).", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a FastAPI dependency function `get_db` that creates a SQLAlchemy database session, yields it for the request, and ensures it is closed after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Setup (usually in a separate config file)\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# The Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a Node.js function using `fs` and `readline` to process a massive CSV file line-by-line asynchronously to avoid loading the whole file into memory. Log the line count at the end.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Process line here (e.g., parse CSV)\n    lineCount++;\n  }\n\n  console.log(`Finished processing. Total lines: ${lineCount}`);\n}"}
{"instruction": "Using Python FastAPI, create an endpoint that accepts a file upload and saves it to disk asynchronously using `aiofiles`.", "output": "from fastapi import FastAPI, UploadFile, File\nimport aiofiles\n\napp = FastAPI()\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile = File(...)):\n    destination_file_path = f\"./uploads/{file.filename}\"\n    \n    async with aiofiles.open(destination_file_path, 'wb') as out_file:\n        # Read the file in chunks to be memory efficient\n        while content := await file.read(1024):\n            await out_file.write(content)\n            \n    return {\"filename\": file.filename, \"status\": \"saved successfully\"}"}
{"instruction": "Write a Node.js script using Mongoose to define a `Product` schema. Include a static method `findByCategory` that returns products sorted by price (ascending).", "output": "const mongoose = require('mongoose');\n\nconst productSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  category: { type: String, required: true, index: true },\n  stock: { type: Number, default: 0 }\n});\n\n// Static method\nproductSchema.statics.findByCategory = function(category) {\n  return this.find({ category: category }).sort({ price: 1 });\n};\n\nconst Product = mongoose.model('Product', productSchema);"}
{"instruction": "Write a SQL transaction block to safely transfer $100 from Account A to Account B. Ensure that the transaction rolls back if Account A has insufficient funds.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE id = 'AccountA' AND balance >= 100;\n\n-- Check if the update actually happened (row count check logic varies by DB driver, purely SQL logic below)\n-- If the previous UPDATE affected 0 rows (insufficient funds), we rollback.\n-- In a stored procedure, you would raise an error here.\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE id = 'AccountB';\n\nCOMMIT;"}
{"instruction": "Create a FastAPI endpoint that accepts a JSON payload for a new user (username, email, password), validates the email format using Pydantic, and returns a success message asynchronously.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate):\n    # Simulate async database operation\n    fake_db_check = False \n    if fake_db_check:\n        raise HTTPException(status_code=400, detail=\"User already exists\")\n    \n    return {\n        \"message\": \"User created successfully\",\n        \"username\": user.username,\n        \"email\": user.email\n    }"}
{"instruction": "Write a PostgreSQL SQL script to create a 'blog_posts' table and a 'comments' table with a foreign key relationship, ensuring that if a post is deleted, all associated comments are also deleted (CASCADE).", "output": "CREATE TABLE blog_posts (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL,\n    author_name VARCHAR(100),\n    comment_body TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_post\n        FOREIGN KEY(post_id) \n        REFERENCES blog_posts(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Using Node.js and Express, create an asynchronous route handler that fetches data from two different third-party APIs concurrently using Promise.all and merges the results.", "output": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.get('/dashboard-data', async (req, res) => {\n  try {\n    const [usersResponse, statsResponse] = await Promise.all([\n      axios.get('https://api.example.com/users'),\n      axios.get('https://api.example.com/stats')\n    ]);\n\n    const mergedData = {\n      users: usersResponse.data,\n      stats: statsResponse.data,\n      timestamp: new Date()\n    };\n\n    res.json(mergedData);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch dashboard data' });\n  }\n});"}
{"instruction": "Implement a FastAPI dependency that connects to an asynchronous SQLAlchemy session, yields the session for the request, and closes it afterwards.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom fastapi import Depends, FastAPI\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\nasync def get_db():\n    async with async_session() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\n# Usage example\n@app.get(\"/items\")\nasync def read_items(db: AsyncSession = Depends(get_db)):\n    # db is ready to use here\n    return {\"status\": \"ok\"}"}
{"instruction": "Write a SQL query to find the top 5 users who have spent the most money, based on an 'orders' table containing 'user_id' and 'total_amount'.", "output": "SELECT user_id, SUM(total_amount) as total_spent\nFROM orders\nGROUP BY user_id\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Node.js utility function that wraps an asynchronous controller function to handle errors automatically, removing the need for try-catch blocks in every route.", "output": "const asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Usage example:\n// app.get('/route', asyncHandler(async (req, res) => {\n//     const data = await someAsyncOperation();\n//     res.json(data);\n// }));"}
{"instruction": "Using FastAPI, create a WebSocket endpoint that accepts a client connection, receives text messages, and broadcasts the message back to the client reversed.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to select all employees who earn more than the average salary of their respective departments.", "output": "WITH DepartmentAverage AS (\n    SELECT department_id, AVG(salary) as avg_salary\n    FROM employees\n    GROUP BY department_id\n)\nSELECT e.first_name, e.last_name, e.salary, e.department_id\nFROM employees e\nJOIN DepartmentAverage da ON e.department_id = da.department_id\nWHERE e.salary > da.avg_salary;"}
{"instruction": "Create a Node.js middleware function that checks for a specific 'X-API-KEY' header. If missing or invalid, return a 401 Unauthorized response; otherwise, proceed to the next handler.", "output": "const validateApiKey = (req, res, next) => {\n  const apiKey = req.get('X-API-KEY');\n  const validKey = process.env.API_KEY_SECRET;\n\n  if (!apiKey || apiKey !== validKey) {\n    return res.status(401).json({ error: 'Unauthorized: Invalid or missing API Key' });\n  }\n\n  next();\n};\n\n// Usage: app.use(validateApiKey);"}
{"instruction": "Using Python and SQLAlchemy (Async), define a model for 'Product' and write a function to update the stock quantity of a product transactionally.", "output": "from sqlalchemy import Column, Integer, String, select\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nBase = declarative_base()\n\nclass Product(Base):\n    __tablename__ = 'products'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    stock = Column(Integer)\n\nasync def update_stock(session: AsyncSession, product_id: int, quantity_sold: int):\n    async with session.begin():\n        result = await session.execute(select(Product).where(Product.id == product_id))\n        product = result.scalars().first()\n        \n        if product and product.stock >= quantity_sold:\n            product.stock -= quantity_sold\n            await session.commit()\n            return True\n        else:\n            await session.rollback()\n            return False"}
{"instruction": "Create an asynchronous FastAPI endpoint that accepts a URL string, fetches the content from that external URL using `httpx`, and returns the HTTP status code and content length.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport httpx\n\napp = FastAPI()\n\nclass UrlRequest(BaseModel):\n    target_url: str\n\n@app.post(\"/fetch-metadata\")\nasync def fetch_metadata(payload: UrlRequest):\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(payload.target_url)\n            return {\n                \"status_code\": response.status_code,\n                \"content_length\": len(response.content)\n            }\n        except httpx.RequestError as exc:\n            raise HTTPException(status_code=400, detail=f\"Error fetching URL: {exc}\")"}
{"instruction": "Write a PostgreSQL schema definition for a 'Library' system containing `authors`, `books`, and a many-to-many relationship table `book_authors`.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE\n);\n\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Implement a Node.js Express middleware function that checks for a valid JWT in the 'Authorization' header (Bearer scheme). If invalid, return 401.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Write a SQL query to find the top 5 users who have spent the most money in the last 30 days. Assume tables: `users` (id, name) and `orders` (user_id, total_amount, created_at).", "output": "SELECT u.name, SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Pydantic model in Python to validate a user registration payload. The password must be at least 8 characters long, and the role must be either 'admin' or 'user'.", "output": "from pydantic import BaseModel, EmailStr, field_validator\nfrom typing import Literal\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n    role: Literal['admin', 'user']\n\n    @field_validator('password')\n    @classmethod\n    def validate_password(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        return v"}
{"instruction": "Write a Node.js function using a theoretical SQL client (like `pg`) to perform an atomic transaction that transfers funds from one account to another.", "output": "async function transferFunds(client, senderId, receiverId, amount) {\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  }\n}"}
{"instruction": "Create a FastAPI dependency that yields a database session and ensures the session is closed after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\n# Assuming SessionLocal is defined elsewhere via sessionmaker\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL statement to add a new column `status` to a large `orders` table with a default value of 'pending', ensuring the operation is efficient (PostgreSQL specific).", "output": "ALTER TABLE orders \nADD COLUMN status VARCHAR(20) DEFAULT 'pending';\n-- Note: In modern PostgreSQL (11+), adding a column with a constant default value is instant and does not require a table rewrite."}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that receives text messages from a client and broadcasts them back (echo).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message text was: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a Node.js utility function that recursively flattens a nested JSON object into a single-depth object with dot-notation keys (useful for API patch updates).", "output": "const flattenObject = (obj, prefix = '') => {\n  return Object.keys(obj).reduce((acc, k) => {\n    const pre = prefix.length ? prefix + '.' : '';\n    if (typeof obj[k] === 'object' && obj[k] !== null && !Array.isArray(obj[k])) {\n      Object.assign(acc, flattenObject(obj[k], pre + k));\n    } else {\n      acc[pre + k] = obj[k];\n    }\n    return acc;\n  }, {});\n};"}
{"instruction": "Create a FastAPI endpoint for user registration. It must validate the input using Pydantic (EmailStr, min length password), hash the password using a placeholder function, and simulate an asynchronous database insert.", "output": "from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, EmailStr, Field\nimport asyncio\n\napp = FastAPI()\n\n# Mock async DB function\nasync def db_create_user(user_data: dict):\n    await asyncio.sleep(0.1) # Simulate I/O\n    return {**user_data, \"id\": 1}\n\n# Mock hashing function\ndef hash_password(password: str) -> str:\n    return f\"hashed_{password}\"\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(min_length=8)\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n@app.post(\"/register\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def register_user(user: UserCreate):\n    # Check if user exists logic would go here\n    \n    hashed_pw = hash_password(user.password)\n    user_dict = user.dict()\n    user_dict[\"password\"] = hashed_pw\n    \n    new_user = await db_create_user(user_dict)\n    return new_user"}
{"instruction": "Write a Node.js function using the `pg` (node-postgres) library to perform an atomic money transfer between two accounts. Include error handling and rollback logic.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n\n    if (deductRes.rows.length === 0 || deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    return { success: false, error: e.message };\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema for a generic E-commerce system handling Products, Orders, and OrderItems. Ensure Referential Integrity is maintained.", "output": "CREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(50) DEFAULT 'pending'\n);\n\nCREATE TABLE order_items (\n    order_item_id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(product_id),\n    quantity INT NOT NULL CHECK (quantity > 0),\n    unit_price DECIMAL(10, 2) NOT NULL\n);"}
{"instruction": "Implement a FastAPI dependency that creates a database session, yields it for the request, and ensures it is closed afterwards. Use Python's context manager logic.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Session active\"}"}
{"instruction": "Write an Express.js middleware that validates a JWT token from the Authorization header. If invalid, return 401; otherwise, attach the decoded user to the request object.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\n// Usage: app.get('/protected', authenticateToken, (req, res) => { ... });"}
{"instruction": "Create a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a FastAPI endpoint that utilizes `BackgroundTasks` to send a welcome email after returning a successful response to the user.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate blocking email sending operation\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a Node.js script using Streams to read a massive CSV file, parse each row, and log only rows where the 'age' column is greater than 30, preventing memory overflow.", "output": "const fs = require('fs');\nconst csv = require('csv-parser');\n\nconst results = [];\n\nfs.createReadStream('large_dataset.csv')\n  .pipe(csv())\n  .on('data', (data) => {\n    // Process row by row without loading all to memory\n    if (parseInt(data.age) > 30) {\n      console.log(`Found user: ${data.name}, Age: ${data.age}`);\n    }\n  })\n  .on('end', () => {\n    console.log('CSV processing finished.');\n  });"}
{"instruction": "Define a Pydantic model with a custom validator that ensures the 'end_date' field is chronologically after the 'start_date' field.", "output": "from pydantic import BaseModel, validator\nfrom datetime import date\n\nclass EventSchema(BaseModel):\n    name: str\n    start_date: date\n    end_date: date\n\n    @validator('end_date')\n    def check_dates(cls, v, values):\n        if 'start_date' in values and v < values['start_date']:\n            raise ValueError('end_date must be after start_date')\n        return v"}
{"instruction": "Write a SQL query to fetch all users who have not placed an order in the last 6 months.", "output": "SELECT u.id, u.email\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id \n    AND o.created_at >= NOW() - INTERVAL '6 months'\nWHERE o.order_id IS NULL;"}
{"instruction": "Create a FastAPI endpoint using Python that registers a user. It should hash the password using 'passlib' before returning a success message. Do not save to a DB for this snippet, just handle the hashing logic.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n\n@app.post(\"/register\")\nasync def register_user(user: UserCreate):\n    hashed_password = pwd_context.hash(user.password)\n    # Logic to save to DB would go here\n    return {\"username\": user.username, \"status\": \"created\", \"password_hash_preview\": hashed_password[:10] + \"...\"}"}
{"instruction": "Write a SQL schema for a simple library system containing 'Authors', 'Books', and a many-to-many relationship table 'Book_Authors'.", "output": "CREATE TABLE Authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    birth_date DATE\n);\n\nCREATE TABLE Books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_year INT\n);\n\nCREATE TABLE Book_Authors (\n    book_id INT REFERENCES Books(book_id) ON DELETE CASCADE,\n    author_id INT REFERENCES Authors(author_id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Create a Node.js Express middleware function that validates a JWT token from the 'Authorization' header.", "output": "const jwt = require('jsonwebtoken');\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}"}
{"instruction": "Using FastAPI, implement an endpoint that accepts an email address and triggers a background task (simulating sending an email) so the response returns immediately without blocking.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_task(email: str):\n    time.sleep(2)  # Simulate long-running process\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_task, email)\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money, assuming tables 'users' (id, name) and 'orders' (user_id, total_amount).", "output": "SELECT u.name, SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Node.js function using async/await to fetch data from three different APIs concurrently using Promise.all to reduce total wait time.", "output": "const axios = require('axios');\n\nasync function loadDashboardData() {\n  try {\n    const [users, posts, comments] = await Promise.all([\n      axios.get('https://api.example.com/users'),\n      axios.get('https://api.example.com/posts'),\n      axios.get('https://api.example.com/comments')\n    ]);\n\n    return {\n      userCount: users.data.length,\n      recentPosts: posts.data.slice(0, 5),\n      comments: comments.data\n    };\n  } catch (error) {\n    console.error(\"Failed to fetch dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Define a Pydantic model in Python for a 'Product' that includes a list of 'Tag' objects. Ensure the price is always positive using a validator.", "output": "from pydantic import BaseModel, field_validator\nfrom typing import List\n\nclass Tag(BaseModel):\n    name: str\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    price: float\n    tags: List[Tag] = []\n\n    @field_validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be positive')\n        return v"}
{"instruction": "Write a SQL transaction block (PostgreSQL style) to transfer $100 from Account A to Account B, ensuring atomicity.", "output": "BEGIN;\n\nUPDATE accounts \nSET balance = balance - 100.00 \nWHERE account_id = 'A' AND balance >= 100.00;\n\nUPDATE accounts \nSET balance = balance + 100.00 \nWHERE account_id = 'B';\n\n-- If the first update affected 0 rows (insufficient funds), rollback logic would be handled in app code or via stored procedure exception handling.\nCOMMIT;"}
{"instruction": "Create a Node.js HTTP server snippet using the 'fs' module to stream a large text file to the client instead of loading it entirely into memory.", "output": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  const stream = fs.createReadStream('large-file.txt');\n  \n  // Pipe the read stream directly to the response write stream\n  stream.pipe(res);\n\n  stream.on('error', (err) => {\n    res.statusCode = 500;\n    res.end('File not found or error reading file');\n  });\n});\n\nserver.listen(3000);"}
{"instruction": "Implement a FastAPI dependency that creates a database session, yields it for the request, and closes it afterward.", "output": "from fastapi import Depends, FastAPI\n# Assuming SessionLocal is a configured SQLAlchemy sessionmaker\n\napp = FastAPI()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\nasync def read_items(db = Depends(get_db)):\n    # db is now an active session instance\n    return {\"status\": \"db session active\"}"}
{"instruction": "Create a FastAPI async POST endpoint using Pydantic models to create a new 'Item'. The endpoint should accept a JSON body with name (string), price (float), and optional description, and return the created item with an ID.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport uuid\n\napp = FastAPI()\n\nclass ItemCreate(BaseModel):\n    name: str\n    price: float\n    description: Optional[str] = None\n\nclass Item(ItemCreate):\n    id: str\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: ItemCreate):\n    # Simulate async DB operation\n    new_item = Item(id=str(uuid.uuid4()), **item.dict())\n    return new_item"}
{"instruction": "Write a SQL DDL script to create a normalized schema for a simple Blog system with 'users' and 'posts'. Users have a unique email, and posts references users via a foreign key with cascading deletion.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    post_id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n      FOREIGN KEY(user_id) \n      REFERENCES users(user_id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js Express async middleware function that authenticates a user by checking a header token against a mock database function, attaching the user to the request object, or returning 401.", "output": "const mockDbCheck = async (token) => {\n  // Simulate async delay\n  if (token === 'valid-token') return { id: 1, role: 'admin' };\n  return null;\n};\n\nconst authMiddleware = async (req, res, next) => {\n  try {\n    const token = req.headers['authorization'];\n    if (!token) return res.status(401).json({ error: 'No token provided' });\n\n    const user = await mockDbCheck(token);\n    if (!user) return res.status(401).json({ error: 'Invalid token' });\n\n    req.user = user;\n    next();\n  } catch (err) {\n    next(err);\n  }\n};"}
{"instruction": "Using Python and SQLAlchemy (AsyncIO), configure the database engine and create a `get_db` dependency generator function for FastAPI.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\n\nAsyncSessionLocal = sessionmaker(\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money, joining 'customers' and 'orders' tables.", "output": "SELECT \n    c.customer_id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.name\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Write a Node.js function using `Promise.all` to fetch data from three different API endpoints concurrently and return the combined results.", "output": "const fetchData = async () => {\n  const urls = [\n    'https://api.example.com/users',\n    'https://api.example.com/posts',\n    'https://api.example.com/comments'\n  ];\n\n  try {\n    const responses = await Promise.all(urls.map(url => fetch(url)));\n    const data = await Promise.all(responses.map(res => res.json()));\n    \n    return {\n      users: data[0],\n      posts: data[1],\n      comments: data[2]\n    };\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    throw error;\n  }\n};"}
{"instruction": "Implement a FastAPI endpoint that triggers a background task (e.g., sending an email) so the response is returned immediately to the client.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate long running blocking I/O\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a SQL statement to add a new column 'status' to an existing 'orders' table with a default value of 'pending' and create an index on that column for faster filtering.", "output": "ALTER TABLE orders \nADD COLUMN status VARCHAR(20) DEFAULT 'pending' NOT NULL;\n\nCREATE INDEX idx_orders_status ON orders(status);"}
{"instruction": "Create a Node.js script that reads a large JSON file using streams (fs.createReadStream) to avoid loading the entire file into memory.", "output": "const fs = require('fs');\nconst { pipeline } = require('stream');\n\nconst readStream = fs.createReadStream('./large-data.json', { encoding: 'utf8' });\nconst writeStream = process.stdout; // Or another writable stream\n\nreadStream.on('data', (chunk) => {\n  // Process chunk logic here\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\n\nreadStream.on('end', () => {\n  console.log('Finished reading file.');\n});\n\nreadStream.on('error', (err) => {\n  console.error('Stream error:', err);\n});"}
{"instruction": "Create a simple FastAPI WebSocket endpoint that accepts connections and echoes back any message received from the client.", "output": "from fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except Exception as e:\n        print(f\"Connection closed: {e}\")"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should validate that the email is valid and the password is at least 8 characters long.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(min_length=8)\n\n@app.post(\"/register\", status_code=201)\nasync def register_user(user: UserCreate):\n    # Simulate database logic\n    fake_db_check = False\n    if fake_db_check:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    return {\"message\": \"User created successfully\", \"username\": user.username, \"email\": user.email}"}
{"instruction": "Write the SQL DDL commands to create a Many-to-Many relationship schema between 'Books' and 'Authors' in PostgreSQL.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE\n);\n\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Using Node.js and the 'fs/promises' module, write an asynchronous function that reads a JSON file, parses it, updates a specific key, and writes it back to the disk.", "output": "const fs = require('fs/promises');\n\nasync function updateConfig(filePath, key, newValue) {\n  try {\n    const data = await fs.readFile(filePath, 'utf8');\n    const json = JSON.parse(data);\n    \n    json[key] = newValue;\n    \n    await fs.writeFile(filePath, JSON.stringify(json, null, 2));\n    console.log('Config updated successfully');\n  } catch (error) {\n    console.error('Error updating config:', error);\n  }\n}"}
{"instruction": "Implement a FastAPI dependency that connects to a database, yields the session for the request, and ensures the session is closed afterward.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage example\n# @app.get(\"/users/\")\n# def read_users(db: Session = Depends(get_db)):\n#     ..."}
{"instruction": "Write a raw SQL query using a Window Function to find the top 2 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    employee_id, \n    name, \n    department_id, \n    salary\nFROM RankedSalaries\nWHERE rank <= 2;"}
{"instruction": "Create a Node.js Express middleware that logs the method, URL, and duration of every request in milliseconds.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = process.hrtime();\n\n  res.on('finish', () => {\n    const duration = process.hrtime(start);\n    const milliseconds = (duration[0] * 1000 + duration[1] / 1e6).toFixed(2);\n    console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} [${milliseconds}ms]`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Using Python's asyncio, write a function that fetches data from three different URLs concurrently and returns the results as a list.", "output": "import asyncio\nimport aiohttp\n\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def fetch_all(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        return results\n\n# Usage:\n# urls = ['http://site1.com', 'http://site2.com', 'http://site3.com']\n# data = asyncio.run(fetch_all(urls))"}
{"instruction": "Design a SQL schema for a hierarchical comment system (like Reddit) using the Adjacency List model.", "output": "CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INT NOT NULL,\n    user_id INT NOT NULL,\n    content TEXT NOT NULL,\n    parent_id INT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_parent\n      FOREIGN KEY(parent_id) \n      REFERENCES comments(id) \n      ON DELETE CASCADE\n);\n\nCREATE INDEX idx_comments_post ON comments(post_id);\nCREATE INDEX idx_comments_parent ON comments(parent_id);"}
{"instruction": "Create a FastAPI endpoint that accepts an image file upload, validates that the content type is 'image/jpeg' or 'image/png', and returns the file size.", "output": "from fastapi import FastAPI, UploadFile, File, HTTPException\n\napp = FastAPI()\n\n@app.post(\"/upload-image/\")\nasync def upload_image(file: UploadFile = File(...)):\n    if file.content_type not in [\"image/jpeg\", \"image/png\"]:\n        raise HTTPException(status_code=400, detail=\"Invalid file type. Only JPEG and PNG allowed.\")\n    \n    # Move cursor to end to get size, then reset\n    await file.seek(0, 2)\n    file_size = file.file.tell()\n    await file.seek(0)\n    \n    return {\"filename\": file.filename, \"size_bytes\": file_size}"}
{"instruction": "Write a Node.js function using Knex.js (or a generic query builder logic) to perform a transaction that transfers 100 credits from User A to User B.", "output": "const transferCredits = async (db, senderId, receiverId, amount) => {\n  try {\n    await db.transaction(async (trx) => {\n      const sender = await trx('users').where('id', senderId).first();\n      if (!sender || sender.credits < amount) {\n        throw new Error('Insufficient funds');\n      }\n\n      await trx('users')\n        .where('id', senderId)\n        .decrement('credits', amount);\n\n      await trx('users')\n        .where('id', receiverId)\n        .increment('credits', amount);\n    });\n    console.log('Transfer successful');\n  } catch (error) {\n    console.error('Transfer failed:', error.message);\n  }\n};"}
{"instruction": "Create a FastAPI configuration to establish an asynchronous database connection using SQLAlchemy 1.4+ with an AsyncSession.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\n# Create Async Engine\nengine = create_async_engine(DATABASE_URL, echo=True)\n\n# Create Session Factory\nasync_session = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\nBase = declarative_base()\n\n# Dependency to get DB session\nasync def get_db():\n    async with async_session() as session:\n        yield session"}
{"instruction": "Write a Node.js Express middleware function that implements a simple in-memory rate limiter (allow 100 requests per IP per 15 minutes).", "output": "const rateLimit = new Map();\n\nconst rateLimiterMiddleware = (req, res, next) => {\n    const ip = req.ip;\n    const now = Date.now();\n    const windowMs = 15 * 60 * 1000; // 15 minutes\n    const limit = 100;\n\n    if (!rateLimit.has(ip)) {\n        rateLimit.set(ip, { count: 1, startTime: now });\n        return next();\n    }\n\n    const userData = rateLimit.get(ip);\n\n    if (now - userData.startTime > windowMs) {\n        // Reset window\n        userData.count = 1;\n        userData.startTime = now;\n        return next();\n    }\n\n    if (userData.count >= limit) {\n        return res.status(429).json({ error: 'Too many requests' });\n    }\n\n    userData.count++;\n    next();\n};\n\nmodule.exports = rateLimiterMiddleware;"}
{"instruction": "Design a SQL schema (PostgreSQL) for a 'Blog' system with Users, Posts, and a many-to-many relationship for Tags.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and processes it using a BackgroundTask to avoid blocking the response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_file(file_location: str):\n    # Simulate expensive processing (e.g., image resizing, parsing)\n    print(f\"Processing file at {file_location}...\")\n    # Logic here...\n    print(\"Processing complete.\")\n\n@app.post(\"/upload/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file asynchronously\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule processing after response is sent\n    background_tasks.add_task(process_file, file_location)\n    \n    return {\"info\": \"File uploaded, processing started in background\"}"}
{"instruction": "Write a Node.js function using async/await to execute a database transaction (pseudo-code using a generic 'db' client) that transfers money between two accounts.", "output": "async function transferFunds(senderId, receiverId, amount) {\n    const client = await db.connect();\n    try {\n        await client.query('BEGIN');\n\n        const senderRes = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [senderId]);\n        if (senderRes.rows[0].balance < amount) {\n            throw new Error('Insufficient funds');\n        }\n\n        await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, senderId]);\n        await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, receiverId]);\n\n        await client.query('COMMIT');\n        return { success: true };\n    } catch (e) {\n        await client.query('ROLLBACK');\n        console.error('Transaction failed', e);\n        throw e;\n    } finally {\n        client.release();\n    }\n}"}
{"instruction": "Construct a SQL query to find the top 3 users who spent the most money in the last 30 days.", "output": "SELECT \n    u.id,\n    u.username,\n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.order_date >= NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.username\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Define a Pydantic model in Python for a 'Product' that validates the price is positive, the SKU follows a specific regex pattern, and includes a nested list of variants.", "output": "from pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\nimport re\n\nclass Variant(BaseModel):\n    color: str\n    size: str\n    stock: int = Field(ge=0)\n\nclass Product(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float = Field(..., gt=0, description=\"Price must be greater than zero\")\n    sku: str = Field(..., pattern=r\"^[A-Z]{3}-\\\\d{4}$\") # Example: ABC-1234\n    variants: List[Variant]\n\n    @validator('name')\n    def name_must_be_capitalized(cls, v):\n        if not v[0].isupper():\n            raise ValueError('Name must start with a capital letter')\n        return v"}
{"instruction": "Create a Node.js script using the 'fs' module promises API to read a JSON file, modify a key, and write it back asynchronously.", "output": "const fs = require('fs/promises');\nconst path = require('path');\n\nasync function updateConfig() {\n    const filePath = path.join(__dirname, 'config.json');\n    \n    try {\n        // Read file\n        const data = await fs.readFile(filePath, 'utf8');\n        const json = JSON.parse(data);\n        \n        // Modify data\n        json.lastUpdated = new Date().toISOString();\n        json.isActive = true;\n        \n        // Write back\n        await fs.writeFile(filePath, JSON.stringify(json, null, 2));\n        console.log('Config updated successfully');\n    } catch (err) {\n        console.error('Error updating config:', err);\n    }\n}\n\nupdateConfig();"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM employees;"}
{"instruction": "Implement a FastAPI dependency that validates a JWT token from the Authorization header and retrieves the current user.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    # Assume get_user_by_username is an async function defined elsewhere\n    user = await get_user_by_username(username)\n    if user is None:\n        raise credentials_exception\n    return user"}
{"instruction": "Create a basic FastAPI async endpoint that fetches data from an external public API (e.g., https://api.publicapis.org/entries) using the 'httpx' library and returns the count of entries.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-data\")\nasync def get_external_data():\n    url = \"https://api.publicapis.org/entries\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            data = response.json()\n            return {\"count\": data.get(\"count\"), \"status\": \"success\"}\n        except httpx.HTTPError as e:\n            raise HTTPException(status_code=500, detail=str(e))"}
{"instruction": "Write SQL DDL statements to create two tables: 'users' (id, username, email) and 'posts' (id, user_id, title, content, created_at). Ensure 'posts' references 'users' with a foreign key that cascades on delete.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Create a Node.js Express middleware function that logs the HTTP method, URL, and timestamp for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] ${req.method} ${req.url}`);\n    next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n    res.send('Hello World');\n});"}
{"instruction": "Define a Pydantic model in Python for a user registration request. Fields: 'username' (string, min 3 chars), 'email' (valid email), 'age' (int, optional, gt 18), and 'tags' (list of strings).", "output": "from pydantic import BaseModel, EmailStr, Field\nfrom typing import List, Optional\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3)\n    email: EmailStr\n    age: Optional[int] = Field(None, gt=18)\n    tags: List[str] = []"}
{"instruction": "Write a raw SQL query to find the top 5 customers who have spent the most money, based on an 'orders' table with columns 'customer_id' and 'total_amount'.", "output": "SELECT customer_id, SUM(total_amount) as total_spent\nFROM orders\nGROUP BY customer_id\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Using Node.js 'fs/promises', write an async function that reads a JSON file named 'config.json', parses it, and returns the 'database_url' property.", "output": "const fs = require('fs/promises');\n\nasync function getDatabaseUrl() {\n    try {\n        const data = await fs.readFile('config.json', 'utf8');\n        const config = JSON.parse(data);\n        return config.database_url;\n    } catch (error) {\n        console.error('Error reading config:', error);\n        throw error;\n    }\n}"}
{"instruction": "Create a FastAPI dependency function that creates a database session using SQLAlchemy's async engine, yields the session, and closes it after the request is finished.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Node.js Mongoose schema for a 'Product' with fields: name (string, required), price (number, min 0), category (string, enum ['electronics', 'clothing', 'home']), and inStock (boolean, default true).", "output": "const mongoose = require('mongoose');\n\nconst productSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true\n    },\n    price: {\n        type: Number,\n        min: 0,\n        required: true\n    },\n    category: {\n        type: String,\n        enum: ['electronics', 'clothing', 'home'],\n        required: true\n    },\n    inStock: {\n        type: Boolean,\n        default: true\n    }\n});\n\nconst Product = mongoose.model('Product', productSchema);"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and saves it to disk asynchronously using 'aiofiles'.", "output": "from fastapi import FastAPI, UploadFile, File\nimport aiofiles\n\napp = FastAPI()\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile = File(...)):\n    file_location = f\"files/{file.filename}\"\n    async with aiofiles.open(file_location, 'wb') as out_file:\n        content = await file.read()\n        await out_file.write(content)\n    return {\"info\": f\"file '{file.filename}' saved at '{file_location}'\"}"}
{"instruction": "Write a SQL query to select all employees from an 'employees' table who were hired in the last 30 days.", "output": "SELECT *\nFROM employees\nWHERE hire_date >= NOW() - INTERVAL '30 days';"}
{"instruction": "Create a FastAPI endpoint to register a user using Pydantic for input validation and Passlib (bcrypt) for password hashing.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nfake_db = {}\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n@app.post(\"/register\")\nasync def register(user: UserCreate):\n    if user.email in fake_db:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = get_password_hash(user.password)\n    fake_db[user.email] = {\n        \"username\": user.username,\n        \"hashed_password\": hashed_password\n    }\n    return {\"message\": \"User created successfully\", \"username\": user.username}"}
{"instruction": "Write SQL statements to create a normalized schema for a Blog system containing 'Authors', 'Posts', and 'Tags', where Posts and Tags have a many-to-many relationship.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    author_id INT REFERENCES authors(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- Junction table for Many-to-Many relationship\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Implement a Node.js function using `fs/promises` to asynchronously read a directory and return a list of only `.txt` files.", "output": "const fs = require('fs/promises');\nconst path = require('path');\n\nasync function getTextFiles(directoryPath) {\n  try {\n    const files = await fs.readdir(directoryPath);\n    const textFiles = files.filter(file => path.extname(file) === '.txt');\n    return textFiles;\n  } catch (err) {\n    console.error('Error reading directory:', err);\n    throw err;\n  }\n}\n\n// Usage example:\n// getTextFiles('./data').then(console.log);"}
{"instruction": "Implement a FastAPI endpoint that accepts a payload and triggers a background task (simulated email sending) without blocking the HTTP response.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(5)\n    print(f\"Sent email to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a PostgreSQL recursive CTE (Common Table Expression) query to find all subordinates of a specific manager (Manager ID 1) in an `employees` table containing `id`, `name`, and `manager_id`.", "output": "WITH RECURSIVE subordinates AS (\n    -- Base case: direct reports\n    SELECT id, name, manager_id\n    FROM employees\n    WHERE manager_id = 1\n    \n    UNION ALL\n    \n    -- Recursive step: reports of reports\n    SELECT e.id, e.name, e.manager_id\n    FROM employees e\n    INNER JOIN subordinates s ON e.manager_id = s.id\n)\nSELECT * FROM subordinates;"}
{"instruction": "Create an async Express.js middleware that validates a JWT token extracted from the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = async (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) return res.sendStatus(401);\n\n  try {\n    // Verify is synchronous usually, but wrapping in logic for async context\n    const user = await new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n        if (err) reject(err);\n        resolve(user);\n      });\n    });\n    req.user = user;\n    next();\n  } catch (err) {\n    return res.sendStatus(403);\n  }\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Create a FastAPI database dependency that yields a SQLAlchemy session and ensures the session is closed after the request is finished.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # db is available here and closes automatically after request\n    return []"}
{"instruction": "Write a SQL transaction block to safely transfer $100 from Account A (id=1) to Account B (id=2), ensuring ACID compliance.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE id = 1 AND balance >= 100;\n\n-- Check if update happened (logic usually handled in app code, but SQL constraint prevents negative balance)\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE id = 2;\n\nCOMMIT;"}
{"instruction": "Create a Node.js HTTP server that pipes a large video file to the response using streams to prevent memory overload.", "output": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  const filePath = './large-video.mp4';\n  const stat = fs.statSync(filePath);\n\n  res.writeHead(200, {\n    'Content-Type': 'video/mp4',\n    'Content-Length': stat.size\n  });\n\n  const readStream = fs.createReadStream(filePath);\n  \n  // Pipe the read stream to the response (write stream)\n  readStream.pipe(res);\n\n  readStream.on('error', (err) => {\n    res.end(err);\n  });\n});\n\nserver.listen(3000, () => console.log('Server streaming on port 3000'));"}
{"instruction": "Build a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously fetches data from an external public API (e.g., https://api.publicapis.org/entries) using `httpx` and returns a filtered list of entries where the category is 'Animals'.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/animals\")\nasync def get_animals():\n    url = \"https://api.publicapis.org/entries\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            data = response.json()\n            \n            # Filter entries where Category is 'Animals'\n            animals = [entry for entry in data.get('entries', []) if entry.get('Category') == 'Animals']\n            return {\"count\": len(animals), \"data\": animals}\n        except httpx.HTTPError as e:\n            raise HTTPException(status_code=503, detail=f\"External API error: {str(e)}\")"}
{"instruction": "Write a raw SQL schema definition for a simple E-commerce system containing three tables: `users`, `products`, and `orders`. Ensure `orders` references both `users` and `products` via foreign keys, and include a timestamp for when the order was placed.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);"}
{"instruction": "Using Node.js and Express, create a middleware function that logs the HTTP method, the request URL, and the time elapsed for the request to complete.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  const { method, url } = req;\n\n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${method} ${url} - ${res.statusCode} [${duration}ms]`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Define SQLAlchemy (Python) models to represent a Many-to-Many relationship between `Student` and `Course`. A student can enroll in many courses, and a course can have many students.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    # Relationship to Course\n    courses = relationship(\"Course\", secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    # Relationship to Student\n    students = relationship(\"Student\", secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Write a Node.js function using the `pg` (node-postgres) library to asynchronously retrieve a user by email. Use parameterized queries to prevent SQL injection.", "output": "const { Pool } = require('pg');\nconst pool = new Pool(); // Assuming env vars are set\n\nasync function getUserByEmail(email) {\n  const queryText = 'SELECT id, username, email FROM users WHERE email = $1';\n  const values = [email];\n\n  try {\n    const res = await pool.query(queryText, values);\n    if (res.rows.length > 0) {\n      return res.rows[0];\n    }\n    return null;\n  } catch (err) {\n    console.error('Database query error', err.stack);\n    throw err;\n  }\n}"}
{"instruction": "Create a Pydantic V2 model in Python for a User Registration payload. It must validate that the email is valid, the password is at least 8 characters long, and the age is 18 or older.", "output": "from pydantic import BaseModel, EmailStr, Field, field_validator\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8, description=\"Password must be at least 8 chars\")\n    age: int\n\n    @field_validator('age')\n    @classmethod\n    def check_age(cls, v: int) -> int:\n        if v < 18:\n            raise ValueError('User must be at least 18 years old')\n        return v"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money in the last 30 days. Assume tables: `customers` (id, name) and `orders` (customer_id, total_amount, created_at).", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a FastAPI dependency that handles database session management. It should create a new session for a request and ensure it is closed (or rolled back on error) after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\n# Assuming SessionLocal is defined elsewhere via sessionmaker\n# from db import SessionLocal \n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\n# Usage in endpoint:\n# @app.get(\"/users\")\n# def read_users(db: Session = Depends(get_db)):\n#     ..."}
{"instruction": "Using Node.js and Mongoose, define a Schema for a 'BlogPost' that includes a title, a body, an array of tags, and a 'published' boolean. Add a virtual property to get a snippet of the body (first 50 characters).", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst blogPostSchema = new Schema({\n  title: { type: String, required: true },\n  body: { type: String, required: true },\n  tags: [String],\n  published: { type: Boolean, default: false },\n  createdAt: { type: Date, default: Date.now }\n});\n\n// Virtual for snippet\nblogPostSchema.virtual('snippet').get(function() {\n  if (!this.body) return '';\n  return this.body.length > 50 ? this.body.substring(0, 50) + '...' : this.body;\n});\n\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);"}
{"instruction": "Write a Python function using `asyncio` that simulates processing a batch of data. It should take a list of IDs, process them concurrently using a semaphore to limit concurrency to 3 tasks at a time.", "output": "import asyncio\nimport random\n\nasync def process_item(item_id: int, semaphore: asyncio.Semaphore):\n    async with semaphore:\n        print(f\"Processing {item_id}...\")\n        # Simulate IO work\n        await asyncio.sleep(random.uniform(0.5, 1.5))\n        print(f\"Finished {item_id}\")\n        return f\"Result for {item_id}\"\n\nasync def process_batch(ids: list[int]):\n    semaphore = asyncio.Semaphore(3)\n    tasks = [process_item(i, semaphore) for i in ids]\n    results = await asyncio.gather(*tasks)\n    return results\n\n# Usage:\n# asyncio.run(process_batch([1, 2, 3, 4, 5, 6, 7, 8]))"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously fetches data from an external weather API using the `httpx` library and returns a filtered JSON response.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/weather/{city}\")\nasync def get_weather(city: str):\n    url = f\"https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q={city}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        \n    if response.status_code != 200:\n        raise HTTPException(status_code=404, detail=\"City not found\")\n        \n    data = response.json()\n    return {\n        \"city\": data[\"location\"][\"name\"],\n        \"temperature_c\": data[\"current\"][\"temp_c\"],\n        \"condition\": data[\"current\"][\"condition\"][\"text\"]\n    }"}
{"instruction": "Write a raw SQL schema for a PostgreSQL database defining a Many-to-Many relationship between `users` and `groups`.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE groups (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) NOT NULL,\n    description TEXT\n);\n\nCREATE TABLE user_groups (\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    group_id INT REFERENCES groups(id) ON DELETE CASCADE,\n    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, group_id)\n);"}
{"instruction": "Create a Node.js Express middleware function that validates a JWT token from the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Define a SQLAlchemy (Python) model for an 'Order' that includes a relationship to 'OrderItems' and a calculated property for total price.", "output": "from sqlalchemy import Column, Integer, ForeignKey, Float\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass OrderItem(Base):\n    __tablename__ = 'order_items'\n    id = Column(Integer, primary_key=True)\n    order_id = Column(Integer, ForeignKey('orders.id'))\n    price = Column(Float, nullable=False)\n    quantity = Column(Integer, default=1)\n\nclass Order(Base):\n    __tablename__ = 'orders'\n    id = Column(Integer, primary_key=True)\n    items = relationship(\"OrderItem\", backref=\"order\")\n\n    @property\n    def total_price(self):\n        return sum(item.price * item.quantity for item in self.items)"}
{"instruction": "Write a Node.js function using `pg` (node-postgres) to perform a database transaction that transfers funds between two accounts.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1', [fromAccountId]);\n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromAccountId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toAccountId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a Pydantic model in Python for a User Registration API that validates the password strength and ensures the age is over 18.", "output": "from pydantic import BaseModel, EmailStr, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n    age: int\n\n    @field_validator('age')\n    def check_age(cls, v):\n        if v < 18:\n            raise ValueError('User must be at least 18 years old')\n        return v\n\n    @field_validator('password')\n    def validate_password(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters')\n        if not re.search(r\"[A-Z]\", v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r\"[0-9]\", v):\n            raise ValueError('Password must contain at least one number')\n        return v"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a Mongoose (Node.js) schema for a 'Product' with an async pre-save hook to automatically generate a slug from the product title.", "output": "const mongoose = require('mongoose');\nconst slugify = require('slugify');\n\nconst productSchema = new mongoose.Schema({\n  title: {\n    type: String,\n    required: true\n  },\n  slug: {\n    type: String,\n    unique: true\n  },\n  price: Number\n});\n\nproductSchema.pre('save', async function(next) {\n  if (this.isModified('title') || this.isNew) {\n    this.slug = slugify(this.title, { lower: true, strict: true });\n    // Check for collision logic would go here\n  }\n  next();\n});\n\nmodule.exports = mongoose.model('Product', productSchema);"}
{"instruction": "Write a SQL query to select all users who have NOT placed an order in the last 6 months.", "output": "SELECT u.id, u.email\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id \n    AND o.created_at > NOW() - INTERVAL '6 months'\nWHERE o.id IS NULL;"}
{"instruction": "Create a FastAPI endpoint for user registration that validates input using Pydantic, hashes the password using passlib, and saves the user asynchronously to a hypothetical database.", "output": "from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\nfrom typing import Optional\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# Mock Database\nfake_users_db = {}\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    username: str\n    email: str\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n@app.post(\"/register\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def register_user(user: UserCreate):\n    if user.email in fake_users_db:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = get_password_hash(user.password)\n    \n    # Simulate async DB save\n    user_entry = {\n        \"username\": user.username,\n        \"email\": user.email,\n        \"hashed_password\": hashed_password\n    }\n    fake_users_db[user.email] = user_entry\n    \n    return user_entry"}
{"instruction": "Write a SQL schema (PostgreSQL compatible) for a simple blog system containing 'users', 'posts', and 'comments'. Ensure proper foreign key constraints and timestamps.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE SET NULL,\n    body TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Implement a Node.js Express middleware function that checks for a valid API key in the 'x-api-key' header. If missing or invalid, return a 401 Unauthorized response.", "output": "const VALID_API_KEY = process.env.API_KEY || 'my-secret-key';\n\nconst apiKeyAuth = (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n\n  if (!apiKey || apiKey !== VALID_API_KEY) {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Invalid or missing API key'\n    });\n  }\n\n  next();\n};\n\n// Usage example:\n// app.use('/api', apiKeyAuth);"}
{"instruction": "Create a FastAPI dependency using SQLAlchemy to manage database sessions. The dependency should yield a session and ensure it closes after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom fastapi import Depends\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money in the last 30 days. Assume tables: 'orders' (id, user_id, total_amount, created_at) and 'users' (id, name).", "output": "SELECT \n    u.name,\n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Using Node.js, create an asynchronous function that reads a JSON file, parses it, modifies a specific property, and writes it back to disk. Handle errors appropriately.", "output": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function updateConfig(filePath, key, value) {\n  try {\n    // Read file asynchronously\n    const data = await fs.readFile(filePath, 'utf8');\n    \n    // Parse JSON\n    const config = JSON.parse(data);\n    \n    // Modify property\n    config[key] = value;\n    \n    // Write back to file\n    await fs.writeFile(filePath, JSON.stringify(config, null, 2));\n    console.log('Config updated successfully');\n    \n  } catch (error) {\n    console.error('Error updating config:', error.message);\n    throw error;\n  }\n}"}
{"instruction": "Implement a FastAPI WebSocket endpoint that accepts a connection, receives text messages, and echoes them back to the client with a 'Message received: ' prefix until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to fetch a category hierarchy (tree structure) starting from a root category. Table 'categories' has columns: id, name, parent_id.", "output": "WITH RECURSIVE category_tree AS (\n    -- Anchor member: select the root category (e.g., id = 1)\n    SELECT id, name, parent_id, 1 as level\n    FROM categories\n    WHERE id = 1\n    \n    UNION ALL\n    \n    -- Recursive member: join with the previous result\n    SELECT c.id, c.name, c.parent_id, ct.level + 1\n    FROM categories c\n    INNER JOIN category_tree ct ON c.parent_id = ct.id\n)\nSELECT * FROM category_tree;"}
{"instruction": "Create a Node.js Express route that handles a POST request to upload a file using 'multer', validates the file type (only images allowed), and returns the file path.", "output": "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\n\nconst app = express();\n\n// Configure storage\nconst storage = multer.diskStorage({\n  destination: './uploads/',\n  filename: (req, file, cb) => {\n    cb(null, Date.now() + path.extname(file.originalname));\n  }\n});\n\n// File filter for images\nconst fileFilter = (req, file, cb) => {\n  if (file.mimetype.startsWith('image/')) {\n    cb(null, true);\n  } else {\n    cb(new Error('Only images are allowed!'), false);\n  }\n};\n\nconst upload = multer({ storage: storage, fileFilter: fileFilter });\n\napp.post('/upload', upload.single('avatar'), (req, res) => {\n  try {\n    res.json({ \n      message: 'File uploaded successfully', \n      path: req.file.path \n    });\n  } catch (err) {\n    res.status(400).send({ error: err.message });\n  }\n});"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user successfully creates an account, ensuring the API response is not blocked by the simulated delay.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate blocking I/O operation\n    time.sleep(2)\n    print(f\"Sent welcome email to {email}\")\n\n@app.post(\"/users/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    # Add task to be run after response is sent\n    background_tasks.add_task(send_welcome_email, email)\n    return {\"message\": \"User created. Email will be sent shortly.\"}"}
{"instruction": "Create a FastAPI async endpoint that creates a new 'Item'. It should validate the input using a Pydantic model (containing name, price, and an optional description) and return the created item with a generated ID.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport uuid\n\napp = FastAPI()\n\nclass ItemSchema(BaseModel):\n    name: str\n    price: float\n    description: Optional[str] = None\n\nclass ItemResponse(ItemSchema):\n    id: str\n\n@app.post(\"/items/\", response_model=ItemResponse)\nasync def create_item(item: ItemSchema):\n    # Simulate async database insertion\n    new_id = str(uuid.uuid4())\n    item_dict = item.dict()\n    item_dict[\"id\"] = new_id\n    \n    # In a real app: await database.execute(...)\n    \n    return item_dict"}
{"instruction": "Write a Node.js (Express) middleware function that verifies a JWT token from the 'Authorization' header. If valid, attach the user to the request object; otherwise, return a 401 status.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <TOKEN>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Write a SQL DDL script to create a schema for a 'Blog' system. It requires a 'users' table and a 'posts' table. One user can have many posts. Ensure foreign keys and timestamps are included.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n        FOREIGN KEY(user_id) \n        REFERENCES users(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Create a FastAPI dependency that yields a database session using SQLAlchemy. Then, write a route that uses this dependency to fetch a specific user by ID.", "output": "from fastapi import Depends, FastAPI, HTTPException\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal, engine, Base\nfrom . import models\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\")\ndef read_user(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(models.User).filter(models.User.id == user_id).first()\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user"}
{"instruction": "Using Node.js, write a function that performs three asynchronous API calls (e.g., fetching user data, orders, and notifications) concurrently using Promise.all and returns a combined object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function loadDashboardData(userId) {\n  try {\n    const [user, orders, notifications] = await Promise.all([\n      fetch(`https://api.example.com/users/${userId}`).then(res => res.json()),\n      fetch(`https://api.example.com/orders/${userId}`).then(res => res.json()),\n      fetch(`https://api.example.com/notifications/${userId}`).then(res => res.json())\n    ]);\n\n    return {\n      user,\n      orders,\n      notifications,\n      timestamp: new Date()\n    };\n  } catch (error) {\n    console.error(\"Failed to load dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a FastAPI WebSocket endpoint that accepts a connection, listens for messages, and echoes the message back to the client reversed.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Using Node.js 'fs' and 'readline' modules, write a script to process a massive CSV file line-by-line asynchronously without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line here (e.g., parse CSV, insert to DB)\n    const columns = line.split(',');\n    console.log(`Processing ID: ${columns[0]}`);\n  }\n}"}
{"instruction": "Write a complex SQL query to find the top 5 customers who have spent the most money in the last 30 days. Assume tables 'customers' (id, name) and 'orders' (customer_id, total_amount, created_at).", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a FastAPI route that accepts an email address, schedules a background task to send a welcome email, and immediately returns a success message to the user.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate a long-running email sending operation\n    print(f\"Sending email to {email}...\")\n    # time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_welcome_email, email)\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Create a Python FastAPI endpoint using async/await that fetches data from an external API (e.g., https://api.example.com/users/{id}), processes the JSON to extract the username and email, and returns a simplified dictionary. Handle potential HTTP errors.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/user-summary/{user_id}\")\nasync def get_user_summary(user_id: int):\n    url = f\"https://api.example.com/users/{user_id}\"\n    \n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n        except httpx.RequestError:\n            raise HTTPException(status_code=503, detail=\"Service unavailable\")\n\n    data = response.json()\n    \n    # Process and return simplified data\n    return {\n        \"id\": data.get(\"id\"),\n        \"username\": data.get(\"username\"),\n        \"email\": data.get(\"email\"),\n        \"status\": \"active\" if data.get(\"is_active\") else \"inactive\"\n    }"}
{"instruction": "Write the SQL DDL commands to create a PostgreSQL schema for a Blog system. It requires three tables: 'authors' (id, name, email), 'posts' (id, title, content, published_at, author_id), and 'tags' (id, name). Include a many-to-many relationship table between posts and tags called 'post_tags'. Ensure proper foreign keys and a unique constraint on the tag name.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(150) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    author_id INT NOT NULL REFERENCES authors(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);\n\n-- Optional: Add index for performance\nCREATE INDEX idx_posts_author ON posts(author_id);"}
{"instruction": "Create a Node.js Express middleware function that validates a JWT (JSON Web Token) found in the 'Authorization' header (Bearer schema). If valid, attach the decoded user to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token missing' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid or expired token' });\n    }\n    \n    // Attach user payload to request\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Using Python's SQLAlchemy (ORM), define the models for a 'Department' and 'Employee' relationship. A Department can have multiple Employees (One-to-Many). Include the necessary columns and relationship directives.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\nclass Department(Base):\n    __tablename__ = 'departments'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    \n    # Relationship to Employee\n    employees = relationship(\"Employee\", back_populates=\"department\")\n\nclass Employee(Base):\n    __tablename__ = 'employees'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\n    email = Column(String, unique=True)\n    department_id = Column(Integer, ForeignKey('departments.id'))\n    \n    # Relationship back to Department\n    department = relationship(\"Department\", back_populates=\"employees\")"}
{"instruction": "Write a Node.js function using async/await that performs three independent asynchronous tasks (simulated by helper functions) in parallel using Promise.all to optimize performance, rather than awaiting them sequentially. Return an object aggregating the results.", "output": "async function getUserDashboardData(userId) {\n  // Simulated async fetch functions\n  const fetchProfile = () => new Promise(resolve => setTimeout(() => resolve({ name: 'Alice' }), 100));\n  const fetchOrders = () => new Promise(resolve => setTimeout(() => resolve([101, 102]), 150));\n  const fetchNotifications = () => new Promise(resolve => setTimeout(() => resolve(5), 50));\n\n  try {\n    // Execute in parallel\n    const [profile, orders, notificationCount] = await Promise.all([\n      fetchProfile(),\n      fetchOrders(),\n      fetchNotifications()\n    ]);\n\n    return {\n      userId,\n      profile,\n      orders,\n      notificationCount,\n      timestamp: new Date()\n    };\n  } catch (error) {\n    console.error(\"Error fetching dashboard data:\", error);\n    throw error;\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to calculate the 'Running Total' of revenue for each day, ordered by date. The table 'sales' has columns: id, sale_date, and amount.", "output": "SELECT \n    sale_date,\n    amount,\n    SUM(amount) OVER (ORDER BY sale_date) as running_total\nFROM \n    sales\nORDER BY \n    sale_date;"}
{"instruction": "Implement a Python FastAPI WebSocket endpoint that accepts connections, receives text messages from a client, and echoes the message back with a 'Server received: ' prefix. Handle the client disconnecting gracefully.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            # Wait for message from client\n            data = await websocket.receive_text()\n            # Echo message back\n            await websocket.send_text(f\"Server received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n        await websocket.close()"}
{"instruction": "Define a Mongoose (Node.js/MongoDB) schema for a 'Product'. It should have a name (string, required), price (number, min 0), tags (array of strings), and a virtual property 'isOnSale' that returns true if the 'discountPercentage' field is greater than 0.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst productSchema = new Schema({\n  name: {\n    type: String,\n    required: true,\n    trim: true\n  },\n  price: {\n    type: Number,\n    required: true,\n    min: 0\n  },\n  discountPercentage: {\n    type: Number,\n    default: 0,\n    min: 0,\n    max: 100\n  },\n  tags: [String]\n}, {\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Virtual property\nproductSchema.virtual('isOnSale').get(function() {\n  return this.discountPercentage > 0;\n});\n\nconst Product = mongoose.model('Product', productSchema);"}
{"instruction": "Create a Pydantic model in Python to validate a registration payload. Fields: 'username' (alphanumeric only), 'password' (min 8 chars), 'age' (must be 18+), and 'tags' (list of strings, max 5 items).", "output": "from pydantic import BaseModel, Field, field_validator\nfrom typing import List\nimport re\n\nclass RegistrationForm(BaseModel):\n    username: str = Field(..., min_length=3, max_length=30)\n    password: str = Field(..., min_length=8)\n    age: int = Field(..., ge=18)\n    tags: List[str] = Field(default_factory=list, max_length=5)\n\n    @field_validator('username')\n    def validate_username(cls, v):\n        if not re.match(\"^[a-zA-Z0-9]+$\", v):\n            raise ValueError('Username must be alphanumeric')\n        return v"}
{"instruction": "Write a Node.js script using the 'fs' and 'readline' modules to process a massive CSV file line-by-line (streams) to avoid loading the whole file into memory. Log the line count at the end.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Process line here (e.g., split by comma)\n    lineCount++;\n  }\n\n  console.log(`Finished processing. Total lines: ${lineCount}`);\n}\n\n// Usage: processLargeFile('./huge_data.csv');"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to create a new item. The endpoint should accept a POST request at '/items/', validate that the 'price' is positive, and return the item with a generated ID.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\nimport uuid\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float = Field(..., gt=0, description=\"The price must be greater than zero\")\n    tax: Optional[float] = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    item_dict = item.dict()\n    if item.tax:\n        price_with_tax = item.price + item.tax\n        item_dict.update({\"price_with_tax\": price_with_tax})\n    \n    # Simulate database ID generation\n    item_dict[\"id\"] = str(uuid.uuid4())\n    return item_dict"}
{"instruction": "Write the SQL DDL commands to define a many-to-many relationship between 'Students' and 'Courses' using PostgreSQL syntax. Include primary keys and foreign keys.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    first_name VARCHAR(100) NOT NULL,\n    last_name VARCHAR(100) NOT NULL,\n    email VARCHAR(150) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    course_name VARCHAR(100) NOT NULL,\n    course_code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    FOREIGN KEY (student_id) REFERENCES students(student_id) ON DELETE CASCADE,\n    FOREIGN KEY (course_id) REFERENCES courses(course_id) ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js Express middleware function that validates a JWT token from the 'Authorization' header. If the token is missing or invalid, return a 401 or 403 status.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Header format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) {\n    return res.status(401).json({ message: 'No token provided' });\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid token' });\n    }\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Create a FastAPI dependency that manages a SQLAlchemy database session. It should yield the session to the path operation and ensure the session is closed after the request is finished.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a Node.js function using the 'pg' library (node-postgres) to asynchronously fetch a user by email using a parameterized query to prevent SQL injection.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function getUserByEmail(email) {\n  const query = 'SELECT * FROM users WHERE email = $1';\n  const values = [email];\n\n  try {\n    const res = await pool.query(query, values);\n    if (res.rows.length > 0) {\n      return res.rows[0];\n    } else {\n      return null;\n    }\n  } catch (err) {\n    console.error('Database query error', err.stack);\n    throw err;\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments. The output should include employee name, department, salary, and rank.", "output": "SELECT \n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a FastAPI endpoint that triggers a background task (e.g., sending a welcome email) so the API can return a response immediately without waiting for the task to complete.", "output": "from fastapi import BackgroundTasks, FastAPI\n\napp = FastAPI()\n\ndef write_notification(email: str, message=\"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, email, message=\"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Create a Node.js script using Streams to read a large text file named 'input.txt', transform the text to uppercase, and write it to 'output.txt' to minimize memory usage.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst readStream = fs.createReadStream('input.txt', { encoding: 'utf8' });\nconst writeStream = fs.createWriteStream('output.txt');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\nreadStream\n  .pipe(upperCaseTransform)\n  .pipe(writeStream)\n  .on('finish', () => console.log('File processing completed.'));"}
{"instruction": "Write a SQL query to find customers who have placed orders in the last 30 days but have not made a payment in that same timeframe.", "output": "SELECT DISTINCT c.customer_id, c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE o.order_date >= NOW() - INTERVAL '30 days'\nAND c.customer_id NOT IN (\n    SELECT p.customer_id\n    FROM payments p\n    WHERE p.payment_date >= NOW() - INTERVAL '30 days'\n);"}
{"instruction": "Create a basic WebSocket endpoint in FastAPI that accepts a client connection and echoes back any text message received.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy that registers a new user. The code should hash the password using 'passlib' before saving the user to the database.", "output": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\nfrom .database import get_db, UserModel  # Assuming these exist\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nrouter = APIRouter()\n\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n@router.post(\"/users/\")\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    hashed_password = pwd_context.hash(user.password)\n    db_user = UserModel(email=user.email, hashed_password=hashed_password)\n    \n    existing_user = db.query(UserModel).filter(UserModel.email == user.email).first()\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return {\"id\": db_user.id, \"email\": db_user.email}"}
{"instruction": "Write a raw SQL schema definition for an 'orders' table. It should include a primary key, a foreign key to a 'users' table, a total amount (decimal), a status (ENUM: pending, shipped, delivered), and an automatic 'created_at' timestamp.", "output": "CREATE TYPE order_status AS ENUM ('pending', 'shipped', 'delivered');\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    total_amount DECIMAL(10, 2) NOT NULL,\n    status order_status DEFAULT 'pending',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n      FOREIGN KEY(user_id) \n      REFERENCES users(id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Using Node.js and the 'knex' query builder, write an asynchronous function that performs a transaction to transfer funds between two users. If either update fails, the transaction must roll back.", "output": "const knex = require('./db'); // knex instance\n\nasync function transferFunds(senderId, receiverId, amount) {\n  try {\n    await knex.transaction(async (trx) => {\n      const sender = await trx('users').where('id', senderId).first();\n      if (!sender || sender.balance < amount) {\n        throw new Error('Insufficient funds or invalid sender');\n      }\n\n      await trx('users')\n        .where('id', senderId)\n        .decrement('balance', amount);\n\n      await trx('users')\n        .where('id', receiverId)\n        .increment('balance', amount);\n    });\n    console.log('Transfer successful');\n  } catch (error) {\n    console.error('Transfer failed:', error.message);\n    throw error;\n  }\n}"}
{"instruction": "Implement a FastAPI endpoint that fetches data from two different external APIs concurrently using 'httpx' and 'asyncio.gather' to reduce latency.", "output": "import asyncio\nimport httpx\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\nasync def fetch_url(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@router.get(\"/dashboard-data\")\nasync def get_dashboard_data():\n    async with httpx.AsyncClient() as client:\n        weather_url = \"https://api.weather.com/v1/current\"\n        stocks_url = \"https://api.stocks.com/v1/summary\"\n        \n        # Run requests concurrently\n        weather_task = fetch_url(client, weather_url)\n        stocks_task = fetch_url(client, stocks_url)\n        \n        weather_data, stocks_data = await asyncio.gather(weather_task, stocks_task)\n        \n    return {\n        \"weather\": weather_data,\n        \"stocks\": stocks_data\n    }"}
{"instruction": "Create a Node.js Express middleware that wraps async route handlers to catch errors automatically and pass them to the global error handler, avoiding repeated try-catch blocks.", "output": "const asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Usage example:\n// app.get('/users', asyncHandler(async (req, res) => {\n//    const users = await db.getUsers();\n//    res.json(users);\n// }));\n\nmodule.exports = asyncHandler;"}
{"instruction": "Design a Pydantic model in Python for a 'Product' with a nested 'Category' object. Include a custom validator to ensure the product price is positive.", "output": "from pydantic import BaseModel, field_validator\nfrom typing import List, Optional\n\nclass Category(BaseModel):\n    id: int\n    name: str\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    price: float\n    tags: List[str] = []\n    category: Category\n\n    @field_validator('price')\n    @classmethod\n    def price_must_be_positive(cls, v: float) -> float:\n        if v <= 0:\n            raise ValueError('Price must be greater than zero')\n        return v"}
{"instruction": "Using SQL, create a Many-to-Many schema for a 'Students' and 'Classes' relationship, including an 'enrollment_date' in the junction table.", "output": "CREATE TABLE students (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE classes (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INTEGER NOT NULL,\n    class_id INTEGER NOT NULL,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, class_id),\n    CONSTRAINT fk_student FOREIGN KEY (student_id) REFERENCES students(id),\n    CONSTRAINT fk_class FOREIGN KEY (class_id) REFERENCES classes(id)\n);"}
{"instruction": "Create a FastAPI Background Task that processes a log message after returning a response to the user, ensuring the API request is not blocked by the logging operation.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef write_log(message: str):\n    # Simulate a blocking I/O operation\n    time.sleep(2)\n    with open(\"log.txt\", \"a\") as log_file:\n        log_file.write(f\"{message}\\n\")\n\n@router.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_log, f\"Notification sent to {email}\")\n    return {\"message\": \"Notification scheduled\"}"}
{"instruction": "Using Node.js and the 'pg' (node-postgres) library, create a function to search for products using a parameterized query with ILIKE for case-insensitive fuzzy matching.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function searchProducts(searchTerm) {\n  const query = `\n    SELECT id, name, description, price \n    FROM products \n    WHERE name ILIKE $1 OR description ILIKE $1\n  `;\n  \n  // Add wildcards for fuzzy matching\n  const values = [`%${searchTerm}%`];\n\n  try {\n    const res = await pool.query(query, values);\n    return res.rows;\n  } catch (err) {\n    console.error('Database query error', err.stack);\n    throw err;\n  }\n}"}
{"instruction": "Implement a pagination dependency in FastAPI that extracts 'skip' and 'limit' query parameters and applies them to a SQLAlchemy query.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n\n# Dependency\ndef pagination_params(skip: int = 0, limit: int = 100):\n    return {\"skip\": skip, \"limit\": limit}\n\n@app.get(\"/items/\")\ndef read_items(commons: dict = Depends(pagination_params), db: Session = Depends(get_db)):\n    # commons contains {'skip': ..., 'limit': ...}\n    items = db.query(Item).offset(commons['skip']).limit(commons['limit']).all()\n    return items"}
{"instruction": "Create a FastAPI endpoint that accepts a user registration payload and triggers a simulated email notification as a background task, ensuring the HTTP response is returned immediately.", "output": "from fastapi import FastAPI, BackgroundTasks, status\nfrom pydantic import BaseModel\nimport asyncio\n\napp = FastAPI()\n\nclass UserIn(BaseModel):\n    email: str\n    username: str\n\nasync def send_welcome_email(email: str):\n    # Simulate a long-running I/O task\n    await asyncio.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register\", status_code=status.HTTP_202_ACCEPTED)\nasync def register_user(user: UserIn, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_welcome_email, user.email)\n    return {\"message\": \"Registration successful. Email will be sent shortly.\"}"}
{"instruction": "Write a raw SQL schema definition for a Many-to-Many relationship between 'Students' and 'Courses' in a PostgreSQL database, including primary keys and foreign keys.", "output": "CREATE TABLE students (\n    student_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(150) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE courses (\n    course_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    credits INT CHECK (credits > 0)\n);\n\nCREATE TABLE student_courses (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrollment_date DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    CONSTRAINT fk_student\n      FOREIGN KEY(student_id) \n      REFERENCES students(student_id)\n      ON DELETE CASCADE,\n    CONSTRAINT fk_course\n      FOREIGN KEY(course_id) \n      REFERENCES courses(course_id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js function using the 'pg' (node-postgres) library to perform an atomic bank transfer between two accounts using async/await and SQL transactions.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Deduct from sender\n    const senderRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n    \n    if (senderRes.rows.length === 0 || senderRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a Pydantic model in Python to validate a product creation payload. It must ensure the price is positive, the name is not empty, and tags are a list of unique strings.", "output": "from pydantic import BaseModel, Field, validator\nfrom typing import List, Set\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1)\n    description: str | None = None\n    price: float = Field(..., gt=0)\n    tags: List[str] = []\n\n    @validator('tags')\n    def unique_tags(cls, v):\n        if len(v) != len(set(v)):\n            raise ValueError('Tags must be unique')\n        return v\n\n# Example usage\n# try:\n#     p = ProductCreate(name=\"Widget\", price=19.99, tags=[\"new\", \"sale\"])\n# except ValidationError as e:\n#     print(e)"}
{"instruction": "Write a SQL query using a Window Function to rank employees by their salary within their respective departments. The output should include employee name, department, salary, and rank.", "output": "SELECT \n    employee_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, \n    salary_rank;"}
{"instruction": "Create a FastAPI dependency function that yields a SQLAlchemy database session, handling the setup and teardown (closing) of the session automatically.", "output": "from sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Implement a simple Node.js Express middleware that logs the HTTP method, URL, and the time taken to process the request (in milliseconds) for every incoming request.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  \n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`[${req.method}] ${req.originalUrl} - ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});"}
{"instruction": "Define a SQLAlchemy ORM model for a 'Book' entity. It should include a UUID primary key, a title, a publication year, and a CheckConstraint to ensure the year is not in the future (e.g., <= 2025).", "output": "import uuid\nfrom sqlalchemy import Column, String, Integer, CheckConstraint\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import declarative_base\n\nBase = declarative_base()\n\nclass Book(Base):\n    __tablename__ = 'books'\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    title = Column(String, nullable=False)\n    publication_year = Column(Integer, nullable=False)\n\n    __table_args__ = (\n        CheckConstraint('publication_year <= 2025', name='check_valid_year'),\n    )"}
{"instruction": "Using Node.js and Mongoose, write an aggregation pipeline to calculate the average rating and total number of reviews for each product in a 'reviews' collection.", "output": "const mongoose = require('mongoose');\nconst Review = mongoose.model('Review');\n\nasync function getProductStats() {\n  return await Review.aggregate([\n    {\n      $group: {\n        _id: \"$productId\",\n        averageRating: { $avg: \"$rating\" },\n        totalReviews: { $sum: 1 }\n      }\n    },\n    {\n      $sort: { averageRating: -1 }\n    }\n  ]);\n}"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts connections and echoes back any text message received from the client, prefixed with 'Echo: '.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new product (name, price, stock), validates it using Pydantic, and returns a confirmation message asynchronously.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str = Field(..., min_length=3)\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\n@app.post(\"/products/\", status_code=201)\nasync def create_product(product: ProductSchema):\n    # Simulate async database operation\n    # await db.products.insert_one(product.dict())\n    return {\n        \"message\": \"Product created successfully\",\n        \"product_name\": product.name,\n        \"status\": \"active\"\n    }"}
{"instruction": "Write a PostgreSQL SQL schema definition for a simple 'Blog' system containing tables for 'users' and 'posts', where a user can have multiple posts (One-to-Many).", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);"}
{"instruction": "Implement a Node.js Express middleware function that validates a JWT token from the 'Authorization' header. If valid, attach the user to the request object; otherwise, return 401.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid or expired token' });\n    }\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Using Python's SQLAlchemy (Async), define a Many-to-Many relationship model between 'Students' and 'Courses'.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nstudent_course_association = Table(\n    \"student_course\",\n    Base.metadata,\n    Column(\"student_id\", ForeignKey(\"students.id\"), primary_key=True),\n    Column(\"course_id\", ForeignKey(\"courses.id\"), primary_key=True),\n)\n\nclass Student(Base):\n    __tablename__ = \"students\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    courses: Mapped[list[\"Course\"]] = relationship(\n        secondary=student_course_association, back_populates=\"students\"\n    )\n\nclass Course(Base):\n    __tablename__ = \"courses\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str] = mapped_column(String(100))\n    students: Mapped[list[\"Student\"]] = relationship(\n        secondary=student_course_association, back_populates=\"courses\"\n    )"}
{"instruction": "Write a Node.js function using `async/await` and the `pg` library to execute a transaction that transfers money between two accounts.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromId, toId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromId]);\n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency that yields an asynchronous database session and ensures the session is closed after the request is finished.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\n\nAsyncSessionLocal = sessionmaker(\n    bind=engine, \n    class_=AsyncSession, \n    expire_on_commit=False\n)\n\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query to calculate the total revenue per month for the current year, assuming an 'orders' table with 'amount' and 'created_at' columns.", "output": "SELECT \n    DATE_TRUNC('month', created_at) AS month,\n    SUM(amount) AS total_revenue\nFROM \n    orders\nWHERE \n    created_at >= DATE_TRUNC('year', CURRENT_DATE)\nGROUP BY \n    1\nORDER BY \n    1 ASC;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a Node.js script using the 'fs' and 'readline' modules to process a large log file line-by-line efficiently (streams) without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line here\n    if (line.includes('ERROR')) {\n      console.log(`Found error: ${line}`);\n    }\n  }\n}\n\nprocessLineByLine('application.log');"}
{"instruction": "Create a FastAPI endpoint that triggers a background task (e.g., sending an email) which runs after the HTTP response is returned to the user.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate a long-running blocking I/O operation\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification scheduled\"}"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new product (name, price, stock), validates it using Pydantic, and returns the created object with a generated ID. Ensure the endpoint is asynchronous.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport uuid\n\napp = FastAPI()\n\nclass ProductBase(BaseModel):\n    name: str\n    price: float\n    stock: int\n    description: Optional[str] = None\n\nclass ProductResponse(ProductBase):\n    id: str\n\n@app.post(\"/products/\", response_model=ProductResponse)\nasync def create_product(product: ProductBase):\n    # Simulate async database operation\n    product_dict = product.dict()\n    product_dict[\"id\"] = str(uuid.uuid4())\n    return product_dict"}
{"instruction": "Write a SQL DDL script (PostgreSQL flavor) to create a schema for a 'Library' system. It should include a 'Authors' table and a 'Books' table. An author can have many books, and the Books table should include a foreign key constraint and an index on the title.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE,\n    author_id INT NOT NULL,\n    CONSTRAINT fk_author\n        FOREIGN KEY(author_id)\n        REFERENCES authors(author_id)\n        ON DELETE CASCADE\n);\n\nCREATE INDEX idx_books_title ON books(title);"}
{"instruction": "Using Node.js and Express, create a middleware function that handles asynchronous errors in route handlers to avoid unhandled promise rejections crashing the server.", "output": "const asyncHandler = (fn) => (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Usage example:\n// app.get('/route', asyncHandler(async (req, res) => {\n//     const data = await database.query();\n//     res.json(data);\n// }));"}
{"instruction": "Write a Python function using SQLAlchemy (AsyncSession) to retrieve a user by email, including their related 'posts' using an eager load option to prevent N+1 query issues.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom sqlalchemy.orm import selectinload\nfrom models import User\n\nasync def get_user_with_posts(session: AsyncSession, email: str):\n    stmt = (\n        select(User)\n        .options(selectinload(User.posts))\n        .where(User.email == email)\n    )\n    result = await session.execute(stmt)\n    return result.scalars().first()"}
{"instruction": "Create a SQL query that calculates the total revenue per month for the year 2023 from an 'orders' table. The table has 'created_at' (timestamp) and 'total_amount' (decimal) columns.", "output": "SELECT \n    EXTRACT(MONTH FROM created_at) AS month,\n    SUM(total_amount) AS total_revenue\nFROM \n    orders\nWHERE \n    created_at >= '2023-01-01' AND created_at < '2024-01-01'\nGROUP BY \n    EXTRACT(MONTH FROM created_at)\nORDER BY \n    month ASC;"}
{"instruction": "Using Node.js, write a function that reads a large JSON file using streams and processes each object as it comes in, rather than loading the whole file into memory.", "output": "const fs = require('fs');\nconst StreamArray = require('stream-json/streamers/StreamArray');\nconst { Writable } = require('stream');\n\nconst processLargeFile = (filePath) => {\n    const fileStream = fs.createReadStream(filePath);\n    const jsonStream = StreamArray.withParser();\n    \n    const processingStream = new Writable({\n        objectMode: true,\n        write(object, encoding, callback) {\n            // object.key is the index, object.value is the actual data\n            console.log('Processing item:', object.value.id);\n            callback();\n        }\n    });\n\n    fileStream.pipe(jsonStream).pipe(processingStream);\n    \n    processingStream.on('finish', () => console.log('Done processing.'));\n};"}
{"instruction": "Implement a FastAPI dependency that verifies a JWT token from the Authorization header. If valid, it returns the decoded user payload; otherwise, it raises a 401 HTTPException.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\n\nSECRET_KEY = \"mysecret\"\nALGORITHM = \"HS256\"\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise ValueError(\"No subject\")\n        return payload\n    except (jwt.PyJWTError, ValueError):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 employees with the highest salaries in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM \n    RankedSalaries\nWHERE \n    rank <= 3;"}
{"instruction": "Create a Node.js function using the 'pg' (node-postgres) library to perform a database transaction. The function should transfer funds from Account A to Account B. If any step fails, roll back the transaction.", "output": "const transferFunds = async (client, fromId, toId, amount) => {\n    try {\n        await client.query('BEGIN');\n        \n        const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [fromId]);\n        if (res.rows[0].balance < amount) {\n            throw new Error('Insufficient funds');\n        }\n\n        await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n        await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n\n        await client.query('COMMIT');\n        return true;\n    } catch (e) {\n        await client.query('ROLLBACK');\n        throw e;\n    }\n};"}
{"instruction": "Implement a Python function using `asyncio` to fetch data from three different URLs concurrently and aggregate the results.", "output": "import asyncio\nimport httpx\n\nasync def fetch_url(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\nasync def aggregate_data():\n    urls = [\n        \"https://api.service.com/users\",\n        \"https://api.service.com/posts\",\n        \"https://api.service.com/comments\"\n    ]\n    async with httpx.AsyncClient() as client:\n        tasks = [fetch_url(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    \n    return {\n        \"users\": results[0],\n        \"posts\": results[1],\n        \"comments\": results[2]\n    }"}
{"instruction": "Create a FastAPI route using Pydantic models to register a user. The route should validate the email format and ensure the password is at least 8 characters long before returning a success message without the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n    id: int\n\n# Mock DB\nfake_db = []\n\n@app.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    # Simulate checking if user exists\n    if any(u['email'] == user.email for u in fake_db):\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    new_user = user.dict()\n    new_user['id'] = len(fake_db) + 1\n    # In reality, hash the password here\n    fake_db.append(new_user)\n    \n    return new_user"}
{"instruction": "Write a PostgreSQL schema for a 'Blog' system. It needs three tables: 'users', 'posts', and 'comments'. Include foreign keys, primary keys, and a constraint that ensures a user cannot be deleted if they have written posts.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_user\n      FOREIGN KEY(user_id) \n      REFERENCES users(id)\n      ON DELETE RESTRICT -- Prevents user deletion if posts exist\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INT NOT NULL,\n    user_id INT NOT NULL,\n    comment_text TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);"}
{"instruction": "Using Node.js and the 'pg' library, write an asynchronous function that performs a database transaction. It should transfer funds from one account to another. If any step fails, roll back the transaction.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromAccountId]\n    );\n\n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI endpoint that aggregates data from two external public APIs asynchronously using `httpx` and `asyncio.gather` to minimize latency.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_data(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-stats\")\nasync def get_dashboard_stats():\n    url_users = \"https://jsonplaceholder.typicode.com/users\"\n    url_todos = \"https://jsonplaceholder.typicode.com/todos\"\n    \n    async with httpx.AsyncClient() as client:\n        # Run both requests concurrently\n        users_resp, todos_resp = await asyncio.gather(\n            fetch_data(client, url_users),\n            fetch_data(client, url_todos)\n        )\n    \n    return {\n        \"user_count\": len(users_resp),\n        \"todo_count\": len(todos_resp),\n        \"active_todos\": sum(1 for t in todos_resp if not t['completed'])\n    }"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees;\n-- This assigns a rank of 1 to the highest paid employee in each department."}
{"instruction": "Implement a Node.js Express middleware that handles asynchronous errors globally, preventing the need for try-catch blocks in every route handler.", "output": "const express = require('express');\nconst app = express();\n\n// Wrapper function to catch async errors\nconst asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Example Route\napp.get('/users', asyncHandler(async (req, res) => {\n    const users = await someDbCall(); // If this throws, it goes to error handler\n    res.json(users);\n}));\n\n// Global Error Handler Middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Internal Server Error',\n    message: err.message\n  });\n});"}
{"instruction": "Create a FastAPI dependency that retrieves a database session using SQLAlchemy, ensuring the session is closed after the request is finished (using `yield`).", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # db is used here and automatically closed after request\n    return {\"status\": \"Db session active\"}"}
{"instruction": "Write a Recursive CTE (Common Table Expression) in SQL to fetch a category hierarchy (e.g., Electronics -> Computers -> Laptops) given a specific category ID.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: Select the specific category\n    SELECT \n        id, \n        name, \n        parent_id, \n        0 as level\n    FROM categories\n    WHERE id = 5 -- Assuming we want the path for ID 5\n\n    UNION ALL\n\n    -- Recursive member: Join with parent\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        cp.level + 1\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath ORDER BY level DESC;"}
{"instruction": "Using Node.js native `stream` module, create a script that reads a large CSV file and pipes it to a writable stream (simulating a transformation or DB insert) to avoid loading the whole file into memory.", "output": "const fs = require('fs');\nconst { Transform, pipeline } = require('stream');\n\nconst readStream = fs.createReadStream('./large_dataset.csv');\nconst writeStream = fs.createWriteStream('./output.json');\n\n// Transform stream to convert CSV lines to JSON objects\nconst csvToJson = new Transform({\n  readableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    const lines = chunk.toString().split('\\n');\n    // Simplified logic: just passing length for demonstration\n    this.push(JSON.stringify({ chunk_size: lines.length }) + '\\n');\n    callback();\n  }\n});\n\npipeline(\n  readStream,\n  csvToJson,\n  writeStream,\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a client connection and echoes back any message received until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI model and endpoint using SQLAlchemy and Pydantic to register a new user. The solution must include password hashing using passlib.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom passlib.context import CryptContext\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Security\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# SQLAlchemy Model\nclass UserDB(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    email: str\n    class Config:\n        orm_mode = True\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=UserResponse)\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(UserDB).filter(UserDB.email == user.email).first()\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_pwd = pwd_context.hash(user.password)\n    new_user = UserDB(email=user.email, hashed_password=hashed_pwd)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return new_user"}
{"instruction": "Using Node.js and Mongoose, define two schemas: 'Author' and 'Book'. Create an async function to fetch an author and populate their published books.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\n// Define Book Schema\nconst bookSchema = new Schema({\n  title: String,\n  pages: Number,\n  author: { type: Schema.Types.ObjectId, ref: 'Author' }\n});\n\n// Define Author Schema\nconst authorSchema = new Schema({\n  name: String,\n  bio: String,\n  books: [{ type: Schema.Types.ObjectId, ref: 'Book' }]\n});\n\nconst Book = mongoose.model('Book', bookSchema);\nconst Author = mongoose.model('Author', authorSchema);\n\n// Async function to get Author with populated Books\nasync function getAuthorWithBooks(authorId) {\n  try {\n    const author = await Author.findById(authorId)\n      .populate('books', 'title pages') // Only select title and pages\n      .exec();\n      \n    if (!author) {\n      throw new Error('Author not found');\n    }\n    \n    return author;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}"}
{"instruction": "Write a FastAPI endpoint that performs an asynchronous HTTP GET request to an external API using `httpx` and returns specific data fields.", "output": "import httpx\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/external-data/{item_id}\")\nasync def get_external_data(item_id: int):\n    url = f\"https://api.example.com/items/{item_id}\"\n    \n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, timeout=5.0)\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n        except httpx.RequestError:\n            raise HTTPException(status_code=503, detail=\"External service unavailable\")\n\n    data = response.json()\n    \n    # Return only specific fields\n    return {\n        \"external_id\": data.get(\"id\"),\n        \"name\": data.get(\"name\"),\n        \"is_active\": data.get(\"active\", False)\n    }"}
{"instruction": "Write a raw SQL query for PostgreSQL to find the top 5 customers who spent the most money in the last 30 days. Assume tables: `customers` (id, name) and `orders` (id, customer_id, total_amount, created_at).", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js Express middleware that caches the response of a GET request using Redis for 60 seconds.", "output": "const redis = require('redis');\nconst client = redis.createClient();\n\n// Connect to Redis\n(async () => { await client.connect(); })();\n\nconst cacheMiddleware = async (req, res, next) => {\n  const key = `route_cache_${req.originalUrl}`;\n\n  try {\n    const cachedData = await client.get(key);\n    if (cachedData) {\n      // Cache hit: return data immediately\n      return res.json(JSON.parse(cachedData));\n    }\n    \n    // Cache miss: override res.json to store data before sending\n    const originalJson = res.json;\n    res.json = (body) => {\n      client.setEx(key, 60, JSON.stringify(body)); // Cache for 60s\n      originalJson.call(res, body);\n    };\n    \n    next();\n  } catch (err) {\n    console.error(\"Redis error\", err);\n    next(); // Skip cache on error\n  }\n};\n\nmodule.exports = cacheMiddleware;"}
{"instruction": "Design a SQL schema (DDL) for a simple E-commerce system managing Products, Categories, and a Many-to-Many relationship between them.", "output": "CREATE TABLE categories (\n    category_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    slug VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Junction table for Many-to-Many relationship\nCREATE TABLE product_categories (\n    product_id INT NOT NULL,\n    category_id INT NOT NULL,\n    PRIMARY KEY (product_id, category_id),\n    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE CASCADE,\n    FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE\n);"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and processes it in the background using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport shutil\nimport time\n\napp = FastAPI()\n\ndef process_file_task(filename: str):\n    # Simulate a long-running CPU bound task\n    print(f\"Starting processing for {filename}...\")\n    time.sleep(5)\n    # Logic to parse file, resize image, etc.\n    print(f\"Finished processing {filename}.\")\n\n@app.post(\"/upload/\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file to disk asynchronously\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule the processing task\n    background_tasks.add_task(process_file_task, file.filename)\n    \n    return {\"message\": \"File uploaded, processing started in background\", \"filename\": file.filename}"}
{"instruction": "Using Node.js Sequelize ORM, define a 'User' model and write a transaction that creates a user and creates an initial 'Wallet' record for them simultaneously.", "output": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('sqlite::memory:');\n\nconst User = sequelize.define('User', {\n  username: { type: DataTypes.STRING, allowNull: false }\n});\n\nconst Wallet = sequelize.define('Wallet', {\n  balance: { type: DataTypes.DECIMAL, defaultValue: 0.00 },\n  userId: { type: DataTypes.INTEGER, allowNull: false }\n});\n\n// Establish relationship\nUser.hasOne(Wallet, { foreignKey: 'userId' });\n\nasync function registerUserWithWallet(username) {\n  const t = await sequelize.transaction();\n\n  try {\n    const user = await User.create({ username }, { transaction: t });\n    \n    await Wallet.create({\n      userId: user.id,\n      balance: 100.00 // Welcome bonus\n    }, { transaction: t });\n\n    await t.commit();\n    return user;\n  } catch (error) {\n    await t.rollback();\n    throw error;\n  }\n}"}
{"instruction": "Write a Python function using `asyncpg` to insert multiple rows into a PostgreSQL database efficiently using `executemany`.", "output": "import asyncpg\nimport asyncio\n\nasync def bulk_insert_logs(logs_data):\n    # logs_data is a list of tuples: [(level, message, timestamp), ...]\n    \n    conn = await asyncpg.connect(user='user', password='pwd', database='db', host='127.0.0.1')\n\n    try:\n        query = \"INSERT INTO system_logs (level, message, created_at) VALUES ($1, $2, $3)\"\n        \n        # executemany is optimized for bulk operations\n        await conn.executemany(query, logs_data)\n        print(f\"Successfully inserted {len(logs_data)} records.\")\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        await conn.close()\n\n# Example Usage\n# asyncio.run(bulk_insert_logs([('INFO', 'Test 1', now), ('ERROR', 'Test 2', now)]))"}
{"instruction": "Implement a Node.js script using the `fs` module streams to read a massive CSV file line-by-line and transform data without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\nconst { pipeline } = require('stream');\n\nasync function processLargeCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Skip header\n    if (lineCount === 0) {\n      lineCount++;\n      continue;\n    }\n\n    const columns = line.split(',');\n    const userId = columns[0];\n    const score = parseInt(columns[1]);\n\n    // Process logic here (e.g., filter or transform)\n    if (score > 50) {\n      // Simulate writing to DB or another stream\n      console.log(`User ${userId} passed with score ${score}`);\n    }\n    \n    lineCount++;\n  }\n  console.log('Processing complete.');\n}"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should validate that the email is valid and the password is at least 8 characters long. Return a 201 status code with the created user data (excluding the password).", "output": "from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\nclass UserResponse(BaseModel):\n    username: str\n    email: EmailStr\n\n# Mock database\nfake_users_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def create_user(user: UserCreate):\n    # Check if email exists\n    if any(u['email'] == user.email for u in fake_users_db):\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    user_dict = user.dict()\n    fake_users_db.append(user_dict)\n    return user_dict"}
{"instruction": "Write a Node.js function using the 'pg' library (node-postgres) to perform an atomic bank transfer between two accounts. The function must use a SQL transaction (BEGIN, COMMIT, ROLLBACK) to ensure data integrity.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query(\n      'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',\n      [senderId]\n    );\n    \n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, senderId]\n    );\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a PostgreSQL database schema for a simple E-commerce system containing 'users', 'products', and 'orders'. Include primary keys, foreign keys, and a many-to-many relationship for order items.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    order_id INT REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(id) ON DELETE SET NULL,\n    quantity INT NOT NULL,\n    unit_price DECIMAL(10, 2) NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);"}
{"instruction": "Implement a FastAPI dependency that validates a custom 'X-API-Key' header. If the key is invalid, raise a 403 Forbidden error. Apply this dependency to a protected route.", "output": "from fastapi import FastAPI, Header, HTTPException, Depends\n\napp = FastAPI()\nAPI_TOKEN = \"secret-token-123\"\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_TOKEN:\n        raise HTTPException(status_code=403, detail=\"Could not validate credentials\")\n    return x_api_key\n\n@app.get(\"/protected-data\")\nasync def get_protected_data(api_key: str = Depends(verify_api_key)):\n    return {\n        \"message\": \"You are authorized\",\n        \"key_used\": api_key\n    }"}
{"instruction": "Write a SQL query using a Window Function to calculate the running total of sales for each day, ordered by date.", "output": "SELECT \n    sale_date,\n    daily_amount,\n    SUM(daily_amount) OVER (ORDER BY sale_date) as running_total\nFROM \n    daily_sales\nORDER BY \n    sale_date;"}
{"instruction": "Create a Node.js Express middleware that checks if a user has the required role from a database before allowing access to a route. Assume 'req.user.id' is populated by previous auth middleware.", "output": "const checkRole = (requiredRole) => {\n  return async (req, res, next) => {\n    try {\n      // Assuming db is an initialized database client\n      const result = await db.query(\n        'SELECT role FROM users WHERE id = $1',\n        [req.user.id]\n      );\n\n      if (result.rows.length === 0) {\n        return res.status(404).json({ error: 'User not found' });\n      }\n\n      const userRole = result.rows[0].role;\n      \n      if (userRole !== requiredRole) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      next();\n    } catch (err) {\n      next(err);\n    }\n  };\n};\n\n// Usage: app.get('/admin', checkRole('admin'), adminHandler);"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user signs up. The API should return the response immediately while the task runs in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_task(email: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(5)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_task, email)\n    return {\"message\": \"User created. Email will be sent shortly.\"}"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money in the year 2023. You need to join 'users' and 'orders' tables.", "output": "SELECT \n    u.id,\n    u.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    users u\nJOIN \n    orders o ON u.id = o.user_id\nWHERE \n    o.created_at >= '2023-01-01' AND o.created_at <= '2023-12-31'\nGROUP BY \n    u.id, u.name\nORDER BY \n    total_spent DESC\nLIMIT 3;"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that accepts connections, receives text messages, and broadcasts the message back to the sender prefixed with 'Echo: '.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Implement a Node.js function to efficiently process a large CSV file using Streams. The function should parse the CSV row by row and log the data, avoiding loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Assuming CSV is comma-separated\n    const columns = line.split(',');\n    console.log('Processing row:', columns);\n    // Perform async DB insert here if needed\n  }\n}\n\n// Usage: processLargeCsv('./large_data.csv');"}
{"instruction": "Create a SQLAlchemy ORM model definition in Python for a FastAPI application representing a 'User' and a 'Post' with a one-to-many relationship.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom database import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    content = Column(String)\n    author_id = Column(Integer, ForeignKey(\"users.id\"))\n    \n    author = relationship(\"User\", back_populates=\"posts\")"}
{"instruction": "Write a Node.js function using the 'pg' library to perform an ACID transaction that transfers funds between two accounts asynchronously.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const senderRes = await client.query(\n      'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',\n      [senderId]\n    );\n    \n    if (senderRes.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, senderId]\n    );\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI async endpoint that fetches data from an external API using `httpx` and returns a processed subset of that data.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-data/{user_id}\")\nasync def get_external_data(user_id: str):\n    url = f\"https://api.example.com/users/{user_id}\"\n    \n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        \n    if response.status_code != 200:\n        raise HTTPException(status_code=response.status_code, detail=\"External API error\")\n        \n    data = response.json()\n    \n    # Process data to return only specific fields\n    return {\n        \"id\": data.get(\"id\"),\n        \"full_name\": f\"{data.get('first_name')} {data.get('last_name')}\",\n        \"active\": data.get(\"status\") == \"active\"\n    }"}
{"instruction": "Write a raw SQL query to find the top 5 customers by total spending amount in the last 30 days.", "output": "SELECT \n    c.customer_id,\n    c.email,\n    SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE o.order_date >= NOW() - INTERVAL '30 days'\nGROUP BY c.customer_id, c.email\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js Express middleware that validates a JSON Web Token (JWT) from the Authorization header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1]; \n\n  if (!token) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Create a FastAPI dependency that retrieves a database session and ensures it is closed after the request is processed.", "output": "from sqlalchemy.orm import Session\nfrom database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage example in a route\n# @app.get(\"/users/\")\n# def read_users(db: Session = Depends(get_db)):\n#     return db.query(User).all()"}
{"instruction": "Write a DDL SQL statement to create a 'products' table with a check constraint ensuring price is positive and a composite index on category and status.", "output": "CREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL,\n    category VARCHAR(100) NOT NULL,\n    status VARCHAR(50) DEFAULT 'active',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    \n    CONSTRAINT price_check CHECK (price > 0)\n);\n\nCREATE INDEX idx_products_category_status ON products(category, status);"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user registers.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate a long-running blocking I/O operation\n    time.sleep(2) \n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register/{email}\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    # Logic to save user to DB would go here\n    \n    # Queue the background task\n    background_tasks.add_task(send_welcome_email, email)\n    \n    return {\"message\": \"User registered, email will be sent shortly\"}"}
{"instruction": "Write a Node.js function using `knex.js` to perform a batch insert of rows, ignoring duplicates based on a unique key constraint.", "output": "const knex = require('knex')({ client: 'pg' });\n\nasync function batchInsertIgnoreDuplicates(users) {\n  // users is an array of objects: [{ email: '...', name: '...' }, ...]\n  \n  return await knex('users')\n    .insert(users)\n    .onConflict('email') // Assumes 'email' has a unique constraint\n    .ignore();\n}"}
{"instruction": "Create a WebSocket endpoint in FastAPI that echoes messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy to register a new user. The solution must include a Pydantic model for validation, hash the password using a hypothetical 'hash_password' utility, and handle potential database integrity errors (e.g., duplicate email).", "output": "from fastapi import APIRouter, HTTPException, Depends\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\nfrom pydantic import BaseModel, EmailStr\nfrom .database import get_db\nfrom .models import User\nfrom .utils import hash_password\n\nrouter = APIRouter()\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n    full_name: str\n\n@router.post(\"/register\", status_code=201)\ndef register_user(user: UserCreate, db: Session = Depends(get_db)):\n    hashed_pw = hash_password(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_pw, full_name=user.full_name)\n    \n    try:\n        db.add(db_user)\n        db.commit()\n        db.refresh(db_user)\n        return {\"id\": db_user.id, \"email\": db_user.email}\n    except IntegrityError:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=\"Email already registered\")"}
{"instruction": "Write a Node.js function using 'knex' to perform a transaction. The function should insert a new order into the 'orders' table and then iterate through an array of items to insert them into the 'order_items' table. If any insertion fails, the transaction must roll back.", "output": "const knex = require('./db');\n\nasync function createOrder(userId, items) {\n  try {\n    await knex.transaction(async (trx) => {\n      // Insert Order\n      const [order] = await trx('orders')\n        .insert({\n          user_id: userId,\n          total_price: items.reduce((acc, item) => acc + item.price, 0),\n          created_at: new Date()\n        })\n        .returning('id');\n\n      // Prepare Order Items\n      const orderItems = items.map(item => ({\n        order_id: order.id,\n        product_id: item.productId,\n        quantity: item.quantity\n      }));\n\n      // Insert Items\n      await trx('order_items').insert(orderItems);\n    });\n    console.log('Transaction complete.');\n  } catch (error) {\n    console.error('Transaction failed, rolled back:', error);\n    throw error;\n  }\n}"}
{"instruction": "Design a SQL query using a Recursive CTE (Common Table Expression) to fetch a category tree. Given a table 'categories' with columns 'id', 'name', and 'parent_id', select the full path of category names for a specific category ID (e.g., ID 5).", "output": "WITH RECURSIVE category_path (id, name, parent_id, path) AS (\n    -- Anchor member: select the specific category\n    SELECT id, name, parent_id, CAST(name AS TEXT) as path\n    FROM categories\n    WHERE id = 5\n    \n    UNION ALL\n    \n    -- Recursive member: join with parent\n    SELECT c.id, c.name, c.parent_id, c.name || ' > ' || cp.path\n    FROM categories c\n    INNER JOIN category_path cp ON c.id = cp.parent_id\n)\nSELECT path FROM category_path WHERE parent_id IS NULL;"}
{"instruction": "Implement a FastAPI background task. Create an endpoint that accepts a file upload, returns a 202 Accepted response immediately, and processes the file (simulated by a sleep function) in the background without blocking the response.", "output": "from fastapi import FastAPI, BackgroundTasks, UploadFile, File\nimport asyncio\n\napp = FastAPI()\n\nasync def process_file_data(filename: str):\n    # Simulate heavy processing\n    await asyncio.sleep(5)\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Add the processing function to background tasks\n    background_tasks.add_task(process_file_data, file.filename)\n    return {\"message\": \"File received, processing in background\", \"filename\": file.filename}"}
{"instruction": "Write a Mongoose (Node.js) schema definition for a 'BlogPost'. It should include a title, a slug (which must be unique), a published boolean, an author reference (ObjectId), and an array of embedded comments, where each comment has a body and a date.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst commentSchema = new Schema({\n  body: { type: String, required: true },\n  date: { type: Date, default: Date.now },\n  user: { type: String, required: true } // Simplified user identifier\n});\n\nconst blogPostSchema = new Schema({\n  title: { type: String, required: true, trim: true },\n  slug: { type: String, required: true, unique: true, lowercase: true },\n  content: { type: String, required: true },\n  isPublished: { type: Boolean, default: false },\n  author: { type: Schema.Types.ObjectId, ref: 'User', required: true },\n  comments: [commentSchema],\n  tags: [{ type: String }]\n}, { timestamps: true });\n\nmodule.exports = mongoose.model('BlogPost', blogPostSchema);"}
{"instruction": "Create a SQL query using Window Functions to rank employees by salary within each department. The output should include the department, employee name, salary, and their rank within that department (1 being the highest salary).", "output": "SELECT \n    department_id,\n    employee_name,\n    salary,\n    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, salary_rank;"}
{"instruction": "Write a Node.js function using async/await to fetch data from two different third-party APIs concurrently using `Promise.all`. Return a combined object containing data from both sources.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function getUserDashboardData(userId) {\n  const userUrl = `https://api.example.com/users/${userId}`;\n  const postsUrl = `https://api.example.com/users/${userId}/posts`;\n\n  try {\n    const [userRes, postsRes] = await Promise.all([\n      fetch(userUrl),\n      fetch(postsUrl)\n    ]);\n\n    if (!userRes.ok || !postsRes.ok) {\n      throw new Error('Failed to fetch data from one or more endpoints');\n    }\n\n    const user = await userRes.json();\n    const posts = await postsRes.json();\n\n    return {\n      userDetails: user,\n      recentPosts: posts\n    };\n  } catch (error) {\n    console.error('Error aggregation data:', error);\n    throw error;\n  }\n}"}
{"instruction": "Implement a Pydantic model in Python with a custom validator. The model represents a 'Booking' with 'start_date' and 'end_date'. The validator must ensure that 'end_date' is after 'start_date'.", "output": "from pydantic import BaseModel, model_validator\nfrom datetime import date\n\nclass Booking(BaseModel):\n    room_id: int\n    start_date: date\n    end_date: date\n\n    @model_validator(mode='after')\n    def check_dates(self):\n        if self.end_date <= self.start_date:\n            raise ValueError('end_date must be after start_date')\n        return self"}
{"instruction": "Write a raw SQL migration script (PostgreSQL flavor) to create a 'products' table. It should have a UUID primary key, a JSONB column for dynamic attributes, a price column with a check constraint ensuring it is positive, and an index on the 'sku' column.", "output": "CREATE TABLE products (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    sku VARCHAR(50) NOT NULL UNIQUE,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),\n    attributes JSONB DEFAULT '{}'::jsonb,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_products_sku ON products(sku);\nCREATE INDEX idx_products_attributes ON products USING GIN (attributes);"}
{"instruction": "Create a FastAPI WebSocket endpoint. The endpoint should accept a connection, listen for text messages, and echo the message back to the client in reverse order until the client disconnects.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo-reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using async/await and SQLAlchemy to create a new 'User' in a PostgreSQL database. Include the Pydantic model and the SQLAlchemy model definition.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom sqlalchemy import Column, Integer, String\nfrom pydantic import BaseModel\n\n# Database Setup\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\nBase = declarative_base()\n\n# SQLAlchemy Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Pydantic Model\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    new_user = User(email=user.email, hashed_password=user.password + \"not_real_hash\")\n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    return {\"id\": new_user.id, \"email\": new_user.email}"}
{"instruction": "Write a Node.js (Express) route that handles a database transaction using the 'pg' library. The route should transfer funds between two accounts atomically.", "output": "const express = require('express');\nconst { Pool } = require('pg');\nconst pool = new Pool();\nconst router = express.Router();\n\nrouter.post('/transfer', async (req, res) => {\n  const { fromId, toId, amount } = req.body;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromId]\n    );\n\n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toId]\n    );\n\n    await client.query('COMMIT');\n    res.status(200).json({ success: true });\n  } catch (e) {\n    await client.query('ROLLBACK');\n    res.status(400).json({ error: e.message });\n  } finally {\n    client.release();\n  }\n});"}
{"instruction": "Design a SQL schema for a 'Blog' system. Create tables for Authors, Posts, and Tags, implementing a Many-to-Many relationship between Posts and Tags.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    post_id SERIAL PRIMARY KEY,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP\n);\n\nCREATE TABLE tags (\n    tag_id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- Junction table for Many-to-Many relationship\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(post_id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(tag_id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Using FastAPI, create an endpoint that accepts a file upload and triggers a background task to process that file (simulated by a sleep function), returning a response immediately.", "output": "from fastapi import FastAPI, BackgroundTasks, UploadFile, File\nimport asyncio\n\napp = FastAPI()\n\nasync def process_file(filename: str):\n    # Simulate a long-running CPU bound or I/O task\n    await asyncio.sleep(5)\n    print(f\"Finished processing {filename}\")\n    # Logic to update DB status would go here\n\n@app.post(\"/upload/\")\nasync def upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # The response is sent immediately, while process_file runs in the background\n    background_tasks.add_task(process_file, file.filename)\n    return {\"message\": \"File uploaded. Processing started in background.\", \"filename\": file.filename}"}
{"instruction": "Write a complex SQL query using a Common Table Expression (CTE) to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM \n    RankedSalaries\nWHERE \n    rank <= 3\nORDER BY \n    department_id, \n    salary DESC;"}
{"instruction": "Implement a Node.js function that makes three asynchronous API calls in parallel using Promise.all and aggregates the results.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData(userId) {\n  try {\n    const [userProfile, recentOrders, notifications] = await Promise.all([\n      axios.get(`https://api.example.com/users/${userId}`),\n      axios.get(`https://api.example.com/orders?user=${userId}&limit=5`),\n      axios.get(`https://api.example.com/notifications?user=${userId}`)\n    ]);\n\n    return {\n      profile: userProfile.data,\n      orders: recentOrders.data,\n      alerts: notifications.data\n    };\n  } catch (error) {\n    console.error(\"Failed to fetch dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Create a FastAPI Pydantic model structure to validate a nested JSON payload for an E-commerce Order, including a list of items and a shipping address.", "output": "from pydantic import BaseModel, Field, EmailStr\nfrom typing import List, Optional\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zip_code: str = Field(..., min_length=5, max_length=10)\n    country: str\n\nclass OrderItem(BaseModel):\n    product_id: int\n    quantity: int = Field(..., gt=0)\n    price_at_purchase: float = Field(..., gt=0)\n\nclass CreateOrderRequest(BaseModel):\n    user_id: int\n    contact_email: EmailStr\n    shipping_address: Address\n    items: List[OrderItem]\n    notes: Optional[str] = None"}
{"instruction": "Write a recursive SQL query (using WITH RECURSIVE) to fetch a category hierarchy (tree structure) given a specific root category ID.", "output": "WITH RECURSIVE CategoryTree AS (\n    -- Anchor member: select the root category\n    SELECT \n        id, \n        name, \n        parent_id, \n        1 as level\n    FROM \n        categories\n    WHERE \n        id = 1 -- Assuming 1 is the root ID we want\n\n    UNION ALL\n\n    -- Recursive member: join the CTE with the table to find children\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        ct.level + 1\n    FROM \n        categories c\n    INNER JOIN \n        CategoryTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CategoryTree ORDER BY level, id;"}
{"instruction": "Create a Node.js middleware for Express that calculates the time taken for a request to process and logs it using the 'on-headers' approach or simple event listeners.", "output": "const responseTimeLogger = (req, res, next) => {\n  const startHrTime = process.hrtime();\n\n  res.on('finish', () => {\n    const elapsedHrTime = process.hrtime(startHrTime);\n    const elapsedTimeInMs = elapsedHrTime[0] * 1000 + elapsedHrTime[1] / 1e6;\n    \n    console.log(`[${req.method}] ${req.originalUrl} - ${res.statusCode} - ${elapsedTimeInMs.toFixed(3)}ms`);\n  });\n\n  next();\n};\n\n// Usage: app.use(responseTimeLogger);"}
{"instruction": "Implement a FastAPI WebSocket endpoint that broadcasts received messages to all connected clients (Simple Chat Room).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")"}
{"instruction": "Create a FastAPI endpoint that asynchronously registers a user. It should validate the input using Pydantic, hash the password using a hypothetical 'hash_password' function, and return the user info without the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\nimport asyncio\n\napp = FastAPI()\n\n# Mock Database\nfake_users_db = []\n\n# Utilities\nasync def hash_password(password: str) -> str:\n    await asyncio.sleep(0.1) # Simulate CPU work\n    return f\"hashed_{password}\"\n\n# Schemas\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n@app.post(\"/register\", response_model=UserResponse, status_code=201)\nasync def register_user(user: UserCreate):\n    # Check if user exists\n    if any(u['email'] == user.email for u in fake_users_db):\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_pw = await hash_password(user.password)\n    \n    new_user = {\n        \"id\": len(fake_users_db) + 1,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"password\": hashed_pw\n    }\n    \n    fake_users_db.append(new_user)\n    return new_user"}
{"instruction": "Write a SQL schema (PostgreSQL) for a simple 'Blog' system containing 'users' and 'posts'. Include foreign keys, constraints, and an automatic updated_at trigger function.", "output": "-- Users Table\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Posts Table\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    is_published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Function to update timestamp\nCREATE OR REPLACE FUNCTION update_modified_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\n-- Trigger for Posts\nCREATE TRIGGER update_posts_modtime\n    BEFORE UPDATE ON posts\n    FOR EACH ROW\n    EXECUTE FUNCTION update_modified_column();"}
{"instruction": "Using Node.js, write a function that performs three asynchronous API calls in parallel using `Promise.all` and returns a combined result object. Handle errors gracefully if one fails.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function fetchDashboardData(userId) {\n    const endpoints = [\n        `https://api.example.com/users/${userId}/profile`,\n        `https://api.example.com/users/${userId}/posts`,\n        `https://api.example.com/users/${userId}/notifications`\n    ];\n\n    try {\n        const results = await Promise.all(\n            endpoints.map(url => fetch(url).then(res => {\n                if (!res.ok) throw new Error(`Failed to fetch ${url}`);\n                return res.json();\n            }))\n        );\n\n        return {\n            profile: results[0],\n            posts: results[1],\n            notifications: results[2],\n            status: 'success'\n        };\n    } catch (error) {\n        console.error(\"Error fetching dashboard data:\", error.message);\n        return {\n            status: 'error',\n            message: 'Partial or complete data fetch failure',\n            details: error.message\n        };\n    }\n}"}
{"instruction": "Create a FastAPI dependency that connects to a database, yields the session to the route handler, and closes the session afterwards (Context Manager pattern).", "output": "from fastapi import Depends, FastAPI\nfrom typing import Generator\n\n# Mock Session class\nclass MockSession:\n    def close(self):\n        print(\"Closing DB session\")\n\n# Mock SessionLocal factory\nclass SessionFactory:\n    def __call__(self):\n        print(\"Creating DB session\")\n        return MockSession()\n\nSessionLocal = SessionFactory()\n\ndef get_db() -> Generator:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: MockSession = Depends(get_db)):\n    # Use db here\n    return {\"status\": \"Session used\"}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    first_name,\n    last_name,\n    department_id,\n    salary,\n    RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, \n    salary_rank;"}
{"instruction": "Implement a Node.js Express middleware that checks for a valid JWT in the Authorization header. If invalid or missing, return 401.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n    const authHeader = req.headers['authorization'];\n    // Bearer <token>\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (token == null) {\n        return res.status(401).json({ message: \"No token provided\" });\n    }\n\n    jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n        if (err) {\n            return res.status(403).json({ message: \"Invalid token\" });\n        }\n        req.user = user;\n        next();\n    });\n};\n\n// Usage: app.get('/protected', authenticateToken, (req, res) => { ... });"}
{"instruction": "Using FastAPI, create an endpoint that accepts a file upload and processes it in the background using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_image(file_path: str):\n    # Simulate a long-running CPU task like resizing or ML inference\n    import time\n    time.sleep(5)\n    print(f\"Finished processing {file_path}\")\n\n@app.post(\"/upload-image/\")\nasync def create_upload_file(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file asynchronously\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule background task\n    background_tasks.add_task(process_image, file_location)\n    \n    return {\"info\": f\"file '{file.filename}' saved at '{file_location}' and processing started.\"}"}
{"instruction": "Write a SQL query that uses a Recursive CTE (Common Table Expression) to find all ancestors of a specific category in a hierarchical category tree.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: start with the specific category (e.g., id = 5)\n    SELECT \n        id, \n        name, \n        parent_id\n    FROM \n        categories\n    WHERE \n        id = 5\n\n    UNION ALL\n\n    -- Recursive member: join with parent\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id\n    FROM \n        categories c\n    INNER JOIN \n        CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath;"}
{"instruction": "Create a Node.js Stream script to read a massive CSV file line-by-line and transform the data without loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\nconst { Transform } = require('stream');\n\nasync function processLargeCsv(filePath) {\n    const fileStream = fs.createReadStream(filePath);\n\n    const rl = readline.createInterface({\n        input: fileStream,\n        crlfDelay: Infinity\n    });\n\n    for await (const line of rl) {\n        // Skip header or empty lines\n        if (!line || line.startsWith('id,')) continue;\n\n        const columns = line.split(',');\n        const user = {\n            id: columns[0],\n            name: columns[1].toUpperCase(), // Transform logic\n            email: columns[2]\n        };\n\n        // Simulate DB insert or writing to another stream\n        console.log(`Processing user: ${user.name}`);\n    }\n}\n\n// Usage: processLargeCsv('./huge_data.csv');"}
{"instruction": "Write a Python/FastAPI Websocket endpoint that accepts connections and broadcasts any received message to all other connected clients (Simple Chat).", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str, sender: WebSocket):\n        for connection in self.active_connections:\n            if connection != sender:\n                await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\", websocket)\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\", websocket)"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously fetches data from an external API (e.g., 'https://api.example.com/data') using the 'httpx' library and returns the JSON response.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/fetch-external\")\nasync def fetch_external_data():\n    url = \"https://api.example.com/data\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n        except httpx.RequestError:\n            raise HTTPException(status_code=503, detail=\"External API unreachable\")"}
{"instruction": "Design a PostgreSQL database schema for a simple blog system containing 'users' and 'posts'. Users have a username and email. Posts have a title, content, published status, and a foreign key linking to the user.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    is_published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Write a Node.js Express middleware function that validates a JSON Web Token (JWT) from the 'Authorization' header. If valid, attach the user to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Format: \"Bearer <TOKEN>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ message: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ message: 'Invalid or expired token' });\n    }\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Define a Pydantic model in Python for a FastAPI 'UserRegistration' payload. It should validate that the username is alphanumeric and the password is at least 8 characters long.", "output": "from pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\n    @validator('username')\n    def username_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        return v\n\n    @validator('password')\n    def password_complexity(cls, v):\n        # Example: Just checking length is handled by Field, but complex logic goes here\n        return v"}
{"instruction": "Write a SQL query to select the top 5 customers based on the total amount they have spent on orders in the current year. Assume tables 'customers' (id, name) and 'orders' (id, customer_id, total_amount, created_at).", "output": "SELECT \n    c.id, \n    c.name, \n    SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE o.created_at >= DATE_TRUNC('year', CURRENT_DATE)\nGROUP BY c.id, c.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a Node.js function using async/await to handle a database transaction for transferring money between two accounts. Assume a 'db' object with 'query', 'begin', 'commit', and 'rollback' methods.", "output": "async function transferFunds(senderId, receiverId, amount) {\n  const client = await db.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [senderId]);\n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, senderId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, receiverId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency using Python's generator pattern to manage a SQLAlchemy database session. The session should close automatically after the request is processed.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write the SQL DDL commands to create a composite index on a 'sales' table for columns 'region' and 'sale_date' to optimize queries filtering by region and sorting by date.", "output": "CREATE INDEX idx_sales_region_date \nON sales (region, sale_date DESC);"}
{"instruction": "Create a Node.js function that reads a large CSV file using streams to prevent high memory usage, logging each row to the console.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeCsv(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Assuming simple comma separation, complex CSVs might need a parser library\n    const columns = line.split(',');\n    console.log('Row data:', columns);\n  }\n}"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that accepts a connection, receives text messages, and echoes them back to the client prefixed with 'Echo: '.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to validate an incoming 'Product' payload. The endpoint should be asynchronous and return the created product with a generated ID.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\nimport uuid\n\napp = FastAPI()\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=3, max_length=50)\n    price: float = Field(..., gt=0)\n    description: Optional[str] = None\n\nclass ProductDB(ProductBase):\n    id: str\n\n@app.post(\"/products/\", response_model=ProductDB)\nasync def create_product(product: ProductBase):\n    # Simulate async database insertion\n    new_id = str(uuid.uuid4())\n    product_in_db = ProductDB(id=new_id, **product.dict())\n    return product_in_db"}
{"instruction": "Write SQL DDL statements to create a Many-to-Many relationship schema between 'Users' and 'Roles'. Include necessary foreign keys and constraints.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE roles (\n    role_id SERIAL PRIMARY KEY,\n    role_name VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE user_roles (\n    user_id INT NOT NULL,\n    role_id INT NOT NULL,\n    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, role_id),\n    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,\n    FOREIGN KEY (role_id) REFERENCES roles(role_id) ON DELETE CASCADE\n);"}
{"instruction": "In a Node.js Express route, implement logic to fetch a User and their recent Orders in parallel to optimize performance using async/await.", "output": "const express = require('express');\nconst router = express.Router();\nconst db = require('./db'); // Hypothetical DB module\n\nrouter.get('/dashboard/:userId', async (req, res) => {\n  const { userId } = req.params;\n\n  try {\n    // Execute queries in parallel\n    const [user, orders] = await Promise.all([\n      db.query('SELECT * FROM users WHERE id = ?', [userId]),\n      db.query('SELECT * FROM orders WHERE user_id = ? LIMIT 5', [userId])\n    ]);\n\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      profile: user,\n      recentOrders: orders\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Internal Server Error' });\n  }\n});"}
{"instruction": "Create a Python/FastAPI dependency that yields a database session and ensures the session is closed after the request is processed.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming SessionLocal is a configured sessionmaker instance\n# from database import SessionLocal\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"status\": \"Session active\"}"}
{"instruction": "Write a SQL query using a Window Function to find the top 2 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    employee_id,\n    name,\n    department_id,\n    salary\nFROM RankedSalaries\nWHERE rank <= 2;"}
{"instruction": "Implement a Node.js function that performs an atomic money transfer between two accounts using a SQL transaction.", "output": "const transferFunds = async (client, fromAccountId, toAccountId, amount) => {\n  try {\n    await client.query('BEGIN');\n\n    const res = await client.query(\n      'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',\n      [fromAccountId]\n    );\n    \n    if (res.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, fromAccountId]\n    );\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  }\n};"}
{"instruction": "Using FastAPI, create an endpoint that accepts a file upload and triggers a background task to process it without blocking the response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\n\napp = FastAPI()\n\ndef process_image(file_name: str):\n    # Simulate heavy processing (e.g., resizing, S3 upload)\n    print(f\"Processing image: {file_name}...\")\n    # ... logic here ...\n    print(f\"Finished {file_name}\")\n\n@app.post(\"/upload/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Save temp file logic would go here\n    file_name = file.filename\n    \n    # Schedule task\n    background_tasks.add_task(process_image, file_name)\n    \n    return {\"message\": \"Upload received, processing in background\"}"}
{"instruction": "Write a SQL query to retrieve a hierarchical category tree (Parent -> Child) using a Recursive CTE.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: select root categories\n    SELECT \n        id, \n        name, \n        parent_id, \n        name::TEXT as path\n    FROM categories \n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: join children to parents\n    SELECT \n        c.id, \n        c.name, \n        c.parent_id, \n        (cp.path || ' -> ' || c.name)\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.parent_id = cp.id\n)\nSELECT * FROM CategoryPath ORDER BY path;"}
{"instruction": "Create a Node.js middleware to check if a valid API Key exists in the headers before allowing access to a protected route.", "output": "const apiKeyMiddleware = async (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n\n  if (!apiKey) {\n    return res.status(401).json({ error: 'API Key missing' });\n  }\n\n  // Simulate DB lookup for valid key\n  const isValid = await checkKeyInDb(apiKey);\n\n  if (!isValid) {\n    return res.status(403).json({ error: 'Invalid API Key' });\n  }\n\n  next();\n};\n\n// Usage: app.use('/api/private', apiKeyMiddleware, privateRoutes);"}
{"instruction": "Create a Python/FastAPI WebSocket endpoint that handles real-time chat messages for a specific room ID.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{room_id}\")\nasync def websocket_endpoint(websocket: WebSocket, room_id: str):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Room {room_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client left Room {room_id}\")"}
{"instruction": "Create a Python FastAPI endpoint using SQLAlchemy that registers a new user. The solution must include the SQLAlchemy model for the User, a Pydantic schema for input validation, and the route handler that hashes the password before saving.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom passlib.context import CryptContext\n\n# Database Setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Password Hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# SQLAlchemy Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schema\nclass UserCreate(BaseModel):\n    email: str\n    password: str\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.post(\"/users/\")\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.email == user.email).first()\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = pwd_context.hash(user.password)\n    new_user = User(email=user.email, hashed_password=hashed_password)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    return {\"id\": new_user.id, \"email\": new_user.email}"}
{"instruction": "Write a raw SQL query (PostgreSQL dialect) to create a 'products' table and an 'orders' table. The orders table should have a foreign key referencing products, a quantity column, and a timestamp default to now.", "output": "CREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT fk_product\n        FOREIGN KEY(product_id) \n        REFERENCES products(id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Using Node.js and Express, create a middleware function that simulates an asynchronous authentication check (e.g., verifying a token against a database) using async/await. If valid, attach the user to the request object; otherwise, send a 401 error.", "output": "const express = require('express');\nconst app = express();\n\n// Mock async database lookup\nconst findUserByToken = async (token) => {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            if (token === 'valid-token') resolve({ id: 1, name: 'Alice' });\n            else resolve(null);\n        }, 100);\n    });\n};\n\nconst authMiddleware = async (req, res, next) => {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return res.status(401).json({ error: 'Missing token' });\n    }\n\n    const token = authHeader.split(' ')[1];\n\n    try {\n        const user = await findUserByToken(token);\n        if (!user) {\n            return res.status(401).json({ error: 'Invalid token' });\n        }\n        req.user = user;\n        next();\n    } catch (err) {\n        res.status(500).json({ error: 'Internal Server Error' });\n    }\n};\n\napp.get('/profile', authMiddleware, (req, res) => {\n    res.json({ message: `Hello ${req.user.name}` });\n});"}
{"instruction": "Create a Python FastAPI endpoint that performs two external API calls concurrently using `asyncio.gather` to optimize performance, rather than awaiting them sequentially.", "output": "import asyncio\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def fetch_data(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\n@app.get(\"/dashboard-stats\")\nasync def get_dashboard_stats():\n    async with httpx.AsyncClient() as client:\n        # Start both requests concurrently\n        task1 = fetch_data(client, \"https://api.example.com/users/count\")\n        task2 = fetch_data(client, \"https://api.example.com/revenue/total\")\n        \n        # Wait for both to finish\n        user_count, total_revenue = await asyncio.gather(task1, task2)\n        \n    return {\n        \"users\": user_count,\n        \"revenue\": total_revenue\n    }"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money based on an 'orders' table with columns (customer_id, total_amount).", "output": "SELECT \n    customer_id, \n    SUM(total_amount) as total_spent\nFROM \n    orders\nGROUP BY \n    customer_id\nORDER BY \n    total_spent DESC\nLIMIT 3;"}
{"instruction": "Using Node.js, write a script using the `fs/promises` module to read a large JSON file asynchronously, parse it, and filter out items where `isActive` is false, then write the result to a new file.", "output": "const fs = require('fs/promises');\nconst path = require('path');\n\nasync function processData() {\n    const inputPath = path.join(__dirname, 'data.json');\n    const outputPath = path.join(__dirname, 'active_data.json');\n\n    try {\n        const rawData = await fs.readFile(inputPath, 'utf-8');\n        const items = JSON.parse(rawData);\n\n        const activeItems = items.filter(item => item.isActive === true);\n\n        await fs.writeFile(outputPath, JSON.stringify(activeItems, null, 2));\n        console.log(`Processed ${activeItems.length} active items.`);\n    } catch (error) {\n        console.error('Error processing file:', error);\n    }\n}\n\nprocessData();"}
{"instruction": "Create a Pydantic model in Python for a complex 'Product' entry that includes nested objects (variants) and validation to ensure the price is positive.", "output": "from typing import List, Optional\nfrom pydantic import BaseModel, Field, validator\n\nclass Variant(BaseModel):\n    sku: str\n    color: str\n    size: str\n    stock: int = Field(ge=0, description=\"Stock must be non-negative\")\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n    price: float\n    tags: List[str] = []\n    variants: List[Variant]\n\n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than zero')\n        return v\n\n# Example Usage\n# product = Product(id=1, name=\"T-Shirt\", price=19.99, variants=[...])"}
{"instruction": "Design a Database Schema (SQL) for a Many-to-Many relationship between 'Students' and 'Courses'. Output the CREATE TABLE statements for the three necessary tables.", "output": "CREATE TABLE students (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE courses (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(100) NOT NULL,\n    code VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE enrollments (\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    enrolled_at DATE DEFAULT CURRENT_DATE,\n    PRIMARY KEY (student_id, course_id),\n    CONSTRAINT fk_student\n        FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,\n    CONSTRAINT fk_course\n        FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE\n);"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that accepts a connection, receives text messages, and echoes them back to the client with a 'Server received: ' prefix.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Server received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Using Node.js and Mongoose (MongoDB), define a Schema for a 'BlogPost' which includes a title, body, and an array of embedded 'Comment' sub-documents.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst commentSchema = new Schema({\n  author: { type: String, required: true },\n  content: { type: String, required: true },\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst blogPostSchema = new Schema({\n  title: { type: String, required: true, index: true },\n  body: { type: String, required: true },\n  isPublished: { type: Boolean, default: false },\n  tags: [String],\n  comments: [commentSchema],\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);\n\nmodule.exports = BlogPost;"}
{"instruction": "Create a FastAPI endpoint that asynchronously fetches data from an external public API (e.g., jsonplaceholder) using `httpx` and returns a filtered subset of the data.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-posts/{user_id}\")\nasync def get_user_posts(user_id: int):\n    url = f\"https://jsonplaceholder.typicode.com/posts?userId={user_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        \n    if response.status_code != 200:\n        raise HTTPException(status_code=502, detail=\"Error fetching external data\")\n        \n    data = response.json()\n    # Return only titles of the posts\n    return {\"user_id\": user_id, \"titles\": [post[\"title\"] for post in data]}"}
{"instruction": "Write a SQL schema definition (PostgreSQL) for a simple Library system containing `authors` and `books`. Ensure a one-to-many relationship where an author can have multiple books, including foreign keys and indexes.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(20) UNIQUE,\n    author_id INTEGER REFERENCES authors(id) ON DELETE CASCADE,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_books_author_id ON books(author_id);"}
{"instruction": "Create a Node.js (Express) middleware function that verifies a JWT token from the `Authorization` header. If valid, attach the decoded user to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1]; \n\n  if (!token) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Define Pydantic models in Python for a User Registration API. Include validation to ensure the username is alphanumeric, the password is at least 8 characters long, and the email is valid.", "output": "from pydantic import BaseModel, EmailStr, Field, validator\nimport re\n\nclass UserRegister(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\n    @validator('username')\n    def username_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        return v\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\n    class Config:\n        orm_mode = True"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money in the last 30 days. Assume tables: `customers` (id, name) and `orders` (id, customer_id, total_amount, created_at).", "output": "SELECT \n    c.name, \n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Using Node.js and the `pg` library, create a function that executes two database inserts (creating a user and their settings) within a single transaction to ensure data integrity.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function createUserWithSettings(username, theme) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const userRes = await client.query(\n      'INSERT INTO users(username) VALUES($1) RETURNING id',\n      [username]\n    );\n    const userId = userRes.rows[0].id;\n    \n    await client.query(\n      'INSERT INTO settings(user_id, theme) VALUES($1, $2)',\n      [userId, theme]\n    );\n    \n    await client.query('COMMIT');\n    return userId;\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Implement a FastAPI dependency that yields a database session using SQLAlchemy. This ensures a session is created for a request and closed (or rolled back) after the request is finished.", "output": "from sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL query to soft-delete a user by setting a `deleted_at` timestamp, but only if they haven't logged in within the last year.", "output": "UPDATE users\nSET deleted_at = CURRENT_TIMESTAMP\nWHERE last_login < NOW() - INTERVAL '1 year'\n  AND deleted_at IS NULL;"}
{"instruction": "Create a Node.js utility function using `Promise.all` to fetch data from three different API endpoints concurrently and merge the results into a single object.", "output": "const axios = require('axios');\n\nasync function getDashboardData(userId) {\n  try {\n    const [profile, stats, notifications] = await Promise.all([\n      axios.get(`/api/users/${userId}`),\n      axios.get(`/api/users/${userId}/stats`),\n      axios.get(`/api/users/${userId}/notifications`)\n    ]);\n\n    return {\n      profile: profile.data,\n      stats: stats.data,\n      notifications: notifications.data\n    };\n  } catch (error) {\n    console.error(\"Failed to load dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload and triggers a background task (e.g., image processing) so the user gets an immediate response without waiting for the heavy computation.", "output": "from fastapi import FastAPI, BackgroundTasks, UploadFile, File\nimport shutil\n\napp = FastAPI()\n\ndef process_image(file_path: str):\n    # Simulate heavy processing (e.g., resizing, AI analysis)\n    print(f\"Processing image at {file_path}...\")\n    # ... logic here ...\n    print(\"Processing complete.\")\n\n@app.post(\"/upload-image/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Add task to background queue\n    background_tasks.add_task(process_image, file_location)\n    \n    return {\"info\": \"File uploaded, processing started in background\"}"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new product (name, price, tags) using Pydantic for validation. The 'tags' field should be an optional list of strings.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str\n    price: float\n    tags: Optional[List[str]] = []\n\n@app.post(\"/products/\")\nasync def create_product(product: ProductSchema):\n    # Simulate database insertion\n    return {\n        \"message\": \"Product created successfully\",\n        \"data\": product.dict()\n    }"}
{"instruction": "Write a SQL DDL script to create a normalized schema for a Library system. It needs an 'authors' table and a 'books' table. A book belongs to one author.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_year INT,\n    author_id INT,\n    CONSTRAINT fk_author\n        FOREIGN KEY(author_id) \n        REFERENCES authors(author_id)\n        ON DELETE SET NULL\n);"}
{"instruction": "Using Node.js and Express, write a custom middleware function that checks for a header 'X-API-KEY'. If missing or invalid, return 401 Unauthorized; otherwise, call the next handler.", "output": "const express = require('express');\nconst app = express();\n\nconst apiKeyMiddleware = (req, res, next) => {\n    const apiKey = req.get('X-API-KEY');\n    const validKey = 'my-secret-key-123';\n\n    if (!apiKey || apiKey !== validKey) {\n        return res.status(401).json({ error: 'Unauthorized: Invalid or missing API Key' });\n    }\n    next();\n};\n\napp.use(apiKeyMiddleware);\n\napp.get('/secure-data', (req, res) => {\n    res.json({ secret: 'This is protected data' });\n});"}
{"instruction": "Write a Python function using SQLAlchemy (Async) to fetch a user by ID and eagerly load their related 'posts'.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom sqlalchemy.orm import selectinload\nfrom models import User\n\nasync def get_user_with_posts(session: AsyncSession, user_id: int):\n    # Use selectinload for async compatible eager loading\n    stmt = select(User).options(selectinload(User.posts)).where(User.id == user_id)\n    result = await session.execute(stmt)\n    return result.scalars().first()"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money, assuming tables 'customers' (id, name) and 'orders' (customer_id, total_amount).", "output": "SELECT c.name, SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nGROUP BY c.id, c.name\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Create a Node.js script using the 'pg' library to perform a database transaction. It should transfer $100 from Account A to Account B.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromId, toId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING *',\n      [amount, fromId]\n    );\n    \n    if (deductRes.rows.length === 0) throw new Error('Sender not found');\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toId]\n    );\n\n    await client.query('COMMIT');\n    console.log('Transfer successful');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Implement a FastAPI WebSocket endpoint that echoes received text back to the client in uppercase.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data.upper()}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments.", "output": "SELECT \n    employee_id,\n    name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM employees;"}
{"instruction": "Create a Node.js utility function that reads a JSON file asynchronously and returns the parsed object, handling errors gracefully.", "output": "const fs = require('fs').promises;\n\nasync function loadConfig(filePath) {\n    try {\n        const data = await fs.readFile(filePath, 'utf8');\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(`Error reading config from ${filePath}:`, error.message);\n        return null;\n    }\n}"}
{"instruction": "Implement a FastAPI endpoint that triggers a background task (e.g., sending an email) and immediately returns a 202 Accepted response.", "output": "from fastapi import FastAPI, BackgroundTasks, status\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\ndef send_email_notification(email: str, message: str):\n    # Simulate blocking I/O operation\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\", status_code=status.HTTP_202_ACCEPTED)\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email, \"Welcome to our platform!\")\n    return {\"message\": \"Notification scheduled\"}"}
{"instruction": "Create a Python FastAPI endpoint that asynchronously fetches data from an external API using `httpx` and returns a filtered subset of that data.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\nclass UserSummary(BaseModel):\n    id: int\n    username: str\n    email: str\n\n@app.get(\"/users/external\", response_model=List[UserSummary])\nasync def get_external_users():\n    external_url = \"https://jsonplaceholder.typicode.com/users\"\n    \n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(external_url)\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n            \n    data = response.json()\n    \n    # Filter and map data to the response model\n    users = [\n        UserSummary(id=u['id'], username=u['username'], email=u['email'])\n        for u in data\n    ]\n    \n    return users"}
{"instruction": "Write a Node.js module using the `pg` library to establish a PostgreSQL connection pool and export a query function that logs the duration of each query.", "output": "const { Pool } = require('pg');\n\nconst pool = new Pool({\n  user: process.env.DB_USER,\n  host: process.env.DB_HOST,\n  database: process.env.DB_NAME,\n  password: process.env.DB_PASSWORD,\n  port: process.env.DB_PORT,\n});\n\nmodule.exports = {\n  query: async (text, params) => {\n    const start = Date.now();\n    try {\n      const res = await pool.query(text, params);\n      const duration = Date.now() - start;\n      console.log('Executed query', { text, duration, rows: res.rowCount });\n      return res;\n    } catch (error) {\n      console.error('Query error', { text, error });\n      throw error;\n    }\n  },\n  getClient: () => pool.connect(),\n};"}
{"instruction": "Design a SQL schema (PostgreSQL) for a simple Blog system containing `users`, `posts`, and `comments`. Ensure referential integrity and include timestamps.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\n    body TEXT NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Create a FastAPI dependency function to manage a SQLAlchemy database session, ensuring the session is closed after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\n# Setup (usually in a separate database.py file)\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# The Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage example in a route\n# @app.get(\"/items/\")\n# def read_items(db: Session = Depends(get_db)):\n#     return db.query(Item).all()"}
{"instruction": "Write a Node.js function that processes an array of User IDs asynchronously, fetching details for all of them in parallel, but handles errors for individual requests gracefully (returning null for failed fetches).", "output": "async function fetchUserDetails(userId) {\n  // Simulate async API call\n  if (Math.random() < 0.1) throw new Error(\"Fetch failed\");\n  return { id: userId, name: `User ${userId}` };\n}\n\nasync function processUserIds(ids) {\n  const promises = ids.map(async (id) => {\n    try {\n      return await fetchUserDetails(id);\n    } catch (error) {\n      console.error(`Failed to fetch user ${id}:`, error.message);\n      return null;\n    }\n  });\n\n  const results = await Promise.all(promises);\n  \n  // Filter out nulls if you only want successful results\n  return results.filter(user => user !== null);\n}"}
{"instruction": "Write a SQL query to find the top 5 customers who have spent the most money, joining `customers`, `orders`, and `order_items` tables.", "output": "SELECT \n    c.id,\n    c.name,\n    SUM(oi.quantity * oi.unit_price) AS total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nJOIN \n    order_items oi ON o.id = oi.order_id\nWHERE \n    o.status = 'completed'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 5;"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that accepts connections, receives text messages, and broadcasts the message to all currently connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(\"A client left the chat\")"}
{"instruction": "Create a Node.js function using raw SQL (pg driver) to perform a bank transfer transaction. It must deduct from one account and add to another atomically.", "output": "const db = require('./db'); // Assuming the pool module from Task 2\n\nasync function transferFunds(fromAccountId, toAccountId, amount) {\n  const client = await db.getClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, fromAccountId]\n    );\n    \n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender account');\n    }\n\n    // Add to receiver\n    const addRes = await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2 RETURNING *',\n      [amount, toAccountId]\n    );\n\n    if (addRes.rowCount === 0) {\n      throw new Error('Invalid receiver account');\n    }\n\n    await client.query('COMMIT');\n    return { success: true, newBalance: deductRes.rows[0].balance };\n\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Define SQLAlchemy models for a Many-to-Many relationship between `Student` and `Course` using an association table.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    # Relationship\n    courses = relationship(\n        \"Course\",\n        secondary=student_course_association,\n        back_populates=\"students\"\n    )\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    # Reverse Relationship\n    students = relationship(\n        \"Student\",\n        secondary=student_course_association,\n        back_populates=\"courses\"\n    )\n"}
{"instruction": "Write a Node.js Express middleware function to verify a JWT (JSON Web Token) from the `Authorization` header.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // Expect format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) {\n    return res.sendStatus(401); // Unauthorized\n  }\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) {\n      return res.sendStatus(403); // Forbidden (invalid token)\n    }\n    \n    // Attach user payload to request object\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a new user. The endpoint should accept a JSON body with 'username', 'email', and 'password', validate the email format, and return the created user data excluding the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n    class Config:\n        orm_mode = True\n\nfake_db = []\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate):\n    # Simulate DB auto-increment ID\n    new_id = len(fake_db) + 1\n    user_data = user.dict()\n    user_data[\"id\"] = new_id\n    \n    # In a real app, hash password here\n    fake_db.append(user_data)\n    \n    return user_data"}
{"instruction": "Write a Node.js function using `Promise.all` to fetch data from three different API endpoints concurrently and return a combined result object. Handle potential errors if one request fails.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData() {\n  try {\n    const [users, posts, comments] = await Promise.all([\n      axios.get('https://api.example.com/users'),\n      axios.get('https://api.example.com/posts'),\n      axios.get('https://api.example.com/comments')\n    ]);\n\n    return {\n      userCount: users.data.length,\n      recentPosts: posts.data.slice(0, 5),\n      totalComments: comments.data.length\n    };\n  } catch (error) {\n    console.error('Error fetching dashboard data:', error.message);\n    throw new Error('Failed to load dashboard resources');\n  }\n}"}
{"instruction": "Design a SQL schema (PostgreSQL syntax) for a 'Library' system. Create tables for `Authors` and `Books` with a one-to-many relationship, and a `Book_Loans` table for a many-to-many relationship between `Books` and `Users` (schema for Users not required, assume user_id exists). Include foreign keys and a check constraint to ensure the due_date is after the loan_date.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    author_id INT REFERENCES authors(author_id) ON DELETE SET NULL,\n    published_date DATE\n);\n\nCREATE TABLE book_loans (\n    loan_id SERIAL PRIMARY KEY,\n    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,\n    user_id INT NOT NULL,\n    loan_date DATE DEFAULT CURRENT_DATE,\n    due_date DATE,\n    returned_date DATE,\n    CONSTRAINT check_dates CHECK (due_date > loan_date)\n);"}
{"instruction": "Implement a FastAPI dependency that retrieves a database session using SQLAlchemy. The dependency should ensure the session is closed after the request is processed, even if an error occurs.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Create a Node.js Express middleware that limits incoming requests from a specific IP address to 100 requests per 15 minutes. Use a simple in-memory object for storage.", "output": "const rateLimitMap = new Map();\n\nconst rateLimiter = (req, res, next) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const windowMs = 15 * 60 * 1000;\n  const limit = 100;\n\n  if (!rateLimitMap.has(ip)) {\n    rateLimitMap.set(ip, { count: 1, startTime: now });\n    return next();\n  }\n\n  const data = rateLimitMap.get(ip);\n\n  if (now - data.startTime > windowMs) {\n    // Reset window\n    rateLimitMap.set(ip, { count: 1, startTime: now });\n    return next();\n  }\n\n  if (data.count >= limit) {\n    return res.status(429).json({ error: 'Too many requests, please try again later.' });\n  }\n\n  data.count++;\n  next();\n};\n\nmodule.exports = rateLimiter;"}
{"instruction": "Write a SQL query using a Common Table Expression (CTE) to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_num\n    FROM employees\n)\nSELECT \n    name, \n    department_id, \n    salary\nFROM RankedSalaries\nWHERE rank_num <= 3;"}
{"instruction": "Create a FastAPI endpoint that accepts a CSV file upload. The endpoint should read the file asynchronously line by line and return the total number of rows processed.", "output": "from fastapi import FastAPI, UploadFile, File\nimport io\n\napp = FastAPI()\n\n@app.post(\"/upload-csv/\")\nasync def upload_csv(file: UploadFile = File(...)):\n    content = await file.read()\n    # Decode bytes to string\n    text_content = content.decode(\"utf-8\")\n    \n    # Use io.StringIO to treat the string like a file object\n    csv_file = io.StringIO(text_content)\n    \n    row_count = 0\n    # Skip header if necessary, then count\n    for line in csv_file:\n        if line.strip():\n            row_count += 1\n            \n    return {\"filename\": file.filename, \"rows_processed\": row_count}"}
{"instruction": "Write a Node.js script using the `stream` module to create a read stream for a large video file and pipe it to the HTTP response object, handling backpressure automatically.", "output": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'large-video.mp4');\n  const stat = fs.statSync(filePath);\n\n  res.writeHead(200, {\n    'Content-Type': 'video/mp4',\n    'Content-Length': stat.size\n  });\n\n  const readStream = fs.createReadStream(filePath);\n  \n  // Pipe handles backpressure automatically\n  readStream.pipe(res);\n\n  readStream.on('error', (err) => {\n    console.error('Stream error:', err);\n    res.end();\n  });\n});\n\nserver.listen(3000);"}
{"instruction": "Write a SQL query to update the `status` of all orders to 'Archived' where the order was created more than 2 years ago and the total order value was less than $50.", "output": "UPDATE orders\nSET status = 'Archived'\nWHERE created_at < NOW() - INTERVAL '2 years'\nAND total_value < 50.00;"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that accepts a client connection, receives text messages, reverses the text strings, and sends them back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new user (username, email, password), hashes the password using a hypothetical 'hash_password' function, and saves it to an async database session. Include Pydantic models for validation.", "output": "from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\n# Assuming database setup (e.g., SQLAlchemy Async) is imported as AsyncSession, User, get_db\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\n    class Config:\n        orm_mode = True\n\n# Mock hashing function\ndef hash_password(password: str) -> str:\n    return password + \"_hashed\"\n\n@app.post(\"/users/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check if email exists (omitted for brevity)\n    \n    hashed_pwd = hash_password(user.password)\n    new_user = User(username=user.username, email=user.email, hashed_password=hashed_pwd)\n    \n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    \n    return new_user"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to select a full category hierarchy (breadcrumbs) for a specific category ID from a table 'categories' with columns: id, name, parent_id.", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: select the specific category\n    SELECT id, name, parent_id, 1 as level\n    FROM categories\n    WHERE id = 5 -- Assuming we want hierarchy for ID 5\n\n    UNION ALL\n\n    -- Recursive member: join with parent\n    SELECT c.id, c.name, c.parent_id, cp.level + 1\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.id = cp.parent_id\n)\nSELECT * FROM CategoryPath ORDER BY level DESC;"}
{"instruction": "Using Node.js and Express, write an async route handler that fetches a user's profile and their last 5 orders concurrently from a PostgreSQL database using the 'pg' library.", "output": "const express = require('express');\nconst { Pool } = require('pg');\nconst router = express.Router();\nconst pool = new Pool(); // config omitted\n\nrouter.get('/users/:id/dashboard', async (req, res, next) => {\n  const userId = req.params.id;\n\n  try {\n    // Execute queries concurrently using Promise.all\n    const [userResult, ordersResult] = await Promise.all([\n      pool.query('SELECT id, name, email FROM users WHERE id = $1', [userId]),\n      pool.query('SELECT id, total, created_at FROM orders WHERE user_id = $1 ORDER BY created_at DESC LIMIT 5', [userId])\n    ]);\n\n    if (userResult.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      profile: userResult.rows[0],\n      recentOrders: ordersResult.rows\n    });\n  } catch (err) {\n    next(err);\n  }\n});"}
{"instruction": "Design a SQL schema (DDL) for a simple Blog system containing 'users', 'posts', and a many-to-many relationship for 'tags'. Include foreign keys and constraints.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Create a Python function using `asyncio` that simulates fetching data from 3 different external APIs concurrently and aggregates the results. Handle potential exceptions for individual tasks without crashing the whole operation.", "output": "import asyncio\nimport random\n\nasync def fetch_data(source_name: str):\n    await asyncio.sleep(random.uniform(0.5, 1.5))\n    if random.random() < 0.2:  # Simulate failure\n        raise Exception(f\"Failed to fetch from {source_name}\")\n    return {\"source\": source_name, \"data\": \"ok\"}\n\nasync def aggregate_data():\n    sources = [\"API_A\", \"API_B\", \"API_C\"]\n    tasks = [fetch_data(src) for src in sources]\n    \n    # return_exceptions=True prevents one failure from stopping others\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    \n    final_output = {\n        \"success\": [],\n        \"errors\": []\n    }\n    \n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            final_output[\"errors\"].append(f\"{sources[i]}: {str(result)}\")\n        else:\n            final_output[\"success\"].append(result)\n            \n    return final_output"}
{"instruction": "Write a FastAPI path operation that triggers a background task (e.g., sending a welcome email) after returning the response to the client.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_welcome_email(email: str, message: str):\n    # Simulate a long blocking operation (e.g., SMTP connection)\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_welcome_email, email, message=\"Welcome to our platform!\")\n    \n    return {\"message\": \"Signup successful. Check your email shortly.\"}"}
{"instruction": "Write a SQL query using a Window Function to calculate the 'Running Total' of revenue per day from a 'sales' table (columns: date, amount).", "output": "SELECT \n    date,\n    amount,\n    SUM(amount) OVER (ORDER BY date ASC) as running_total\nFROM \n    sales\nORDER BY \n    date;"}
{"instruction": "Using Node.js, write a function that performs a database transaction to transfer funds between two accounts. Rollback if any step fails.", "output": "const transferFunds = async (client, fromAccountId, toAccountId, amount) => {\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, fromAccountId]\n    );\n\n    if (deductRes.rows.length === 0 || deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds or invalid account');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccountId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  }\n};"}
{"instruction": "Implement a FastAPI Dependency that yields a database session and ensures the session is closed after the request is finished, even if errors occur.", "output": "from typing import AsyncGenerator\n# Assuming AsyncSession and SessionLocal are defined via SQLAlchemy\n\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()"}
{"instruction": "Write a SQL query to find the top 3 highest-paid employees in *each* department from an 'employees' table.", "output": "WITH RankedEmployees AS (\n    SELECT \n        id, \n        name, \n        department_id, \n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM \n        employees\n)\nSELECT \n    name, \n    department_id, \n    salary \nFROM \n    RankedEmployees \nWHERE \n    rank <= 3;"}
{"instruction": "Create a FastAPI endpoint that simulates a non-blocking external API call taking 2 seconds using async/await logic.", "output": "import asyncio\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/external-data\")\nasync def get_external_data():\n    # Simulate a non-blocking I/O operation (e.g., waiting for an upstream API)\n    await asyncio.sleep(2)\n    return {\"data\": \"fetched\", \"status\": \"success\"}"}
{"instruction": "Write a Node.js Express middleware function that logs the HTTP method, URL, and the duration of the request in milliseconds.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = (req, res, next) => {\n  const start = Date.now();\n  \n  // Listen for the response to finish to calculate duration\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`${req.method} ${req.originalUrl} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Write SQL commands to create a normalized schema for a Blog system with tables for 'authors', 'posts', and 'comments'. Include foreign keys and ensure comments are deleted if the parent post is deleted.", "output": "CREATE TABLE authors (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    author_id INT REFERENCES authors(id),\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INT REFERENCES posts(id) ON DELETE CASCADE,\n    author_name VARCHAR(50),\n    comment_text TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Define a Pydantic model for a 'Product' with fields: name (string), price (positive float), and tags (list of strings). Create a FastAPI POST endpoint to validate this data.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field, PositiveFloat\nfrom typing import List\n\napp = FastAPI()\n\nclass Product(BaseModel):\n    name: str\n    price: PositiveFloat\n    tags: List[str] = []\n\n@app.post(\"/products/\")\nasync def create_product(product: Product):\n    # Pydantic automatically validates types and constraints\n    return {\"message\": \"Product created\", \"product\": product}"}
{"instruction": "Using the 'pg' library in Node.js, write an async function that performs an atomic transaction to transfer funds between two users. It should rollback if any error occurs.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return 'Transfer successful';\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their specific department.", "output": "SELECT \n    employee_id,\n    name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Implement a FastAPI dependency that checks for a specific header 'X-API-Key'. If missing or invalid, raise an HTTPException with status 401.", "output": "from fastapi import FastAPI, Header, HTTPException, Depends\n\napp = FastAPI()\n\nasync def verify_token(x_api_key: str = Header(...)):\n    if x_api_key != \"secret-token\":\n        raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n\n@app.get(\"/secure-data\", dependencies=[Depends(verify_token)])\nasync def get_secure_data():\n    return {\"data\": \"This is protected data\"}"}
{"instruction": "Write a Node.js script using the 'fs' and 'readline' modules to process a large CSV file line-by-line to avoid high memory usage.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLineByLine() {\n  const fileStream = fs.createReadStream('large_data.csv');\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Process each line individually without loading the whole file\n    console.log(`Processing line: ${line}`);\n  }\n}\n\nprocessLineByLine();"}
{"instruction": "Write a SQL query to find users who have placed more than 5 orders in the last 30 days using aggregation and filtering.", "output": "SELECT \n    user_id,\n    COUNT(order_id) as order_count\nFROM \n    orders\nWHERE \n    order_date >= NOW() - INTERVAL '30 days'\nGROUP BY \n    user_id\nHAVING \n    COUNT(order_id) > 5;"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and immediately returns a 202 Accepted status, while processing the file in the background.", "output": "from fastapi import FastAPI, UploadFile, BackgroundTasks\n\napp = FastAPI()\n\ndef process_file(filename: str):\n    # Simulate expensive processing\n    print(f\"Processing {filename}...\")\n    # Logic to parse/save file goes here\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile, background_tasks: BackgroundTasks):\n    # Add task to be run after response is sent\n    background_tasks.add_task(process_file, file.filename)\n    return {\"status\": \"File received\", \"filename\": file.filename}"}
{"instruction": "Create a FastAPI async endpoint that registers a user using SQLAlchemy (async). Include a Pydantic model for input validation and password hashing context.", "output": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel, EmailStr\nfrom passlib.context import CryptContext\nfrom .database import get_db\nfrom .models import User\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\nrouter = APIRouter()\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n@router.post(\"/users/\", status_code=201)\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    hashed_password = pwd_context.hash(user.password)\n    new_user = User(email=user.email, hashed_password=hashed_password)\n    \n    db.add(new_user)\n    try:\n        await db.commit()\n        await db.refresh(new_user)\n    except Exception:\n        await db.rollback()\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n        \n    return {\"id\": new_user.id, \"email\": new_user.email}"}
{"instruction": "Write a raw SQL query using PostgreSQL syntax to create a schema for an Order system. It should include an 'orders' table and an 'order_items' table with foreign keys and a check constraint for positive quantity.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(20) DEFAULT 'pending'\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    price_per_unit DECIMAL(10, 2) NOT NULL\n);"}
{"instruction": "Implement a Node.js function using the 'pg' library to perform a database transaction that transfers money between two accounts asynchronously.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n\n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI WebSocket endpoint that accepts a connection, receives text messages, and echoes them back reversed.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/reverse\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            reversed_text = data[::-1]\n            await websocket.send_text(f\"Reversed: {reversed_text}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Write a SQL query to find the top 3 selling products by total revenue for the current month.", "output": "SELECT \n    p.product_name,\n    SUM(oi.quantity * oi.price_per_unit) as total_revenue\nFROM order_items oi\nJOIN orders o ON oi.order_id = o.id\nJOIN products p ON oi.product_id = p.id\nWHERE \n    o.created_at >= DATE_TRUNC('month', CURRENT_DATE)\n    AND o.created_at < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'\nGROUP BY p.product_id, p.product_name\nORDER BY total_revenue DESC\nLIMIT 3;"}
{"instruction": "Create a Node.js Express middleware that validates a custom API Key header asynchronously against a Redis database.", "output": "const redis = require('redis');\nconst client = redis.createClient();\nclient.connect();\n\nconst apiKeyAuth = async (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n\n  if (!apiKey) {\n    return res.status(401).json({ error: 'API Key missing' });\n  }\n\n  try {\n    const isValid = await client.get(`apikey:${apiKey}`);\n    if (!isValid) {\n      return res.status(403).json({ error: 'Invalid API Key' });\n    }\n    next();\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Internal Server Error' });\n  }\n};\n\nmodule.exports = apiKeyAuth;"}
{"instruction": "Define a Pydantic v2 model in Python with a custom field validator that ensures a 'tags' list contains at least one item and no duplicates.", "output": "from pydantic import BaseModel, field_validator\nfrom typing import List\n\nclass BlogPost(BaseModel):\n    title: str\n    content: str\n    tags: List[str]\n\n    @field_validator('tags')\n    @classmethod\n    def validate_tags(cls, v: List[str]) -> List[str]:\n        if not v:\n            raise ValueError('Tags list cannot be empty')\n        if len(v) != len(set(v)):\n            raise ValueError('Tags must be unique')\n        return v"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to fetch a category hierarchy (e.g., Electronics -> Laptops -> Gaming Laptops).", "output": "WITH RECURSIVE CategoryPath AS (\n    -- Anchor member: select the root category (or specific starting point)\n    SELECT id, name, parent_id, name::TEXT as path\n    FROM categories\n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive member: join with the previous level\n    SELECT c.id, c.name, c.parent_id, cp.path || ' -> ' || c.name\n    FROM categories c\n    INNER JOIN CategoryPath cp ON c.parent_id = cp.id\n)\nSELECT id, name, path FROM CategoryPath;"}
{"instruction": "Create a FastAPI endpoint that utilizes 'BackgroundTasks' to simulate processing a heavy image file after returning a response to the client.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(image_name: str):\n    # Simulate heavy blocking I/O operation\n    time.sleep(5)\n    print(f\"Finished processing {image_name}\")\n\n@app.post(\"/upload-image/{image_name}\")\nasync def upload_image(image_name: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(process_image, image_name)\n    return {\"message\": \"Image received. Processing in background.\"}"}
{"instruction": "Write a Node.js script using the 'fs' module streams to read a large CSV file and pipe it to a transform stream that converts it to JSON lines.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst csvPath = './large_data.csv';\nconst readStream = fs.createReadStream(csvPath, { encoding: 'utf8' });\n\nconst csvToJson = new Transform({\n  readableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    // Simple implementation assuming chunk doesn't split lines (for brevity)\n    // In production, use a library like 'csv-parser'\n    const lines = chunk.toString().split('\\n');\n    lines.forEach(line => {\n      if (line.trim()) {\n        const [id, name, value] = line.split(',');\n        this.push(JSON.stringify({ id, name, value }) + '\\n');\n      }\n    });\n    callback();\n  }\n});\n\nreadStream\n  .pipe(csvToJson)\n  .pipe(process.stdout)\n  .on('finish', () => console.log('Processing complete'));"}
{"instruction": "Create a FastAPI endpoint that accepts a user registration request, returns a 202 Accepted status immediately, and triggers a simulated background task to send a welcome email.", "output": "from fastapi import FastAPI, BackgroundTasks, status\nfrom pydantic import BaseModel\nimport asyncio\n\napp = FastAPI()\n\nclass UserEmail(BaseModel):\n    email: str\n    username: str\n\nasync def send_welcome_email(email: str, username: str):\n    # Simulate a long-running email sending process\n    await asyncio.sleep(5)\n    print(f\"Email sent to {email} for user {username}\")\n\n@app.post(\"/register\", status_code=status.HTTP_202_ACCEPTED)\nasync def register_user(user: UserEmail, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_welcome_email, user.email, user.username)\n    return {\"message\": \"Registration accepted. Email will be sent in the background.\"}"}
{"instruction": "Write a SQL DDL script (PostgreSQL dialect) to create a schema for a simple library system. Include tables for 'Authors' and 'Books' with a one-to-many relationship, enforcing foreign keys and non-null constraints.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(20) UNIQUE NOT NULL,\n    published_year INTEGER,\n    author_id INTEGER NOT NULL,\n    CONSTRAINT fk_author\n        FOREIGN KEY(author_id) \n        REFERENCES authors(author_id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js/Express middleware function that verifies a JSON Web Token (JWT) extracted from the 'Authorization' header (Bearer scheme).", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Using Python and SQLAlchemy (Async), define the models for a Many-to-Many relationship between 'Students' and 'Courses' using an association table.", "output": "from sqlalchemy import Column, Integer, String, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, DeclarativeBase\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\n\nclass Base(AsyncAttrs, DeclarativeBase):\n    pass\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', ForeignKey('students.id'), primary_key=True),\n    Column('course_id', ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Write a Node.js function using Mongoose to perform an aggregation that calculates the total sales revenue per region, sorting the results by revenue in descending order.", "output": "const Sales = require('./models/Sales');\n\nasync function getRevenueByRegion() {\n  try {\n    const revenueStats = await Sales.aggregate([\n      {\n        $group: {\n          _id: \"$region\",\n          totalRevenue: { $sum: \"$amount\" },\n          count: { $sum: 1 }\n        }\n      },\n      {\n        $sort: { totalRevenue: -1 }\n      }\n    ]);\n    return revenueStats;\n  } catch (error) {\n    console.error(\"Aggregation failed:\", error);\n    throw error;\n  }\n}"}
{"instruction": "Create a Pydantic v2 model in Python that validates a configuration object. It must ensure that 'max_retries' is positive and that if 'ssl_enabled' is True, the 'port' must be 443.", "output": "from pydantic import BaseModel, Field, model_validator\nfrom typing import Optional\n\nclass ServerConfig(BaseModel):\n    host: str\n    port: int\n    ssl_enabled: bool = False\n    max_retries: int = Field(default=3, gt=0)\n\n    @model_validator(mode='after')\n    def check_ssl_port(self) -> 'ServerConfig':\n        if self.ssl_enabled and self.port != 443:\n            raise ValueError('Port must be 443 when SSL is enabled')\n        return self"}
{"instruction": "Write a SQL query using a Window Function to find the top 3 highest paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    employee_id,\n    name,\n    department_id,\n    salary\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Write a Node.js async function that fetches user data and their posts simultaneously from two different mock API endpoints using Promise.all to optimize performance.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or Node 18+ native fetch\n\nasync function getUserProfile(userId) {\n  const userUrl = `https://api.example.com/users/${userId}`;\n  const postsUrl = `https://api.example.com/users/${userId}/posts`;\n\n  try {\n    const [userRes, postsRes] = await Promise.all([\n      fetch(userUrl),\n      fetch(postsUrl)\n    ]);\n\n    if (!userRes.ok || !postsRes.ok) throw new Error('Network response was not ok');\n\n    const userData = await userRes.json();\n    const userPosts = await postsRes.json();\n\n    return { ...userData, posts: userPosts };\n  } catch (error) {\n    console.error('Error fetching profile:', error);\n    return null;\n  }\n}"}
{"instruction": "Create a FastAPI dependency that yields an asynchronous database session using SQLModel/SQLAlchemy and ensures the session is closed after the request is processed.", "output": "from typing import AsyncGenerator\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session_maker = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a raw SQL transaction that transfers $100 from account A to account B, ensuring atomicity. If any step fails, the whole operation should roll back.", "output": "BEGIN;\n\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 'A' AND balance >= 100;\n\n-- Check if the update actually happened (row count check logic usually handled in app code, but SQL logic follows)\n-- If the previous update affected 0 rows (insufficient funds), we would ROLLBACK here in application logic.\n\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 'B';\n\nCOMMIT;"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously accepts a user profile with validation using Pydantic. The endpoint should calculate the user's age based on their birthdate and return a JSON response.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom datetime import date\n\napp = FastAPI()\n\nclass UserProfile(BaseModel):\n    username: str\n    email: str\n    birthdate: date\n\n@app.post(\"/calculate-age\")\nasync def calculate_user_age(user: UserProfile):\n    today = date.today()\n    if user.birthdate > today:\n        raise HTTPException(status_code=400, detail=\"Birthdate cannot be in the future\")\n    \n    age = today.year - user.birthdate.year - ((today.month, today.day) < (user.birthdate.month, user.birthdate.day))\n    \n    return {\n        \"username\": user.username,\n        \"age\": age,\n        \"status\": \"active\"\n    }"}
{"instruction": "Write a raw SQL schema (PostgreSQL compatible) for a 'Library' system. Create tables for 'Authors' and 'Books' with a One-to-Many relationship, ensuring referential integrity with cascading deletes.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE,\n    author_id INT,\n    CONSTRAINT fk_author\n      FOREIGN KEY(author_id) \n      REFERENCES authors(author_id)\n      ON DELETE CASCADE\n);"}
{"instruction": "Implement a Node.js Express middleware function that asynchronously logs the duration of every HTTP request in milliseconds.", "output": "const express = require('express');\nconst app = express();\n\nconst requestLogger = async (req, res, next) => {\n  const start = Date.now();\n  \n  // Hook into the response 'finish' event to calculate duration after the response is sent\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`[${req.method}] ${req.originalUrl} - ${res.statusCode} - ${duration}ms`);\n  });\n\n  next();\n};\n\napp.use(requestLogger);"}
{"instruction": "Using Python and SQLAlchemy (asyncio extension), define a Many-to-Many relationship between 'Students' and 'Courses' using an association table.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_courses = Table(\n    'student_courses',\n    Base.metadata,\n    Column('student_id', ForeignKey('students.id'), primary_key=True),\n    Column('course_id', ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_courses, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_courses, back_populates=\"courses\")"}
{"instruction": "Create a Node.js function using `fs` and `readline` to process a massive CSV file line-by-line asynchronously to avoid blocking the event loop.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Simulate async processing per line\n    const data = line.split(',');\n    await saveToDatabase(data);\n  }\n  console.log('File processing complete.');\n}\n\nasync function saveToDatabase(data) {\n  // Placeholder for DB logic\n  return new Promise(resolve => setTimeout(resolve, 1));\n}"}
{"instruction": "Write a SQL query to find the top 3 customers who have spent the most money in the current month, assuming tables `customers` (id, name) and `orders` (id, customer_id, total_amount, created_at).", "output": "SELECT \n    c.name,\n    SUM(o.total_amount) as total_spent\nFROM \n    customers c\nJOIN \n    orders o ON c.id = o.customer_id\nWHERE \n    o.created_at >= DATE_TRUNC('month', CURRENT_DATE)\n    AND o.created_at < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_spent DESC\nLIMIT 3;"}
{"instruction": "In FastAPI, create a dependency function to manage a database session that opens a session, yields it to the path operation, and ensures it closes afterwards.", "output": "from typing import Generator\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming SessionLocal is defined elsewhere in database.py\n\ndef get_db() -> Generator:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items(db: Session = Depends(get_db)):\n    # db is used here and automatically closed after request\n    return db.query(Item).all()"}
{"instruction": "Using Node.js, write an async function that fetches data from three different APIs concurrently using `Promise.all` and returns the combined result.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData() {\n  try {\n    const [usersRes, postsRes, commentsRes] = await Promise.all([\n      axios.get('https://api.example.com/users'),\n      axios.get('https://api.example.com/posts'),\n      axios.get('https://api.example.com/comments')\n    ]);\n\n    return {\n      userCount: usersRes.data.length,\n      recentPosts: postsRes.data.slice(0, 5),\n      latestComments: commentsRes.data.slice(0, 5)\n    };\n  } catch (error) {\n    console.error(\"Error fetching dashboard data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Write a SQL query using a Recursive CTE (Common Table Expression) to retrieve a full category hierarchy (category tree) starting from a root category with `id = 1`.", "output": "WITH RECURSIVE category_path (id, name, parent_id, level) AS (\n    -- Anchor member: select the root\n    SELECT id, name, parent_id, 0\n    FROM categories\n    WHERE id = 1\n    \n    UNION ALL\n    \n    -- Recursive member: join with the previous level\n    SELECT c.id, c.name, c.parent_id, cp.level + 1\n    FROM categories c\n    INNER JOIN category_path cp ON c.parent_id = cp.id\n)\nSELECT * FROM category_path ORDER BY level;"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload and triggers a background task (e.g., image processing) so the user gets an immediate response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\n\napp = FastAPI()\n\ndef process_image(filename: str):\n    # Simulate a long-running CPU bound task\n    import time\n    time.sleep(5)\n    print(f\"Finished processing {filename}\")\n\n@app.post(\"/upload-image/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Save file temporarily (logic omitted for brevity)\n    \n    # Add processing to background tasks\n    background_tasks.add_task(process_image, file.filename)\n    \n    return {\"message\": \"Image received. Processing started in background.\", \"filename\": file.filename}"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to validate an incoming JSON payload for creating a new user. The payload must contain a username (string), email (valid email), and age (integer > 18).", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    age: int = Field(..., gt=18, description=\"Age must be greater than 18\")\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate):\n    # Simulate database insertion logic here\n    return {\"message\": \"User created successfully\", \"data\": user}"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to perform an atomic transaction. The function should transfer a specific amount from one account ID to another.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rows.length === 0) throw new Error('Sender not found');\n    \n    const addRes = await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2 RETURNING *',\n      [amount, receiverId]\n    );\n    \n    if (addRes.rows.length === 0) throw new Error('Receiver not found');\n    \n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema for a simple Library system. Create tables for 'Authors' and 'Books', ensuring a one-to-many relationship where an author can have multiple books.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_year INT,\n    author_id INT,\n    CONSTRAINT fk_author\n      FOREIGN KEY(author_id) \n      REFERENCES authors(author_id)\n      ON DELETE SET NULL\n);"}
{"instruction": "Implement a FastAPI dependency that connects to a database session, yields it for the request, and closes it afterward. Show how to inject it into a route.", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming 'SessionLocal' is already configured in a database module\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\nasync def read_items(db: Session = Depends(get_db)):\n    # Use the synchronous db session within the async path operation\n    # Note: For heavy blocking I/O, consider run_in_threadpool or async drivers\n    items = db.execute(\"SELECT * FROM items\").fetchall()\n    return items"}
{"instruction": "Write a SQL query using a Window Function to rank employees by their salary within their specific department.", "output": "SELECT \n    employee_id,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM \n    employees;"}
{"instruction": "Create a Node.js Express middleware that validates a custom header 'X-API-Key'. If the key is missing or invalid, return a 401 Unauthorized response.", "output": "const express = require('express');\nconst app = express();\n\nconst validateApiKey = (req, res, next) => {\n  const apiKey = req.get('X-API-Key');\n  const validKey = process.env.API_KEY_SECRET;\n\n  if (!apiKey || apiKey !== validKey) {\n    return res.status(401).json({ error: 'Unauthorized: Invalid or missing API Key' });\n  }\n  next();\n};\n\napp.use('/protected', validateApiKey);\n\napp.get('/protected/resource', (req, res) => {\n  res.json({ data: 'Secret data' });\n});"}
{"instruction": "Using FastAPI, implement a Background Task that sends a welcome email after the user successfully registers, without blocking the response.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef send_welcome_email(email: str):\n    # Simulate a long-running email sending process\n    print(f\"Sending email to {email}...\")\n    # time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register/{email}\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_welcome_email, email)\n    return {\"message\": \"Registration successful. Email will be sent shortly.\"}"}
{"instruction": "Write a SQL query to fetch the top 3 product categories by total sales revenue. Assume tables: 'categories', 'products', and 'order_items'.", "output": "SELECT \n    c.name AS category_name,\n    SUM(oi.quantity * oi.unit_price) AS total_revenue\nFROM \n    categories c\nJOIN \n    products p ON c.id = p.category_id\nJOIN \n    order_items oi ON p.id = oi.product_id\nGROUP BY \n    c.id, c.name\nORDER BY \n    total_revenue DESC\nLIMIT 3;"}
{"instruction": "Create a Node.js script that reads a large CSV file using streams and logs the number of lines processed, to avoid loading the whole file into memory.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineCount = 0;\n\n  for await (const line of rl) {\n    // Process line here (e.g., parse CSV)\n    lineCount++;\n  }\n\n  console.log(`Processed ${lineCount} lines.`);\n}\n\nprocessLargeFile('./large_data.csv');"}
{"instruction": "Implement a WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint using SQLAlchemy (Async) that registers a new user. Include a Pydantic model for input validation and hash the password before saving.", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel, EmailStr\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import Column, Integer, String, select\nfrom sqlalchemy.orm import declarative_base\nfrom passlib.context import CryptContext\n\n# Setup\napp = FastAPI()\nBase = declarative_base()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# Database Model\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Pydantic Schema\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n# Helper\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n# Dependency (Mocked for snippet)\nasync def get_db():\n    # yield async_session\n    pass\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check existing\n    result = await db.execute(select(User).filter(User.email == user.email))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    # Create User\n    hashed_pw = get_password_hash(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_pw)\n    db.add(db_user)\n    await db.commit()\n    await db.refresh(db_user)\n    return {\"id\": db_user.id, \"email\": db_user.email}"}
{"instruction": "Write a Node.js function using the 'pg' library to perform a transactional bank transfer between two accounts. Ensure that if the credit or debit fails, the entire transaction rolls back.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Deduct from sender\n    const debitRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (debitRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    const creditRes = await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2 RETURNING *',\n      [amount, receiverId]\n    );\n\n    if (creditRes.rowCount === 0) {\n      throw new Error('Invalid receiver');\n    }\n\n    await client.query('COMMIT');\n    return { success: true, sender: debitRes.rows[0], receiver: creditRes.rows[0] };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema for a Library system. Create tables for 'Authors', 'Books', and a many-to-many relationship table 'Book_Authors' to handle books with multiple authors.", "output": "CREATE TABLE Authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE NOT NULL,\n    published_date DATE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Book_Authors (\n    book_id INT NOT NULL,\n    author_id INT NOT NULL,\n    PRIMARY KEY (book_id, author_id),\n    CONSTRAINT fk_book\n        FOREIGN KEY(book_id) \n        REFERENCES Books(book_id)\n        ON DELETE CASCADE,\n    CONSTRAINT fk_author\n        FOREIGN KEY(author_id) \n        REFERENCES Authors(author_id)\n        ON DELETE CASCADE\n);"}
{"instruction": "Using FastAPI and Pydantic, implement a model validator that ensures the 'end_date' of an event is chronologically after the 'start_date'.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, model_validator\nfrom datetime import datetime\n\nclass EventSchema(BaseModel):\n    name: str\n    start_date: datetime\n    end_date: datetime\n\n    @model_validator(mode='after')\n    def check_dates(self):\n        if self.end_date <= self.start_date:\n            raise ValueError('end_date must be after start_date')\n        return self\n\napp = FastAPI()\n\n@app.post(\"/events/\")\nasync def create_event(event: EventSchema):\n    return {\"msg\": \"Event created successfully\", \"event\": event}"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within their respective departments. The output should include employee name, department, salary, and their rank.", "output": "SELECT \n    employee_name,\n    department_id,\n    salary,\n    DENSE_RANK() OVER (\n        PARTITION BY department_id \n        ORDER BY salary DESC\n    ) as salary_rank\nFROM \n    employees\nORDER BY \n    department_id, salary_rank;"}
{"instruction": "Create a Node.js Express middleware that validates a JWT token from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return 401.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer TOKEN\"\n  const token = authHeader && authHeader.split(' ')[1]; \n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid or expired token' });\n    }\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Implement a FastAPI endpoint using 'BackgroundTasks' to simulate sending a welcome email after a user signs up, ensuring the HTTP response is not blocked by the email delay.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_logic(email: str):\n    # Simulate blocking I/O operation\n    time.sleep(2) \n    print(f\"Email sent to {email}\")\n\n@app.post(\"/signup/{email}\")\nasync def signup(email: str, background_tasks: BackgroundTasks):\n    # Add task to queue, returns response immediately\n    background_tasks.add_task(send_email_logic, email)\n    return {\"status\": \"Signup successful. Email will be sent shortly.\"}"}
{"instruction": "Write a Node.js script that fetches data from two different public APIs concurrently using Promise.all to optimize performance, then merges the results.", "output": "const axios = require('axios');\n\nasync function getUserData(userId) {\n  try {\n    const [userRes, postsRes] = await Promise.all([\n      axios.get(`https://jsonplaceholder.typicode.com/users/${userId}`),\n      axios.get(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`)\n    ]);\n\n    const userData = {\n      ...userRes.data,\n      posts: postsRes.data\n    };\n\n    return userData;\n  } catch (error) {\n    console.error(\"Error fetching data:\", error.message);\n    throw error;\n  }\n}\n\n// Usage\ngetUserData(1).then(data => console.log(JSON.stringify(data, null, 2)));"}
{"instruction": "Write a SQL query to find the monthly revenue for the current year, grouping results by month. Assume a 'orders' table with 'amount' and 'created_at' columns.", "output": "SELECT \n    EXTRACT(MONTH FROM created_at) AS month,\n    SUM(amount) AS total_revenue\nFROM \n    orders\nWHERE \n    EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY \n    EXTRACT(MONTH FROM created_at)\nORDER BY \n    month;"}
{"instruction": "Create a Python function using SQLAlchemy's async engine to perform a bulk insert of dictionary data into a database table.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import insert\n# Assuming 'User' model exists\n\nasync def bulk_create_users(db: AsyncSession, user_data_list: list[dict]):\n    \"\"\"\n    user_data_list example: [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]\n    \"\"\"\n    try:\n        stmt = insert(User).values(user_data_list)\n        await db.execute(stmt)\n        await db.commit()\n        return True\n    except Exception as e:\n        await db.rollback()\n        print(f\"Bulk insert failed: {e}\")\n        return False"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to validate and accept a new 'Product' entry containing a name, price (must be positive), and an optional description.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str\n    price: float = Field(..., gt=0, description=\"The price must be greater than zero\")\n    description: Optional[str] = None\n\n@app.post(\"/products/\")\nasync def create_product(product: ProductSchema):\n    # Simulate database insertion\n    product_data = product.dict()\n    product_data[\"id\"] = 101  # Mock ID\n    return {\"status\": \"created\", \"product\": product_data}"}
{"instruction": "Write a Node.js function using async/await to fetch data from two different API endpoints in parallel using Promise.all to optimize performance.", "output": "const fetch = require('node-fetch');\n\nasync function fetchDashboardData() {\n  try {\n    const [userResponse, statsResponse] = await Promise.all([\n      fetch('https://api.example.com/users/me'),\n      fetch('https://api.example.com/stats/daily')\n    ]);\n\n    if (!userResponse.ok || !statsResponse.ok) {\n      throw new Error('One or more requests failed');\n    }\n\n    const userData = await userResponse.json();\n    const statsData = await statsResponse.json();\n\n    return { user: userData, stats: statsData };\n  } catch (error) {\n    console.error('Error fetching dashboard data:', error);\n    throw error;\n  }\n}"}
{"instruction": "Design a SQL schema (PostgreSQL) for a 'Library' system handling a Many-to-Many relationship between Authors and Books.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    isbn VARCHAR(13) UNIQUE NOT NULL,\n    published_date DATE\n);\n\n-- Junction table for Many-to-Many relationship\nCREATE TABLE book_authors (\n    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    PRIMARY KEY (book_id, author_id)\n);"}
{"instruction": "Implement a FastAPI background task that simulates sending a welcome email after a user registers, ensuring the HTTP response is returned immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport asyncio\n\napp = FastAPI()\n\nasync def send_email_notification(email: str):\n    # Simulate a long-running blocking I/O operation\n    await asyncio.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/register/{email}\")\nasync def register_user(email: str, background_tasks: BackgroundTasks):\n    # Add the task to be executed after the response is sent\n    background_tasks.add_task(send_email_notification, email)\n    return {\"message\": \"Registration successful. Email will be sent shortly.\"}"}
{"instruction": "Write a raw SQL query to find the top 3 highest-paid employees in each department using a Window Function.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Create a Node.js Express middleware that checks for a custom header 'X-API-Key' and rejects the request with a 401 status if it is missing or invalid.", "output": "const express = require('express');\nconst app = express();\n\nconst VALID_API_KEY = 'secret-123';\n\nconst apiKeyMiddleware = (req, res, next) => {\n  const apiKey = req.get('X-API-Key');\n  \n  if (!apiKey || apiKey !== VALID_API_KEY) {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Invalid or missing API Key'\n    });\n  }\n  \n  next();\n};\n\napp.use('/secure', apiKeyMiddleware);\n\napp.get('/secure/data', (req, res) => {\n  res.json({ secret: 'This is protected data' });\n});"}
{"instruction": "Implement a FastAPI dependency that verifies a JWT token from the Authorization header.", "output": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    token = credentials.credentials\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token has expired\"\n        )\n    except jwt.InvalidTokenError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid token\"\n        )"}
{"instruction": "Using Node.js fs streams, write a script to read a large CSV file and pipe it to a writable stream (simulating a file copy) to avoid high memory usage.", "output": "const fs = require('fs');\nconst path = require('path');\n\nconst sourcePath = path.join(__dirname, 'large-data.csv');\nconst destPath = path.join(__dirname, 'copy-data.csv');\n\n// Create read and write streams\nconst readStream = fs.createReadStream(sourcePath);\nconst writeStream = fs.createWriteStream(destPath);\n\n// Pipe read stream to write stream\nreadStream.pipe(writeStream);\n\nreadStream.on('error', (err) => {\n  console.error('Error reading file:', err);\n});\n\nwriteStream.on('finish', () => {\n  console.log('File copied successfully using streams.');\n});"}
{"instruction": "Write a SQL transaction block to safely transfer $100 from Account A to Account B, ensuring ACID properties.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE account_id = 'A' AND balance >= 100;\n\n-- Check if the update actually happened (row count check logic varies by DB driver, assuming success here)\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE account_id = 'B';\n\nCOMMIT;\n-- If any error occurs during execution, a ROLLBACK would be issued by the application logic."}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that echoes received messages back to the client.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/echo\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
{"instruction": "Create a FastAPI endpoint that accepts a user email and schedules a background task to simulate sending a welcome email without blocking the response.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_notification(email: str):\n    # Simulate a long-running email process\n    time.sleep(2)\n    print(f\"Email sent to {email}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_notification, email)\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Using Node.js and Express, write an async route handler that fetches user details and their recent orders concurrently from two hypothetical async service functions to optimize performance.", "output": "const express = require('express');\nconst router = express.Router();\nconst { getUserById, getOrdersByUserId } = require('./services');\n\nrouter.get('/user-dashboard/:id', async (req, res, next) => {\n  try {\n    const userId = req.params.id;\n\n    // Execute both promises concurrently\n    const [user, orders] = await Promise.all([\n      getUserById(userId),\n      getOrdersByUserId(userId)\n    ]);\n\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({\n      user,\n      recentOrders: orders\n    });\n  } catch (error) {\n    next(error);\n  }\n});"}
{"instruction": "Write the SQL DDL commands to create a normalized schema for a simple E-commerce system with 'Customers', 'Products', and a many-to-many relationship via 'Orders' and 'OrderItems'.", "output": "CREATE TABLE Customers (\n    customer_id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE Products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE Orders (\n    order_id SERIAL PRIMARY KEY,\n    customer_id INT REFERENCES Customers(customer_id),\n    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE OrderItems (\n    order_id INT REFERENCES Orders(order_id),\n    product_id INT REFERENCES Products(product_id),\n    quantity INT NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);"}
{"instruction": "Define a Pydantic model in Python for a 'BlogPost' that validates the title is not empty and the status is either 'draft' or 'published'.", "output": "from pydantic import BaseModel, field_validator, ValidationInfo\nfrom typing import Literal\n\nclass BlogPost(BaseModel):\n    title: str\n    content: str\n    status: Literal['draft', 'published']\n\n    @field_validator('title')\n    @classmethod\n    def title_must_not_be_empty(cls, v: str) -> str:\n        if not v.strip():\n            raise ValueError('Title cannot be empty or whitespace')\n        return v"}
{"instruction": "Write a complex SQL query to find the total revenue generated by each product category, ordered by highest revenue first.", "output": "SELECT \n    c.category_name,\n    SUM(oi.quantity * p.price) as total_revenue\nFROM Categories c\nJOIN Products p ON c.category_id = p.category_id\nJOIN OrderItems oi ON p.product_id = oi.product_id\nGROUP BY c.category_name\nORDER BY total_revenue DESC;"}
{"instruction": "Create a Node.js middleware function to validate a custom API key header ('X-API-KEY'). Return a 403 Forbidden status if the key is invalid.", "output": "const validateApiKey = (req, res, next) => {\n  const apiKey = req.header('X-API-KEY');\n  const VALID_KEY = process.env.API_SECRET_KEY;\n\n  if (!apiKey || apiKey !== VALID_KEY) {\n    return res.status(403).json({\n      error: 'Forbidden: Invalid or missing API Key'\n    });\n  }\n\n  next();\n};\n\nmodule.exports = validateApiKey;"}
{"instruction": "Implement a FastAPI dependency that yields a database session (using SQLAlchemy style context) and ensures the session is closed after the request is processed.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom .database import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage in route\n# def read_users(db: Session = Depends(get_db)):"}
{"instruction": "Write a SQL query using a Window Function to rank employees by salary within each department.", "output": "SELECT \n    employee_id,\n    name,\n    department_id,\n    salary,\n    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM Employees;"}
{"instruction": "Create a FastAPI endpoint that handles file uploads and validates that the uploaded file is an image (JPEG or PNG).", "output": "from fastapi import FastAPI, UploadFile, HTTPException\n\napp = FastAPI()\n\n@app.post(\"/upload-avatar/\")\nasync def upload_avatar(file: UploadFile):\n    if file.content_type not in [\"image/jpeg\", \"image/png\"]:\n        raise HTTPException(status_code=400, detail=\"Invalid file type. Only JPEG and PNG allowed.\")\n    \n    # Logic to save file would go here\n    return {\"filename\": file.filename, \"content_type\": file.content_type}"}
{"instruction": "Using Node.js, write a function that wraps a callback-based legacy database function 'db.query' into a Promise-based function.", "output": "const dbQueryPromise = (query, params) => {\n  return new Promise((resolve, reject) => {\n    // Assuming db.query(sql, params, callback)\n    db.query(query, params, (err, results) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(results);\n    });\n  });\n};\n\n// Usage: const users = await dbQueryPromise('SELECT * FROM users WHERE id = ?', [1]);"}
{"instruction": "Create a FastAPI endpoint using Python that asynchronously fetches data from an external API (e.g., https://api.example.com/data) using `httpx` and returns the JSON response. Handle potential connection errors.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-data\")\nasync def get_external_data():\n    url = \"https://api.example.com/data\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as exc:\n            raise HTTPException(status_code=exc.response.status_code, detail=\"External API error\")\n        except httpx.RequestError:\n            raise HTTPException(status_code=503, detail=\"External service unavailable\")"}
{"instruction": "Write a Node.js Express middleware function to verify a JWT (JSON Web Token) from the 'Authorization' header (Bearer scheme). Attach the decoded user to the request object or return a 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;"}
{"instruction": "Design a SQL schema (PostgreSQL) for a many-to-many relationship between 'Users' and 'Groups'. Include the necessary CREATE TABLE statements with foreign keys and a unique constraint to prevent duplicate memberships.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE groups (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) NOT NULL,\n    description TEXT\n);\n\nCREATE TABLE user_groups (\n    user_id INT NOT NULL,\n    group_id INT NOT NULL,\n    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, group_id),\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n    FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE\n);"}
{"instruction": "Using FastAPI, create a route that accepts a user registration payload. After successfully returning a 200 OK response, trigger a background task to send a welcome email using FastAPI's `BackgroundTasks`.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass UserEmail(BaseModel):\n    email: str\n    username: str\n\ndef send_welcome_email(email: str, username: str):\n    # Logic to send email (e.g., SMTP)\n    print(f\"Sending email to {email} for user {username}\")\n\n@app.post(\"/register\")\nasync def register_user(user: UserEmail, background_tasks: BackgroundTasks):\n    # Logic to save user to DB would go here\n    background_tasks.add_task(send_welcome_email, user.email, user.username)\n    return {\"message\": \"User registered successfully. Email will be sent shortly.\"}"}
{"instruction": "Write a Node.js function using `Promise.all` to fetch data from three different API endpoints concurrently. Return a combined object, or handle errors if one fails.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or native fetch in Node 18+\n\nasync function fetchDashboardData() {\n  const urls = [\n    'https://api.app.com/users/stats',\n    'https://api.app.com/sales/daily',\n    'https://api.app.com/system/health'\n  ];\n\n  try {\n    const responses = await Promise.all(urls.map(url => fetch(url)));\n    \n    // Check for HTTP errors\n    const data = await Promise.all(responses.map(async (res) => {\n        if (!res.ok) throw new Error(`Failed to fetch ${res.url}`);\n        return res.json();\n    }));\n\n    return {\n      userStats: data[0],\n      sales: data[1],\n      systemHealth: data[2]\n    };\n  } catch (error) {\n    console.error(\"Error aggregating dashboard data:\", error);\n    throw error;\n  }\n}"}
{"instruction": "Write a SQL query using a recursive CTE (Common Table Expression) to retrieve a full category tree (id, name, parent_id) starting from a root category, assuming an adjacency list model.", "output": "WITH RECURSIVE category_tree AS (\n    -- Base case: select the root node(s)\n    SELECT id, name, parent_id, 1 as level\n    FROM categories\n    WHERE parent_id IS NULL\n\n    UNION ALL\n\n    -- Recursive step: join children to parents\n    SELECT c.id, c.name, c.parent_id, ct.level + 1\n    FROM categories c\n    INNER JOIN category_tree ct ON c.parent_id = ct.id\n)\nSELECT * FROM category_tree ORDER BY level, id;"}
{"instruction": "Create a Pydantic model in Python for an 'Order' which contains a list of 'Items'. Ensure that the order has at least one item and the total price is non-negative using validators.", "output": "from pydantic import BaseModel, validator, Field\nfrom typing import List\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    quantity: int\n\nclass Order(BaseModel):\n    order_id: str\n    items: List[Item]\n    total_price: float\n\n    @validator('items')\n    def check_items_not_empty(cls, v):\n        if not v:\n            raise ValueError('Order must contain at least one item')\n        return v\n\n    @validator('total_price')\n    def check_price_non_negative(cls, v):\n        if v < 0:\n            raise ValueError('Total price cannot be negative')\n        return v"}
{"instruction": "Write a raw SQL transaction block to transfer $100 from Account A to Account B. Include error handling logic (ROLLBACK) if the sender has insufficient funds.", "output": "BEGIN;\n\n-- Deduct from Account A\nUPDATE accounts \nSET balance = balance - 100 \nWHERE id = 'AccountA' AND balance >= 100;\n\n-- Check if the update actually happened (row count check logic depends on specific driver/procedure language)\n-- In a stored procedure, you would check ROW_COUNT here. If 0, ROLLBACK.\n\n-- Add to Account B\nUPDATE accounts \nSET balance = balance + 100 \nWHERE id = 'AccountB';\n\nCOMMIT;"}
{"instruction": "Implement a FastAPI dependency (`get_db`) using SQLAlchemy to yield a database session for a request and close it afterwards. Show how to use it in a route.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine\n\n# Setup (Mock)\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # Use db session here\n    # users = db.query(User).all()\n    return {\"status\": \"Connected to DB\"}"}
{"instruction": "Create a Node.js Mongoose schema for a 'Product' with a virtual property 'inStock' that returns true if quantity > 0. Include the configuration to ensure virtuals are included in JSON output.", "output": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst productSchema = new Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  quantity: { type: Number, default: 0 }\n}, {\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\nproductSchema.virtual('inStock').get(function() {\n  return this.quantity > 0;\n});\n\nconst Product = mongoose.model('Product', productSchema);"}
{"instruction": "Create a FastAPI endpoint using Python that accepts a JSON payload for a new product, validates it using Pydantic, and simulates an asynchronous database insertion.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nimport asyncio\n\napp = FastAPI()\n\nclass ProductSchema(BaseModel):\n    name: str = Field(..., min_length=3)\n    price: float = Field(..., gt=0)\n    description: str | None = None\n\n@app.post(\"/products/\", status_code=201)\nasync def create_product(product: ProductSchema):\n    # Simulate async DB operation\n    await asyncio.sleep(0.5)\n    return {\"id\": 101, \"name\": product.name, \"status\": \"created\"}"}
{"instruction": "Write a Node.js (Express) middleware function that asynchronously verifies a JWT token from the 'Authorization' header before allowing access to a protected route.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = async (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token == null) return res.sendStatus(401);\n\n  try {\n    // Verify token asynchronously\n    const user = await new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.TOKEN_SECRET, (err, user) => {\n        if (err) reject(err);\n        resolve(user);\n      });\n    });\n    req.user = user;\n    next();\n  } catch (err) {\n    return res.sendStatus(403);\n  }\n};"}
{"instruction": "Design a SQL schema (PostgreSQL syntax) for a Blog application containing Users, Posts, and a many-to-many relationship for Tags on Posts.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    post_id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published_at TIMESTAMP\n);\n\nCREATE TABLE tags (\n    tag_id SERIAL PRIMARY KEY,\n    name VARCHAR(30) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(post_id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(tag_id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Implement a Python function using SQLAlchemy (Async) to fetch a user by email, handling the database session context.", "output": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom models import User\n\nasync def get_user_by_email(session: AsyncSession, email: str):\n    result = await session.execute(select(User).where(User.email == email))\n    return result.scalars().first()"}
{"instruction": "Write a raw SQL query to calculate the monthly revenue for the current year, assuming an 'orders' table with 'created_at' and 'total_amount' columns.", "output": "SELECT \n    TO_CHAR(created_at, 'YYYY-MM') AS month,\n    SUM(total_amount) AS total_revenue\nFROM orders\nWHERE created_at >= DATE_TRUNC('year', CURRENT_DATE)\nGROUP BY 1\nORDER BY 1;"}
{"instruction": "Create a Node.js function using the 'pg' library to execute a transaction that transfers funds between two accounts safely.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(fromId, toId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const res = await client.query('SELECT balance FROM accounts WHERE id = $1', [fromId]);\n    if (res.rows[0].balance < amount) throw new Error('Insufficient funds');\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n    \n    await client.query('COMMIT');\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a FastAPI dependency that connects to a Redis instance, yields the client for the request scope, and closes the connection afterward.", "output": "import redis.asyncio as redis\nfrom fastapi import Depends\n\nasync def get_redis():\n    client = redis.Redis(host='localhost', port=6379, decode_responses=True)\n    try:\n        yield client\n    finally:\n        await client.close()\n\n# Usage in route: async def read_item(cache: redis.Redis = Depends(get_redis))"}
{"instruction": "Write a SQL query using a Window Function to find the top 3 highest-paid employees in each department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT * \nFROM RankedSalaries\nWHERE rank <= 3;"}
{"instruction": "Implement a Node.js Express route that streams a large CSV file from the file system to the client to reduce memory usage.", "output": "const fs = require('fs');\nconst path = require('path');\n\napp.get('/download/report', (req, res) => {\n  const filePath = path.join(__dirname, 'data', 'large_report.csv');\n  const stat = fs.statSync(filePath);\n\n  res.writeHead(200, {\n    'Content-Type': 'text/csv',\n    'Content-Length': stat.size,\n    'Content-Disposition': 'attachment; filename=report.csv'\n  });\n\n  const readStream = fs.createReadStream(filePath);\n  readStream.pipe(res);\n});"}
{"instruction": "Create a Python script using `asyncio` and `httpx` to fetch data from three different public APIs concurrently and aggregate the results.", "output": "import asyncio\nimport httpx\n\nasync def fetch_url(client, url):\n    resp = await client.get(url)\n    return resp.json()\n\nasync def main():\n    urls = [\n        \"https://api.example.com/users\",\n        \"https://api.example.com/posts\",\n        \"https://api.example.com/comments\"\n    ]\n    async with httpx.AsyncClient() as client:\n        tasks = [fetch_url(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    \n    print(f\"Fetched {len(results)} resources.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"}
{"instruction": "Create a FastAPI dependency that yields an asynchronous SQLAlchemy session for database interactions.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom fastapi import Depends\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session_maker = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Dependency\nasync def get_db() -> AsyncSession:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write a Node.js (Express) route handler that implements cursor-based pagination for a 'products' table using raw SQL.", "output": "const express = require('express');\nconst router = express.Router();\nconst db = require('./db'); // Assumes pg client\n\nrouter.get('/products', async (req, res) => {\n  const { cursor, limit = 10 } = req.query;\n  const limitParsed = parseInt(limit);\n  \n  // SQL: Fetch items created after the cursor (id) assuming sequential IDs\n  let query = 'SELECT id, name, created_at FROM products ';\n  const params = [limitParsed];\n  \n  if (cursor) {\n    query += 'WHERE id > $2 ';\n    params.push(cursor);\n  }\n  \n  query += 'ORDER BY id ASC LIMIT $1';\n\n  try {\n    const { rows } = await db.query(query, params);\n    const nextCursor = rows.length === limitParsed ? rows[rows.length - 1].id : null;\n    \n    res.json({\n      data: rows,\n      nextCursor\n    });\n  } catch (err) {\n    res.status(500).json({ error: 'Database error' });\n  }\n});"}
{"instruction": "Design a PostgreSQL schema for a Blog system containing Users, Posts, and Tags, implementing a Many-to-Many relationship between Posts and Tags.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- Junction Table for Many-to-Many\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Implement a FastAPI endpoint that accepts a file upload and processes it in the background using `BackgroundTasks` to avoid blocking the response.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\nimport shutil\n\napp = FastAPI()\n\ndef process_image(file_path: str):\n    # Simulate long-running CPU task (e.g., resizing, ML inference)\n    print(f\"Processing image at {file_path}...\")\n    # Logic here...\n    print(f\"Finished processing {file_path}\")\n\n@app.post(\"/upload-image/\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    file_location = f\"temp/{file.filename}\"\n    \n    # Save file asynchronously\n    with open(file_location, \"wb+\") as file_object:\n        shutil.copyfileobj(file.file, file_object)\n    \n    # Schedule processing after response is sent\n    background_tasks.add_task(process_image, file_location)\n    \n    return {\"message\": \"Image uploaded and processing started\", \"filename\": file.filename}"}
{"instruction": "Write a Node.js function using `pg` (node-postgres) to perform an atomic bank transfer between two users using SQL transactions.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferMoney(senderId, receiverId, amount) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Deduct from sender\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE user_id = $2 AND balance >= $1 RETURNING *',\n      [amount, senderId]\n    );\n    \n    if (deductRes.rowCount === 0) {\n      throw new Error('Insufficient funds or invalid sender');\n    }\n\n    // Add to receiver\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE user_id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    console.error('Transfer failed', e);\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Create a Pydantic v2 model for User Registration that validates the password contains at least one uppercase letter and one special character.", "output": "from pydantic import BaseModel, field_validator\nimport re\n\nclass UserRegistration(BaseModel):\n    username: str\n    email: str\n    password: str\n\n    @field_validator('password')\n    @classmethod\n    def validate_password_strength(cls, v: str) -> str:\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[@$!%*?&]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v"}
{"instruction": "Write a SQL query using a Window Function to find the top 2 highest-paid employees in every department.", "output": "WITH RankedSalaries AS (\n    SELECT \n        employee_id,\n        name,\n        department_id,\n        salary,\n        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank\n    FROM employees\n)\nSELECT \n    department_id,\n    name,\n    salary\nFROM RankedSalaries\nWHERE rank <= 2\nORDER BY department_id, salary DESC;"}
{"instruction": "Implement a Node.js middleware that checks Redis for a cached response before executing the controller logic.", "output": "const redis = require('redis');\nconst client = redis.createClient();\nclient.connect();\n\nconst cacheMiddleware = async (req, res, next) => {\n  const key = `route_cache_${req.originalUrl}`;\n  \n  try {\n    const cachedData = await client.get(key);\n    if (cachedData) {\n      // Cache hit: return data immediately\n      return res.json(JSON.parse(cachedData));\n    }\n    \n    // Cache miss: override res.json to store data before sending\n    const originalJson = res.json;\n    res.json = (body) => {\n      client.setEx(key, 60, JSON.stringify(body)); // Cache for 60s\n      return originalJson.call(res, body);\n    };\n    \n    next();\n  } catch (err) {\n    console.error('Redis error', err);\n    next(); // Skip cache on error\n  }\n};"}
{"instruction": "Create a FastAPI WebSocket endpoint that manages a list of active connections and broadcasts received messages to all connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Message: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(\"A client left the chat\")"}
{"instruction": "Write a SQL query to update a JSONB column in PostgreSQL, setting a specific key 'settings.theme' to 'dark' for a user with a specific ID.", "output": "UPDATE user_preferences\nSET config = jsonb_set(config, '{settings, theme}', '\"dark\"', TRUE)\nWHERE user_id = 123;"}
{"instruction": "Create a FastAPI POST endpoint that accepts a JSON payload for a 'Product' (name, price, is_offer) and returns the updated price including tax asynchronously.", "output": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport asyncio\n\napp = FastAPI()\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    is_offer: Optional[bool] = None\n\nasync def calculate_tax(price: float) -> float:\n    # Simulate async database lookup or heavy calculation\n    await asyncio.sleep(0.1)\n    return price * 1.2\n\n@app.post(\"/items/\")\nasync def create_item(product: Product):\n    final_price = await calculate_tax(product.price)\n    return {\n        \"item_name\": product.name,\n        \"final_price\": final_price,\n        \"is_offer\": product.is_offer\n    }"}
{"instruction": "Write a Node.js function using `Promise.all` to fetch data from two different API endpoints concurrently and return a combined object.", "output": "const fetch = require('node-fetch'); // Assuming node-fetch v2 or built-in in Node 18+\n\nasync function getUserAndPosts(userId) {\n  try {\n    const userPromise = fetch(`https://api.example.com/users/${userId}`).then(res => res.json());\n    const postsPromise = fetch(`https://api.example.com/users/${userId}/posts`).then(res => res.json());\n\n    const [user, posts] = await Promise.all([userPromise, postsPromise]);\n\n    return {\n      userProfile: user,\n      userPosts: posts\n    };\n  } catch (error) {\n    console.error(\"Error fetching data\", error);\n    throw error;\n  }\n}"}
{"instruction": "Design a PostgreSQL schema for a 'Library' system with a One-to-Many relationship between Authors and Books.", "output": "CREATE TABLE authors (\n    author_id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE books (\n    book_id SERIAL PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    isbn VARCHAR(13) UNIQUE,\n    published_date DATE,\n    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);"}
{"instruction": "Implement a FastAPI dependency that creates a new database session for a request and closes it afterwards (context management pattern).", "output": "from fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n# Assuming SessionLocal is defined elsewhere in database.py\n\napp = FastAPI()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/\")\ndef read_users(db: Session = Depends(get_db)):\n    # Use db session here\n    return {\"message\": \"Database session injected\"}"}
{"instruction": "Write a raw SQL query to find the top 3 customers who have spent the most money, joining an `orders` table and a `customers` table.", "output": "SELECT \n    c.customer_id,\n    c.email,\n    SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.email\nORDER BY total_spent DESC\nLIMIT 3;"}
{"instruction": "Create a Node.js Express middleware that checks for a specific API key in the headers and rejects the request with a 403 status if it is missing or invalid.", "output": "const express = require('express');\nconst app = express();\n\nconst apiKeyMiddleware = (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n  const VALID_KEY = process.env.API_KEY || 'secret123';\n\n  if (!apiKey || apiKey !== VALID_KEY) {\n    return res.status(403).json({ error: 'Forbidden: Invalid or missing API Key' });\n  }\n\n  next();\n};\n\napp.use(apiKeyMiddleware);\n\napp.get('/secure-data', (req, res) => {\n  res.json({ secret: 'data' });\n});"}
{"instruction": "Define SQLAlchemy (Python) models for a Many-to-Many relationship between `Student` and `Course` using an association table.", "output": "from sqlalchemy import Column, Integer, String, Table, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    courses = relationship(\"Course\", secondary=student_course_association, back_populates=\"students\")\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    students = relationship(\"Student\", secondary=student_course_association, back_populates=\"courses\")"}
{"instruction": "Create a FastAPI endpoint that triggers a background task (e.g., sending an email) and returns a response immediately.", "output": "from fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef write_notification(email: str, message: str):\n    # Simulate a long-running sync or async operation\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, email, message=\"Welcome!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a Node.js script using Streams to read a large CSV file and write it to a new file, transforming the text to uppercase, to avoid high memory usage.", "output": "const fs = require('fs');\nconst { Transform } = require('stream');\n\nconst readStream = fs.createReadStream('input.csv', { encoding: 'utf8' });\nconst writeStream = fs.createWriteStream('output.csv');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // Convert chunk to uppercase\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\nreadStream\n  .pipe(upperCaseTransform)\n  .pipe(writeStream)\n  .on('finish', () => console.log('Processing complete.'));"}
{"instruction": "Implement a Python Async Context Manager class that simulates connecting to and disconnecting from a network resource.", "output": "import asyncio\n\nclass AsyncNetworkResource:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n\n    async def __aenter__(self):\n        print(f\"Connecting to {self.host}:{self.port}...\")\n        await asyncio.sleep(0.5) # Simulate connection delay\n        self.connection = f\"ConnectedSocket({self.host})\"\n        return self.connection\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        print(\"Closing connection...\")\n        await asyncio.sleep(0.2)\n        self.connection = None\n\n# Usage\nasync def main():\n    async with AsyncNetworkResource('localhost', 8080) as conn:\n        print(f\"Using {conn}\")\n\n# asyncio.run(main())"}
{"instruction": "Create a FastAPI endpoint using 'httpx' to asynchronously fetch data from an external API ('https://api.thirdparty.com/status') and return it to the client.", "output": "from fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\n\n@app.get(\"/external-status\")\nasync def get_external_status():\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(\"https://api.thirdparty.com/status\")\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            raise HTTPException(status_code=e.response.status_code, detail=\"External API error\")\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=str(e))"}
{"instruction": "Write SQL DDL statements to create a normalized schema for a basic E-commerce system with 'users', 'products', and an 'orders' table that links them with a many-to-many relationship via an 'order_items' table.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id),\n    status VARCHAR(50) DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    order_id INT REFERENCES orders(id),\n    product_id INT REFERENCES products(id),\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);"}
{"instruction": "Implement a Node.js function using async/await to perform a database transaction (transferring money) ensuring ACID properties. Assume a generic 'db' client with query, begin, commit, and rollback methods.", "output": "async function transferFunds(senderId, receiverId, amount) {\n  const client = await db.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const senderRes = await client.query('SELECT balance FROM accounts WHERE id = $1 FOR UPDATE', [senderId]);\n    if (senderRes.rows[0].balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, senderId]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, receiverId]);\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Define a Pydantic model in Python for a 'UserRegistration' payload that validates the email, ensures the password is at least 8 characters, and includes an optional 'age' field that must be 18 or older if provided.", "output": "from pydantic import BaseModel, EmailStr, Field, validator\nfrom typing import Optional\n\nclass UserRegistration(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n    age: Optional[int] = None\n\n    @validator('age')\n    def check_age(cls, v):\n        if v is not None and v < 18:\n            raise ValueError('User must be at least 18 years old')\n        return v"}
{"instruction": "Write a SQL query to find the top 5 customers based on total spending amount in the year 2023, assuming tables 'customers' and 'orders' (with 'total_amount' and 'created_at').", "output": "SELECT \n    c.id, \n    c.name, \n    SUM(o.total_amount) as total_spent\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE o.created_at >= '2023-01-01' AND o.created_at <= '2023-12-31'\nGROUP BY c.id, c.name\nORDER BY total_spent DESC\nLIMIT 5;"}
{"instruction": "Create a Node.js Express middleware that checks for a specific header 'X-Secret-Token'. If missing or invalid, return 403 Forbidden; otherwise, call next().", "output": "const authMiddleware = (req, res, next) => {\n  const token = req.headers['x-secret-token'];\n  const validToken = process.env.SECRET_TOKEN;\n\n  if (!token || token !== validToken) {\n    return res.status(403).json({ error: 'Forbidden: Invalid or missing token' });\n  }\n  \n  next();\n};\n\n// Usage: app.use('/secure', authMiddleware, secureRoutes);"}
{"instruction": "Using FastAPI, create an endpoint that accepts a file upload and triggers a background task to process the image, returning a response immediately to the user.", "output": "from fastapi import FastAPI, UploadFile, File, BackgroundTasks\n\napp = FastAPI()\n\ndef process_image(file_name: str):\n    # Simulate expensive image processing\n    print(f\"Processing {file_name}...\")\n    # ... logic to resize/filter image ...\n    print(f\"Finished {file_name}\")\n\n@app.post(\"/upload\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    # Save file temporarily or stream it\n    file_location = f\"temp/{file.filename}\"\n    with open(file_location, \"wb+\") as file_object:\n        file_object.write(file.file.read())\n    \n    background_tasks.add_task(process_image, file.filename)\n    return {\"message\": \"Image received, processing in background\"}"}
{"instruction": "Write a SQL query using a Window Function to calculate the running total of sales for each day, ordered by date.", "output": "SELECT \n    sale_date,\n    daily_amount,\n    SUM(daily_amount) OVER (ORDER BY sale_date) as running_total\nFROM sales_log\nORDER BY sale_date;"}
{"instruction": "Create a Node.js route (Express) that streams a large CSV file from the file system to the client to prevent high memory usage.", "output": "const fs = require('fs');\nconst path = require('path');\n\napp.get('/download-report', (req, res) => {\n  const filePath = path.join(__dirname, 'data', 'large-report.csv');\n  \n  // Check if file exists\n  if (!fs.existsSync(filePath)) {\n    return res.status(404).send('File not found');\n  }\n\n  res.setHeader('Content-Type', 'text/csv');\n  res.setHeader('Content-Disposition', 'attachment; filename=\"report.csv\"');\n\n  const readStream = fs.createReadStream(filePath);\n  readStream.pipe(res);\n\n  readStream.on('error', (err) => {\n    res.status(500).end();\n  });\n});"}
{"instruction": "Implement a FastAPI dependency that creates a database session, yields it for use in the route, and ensures it is closed after the request is finished.", "output": "from fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom db_setup import SessionLocal\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Usage in route\n# @app.get(\"/users\")\n# def read_users(db: Session = Depends(get_db)):\n#     return crud.get_users(db)"}
{"instruction": "Create a FastAPI async endpoint to register a new user using SQLAlchemy and Pydantic. The endpoint should hash the password (mocked here) and save the user to the database.", "output": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\nfrom db import get_db, User  # Assumed imports\n\nrouter = APIRouter()\n\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n    email: str\n\n@router.post(\"/register\", status_code=201)\nasync def register_user(user_in: UserCreate, db: AsyncSession = Depends(get_db)):\n    # Check if user exists\n    result = await db.execute(select(User).where(User.username == user_in.username))\n    if result.scalars().first():\n        raise HTTPException(status_code=400, detail=\"Username already taken\")\n\n    # Mock hash\n    hashed_pw = user_in.password + \"_hashed\"\n    \n    new_user = User(username=user_in.username, email=user_in.email, hashed_password=hashed_pw)\n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    \n    return {\"id\": new_user.id, \"username\": new_user.username}"}
{"instruction": "Implement a Node.js Express route that fetches paginated results from a PostgreSQL database using the 'pg' library and raw SQL.", "output": "const express = require('express');\nconst { Pool } = require('pg');\nconst router = express.Router();\nconst pool = new Pool(); // Config assumed\n\nrouter.get('/products', async (req, res) => {\n  try {\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 10;\n    const offset = (page - 1) * limit;\n\n    const query = 'SELECT * FROM products ORDER BY created_at DESC LIMIT $1 OFFSET $2';\n    const values = [limit, offset];\n\n    const result = await pool.query(query, values);\n    \n    // Get total count for metadata\n    const countResult = await pool.query('SELECT COUNT(*) FROM products');\n    const totalItems = parseInt(countResult.rows[0].count);\n\n    res.json({\n      data: result.rows,\n      meta: {\n        page,\n        limit,\n        totalItems,\n        totalPages: Math.ceil(totalItems / limit)\n      }\n    });\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Database error' });\n  }\n});"}
{"instruction": "Write the SQL DDL commands to create a normalized schema for a Blog application with Users, Posts, and Tags (Many-to-Many relationship between Posts and Tags).", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INT REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INT REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);"}
{"instruction": "Implement a simple WebSocket endpoint in FastAPI that manages a list of active connections and broadcasts a received message to all other connected clients.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str, sender: WebSocket):\n        for connection in self.active_connections:\n            if connection != sender:\n                await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id} says: {data}\", sender=websocket)\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\", sender=websocket)"}
{"instruction": "In Node.js, write an async function that fetches data from three different API endpoints concurrently using Promise.all and returns a merged object.", "output": "const axios = require('axios');\n\nasync function fetchDashboardData(userId) {\n  const endpoints = [\n    `https://api.example.com/users/${userId}`,\n    `https://api.example.com/users/${userId}/orders`,\n    `https://api.example.com/users/${userId}/notifications`\n  ];\n\n  try {\n    // Fire all requests concurrently\n    const [userRes, ordersRes, notifRes] = await Promise.all(\n      endpoints.map(url => axios.get(url))\n    );\n\n    return {\n      userProfile: userRes.data,\n      recentOrders: ordersRes.data,\n      unreadNotifications: notifRes.data,\n      timestamp: new Date()\n    };\n  } catch (error) {\n    console.error('Failed to aggregate dashboard data', error);\n    throw new Error('Service Unavailable');\n  }\n}"}
{"instruction": "Write a SQL query using a Window Function to calculate the running total of revenue per day for the current month.", "output": "SELECT \n    DATE(payment_date) as day,\n    SUM(amount) as daily_revenue,\n    SUM(SUM(amount)) OVER (\n        ORDER BY DATE(payment_date) \n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) as running_total\nFROM payments\nWHERE \n    payment_date >= DATE_TRUNC('month', CURRENT_DATE)\n    AND payment_date < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'\nGROUP BY DATE(payment_date)\nORDER BY day;"}
{"instruction": "Create an async database session dependency in FastAPI using `sqlalchemy.ext.asyncio`.", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\n\nengine = create_async_engine(DATABASE_URL, echo=True)\n\nasync_session_maker = sessionmaker(\n    engine, class_=AsyncSession, expire_on_commit=False\n)\n\n# Dependency\nasync def get_db() -> AsyncSession:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()"}
{"instruction": "Write an Express.js middleware that validates an API Key present in the request headers and blocks access if invalid.", "output": "const validateApiKey = (req, res, next) => {\n  const apiKey = req.header('x-api-key');\n  const VALID_KEY = process.env.API_KEY_SECRET;\n\n  if (!apiKey) {\n    return res.status(401).json({ \n      success: false, \n      message: 'Access denied. No API key provided.' \n    });\n  }\n\n  if (apiKey !== VALID_KEY) {\n    return res.status(403).json({ \n      success: false, \n      message: 'Invalid API key.' \n    });\n  }\n\n  next();\n};\n\n// Usage: app.use('/api', validateApiKey, apiRoutes);"}
{"instruction": "Create a FastAPI endpoint that accepts a file upload and processes it in the background (mock processing) to avoid blocking the response.", "output": "from fastapi import FastAPI, UploadFile, BackgroundTasks\nimport asyncio\n\napp = FastAPI()\n\nasync def process_file_task(filename: str):\n    # Simulate heavy processing (e.g., image resizing or CSV parsing)\n    await asyncio.sleep(5) \n    print(f\"Finished processing file: {filename}\")\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile, background_tasks: BackgroundTasks):\n    # Add the task to the queue to run after the response is sent\n    background_tasks.add_task(process_file_task, file.filename)\n    \n    return {\n        \"message\": \"File received. Processing started in background.\",\n        \"filename\": file.filename\n    }"}
{"instruction": "Write a SQL query using a Recursive CTE to fetch a category tree (id, name) for a specific root category to show the full hierarchy.", "output": "WITH RECURSIVE CategoryTree AS (\n    -- Anchor member: Select the root category\n    SELECT id, name, parent_id, 1 as level\n    FROM categories\n    WHERE id = 1 -- Assuming Root ID is 1\n\n    UNION ALL\n\n    -- Recursive member: Join with the previous level\n    SELECT c.id, c.name, c.parent_id, ct.level + 1\n    FROM categories c\n    INNER JOIN CategoryTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CategoryTree ORDER BY level, id;"}
{"instruction": "Create a FastAPI endpoint to register a new user. The endpoint should accept a JSON body with 'username' and 'password'. Use 'passlib' to hash the password before 'saving' it (simulated by appending to a global list). Return the user info without the password.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom passlib.context import CryptContext\nfrom typing import List\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n\nclass UserOut(BaseModel):\n    username: str\n\nfake_db = []\n\n@app.post(\"/register\", response_model=UserOut)\nasync def register_user(user: UserCreate):\n    # Check if user exists\n    if any(u['username'] == user.username for u in fake_db):\n        raise HTTPException(status_code=400, detail=\"Username already exists\")\n    \n    hashed_password = pwd_context.hash(user.password)\n    new_user = {\"username\": user.username, \"password\": hashed_password}\n    fake_db.append(new_user)\n    \n    return {\"username\": new_user[\"username\"]}"}
{"instruction": "Write a SQL query to retrieve the top 3 products with the highest total sales revenue. Assume two tables: 'products' (id, name) and 'order_items' (product_id, quantity, unit_price).", "output": "SELECT \n    p.name,\n    SUM(oi.quantity * oi.unit_price) as total_revenue\nFROM \n    products p\nJOIN \n    order_items oi ON p.id = oi.product_id\nGROUP BY \n    p.id, p.name\nORDER BY \n    total_revenue DESC\nLIMIT 3;"}
{"instruction": "Implement an asynchronous function in Node.js using the 'pg' (node-postgres) library to perform a bank transfer between two accounts within a transaction. The function should take senderId, receiverId, and amount.", "output": "const { Pool } = require('pg');\nconst pool = new Pool();\n\nasync function transferFunds(senderId, receiverId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const deductRes = await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance',\n      [amount, senderId]\n    );\n\n    if (deductRes.rows[0].balance < 0) {\n      throw new Error('Insufficient funds');\n    }\n\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, receiverId]\n    );\n\n    await client.query('COMMIT');\n    return { success: true };\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Define a Pydantic schema in Python for a 'Recipe' API. The recipe should have a title (max 100 chars), a list of ingredients (where each ingredient has a name and quantity), and an optional preparation time defaulting to 30 minutes.", "output": "from pydantic import BaseModel, Field\nfrom typing import List, Optional\n\nclass Ingredient(BaseModel):\n    name: str\n    quantity: str\n\nclass Recipe(BaseModel):\n    title: str = Field(..., max_length=100)\n    ingredients: List[Ingredient]\n    prep_time_minutes: Optional[int] = 30"}
{"instruction": "Create a Node.js Express middleware function that implements a simple in-memory rate limiter. It should allow a maximum of 100 requests per IP address per 15-minute window.", "output": "const rateLimit = {};\n\nconst limiter = (req, res, next) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const windowMs = 15 * 60 * 1000;\n\n  if (!rateLimit[ip]) {\n    rateLimit[ip] = { count: 1, startTime: now };\n  } else {\n    if (now - rateLimit[ip].startTime > windowMs) {\n      // Reset window\n      rateLimit[ip] = { count: 1, startTime: now };\n    } else {\n      rateLimit[ip].count++;\n    }\n  }\n\n  if (rateLimit[ip].count > 100) {\n    return res.status(429).json({ error: 'Too many requests' });\n  }\n\n  next();\n};"}
{"instruction": "Write a FastAPI endpoint that accepts an image file upload and uses 'BackgroundTasks' to process the image (simulated function) after returning a 202 Accepted response to the client immediately.", "output": "from fastapi import FastAPI, File, UploadFile, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef process_image(file_name: str):\n    # Simulate heavy processing\n    time.sleep(5)\n    print(f\"Finished processing {file_name}\")\n\n@app.post(\"/upload\")\nasync def upload_image(background_tasks: BackgroundTasks, file: UploadFile = File(...)):\n    background_tasks.add_task(process_image, file.filename)\n    return {\"status\": \"accepted\", \"message\": \"Image processing started in background\"}"}
{"instruction": "Design a SQL table schema (DDL) for a 'User_Roles' many-to-many relationship. Include tables for Users, Roles, and the junction table with foreign keys and a composite primary key.", "output": "CREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL\n);\n\nCREATE TABLE roles (\n    role_id SERIAL PRIMARY KEY,\n    role_name VARCHAR(20) UNIQUE NOT NULL\n);\n\nCREATE TABLE user_roles (\n    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,\n    role_id INT REFERENCES roles(role_id) ON DELETE CASCADE,\n    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, role_id)\n);"}
{"instruction": "Write a Node.js function using Mongoose to fetch users who have not logged in for over 30 days and set their 'isActive' status to false asynchronously.", "output": "const mongoose = require('mongoose');\nconst User = require('./models/User'); // Assuming model exists\n\nasync function deactivateDormantUsers() {\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n  try {\n    const result = await User.updateMany(\n      { lastLogin: { $lt: thirtyDaysAgo }, isActive: true },\n      { $set: { isActive: false } }\n    );\n    console.log(`Deactivated ${result.modifiedCount} users.`);\n  } catch (error) {\n    console.error('Error deactivating users:', error);\n  }\n}"}
{"instruction": "Create a FastAPI dependency that yields a database session using SQLAlchemy. It should ensure the session is closed even if an error occurs during the request.", "output": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}
{"instruction": "Write a SQL query using a Window Function to calculate the running total of sales for each day, ordered by date.", "output": "SELECT \n    sale_date,\n    daily_amount,\n    SUM(daily_amount) OVER (ORDER BY sale_date) as running_total\nFROM \n    sales_log;"}
{"instruction": "Create a FastAPI endpoint using Pydantic models to register a user. The endpoint should validate that the email is valid and the password is at least 8 characters long, then hash the password before returning a success message.", "output": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, Field\nfrom passlib.context import CryptContext\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n@app.post(\"/register\")\nasync def register_user(user: UserCreate):\n    # Simulate database check\n    if user.email == \"exists@example.com\":\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    hashed_password = get_password_hash(user.password)\n    \n    # In a real app, save to DB here: \n    # db.create_user(username=user.username, email=user.email, hashed_pw=hashed_password)\n    \n    return {\"msg\": \"User created successfully\", \"username\": user.username}"}
{"instruction": "Write a Node.js function using the 'pg' (node-postgres) library to asynchronously fetch a user profile by ID. Include error handling for database connection failures or if the user is not found.", "output": "const { Pool } = require('pg');\nconst pool = new Pool(); // Assumes env vars are set\n\nasync function getUserProfile(userId) {\n  const client = await pool.connect();\n  try {\n    const query = 'SELECT id, username, email, created_at FROM users WHERE id = $1';\n    const res = await client.query(query, [userId]);\n    \n    if (res.rows.length === 0) {\n      return { error: 'User not found', status: 404 };\n    }\n    \n    return { data: res.rows[0], status: 200 };\n  } catch (err) {\n    console.error('Database error:', err.stack);\n    return { error: 'Internal Server Error', status: 500 };\n  } finally {\n    client.release();\n  }\n}"}
{"instruction": "Design a SQL schema (PostgreSQL) for a simple E-commerce system. Create tables for 'users', 'products', and 'orders'. Ensure referential integrity using foreign keys.", "output": "CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock_quantity INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(id) ON DELETE CASCADE,\n    status VARCHAR(50) DEFAULT 'pending',\n    total_amount DECIMAL(10, 2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INT REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INT REFERENCES products(id) ON DELETE SET NULL,\n    quantity INT NOT NULL,\n    price_at_purchase DECIMAL(10, 2) NOT NULL\n);"}
{"instruction": "Implement a FastAPI dependency to manage a database session using SQLAlchemy. Create a route that uses this dependency to fetch all items from a database.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Model\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n\nBase.metadata.create_all(bind=engine)\n\napp = FastAPI()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/\")\ndef read_items(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):\n    return db.query(Item).offset(skip).limit(limit).all()"}
{"instruction": "Create a Node.js/Express middleware function that validates a JWT (JSON Web Token) from the 'Authorization' header. If valid, attach the user payload to the request object; otherwise, return a 401 or 403 error.", "output": "const jwt = require('jsonwebtoken');\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  // format: \"Bearer <token>\"\n  const token = authHeader && authHeader.split(' ')[1]; \n\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {\n    if (err) return res.sendStatus(403);\n    \n    // Attach user payload to request for downstream controllers\n    req.user = user;\n    next();\n  });\n};"}
{"instruction": "Using Python and SQLAlchemy, define the models for a Many-to-Many relationship between 'Students' and 'Courses'. Include the association table.", "output": "from sqlalchemy import Table, Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\n# Association Table\nstudent_course_association = Table(\n    'student_course',\n    Base.metadata,\n    Column('student_id', Integer, ForeignKey('students.id'), primary_key=True),\n    Column('course_id', Integer, ForeignKey('courses.id'), primary_key=True)\n)\n\nclass Student(Base):\n    __tablename__ = 'students'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    # Relationship\n    courses = relationship(\n        \"Course\",\n        secondary=student_course_association,\n        back_populates=\"students\"\n    )\n\nclass Course(Base):\n    __tablename__ = 'courses'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    # Relationship\n    students = relationship(\n        \"Student\",\n        secondary=student_course_association,\n        back_populates=\"courses\"\n    )\n"}
{"instruction": "Create a FastAPI route that accepts an email address and triggers a background task to simulate sending an email, allowing the API to return a response immediately without waiting for the email to send.", "output": "from fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef send_email_logic(email: str, message: str):\n    # Simulate long-running I/O operation\n    time.sleep(5) \n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email_logic, email, message=\"Welcome to our platform!\")\n    return {\"message\": \"Notification sent in the background\"}"}
{"instruction": "Write a SQL query to calculate the total revenue per month for the year 2023 from an 'orders' table. The table contains 'created_at' (timestamp) and 'amount' (decimal).", "output": "SELECT \n    DATE_TRUNC('month', created_at) AS month,\n    SUM(amount) AS total_revenue\nFROM \n    orders\nWHERE \n    created_at >= '2023-01-01' AND created_at < '2024-01-01'\nGROUP BY \n    DATE_TRUNC('month', created_at)\nORDER BY \n    month ASC;"}
{"instruction": "Implement a Node.js stream to read a large text file line-by-line and write it to a new file, transforming all text to uppercase. This should use the 'fs' and 'readline' modules to handle memory efficiently.", "output": "const fs = require('fs');\nconst readline = require('readline');\n\nconst inputFile = 'large_input.txt';\nconst outputFile = 'uppercase_output.txt';\n\nconst readStream = fs.createReadStream(inputFile);\nconst writeStream = fs.createWriteStream(outputFile);\n\nconst rl = readline.createInterface({\n  input: readStream,\n  crlfDelay: Infinity\n});\n\nrl.on('line', (line) => {\n  // Transform and write to output\n  const upperLine = line.toUpperCase() + '\\n';\n  // Handle backpressure\n  const canWrite = writeStream.write(upperLine);\n  if (!canWrite) {\n    rl.pause();\n    writeStream.once('drain', () => rl.resume());\n  }\n});\n\nrl.on('close', () => {\n  console.log('Processing complete.');\n  writeStream.end();\n});"}
{"instruction": "Create a simple WebSocket endpoint in FastAPI that accepts connections, receives text messages from the client, and echoes them back with a prefix.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")"}
