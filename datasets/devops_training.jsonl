{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, resource limits (256Mi memory, 500m CPU), and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash script that iterates through all servers listed in a 'servers.txt' file and checks if they are reachable via ping.", "output": "#!/bin/bash\n\nwhile IFS= read -r server; do\n    if ping -c 1 -W 1 \"$server\" &> /dev/null; then\n        echo \"$server is UP\"\n    else\n        echo \"$server is DOWN\"\n    fi\ndone < servers.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a Redis database. The web service should depend on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, builds a Docker image, and logs into Docker Hub using secrets.", "output": "name: Docker Build\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Generate a command to create a Kubernetes Secret named 'db-credentials' from literal username and password values.", "output": "kubectl create secret generic db-credentials --from-literal=username='admin' --from-literal=password='S3cr3tP@ss'"}
{"instruction": "Write a bash script to monitor disk usage. If the usage of the root partition '/' exceeds 80%, print a warning message.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is at ${USAGE}%\"\nfi"}
{"instruction": "Create a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Provide the Docker command to run a container named 'postgres-db' in the background, mapping host port 5432 to container port 5432, and setting the POSTGRES_PASSWORD environment variable.", "output": "docker run -d --name postgres-db -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword postgres:latest"}
{"instruction": "Write a bash script that rotates logs by finding all '.log' files in '/var/log/app' that are older than 7 days and moving them to an archive directory.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nARCHIVE_DIR=\"/var/log/app/archive\"\n\nmkdir -p \"$ARCHIVE_DIR\"\n\nfind \"$SOURCE_DIR\" -maxdepth 1 -name \"*.log\" -mtime +7 -exec mv {} \"$ARCHIVE_DIR\" \\;"}
{"instruction": "Create a Dockerfile for a Go application using multi-stage builds to compile the binary in a builder stage and run it in a minimal Alpine container to reduce image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, resource limits (CPU/Memory), and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 5"}
{"instruction": "Write a bash script to find all log files in `/var/log/app` older than 7 days, compress them, and move them to a backup directory.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/backup/logs\"\nDAYS=7\n\nmkdir -p \"$BACKUP_DIR\"\n\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +$DAYS -exec sh -c '\n  gzip -c \"{}\" > \"$1/$(basename \"{}\" .log)_$(date +%F).gz\" && rm \"{}\"\n' _ \"$BACKUP_DIR\" \\;"}
{"instruction": "Create a docker-compose.yml file to deploy a Python Flask web service and a PostgreSQL database with a persistent volume for the database data.", "output": "version: \"3.8\"\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: flaskdb\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:"}
{"instruction": "Write a GitLab CI (.gitlab-ci.yml) pipeline configuration that runs unit tests on python code and, if successful, builds and pushes a Docker image.", "output": "stages:\n  - test\n  - build\n\nunit_test:\n  stage: test\n  image: python:3.9\n  script:\n    - pip install -r requirements.txt\n    - pytest\n\nbuild_push:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  only:\n    - main"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer to expose a deployment named 'webapp' on external port 80 mapping to container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: webapp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a bash script that monitors disk usage on the root partition and sends an alert email if usage exceeds 90%.", "output": "#!/bin/bash\nTHRESHOLD=90\nEMAIL=\"admin@example.com\"\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Disk usage is critical: ${USAGE}%\" | mail -s \"Disk Alert\" \"$EMAIL\"\nfi"}
{"instruction": "Create a Kubernetes Pod definition that mounts a ConfigMap as a file inside the container and injects a Secret as an environment variable.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: app\n    image: my-app:v1\n    env:\n    - name: API_KEY\n      valueFrom:\n        secretKeyRef:\n          name: app-secrets\n          key: api-key\n    volumeMounts:\n    - name: config-vol\n      mountPath: /etc/config\n  volumes:\n  - name: config-vol\n    configMap:\n      name: app-settings"}
{"instruction": "Write a bash script using `kubectl` to wait until a specific pod in the default namespace enters the 'Running' state before proceeding.", "output": "#!/bin/bash\nPOD_NAME=\"my-app-pod\"\n\necho \"Waiting for $POD_NAME to be ready...\"\nwhile [[ $(kubectl get pod \"$POD_NAME\" -o jsonpath='{.status.phase}') != \"Running\" ]]; do\n  echo \"Status: Pending...\"\n  sleep 2\ndone\necho \"$POD_NAME is running!\""}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network and run two containers (app and redis) attached to that network so they can resolve each other by name.", "output": "docker network create my-net\ndocker run -d --name redis --network my-net redis:alpine\ndocker run -d --name app --network my-net -p 8080:8080 my-app-image"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to compile the binary in the first stage and run it in a scratch image to minimize size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a bash script that iterates through all files in the current directory, checks if they contain the string 'ERROR', and appends the filename to 'errors_found.txt' if they do.", "output": "#!/bin/bash\n\nfor file in *; do\n  if [ -f \"$file\" ]; then\n    if grep -q \"ERROR\" \"$file\"; then\n      echo \"$file\" >> errors_found.txt\n    fi\n  fi\ndone"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx server running 3 replicas, exposing port 80, with a resource limit of 128Mi memory and 500m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Create a docker-compose.yml file that sets up a WordPress service on port 8080 and a MySQL 5.7 database, using a shared network and persistent volumes.", "output": "version: '3.8'\n\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpresspassword\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8080:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\n\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on push to the 'main' branch, checks out the code, sets up Node.js 16, and runs 'npm install' followed by 'npm test'.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 16.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide the Docker CLI command to remove all stopped containers, unused networks, and dangling images (system prune) without asking for confirmation.", "output": "docker system prune -f"}
{"instruction": "Create a Bash script that checks if the disk usage of the root partition ('/') is greater than 80% and prints a warning message if it is.", "output": "#!/bin/bash\n\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is high! Current usage: ${USAGE}%\"\nfi"}
{"instruction": "Define a Kubernetes Service of type 'NodePort' to expose a deployment labeled 'app: backend' on port 30007 of the node, targeting port 8080 on the pods.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a .gitlab-ci.yml file that defines two stages: 'build' (which creates a file artifact) and 'deploy' (which runs only on the master branch and consumes the artifact).", "output": "stages:\n  - build\n  - deploy\n\nbuild_job:\n  stage: build\n  script:\n    - echo \"Building the application...\"\n    - mkdir build\n    - touch build/app.bin\n  artifacts:\n    paths:\n      - build/\n\ndeploy_job:\n  stage: deploy\n  script:\n    - echo \"Deploying application...\"\n    - ls build/app.bin\n  only:\n    - master"}
{"instruction": "Create a Bash function that accepts a Docker container name as an argument and returns 0 if the container is running, or 1 if it is not.", "output": "check_container_status() {\n  local container_name=$1\n  if [ \"$(docker container inspect -f '{{.State.Running}}' \"$container_name\" 2>/dev/null)\" == \"true\" ]; then\n    return 0\n  else\n    return 1\n  fi\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary named 'app', and the final stage should run on Alpine Linux.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes YAML manifest to deploy an Nginx container with 3 replicas and expose it via a Service on NodePort 30007.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  type: NodePort\n  selector:\n    app: nginx\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a Bash script that iterates through all `.log` files in the current directory and archives them into a `logs_archive` directory with a timestamp appended to the filename.", "output": "#!/bin/bash\n\nARCHIVE_DIR=\"logs_archive\"\nmkdir -p \"$ARCHIVE_DIR\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\n\nfor file in *.log; do\n    if [ -f \"$file\" ]; then\n        cp \"$file\" \"$ARCHIVE_DIR/${file%.*}_$TIMESTAMP.log\"\n        echo \"Archived $file\"\n    fi\ndone"}
{"instruction": "Create a GitHub Actions workflow file (`.github/workflows/ci.yml`) that triggers on a push to the `main` branch, checks out the code, and builds a Docker image tagged `latest`.", "output": "name: CI Pipeline\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Build Docker Image\n        run: docker build -t my-app:latest ."}
{"instruction": "Provide a Docker Compose configuration (version 3.8) to spin up a Python web service (building from the current directory) and a PostgreSQL database, ensuring the web service restarts always.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"8000:8000\"\n    restart: always\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydatabase\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:"}
{"instruction": "Write a Kubernetes manifest to create a ConfigMap containing a database URL and mount it as an environment variable in a Pod.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sh\", \"-c\", \"echo $DB_URL && sleep 3600\" ]\n      env:\n        - name: DB_URL\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: DATABASE_URL"}
{"instruction": "Write a Bash script to check if a specific website (passed as an argument) is up (HTTP 200). If it is down, print an error message to stderr and exit with status 1.", "output": "#!/bin/bash\n\nURL=$1\n\nif [ -z \"$URL\" ]; then\n  echo \"Usage: $0 <url>\"\n  exit 1\nfi\n\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"$URL is UP\"\nelse\n  echo \"$URL is DOWN (Status: $HTTP_STATUS)\" >&2\n  exit 1\nfi"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) YAML to automatically scale a deployment named `backend-api` between 2 and 10 pods when CPU utilization hits 50%.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Construct a Dockerfile command to copy a custom entrypoint script into the image, make it executable, and set it to run on container start, accepting arguments for the main application.", "output": "COPY docker-entrypoint.sh /usr/local/bin/\nRUN chmod +x /usr/local/bin/docker-entrypoint.sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nCMD [\"npm\", \"start\"]"}
{"instruction": "Write a one-liner Bash command to find all files larger than 100MB in the `/var/log` directory and delete them.", "output": "find /var/log -type f -size +100M -exec rm -f {} \\;"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for 'nginx-app' with 3 replicas and a rolling update strategy (maxUnavailable: 1, maxSurge: 1).", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-app\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script to move log files older than 7 days from /var/log/app to /backup/logs and compress them.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nDEST_DIR=\"/backup/logs\"\n\nmkdir -p \"$DEST_DIR\"\n\n# Find and move files\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -exec mv {} \"$DEST_DIR\" \\;\n\n# Compress moved files\ncd \"$DEST_DIR\" || exit\nfind . -name \"*.log\" -type f -exec gzip {} \\;"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service dependent on a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Declarative Jenkinsfile to checkout code, run unit tests via Maven, and archive the JAR file.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn clean package'\n            }\n        }\n        stage('Test') {\n            steps {\n                sh 'mvn test'\n            }\n        }\n    }\n    post {\n        success {\n            archiveArtifacts artifacts: 'target/*.jar', fingerprint: true\n        }\n    }\n}"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' with a key 'DATABASE_URL' and a Pod definition that injects it as an environment variable.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sleep\", \"3600\" ]\n    env:\n      - name: DB_URL\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: DATABASE_URL"}
{"instruction": "Write a bash script that iterates through a list of servers defined in a file 'servers.txt' and pings them. If a ping fails, print 'Server X is down'.", "output": "#!/bin/bash\nSERVER_FILE=\"servers.txt\"\n\nwhile IFS= read -r server; do\n    # Ping sending 1 packet with a 1 second timeout\n    ping -c 1 -W 1 \"$server\" > /dev/null 2>&1\n    if [ $? -ne 0 ]; then\n        echo \"Server $server is down\"\n    else\n        echo \"Server $server is up\"\n    fi\ndone < \"$SERVER_FILE\""}
{"instruction": "Define a .gitlab-ci.yml configuration that builds a docker image and pushes it to the registry only on the main branch.", "output": "image: docker:latest\nservices:\n  - docker:dind\n\nstages:\n  - build\n\nbuild_image:\n  stage: build\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  rules:\n    - if: '$CI_COMMIT_BRANCH == \"main\"'"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment named 'webapp' on port 30007.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: NodePort\n  selector:\n    app: webapp\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a shell script to be used as a Docker ENTRYPOINT that replaces environment variables in a configuration file before starting Nginx.", "output": "#!/bin/sh\n# entrypoint.sh\n\n# Replace env vars in template and output to actual config\nenvsubst < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf\n\n# Execute the CMD passed to the docker container (usually 'nginx -g daemon off;')\nexec \"$@\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary 'app' from 'main.go', and the final stage should use a distroless or alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY *.go ./\nRUN CGO_ENABLED=0 GOOS=linux go build -o /app/main .\n\nFROM gcr.io/distroless/static-debian11\nWORKDIR /\nCOPY --from=builder /app/main /main\nEXPOSE 8080\nENTRYPOINT [\"/main\"]"}
{"instruction": "Write a Bash script that iterates through a list of URLs defined in an array, checks if they return a HTTP 200 status code using curl, and prints 'UP' or 'DOWN' for each.", "output": "#!/bin/bash\n\nURLS=(\"https://www.google.com\" \"https://www.github.com\" \"https://invalid-url.local\")\n\nfor url in \"${URLS[@]}\"; do\n    response=$(curl -s -o /dev/null -w \"%{http_code}\" \"$url\")\n    if [ \"$response\" == \"200\" ]; then\n        echo \"$url is UP\"\n    else\n        echo \"$url is DOWN (Status: $response)\"\n    fi\ndone"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (building from the current directory) and a 'db' service (using postgres:13). The web service depends on the db and exposes port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n      - DB_USER=postgres\n      - DB_PASSWORD=secret\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: secret\n      POSTGRES_DB: app_db\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on push to the 'main' branch, checks out the code, logs into Docker Hub using secrets, builds a Docker image, and pushes it.", "output": "name: Docker Build & Push\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Write a Bash script to find all log files in '/var/log/myapp' ending in '.log' that are older than 7 days, compress them into a tarball, and then delete the original files.", "output": "#!/bin/bash\n\nLOG_DIR=\"/var/log/myapp\"\nARCHIVE_NAME=\"logs_archive_$(date +%F).tar.gz\"\n\n# Find files older than 7 days\nFILES=$(find \"$LOG_DIR\" -name \"*.log\" -mtime +7)\n\nif [ -n \"$FILES\" ]; then\n    echo \"Archiving old logs...\"\n    tar -czf \"$LOG_DIR/$ARCHIVE_NAME\" $FILES\n    \n    # Delete originals after successful archive\n    if [ $? -eq 0 ]; then\n        rm $FILES\n        echo \"Cleanup complete.\"\n    else\n        echo \"Archiving failed.\"\n    fi\nelse\n    echo \"No logs older than 7 days found.\"\nfi"}
{"instruction": "Create a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to the 'backend-service' on port 8080 and traffic from 'www.example.com' to the 'frontend-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n  - host: www.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80"}
{"instruction": "Write a Bash one-liner to check the disk usage of the root filesystem. If usage is greater than 85%, print a warning message to standard error.", "output": "df -h / | awk 'NR==2 {print $5}' | sed 's/%//' | awk '{if ($1 > 85) print \"WARNING: Disk usage is high: \" $1 \"%\" > \"/dev/stderr\"}'"}
{"instruction": "Provide the Docker CLI command to run a container named 'redis-cache' in detached mode using the 'redis:alpine' image, mapping host port 6379 to container port 6379, and setting a memory limit of 512MB.", "output": "docker run -d --name redis-cache -p 6379:6379 --memory=\"512m\" redis:alpine"}
{"instruction": "Create a .gitlab-ci.yml file that defines two stages: 'test' and 'deploy'. The test stage runs 'npm test', and the deploy stage runs a script to deploy to a staging server via SSH, only for the 'develop' branch.", "output": "stages:\n  - test\n  - deploy\n\nunit-test:\n  stage: test\n  image: node:16\n  script:\n    - npm install\n    - npm test\n\ndeploy-staging:\n  stage: deploy\n  image: alpine:latest\n  before_script:\n    - apk add --no-cache openssh-client\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' | ssh-add -\n    - mkdir -p ~/.ssh\n    - chmod 700 ~/.ssh\n  script:\n    - ssh -o StrictHostKeyChecking=no user@staging-server \"cd /var/www/app && git pull && npm install && pm2 restart all\"\n  only:\n    - develop"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary named 'app' from 'main.go', and the second stage should use a lightweight Alpine image to run the binary to minimize image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:3.18\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment manifest for an Nginx application with 2 replicas. Include a liveness probe that checks the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Write a bash script that loops through all '.log' files in the '/var/log/myapp' directory. If a file is older than 7 days, compress it using gzip and move it to '/backup/logs'.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/myapp\"\nBACKUP_DIR=\"/backup/logs\"\n\nmkdir -p \"$BACKUP_DIR\"\n\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 | while read -r file; do\n    gzip \"$file\"\n    mv \"${file}.gz\" \"$BACKUP_DIR\"\n    echo \"Archived $file\"\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (building from the current directory) mapping port 5000 to 5000, and links it to a Redis service utilizing the default redis:alpine image.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a basic GitHub Actions workflow file (.github/workflows/ci.yml) that triggers on push to 'main', checks out the code, and builds a Docker image named 'my-app:latest'.", "output": "name: CI Pipeline\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      \n      - name: Build Docker Image\n        run: docker build -t my-app:latest ."}
{"instruction": "Create a Kubernetes Service manifest of type LoadBalancer that exposes a deployment with the selector 'app: backend-api' on external port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a bash script that checks the current disk usage of the root partition ('/'). If usage exceeds 85%, print a warning message to stderr.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"WARNING: Disk usage is critical: ${CURRENT_USAGE}%\" >&2\nfi"}
{"instruction": "Write the Docker CLI command to run a MySQL 5.7 container in the background, named 'mysql-db', setting the root password to 'secret', and creating a volume named 'db_data' mounted to '/var/lib/mysql'.", "output": "docker run -d \\\n  --name mysql-db \\\n  -e MYSQL_ROOT_PASSWORD=secret \\\n  -v db_data:/var/lib/mysql \\\n  mysql:5.7"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) manifest requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Write a bash function that takes a container name as an argument and checks if it is currently running. If it is not running, the function should start it.", "output": "ensure_container_running() {\n    CONTAINER_NAME=$1\n    if [ ! \"$(docker ps -q -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n        if [ \"$(docker ps -aq -f status=exited -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n            echo \"Starting existing container $CONTAINER_NAME...\"\n            docker start \"$CONTAINER_NAME\"\n        else\n            echo \"Container $CONTAINER_NAME does not exist or is not running.\"\n        fi\n    else\n        echo \"Container $CONTAINER_NAME is already running.\"\n    fi\n}"}
{"instruction": "Create a Dockerfile for a Go application using multi-stage builds to compile the binary in a 'builder' stage and run it in a lightweight Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a bash script to archive logs older than 7 days from /var/log/app, compress them, and move them to a backup directory.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/mnt/backups/logs\"\n\nmkdir -p \"$BACKUP_DIR\"\n\n# Find logs older than 7 days, gzip them, and move them\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\nfind \"$LOG_DIR\" -name \"*.gz\" -type f -mtime +7 -exec mv {} \"$BACKUP_DIR\" \\;"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx server that includes a liveness probe checking the /healthz endpoint on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.19\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service dependent on a PostgreSQL database with a persistent volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DATABASE_URL=postgres://user:pass@db:5432/myapp\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n      POSTGRES_DB: myapp\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:"}
{"instruction": "Write a bash script snippet to check if the root filesystem usage exceeds 80% and print a warning message.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Root disk usage is at ${USAGE}%\"\nfi"}
{"instruction": "Create a Kubernetes HorizontalPodAutoscaler (HPA) manifest to scale a deployment named 'backend-api' between 2 and 10 pods based on 50% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Provide a kubectl command to create a generic secret named 'db-credentials' with a username and password using literal values.", "output": "kubectl create secret generic db-credentials \\\n  --from-literal=username=admin \\\n  --from-literal=password='S3cr3tP@ssw0rd'"}
{"instruction": "Write a GitLab CI/CD stage definition to build a Docker image and push it to the registry only when changes are pushed to the 'main' branch.", "output": "build_image:\n  stage: build\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  rules:\n    - if: '$CI_COMMIT_BRANCH == \"main\"'"}
{"instruction": "Write a bash script loop (useful for init containers) that waits until a specific host and port (e.g., db:5432) are available using netcat.", "output": "#!/bin/bash\nHOST=\"db\"\nPORT=\"5432\"\n\necho \"Waiting for $HOST:$PORT...\"\nwhile ! nc -z $HOST $PORT; do\n  sleep 1\ndone\necho \"$HOST:$PORT is available!\""}
{"instruction": "Create a Docker command to run a container named 'isolated-app' connected to a network named 'internal-net' that has no external internet access.", "output": "# First, create the internal network\ndocker network create --internal internal-net\n\n# Run the container attached to that network\ndocker run -d --name isolated-app --network internal-net my-app-image"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the app, and the final stage should use a lightweight Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML file that deploys an Nginx container with 3 replicas, exposing port 80, and setting memory limits to 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n          requests:\n            memory: \"64Mi\""}
{"instruction": "Write a Bash script that parses a standard Apache/Nginx access log file named 'access.log', counts the occurrences of unique IP addresses, and sorts them in descending order.", "output": "#!/bin/bash\n# Assumes standard log format where IP is the first field\nawk '{print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Create a docker-compose.yml file to set up a WordPress environment linked with a MySQL 5.7 database using persistent volumes.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, checks out the code, sets up Node.js version 18, installs dependencies, and runs tests.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Bash script to backup a specific directory to a tarball with a timestamp in the filename, and delete backups older than 7 days.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/www/html\"\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y-%m-%d_%H%M%S)\nARCHIVE_NAME=\"backup-$DATE.tar.gz\"\n\n# Create backup\ntar -czf $BACKUP_DIR/$ARCHIVE_NAME $SOURCE_DIR\n\n# Delete backups older than 7 days\nfind $BACKUP_DIR -type f -name \"backup-*.tar.gz\" -mtime +7 -delete"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer that exposes the 'nginx-deployment' on external port 80 targeting container port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  selector:\n    app: nginx\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n  type: LoadBalancer"}
{"instruction": "Write a command to list all Docker containers (running and stopped) that display only the Container ID and the Image name.", "output": "docker ps -a --format \"{{.ID}}: {{.Image}}\""}
{"instruction": "Write a Bash script that checks if the disk usage of the root filesystem exceeds 90% and prints a warning if it does.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical: $USAGE%\"\nelse\n  echo \"Disk usage is normal: $USAGE%\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap YAML to store application configuration properties like 'ui.theme' and 'feature.enabled'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  ui.theme: \"dark\"\n  feature.enabled: \"true\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\n# Final stage\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script to find files in '/var/log/app' older than 7 days, compress them, move them to an archive folder, and remove the originals.", "output": "#!/bin/bash\nSRC_DIR=\"/var/log/app\"\nARCHIVE_DIR=\"/var/log/app/archive\"\nmkdir -p \"$ARCHIVE_DIR\"\n\nfind \"$SRC_DIR\" -maxdepth 1 -type f -name \"*.log\" -mtime +7 -exec gzip {} \\; -exec mv {}.gz \"$ARCHIVE_DIR\" \\;"}
{"instruction": "Create a docker-compose.yml file to deploy a Python Flask app linked to a PostgreSQL database using environment variables.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DB_HOST=db\n      - DB_NAME=postgres\n      - DB_USER=postgres\n      - DB_PASS=secret\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: secret\n    volumes:\n      - pgdata:/var/lib/postgresql/data\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitLab CI pipeline job configuration to build a Docker image and push it to the registry only when changes are pushed to the 'main' branch.", "output": "build_image:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main"}
{"instruction": "Generate a Kubernetes Service manifest to expose a deployment named 'backend-api' on a static NodePort 30005.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend-api\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30005"}
{"instruction": "Write a bash script that iterates through a list of domains in 'domains.txt' and checks their HTTP status code using curl.", "output": "#!/bin/bash\nwhile IFS= read -r domain; do\n  status=$(curl -o /dev/null -s -w \"%{http_code}\" \"$domain\")\n  echo \"Domain: $domain - Status: $status\"\ndone < domains.txt"}
{"instruction": "Provide the Docker CLI commands to create a named volume 'mysql_data' and run a MySQL container mounting that volume to '/var/lib/mysql'.", "output": "docker volume create mysql_data\ndocker run -d --name mysql-db -e MYSQL_ROOT_PASSWORD=my-secret-pw -v mysql_data:/var/lib/mysql mysql:latest"}
{"instruction": "Create a Kubernetes ConfigMap YAML that stores a custom configuration file named 'custom.conf'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  custom.conf: |\n    server {\n      listen 80;\n      server_name example.com;\n      location / {\n        proxy_pass http://localhost:8080;\n      }\n    }"}
{"instruction": "Write a bash one-liner to display the top 5 processes consuming the most memory on a Linux system.", "output": "ps aux --sort=-%mem | head -n 6"}
{"instruction": "Create a Dockerfile for a Golang application using a multi-stage build to minimize the final image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML manifest for an Nginx application. It should deploy 3 replicas, expose port 80, and include a liveness probe checking the '/healthz' endpoint.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Create a Bash script that iterates through all '.log' files in the '/var/log/app' directory, compresses files older than 7 days, and deletes compressed archives older than 30 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\n\n# Compress logs older than 7 days\nfind \"$LOG_DIR\" -type f -name \"*.log\" -mtime +7 -exec gzip {} \\;\n\n# Delete archives older than 30 days\nfind \"$LOG_DIR\" -type f -name \"*.gz\" -mtime +30 -exec rm {} \\;"}
{"instruction": "Write a docker-compose.yml file to set up a Python Flask application dependent on a PostgreSQL database. The database should use a named volume for persistence.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/flaskdb\n  db:\n    image: postgres:13\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=flaskdb\n\nvolumes:\n  postgres_data:"}
{"instruction": "Create a GitHub Actions workflow YAML file that triggers on a push to the 'main' branch. The job should check out the code, set up Node.js version 16, install dependencies, and run 'npm test'.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 16.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16.x\n    - name: Install dependencies\n      run: npm ci\n    - name: Run tests\n      run: npm test"}
{"instruction": "Write a Kubernetes Service manifest to expose a deployment named 'backend-api' externally using a LoadBalancer on port 80, targeting targetPort 8080 on the pods.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a Bash script that checks the disk usage of the root filesystem ('/'). If usage exceeds 85%, print a warning message to stderr and exit with status code 1.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${CURRENT_USAGE}%\" >&2\n  exit 1\nelse\n  echo \"Disk usage is normal: ${CURRENT_USAGE}%\"\nfi"}
{"instruction": "Provide the command to create a custom Docker bridge network named 'isolated_net' with a subnet of '172.20.0.0/16'.", "output": "docker network create --driver bridge --subnet 172.20.0.0/16 isolated_net"}
{"instruction": "Write a Kubernetes ConfigMap manifest named 'app-config' that stores two key-value pairs: 'DATABASE_HOST' set to 'db.example.com' and 'DEBUG_MODE' set to 'false'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_HOST: \"db.example.com\"\n  DEBUG_MODE: \"false\""}
{"instruction": "Write a Bash script using 'curl' and 'jq' to extract the latest release tag name from a specific GitHub repository API endpoint (e.g., owner/repo).", "output": "#!/bin/bash\nREPO=\"owner/repo\"\nLATEST_TAG=$(curl -s \"https://api.github.com/repos/$REPO/releases/latest\" | jq -r .tag_name)\necho \"Latest tag: $LATEST_TAG\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage compiles the binary, and the final stage uses a scratch image.", "output": "FROM golang:1.19 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a resource limit of 512Mi memory, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Create a Bash script that checks if a specific Docker container is running. If it is not, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-web-server\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Running new container...\"\n        docker run -d --name $CONTAINER_NAME -p 80:80 nginx\n    fi\nelse\n    echo \"Container is already running.\"\nfi"}
{"instruction": "Write a docker-compose.yml file to set up a WordPress site with a MySQL database, ensuring the database starts before the application.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Create a declarative Jenkinsfile that builds a Docker image and pushes it to a registry only if the build succeeds.", "output": "pipeline {\n    agent any\n    environment {\n        REGISTRY = 'myregistry.azurecr.io'\n        IMAGE_NAME = 'myapp'\n    }\n    stages {\n        stage('Build') {\n            steps {\n                script {\n                    dockerImage = docker.build(\"${REGISTRY}/${IMAGE_NAME}:${env.BUILD_ID}\")\n                }\n            }\n        }\n        stage('Push') {\n            steps {\n                script {\n                    docker.withRegistry(\"https://${REGISTRY}\", 'registry-credentials-id') {\n                        dockerImage.push()\n                        dockerImage.push('latest')\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Bash script to parse a log file (access.log), count the occurrences of each IP address, and sort them in descending order.", "output": "#!/bin/bash\nLOG_FILE=\"access.log\"\nif [[ -f \"$LOG_FILE\" ]]; then\n    awk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr\nelse\n    echo \"Log file not found.\"\nfi"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment named 'backend-app' on port 30007.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend-app\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Define a GitLab CI (.gitlab-ci.yml) configuration that runs unit tests on all branches but deploys to production only on the 'main' branch.", "output": "stages:\n  - test\n  - deploy\n\nunit_test:\n  stage: test\n  image: python:3.9\n  script:\n    - pip install -r requirements.txt\n    - pytest\n\ndeploy_prod:\n  stage: deploy\n  script:\n    - echo \"Deploying to production server...\"\n    - ./deploy_script.sh\n  only:\n    - main"}
{"instruction": "Write a Docker command to run a temporary container that mounts the current directory to /app and executes a Maven build command.", "output": "docker run --rm -v \"$(pwd)\":/app -w /app maven:3.8-openjdk-11 mvn clean install"}
{"instruction": "Create a Bash script that monitors disk usage and sends an alert if usage exceeds 90% on the root filesystem.", "output": "#!/bin/bash\nTHRESHOLD=90\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Disk usage is critical: ${CURRENT_USAGE}%\" | mail -s \"Disk Alert\" admin@example.com\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a RollingUpdate strategy to ensure high availability during updates.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script to archive logs older than 7 days from a specific directory into a tarball and then delete the original files.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nARCHIVE_NAME=\"logs_archive_$(date +%F).tar.gz\"\n\n# Find files older than 7 days, append to archive, then delete\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec tar -rvf \"$LOG_DIR/$ARCHIVE_NAME\" {} + -exec rm {} \\;"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service (port 5000) and a Redis database service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Create a GitHub Actions workflow configuration to build a Docker image and push it to Docker Hub whenever a commit is pushed to the 'main' branch.", "output": "name: CI/CD Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: myuser/myapp:latest"}
{"instruction": "Write a Bash script that checks if a website returns an HTTP 200 status code. If it fails, restart the Nginx service using systemctl.", "output": "#!/bin/bash\nURL=\"http://localhost\"\nHTTP_STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -ne 200 ]; then\n  echo \"Site is down. Restarting Nginx...\"\n  systemctl restart nginx\nfi"}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Docker command to run a Postgres container in the background, setting the password via an environment variable and persisting data to a named volume.", "output": "docker run -d \\\n  --name my-postgres \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v pgdata:/var/lib/postgresql/data \\\n  postgres:13"}
{"instruction": "Provide a Kubernetes Pod specification snippet that defines resource limits (512Mi memory, 0.5 CPU) and requests (256Mi memory, 0.25 CPU) for a container.", "output": "spec:\n  containers:\n  - name: app-container\n    image: my-app:1.0\n    resources:\n      requests:\n        memory: \"256Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"512Mi\"\n        cpu: \"500m\""}
{"instruction": "Write a Linux command to create a new user named 'deployer', create their home directory, and add them to the 'docker' group.", "output": "sudo useradd -m -G docker -s /bin/bash deployer"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size using a scratch base.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server with 3 replicas, a liveness probe checking port 80, and memory limits set to 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n          requests:\n            memory: \"64Mi\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that checks disk usage and sends a warning message to stderr if the usage on the root partition exceeds 80%.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is at ${USAGE}%\" >&2\nelse\n    echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service dependent on a PostgreSQL database service with a persistent volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n      - DB_NAME=postgres\n      - DB_USER=postgres\n      - DB_PASS=secret\n  db:\n    image: postgres:13\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_PASSWORD=secret\n\nvolumes:\n  postgres_data:"}
{"instruction": "Write a Kubernetes Ingress resource definition that routes traffic based on paths: '/api' to the 'backend-service' and '/' to the 'frontend-service'.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: minimal-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 80\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80"}
{"instruction": "Create a GitHub Actions workflow file that triggers on a push to 'main', builds a Docker image, and logs into DockerHub using secrets.", "output": "name: CI/CD Pipeline\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Log in to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n        \n    - name: Build and push Docker image\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a Bash script to find all log files in '/var/log/app' older than 7 days and compress them into a backup directory.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/var/backups/app_logs\"\nmkdir -p \"$BACKUP_DIR\"\n\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -print0 | while IFS= read -r -d '' file; do\n    filename=$(basename \"$file\")\n    gzip -c \"$file\" > \"$BACKUP_DIR/$filename-$(date +%F).gz\"\n    rm \"$file\"\ndone"}
{"instruction": "Create a Kubernetes ConfigMap and a Pod definition that injects the ConfigMap data as environment variables.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  APP_MODE: \"production\"\n  LOG_LEVEL: \"info\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sh\", \"-c\", \"env\" ]\n      envFrom:\n      - configMapRef:\n          name: app-config"}
{"instruction": "Write a Docker command to create a custom bridge network with a specific subnet and run a container with a static IP within that subnet.", "output": "docker network create --driver bridge --subnet 172.20.0.0/16 my_custom_net && \\\ndocker run -d --net my_custom_net --ip 172.20.0.5 --name static-ip-container nginx"}
{"instruction": "Write a Bash script that iterates through a list of servers defined in a text file and checks their SSH connectivity using a public key.", "output": "#!/bin/bash\nSERVER_LIST=\"servers.txt\"\nUSER=\"admin\"\n\nwhile IFS= read -r server; do\n    if ssh -o BatchMode=yes -o ConnectTimeout=5 \"$USER@$server\" echo 'OK' &> /dev/null; then\n        echo \"[SUCCESS] Connected to $server\"\n    else\n        echo \"[FAILURE] Could not connect to $server\"\n    fi\ndone < \"$SERVER_LIST\""}
{"instruction": "Write a multi-stage Dockerfile for a Node.js application. The first stage should build the application, and the second stage should use a lightweight Alpine image to run the production artifacts.", "output": "FROM node:18 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY package*.json ./\nRUN npm install --production\nEXPOSE 3000\nCMD [\"node\", \"dist/main.js\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx server with 3 replicas, a label 'app: nginx-web', and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx-web\n  template:\n    metadata:\n      labels:\n        app: nginx-web\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a Bash script that accepts a directory path as an argument, finds all log files older than 7 days within that directory, and deletes them.", "output": "#!/bin/bash\n\nTARGET_DIR=\"$1\"\n\nif [ -z \"$TARGET_DIR\" ]; then\n  echo \"Usage: $0 <directory>\"\n  exit 1\nfi\n\nif [ ! -d \"$TARGET_DIR\" ]; then\n  echo \"Error: Directory not found.\"\n  exit 1\nfi\n\nfind \"$TARGET_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;\necho \"Cleanup completed for files older than 7 days in $TARGET_DIR\""}
{"instruction": "Define a docker-compose.yml file to spin up a Python Flask application and a Redis database, ensuring the Flask app waits for Redis to start.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Generate a GitHub Actions workflow YAML that triggers on push to the 'main' branch, checks out the code, builds a Docker image, and pushes it to Docker Hub.", "output": "name: Build and Push Docker Image\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      \n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      \n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Write a Bash one-liner to parse an Nginx access log file and display the top 10 IP addresses by request count.", "output": "awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a Kubernetes Service YAML of type 'LoadBalancer' to expose a deployment named 'backend-app' on external port 80 targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a Bash script that checks if a specific website (passed as an argument) returns a 200 OK status code using curl. Retry 3 times before failing.", "output": "#!/bin/bash\n\nURL=\"$1\"\nMAX_RETRIES=3\nCOUNT=0\n\nwhile [ $COUNT -lt $MAX_RETRIES ]; do\n  STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" \"$URL\")\n  if [ \"$STATUS\" -eq 200 ]; then\n    echo \"Success: $URL is reachable.\"\n    exit 0\n  fi\n  echo \"Attempt $((COUNT+1)) failed. Retrying...\"\n  sleep 2\n  COUNT=$((COUNT+1))\ndone\n\necho \"Failed to reach $URL after $MAX_RETRIES attempts.\"\nexit 1"}
{"instruction": "Construct a Docker command to run a container named 'postgres-db' in the background, setting the password via an environment variable and mounting a local volume for persistence.", "output": "docker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v postgres-data:/var/lib/postgresql/data \\\n  -p 5432:5432 \\\n  postgres:13"}
{"instruction": "Create a Kubernetes HorizontalPodAutoscaler (HPA) YAML that scales a deployment named 'api-gateway' between 2 and 10 replicas when CPU utilization exceeds 70%.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-gateway-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-gateway\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary using 'golang:alpine', and the second stage should run the binary in a 'scratch' container to minimize image size.", "output": "FROM golang:1.19-alpine AS builder\nWORKDIR /app\nCOPY go.mod ./\nCOPY go.sum ./\nRUN go mod download\nCOPY *.go ./\nRUN CGO_ENABLED=0 GOOS=linux go build -o /docker-gs-ping\n\nFROM scratch\nWORKDIR /\nCOPY --from=builder /docker-gs-ping /docker-gs-ping\nEXPOSE 8080\nENTRYPOINT [\"/docker-gs-ping\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a RollingUpdate strategy ensuring only 1 pod is unavailable during updates.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script to archive logs. It should find files ending in '.log' in '/var/log/app' older than 7 days, compress them with gzip, and delete any .gz files older than 30 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\n\n# Compress logs older than 7 days\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\n\n# Delete archives older than 30 days\nfind \"$LOG_DIR\" -name \"*.gz\" -type f -mtime +30 -delete"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a PostgreSQL database. The database data must be persisted in a named volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13-alpine\n    environment:\n      POSTGRES_USER: myuser\n      POSTGRES_PASSWORD: mypassword\n      POSTGRES_DB: myappdb\n    volumes:\n      - pgdata:/var/lib/postgresql/data\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitLab CI/CD pipeline job (.gitlab-ci.yml) that builds a Docker image and pushes it to the GitLab Container Registry using the built-in CI variables.", "output": "build_image:\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  stage: build\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' with a key 'DATABASE_URL' and a Pod definition that injects this ConfigMap value as an environment variable.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db-service:5432/db\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: backend-pod\nspec:\n  containers:\n    - name: backend\n      image: my-backend:latest\n      env:\n        - name: DB_URL\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: DATABASE_URL"}
{"instruction": "Write a Bash script that checks if the disk usage of the root partition ('/') exceeds 85%. If it does, print a warning message to stderr.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"WARNING: Disk usage is critical: ${CURRENT_USAGE}%\" >&2\nfi"}
{"instruction": "Write the Docker CLI commands to create a user-defined bridge network named 'isolated_net' and run an Alpine container attached to that network.", "output": "docker network create --driver bridge isolated_net && \\\ndocker run -dit --name alpine_container --network isolated_net alpine:latest /bin/sh"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) to automatically scale a deployment named 'api-server' between 2 and 10 pods based on 50% average CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-server-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-server\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Create a simple Jenkinsfile using Declarative Pipeline syntax that has three stages: Checkout, Build (running 'make build'), and Test (running 'make test').", "output": "pipeline {\n    agent any\n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n        stage('Build') {\n            steps {\n                sh 'make build'\n            }\n        }\n        stage('Test') {\n            steps {\n                sh 'make test'\n            }\n        }\n    }\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary named 'app', and the final stage should run on a lightweight Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Configure a rolling update strategy where maxUnavailable is 1 and maxSurge is 1.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through all log files in '/var/log/myapp/', compresses files older than 7 days into a tar.gz archive, and then deletes the original files.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nARCHIVE_DIR=\"/var/log/myapp/archive\"\nmkdir -p \"$ARCHIVE_DIR\"\n\nfind \"$LOG_DIR\" -maxdepth 1 -name \"*.log\" -mtime +7 -print0 | while IFS= read -r -d '' file; do\n    filename=$(basename \"$file\")\n    tar -czf \"$ARCHIVE_DIR/$filename.tar.gz\" \"$file\"\n    if [ $? -eq 0 ]; then\n        rm \"$file\"\n        echo \"Archived and deleted $file\"\n    else\n        echo \"Failed to archive $file\"\n    fi\ndone"}
{"instruction": "Create a docker-compose.yml file that spins up a Python web service (building from the current directory) and a Redis service. The web service should depend on Redis and expose port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file that triggers on push to the 'main' branch. It should check out the code, set up Node.js version 18, install dependencies, and run tests.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' containing a key 'DATABASE_URL', and a Pod definition that injects this key as an environment variable named 'DB_CONNECTION_STRING'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sh\", \"-c\", \"env\" ]\n      env:\n        - name: DB_CONNECTION_STRING\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: DATABASE_URL"}
{"instruction": "Write a one-liner Bash command to check if the Docker daemon is running. If it is not, attempt to start it using systemctl.", "output": "systemctl is-active --quiet docker || sudo systemctl start docker"}
{"instruction": "Construct a Docker command to run a container named 'postgres-db' in the background, setting the password via environment variable, and mounting a local volume 'pgdata' to '/var/lib/postgresql/data'.", "output": "docker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v pgdata:/var/lib/postgresql/data \\\n  postgres:14"}
{"instruction": "Create a Kubernetes Service definition of type NodePort to expose a deployment with label 'app: frontend' on node port 30007 mapping to target port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a Bash script that checks disk usage for the root filesystem. If usage exceeds 85%, send an alert email to 'admin@example.com'.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Disk usage is critical: ${CURRENT_USAGE}%\" | mail -s \"Disk Usage Alert\" admin@example.com\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should use 'golang:1.21-alpine' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a RollingUpdate strategy ensuring only 1 pod is unavailable during updates.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that finds all log files in '/var/log/app' older than 7 days, compresses them, moves them to '/backup/logs', and removes the original files.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/backup/logs\"\n\n# Ensure backup directory exists\nmkdir -p \"$BACKUP_DIR\"\n\n# Find, compress, and move\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -exec sh -c 'gzip -c \"{}\" > \"$BACKUP_DIR/$(basename \"{}\").$(date +%F).gz\" && rm \"{}\"' \\;"}
{"instruction": "Create a docker-compose.yml file to deploy a Python web service on port 5000 and a Redis database, ensuring the web service depends on Redis.", "output": "version: \"3.8\"\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash command to recursively change file permissions to 644 and directory permissions to 755 within the '/var/www/html' directory.", "output": "find /var/www/html -type d -exec chmod 755 {} + && find /var/www/html -type f -exec chmod 644 {} +"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer that exposes a deployment named 'backend-app' on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a GitLab CI (.gitlab-ci.yml) pipeline configuration that builds a Docker image and pushes it to the registry only when changes are pushed to the 'main' branch.", "output": "stages:\n  - build\n\nbuild-job:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t \"$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\" .\n    - docker push \"$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\"\n  only:\n    - main"}
{"instruction": "Write a Bash script to check disk usage. If usage on the root partition ('/') exceeds 90%, print a critical warning.", "output": "#!/bin/bash\nTHRESHOLD=90\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${USAGE}%\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' containing a JSON string and mount it as a volume to a Pod at '/etc/config'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  settings.json: '{\"debug\": true, \"theme\": \"dark\"}'\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app\n      image: my-app:latest\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Write a Docker command to create a custom bridge network named 'secure-net' with a specific subnet, and run an Nginx container with a static IP on that network.", "output": "docker network create --driver bridge --subnet 172.18.0.0/16 secure-net && \\\ndocker run -d --net secure-net --ip 172.18.0.22 --name static-nginx nginx:alpine"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should compile the binary 'app', and the final stage should run on a minimal Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes YAML manifest to deploy 3 replicas of an Nginx web server, exposing container port 80, and applying the label 'app: frontend'.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that checks if the 'nginx' service is active. If it is not running, the script should attempt to restart it and log the event to '/var/log/service_monitor.log'.", "output": "#!/bin/bash\nSERVICE=\"nginx\"\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n  echo \"$(date): $SERVICE is down. Restarting...\" >> /var/log/service_monitor.log\n  systemctl restart \"$SERVICE\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Node.js application (listening on port 3000) linked to a Redis database. The Redis service should persist data to a named volume called 'redis_data'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\"\n    volumes:\n      - redis_data:/data\nvolumes:\n  redis_data:"}
{"instruction": "Write a Bash command to find all log files in '/var/log/myapp' that are older than 7 days and delete them to free up disk space.", "output": "find /var/log/myapp -name \"*.log\" -type f -mtime +7 -exec rm {} \\;"}
{"instruction": "Define a GitHub Actions workflow step (YAML) that builds a Docker image and pushes it to a registry, only triggering on a push to the 'main' branch.", "output": "name: Build and Push Docker Image\non:\n  push:\n    branches:\n      - main\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          push: true\n          tags: user/app:latest"}
{"instruction": "Create a Kubernetes Service manifest of type 'NodePort' to expose a deployment labeled 'app: backend' on port 8080, targeting targetPort 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - port: 8080\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a Bash script snippet that iterates through a list of servers defined in an array and attempts to SSH into them to check their uptime.", "output": "#!/bin/bash\nSERVERS=(\"server1\" \"server2\" \"server3\")\nfor server in \"${SERVERS[@]}\"; do\n  echo \"Checking $server...\"\n  ssh user@\"$server\" \"uptime\"\ndone"}
{"instruction": "Create a Dockerfile for a Python application that installs dependencies from 'requirements.txt', sets an environment variable 'ENV_TYPE' to 'production', and runs 'app.py' on startup.", "output": "FROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nENV ENV_TYPE=production\nCMD [\"python\", \"app.py\"]"}
{"instruction": "Write a Kubernetes ConfigMap manifest to store database configuration details (host and port) that can be injected into pods as environment variables.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: db-config\ndata:\n  DB_HOST: \"postgres-db.local\"\n  DB_PORT: \"5432\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe, and resource limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a Bash script to check if disk usage on the root partition exceeds 80% and print a warning message.", "output": "#!/bin/bash\nTHRESHOLD=80\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is critical at ${USAGE}%\"\nelse\n  echo \"Disk usage is normal at ${USAGE}%\"\nfi"}
{"instruction": "Create a GitHub Actions workflow file that builds a Docker image and pushes it to Docker Hub on a push to the 'main' branch.", "output": "name: Build and Push Docker Image\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Log in to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: myuser/myapp:latest"}
{"instruction": "Write a docker-compose.yml file to deploy a WordPress site linked to a MySQL database.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Create a Kubernetes Service definition to expose a deployment labeled 'app: backend' via a LoadBalancer on port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a Bash command to find all files in the current directory larger than 100MB and list them.", "output": "find . -type f -size +100M -exec ls -lh {} \\;"}
{"instruction": "Create a Kubernetes Pod definition that mounts a ConfigMap named 'app-settings' to '/etc/config' as a volume.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app\n      image: busybox\n      command: [\"sleep\", \"3600\"]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-settings"}
{"instruction": "Write a Bash script that archives (tars) a specific log directory and appends the current date to the filename.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y-%m-%d)\nARCHIVE_NAME=\"logs-backup-$DATE.tar.gz\"\n\nmkdir -p $BACKUP_DIR\ntar -czf \"$BACKUP_DIR/$ARCHIVE_NAME\" \"$LOG_DIR\"\necho \"Backup created: $BACKUP_DIR/$ARCHIVE_NAME\""}
{"instruction": "Create a Dockerfile for a Python Flask application that installs dependencies from requirements.txt and exposes port 5000.", "output": "FROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nEXPOSE 5000\nENV FLASK_APP=app.py\nCMD [\"flask\", \"run\", \"--host=0.0.0.0\"]"}
{"instruction": "Create a multi-stage Dockerfile for a Node.js application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM node:18 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY package*.json ./\nRUN npm install --production\nEXPOSE 3000\nCMD [\"node\", \"dist/index.js\"]"}
{"instruction": "Write a bash one-liner to parse an Nginx access log ('access.log') and display the top 5 IP addresses with the highest number of requests.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Define a Kubernetes Deployment YAML for an application named 'backend-api' with 3 replicas, resource limits, and a readiness probe checking the '/health' endpoint.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: backend-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: backend-api\n  template:\n    metadata:\n      labels:\n        app: backend-api\n    spec:\n      containers:\n      - name: api-container\n        image: myrepo/api:v1\n        ports:\n        - containerPort: 8080\n        resources:\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Create a docker-compose.yml file to set up a WordPress environment dependent on a MySQL database with persistent volumes.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\n    volumes:\n      - wp_data:/var/www/html\n\nvolumes:\n  db_data:\n  wp_data:"}
{"instruction": "Write a bash script that iterates through a list of servers in 'hosts.txt' and checks if the SSH port (22) is open using netcat.", "output": "#!/bin/bash\nwhile IFS= read -r server; do\n  if nc -z -w 2 \"$server\" 22; then\n    echo \"[OK] SSH is open on $server\"\n  else\n    echo \"[FAIL] SSH is closed on $server\"\n  fi\ndone < hosts.txt"}
{"instruction": "Create a GitHub Actions workflow step to log in to Docker Hub, build an image, and push it, triggering only on a push to the 'main' branch.", "output": "name: CI Pipeline\non:\n  push:\n    branches:\n      - main\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      - name: Build and Push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) YAML to automatically scale a deployment named 'frontend' between 2 and 10 pods based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: frontend-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: frontend\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Write a bash script to perform a database backup of a PostgreSQL container and delete backups older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nTIMESTAMP=$(date +\"%Y%m%d%H%M\")\nCONTAINER=\"postgres-db\"\n\n# Create backup\ndocker exec -t $CONTAINER pg_dumpall -c -U postgres > \"$BACKUP_DIR/db_backup_$TIMESTAMP.sql\"\n\n# Compress\ngzip \"$BACKUP_DIR/db_backup_$TIMESTAMP.sql\"\n\n# Delete files older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"*.sql.gz\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a Kubernetes ConfigMap YAML to store nginx configuration and a Pod YAML that mounts this configuration to '/etc/nginx/conf.d'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: nginx-config\ndata:\n  default.conf: |\n    server {\n      listen 80;\n      location / {\n        return 200 'OK';\n      }\n    }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\nspec:\n  containers:\n    - name: nginx\n      image: nginx:alpine\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/nginx/conf.d\n  volumes:\n    - name: config-volume\n      configMap:\n        name: nginx-config"}
{"instruction": "Write the Docker CLI command to remove all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes.", "output": "docker system prune -a --volumes --force"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should use 'golang:1.21-alpine' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a container named 'nginx-web', and a liveness probe checking port 80 via HTTP every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx-web\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that finds all '.log' files in '/var/log/myapp/' that are older than 7 days, compresses them into '.gz' files, and removes the originals.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp/\"\n\nif [ -d \"$LOG_DIR\" ]; then\n  find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\n  echo \"Log rotation complete.\"\nelse\n  echo \"Directory $LOG_DIR does not exist.\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a WordPress service depending on a MySQL 5.7 service, utilizing environment variables for database credentials.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    environment:\n      MYSQL_ROOT_PASSWORD: examplepass\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wpuser\n      MYSQL_PASSWORD: wppassword\n    volumes:\n      - db_data:/var/lib/mysql\n  wordpress:\n    image: wordpress:latest\n    depends_on:\n      - db\n    ports:\n      - \"8000:80\"\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: wpuser\n      WORDPRESS_DB_PASSWORD: wppassword\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow YAML that triggers on push to the 'main' branch, logs into Docker Hub using secrets, and builds/pushes an image.", "output": "name: CI/CD Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Write a Bash one-liner to check if a process is listening on port 8080. If it is, kill that process immediately.", "output": "pid=$(lsof -t -i:8080); [ ! -z \"$pid\" ] && kill -9 $pid && echo \"Process $pid killed on port 8080\" || echo \"No process found on port 8080\""}
{"instruction": "Define a Kubernetes ConfigMap named 'app-config' containing a 'config.json' key, and a Pod YAML that mounts this ConfigMap as a volume at '/etc/config'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  config.json: |\n    { \"debug\": true, \"theme\": \"dark\" }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sleep\", \"3600\" ]\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config"}
{"instruction": "Write a Bash script to monitor disk usage on the root partition ('/'). If usage exceeds 90%, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical: ${USAGE}%\" >&2\nfi"}
{"instruction": "Provide the Docker CLI command to run a Postgres container named 'my-postgres' in the background, mapping host port 5432 to container port 5432, setting the password to 'secret', and using a named volume 'pgdata' for persistence.", "output": "docker run -d --name my-postgres -p 5432:5432 -e POSTGRES_PASSWORD=secret -v pgdata:/var/lib/postgresql/data postgres:latest"}
{"instruction": "Create a Kubernetes Service YAML of type 'NodePort' to expose a deployment with the selector 'app: backend' on port 30007.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary named 'server', and the final stage should use 'scratch' and only include the compiled binary.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o server .\n\nFROM scratch\nCOPY --from=builder /app/server /server\nEXPOSE 8080\nCMD [\"/server\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. It must include a liveness probe checking the root path on port 80 and resource limits of 256Mi RAM and 500m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a bash script that iterates through all files in a directory named '/var/logs/app', compresses any file ending in '.log' into a '.tar.gz' archive, and then deletes the original .log file.", "output": "#!/bin/bash\nLOG_DIR=\"/var/logs/app\"\n\nfor file in \"$LOG_DIR\"/*.log; do\n  if [ -f \"$file\" ]; then\n    tar -czf \"${file}.tar.gz\" \"$file\"\n    if [ $? -eq 0 ]; then\n      rm \"$file\"\n      echo \"Compressed and removed $file\"\n    else\n      echo \"Failed to compress $file\"\n    fi\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml configuration that sets up a WordPress service and a MySQL 5.7 database service. The database credentials should be passed via environment variables, and the MySQL data should persist in a named volume.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a bash one-liner to check if a specific TCP port (e.g., 8080) is currently in use by any process on a Linux server and output the PID of that process.", "output": "lsof -i :8080 -t"}
{"instruction": "Define a GitHub Actions workflow step (YAML) that builds a Docker image tagged with the commit SHA and pushes it to the GitHub Container Registry (ghcr.io). Assume login steps are already handled.", "output": "- name: Build and push Docker image\n  uses: docker/build-push-action@v4\n  with:\n    context: .\n    push: true\n    tags: ghcr.io/${{ github.repository }}/app:${{ github.sha }}"}
{"instruction": "Provide the Kubernetes command to imperatively create a generic Secret named 'db-credentials' containing a username 'admin' and a password 's3cr3tp@ss' from literal values.", "output": "kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password='s3cr3tp@ss'"}
{"instruction": "Write a bash script that performs a health check on a web service running on localhost:3000. It should retry connection 5 times with a 2-second interval before failing.", "output": "#!/bin/bash\nURL=\"http://localhost:3000/health\"\nMAX_RETRIES=5\nCOUNT=0\n\nuntil curl -s -f \"$URL\"; do\n  COUNT=$((COUNT+1))\n  if [ $COUNT -ge $MAX_RETRIES ]; then\n    echo \"Service failed to start after $MAX_RETRIES attempts.\"\n    exit 1\n  fi\n  echo \"Waiting for service... (Attempt $COUNT/$MAX_RETRIES)\"\n  sleep 2\ndone\necho \"Service is up!\""}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Provide a Docker command to run a container named 'temp-runner' from the 'ubuntu' image, mount the current directory to '/workspace' inside the container, and automatically remove the container after the process exits.", "output": "docker run --rm -it -v $(pwd):/workspace --name temp-runner ubuntu bash"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The first stage (builder) compiles 'main.go' into an executable named 'app', and the second stage uses a minimal Alpine image to run the artifact.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server with 3 replicas. Include a liveness probe that checks the path '/healthz' on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          periodSeconds: 10"}
{"instruction": "Create a Bash script that checks if the disk usage of the root filesystem ('/') exceeds 85%. If it does, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is critical: ${USAGE}%\" >&2\nfi"}
{"instruction": "Write a docker-compose.yml file to set up a Python web service and a PostgreSQL database. The web service should depend on the database and expose port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:"}
{"instruction": "Create a GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'build' and 'deploy'. The deploy stage should only run when changes are pushed to the 'main' branch.", "output": "stages:\n  - build\n  - deploy\n\nbuild_job:\n  stage: build\n  script:\n    - echo \"Building the application...\"\n    - ./build.sh\n\ndeploy_job:\n  stage: deploy\n  script:\n    - echo \"Deploying to production...\"\n    - ./deploy.sh\n  only:\n    - main"}
{"instruction": "Write a Kubernetes Ingress resource YAML to route traffic from host 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Bash function that accepts a Docker container name as an argument, checks if it is running, and restarts it if it is not.", "output": "ensure_container_running() {\n  CONTAINER_NAME=$1\n  if [ ! \"$(docker ps -q -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n      echo \"Starting $CONTAINER_NAME...\"\n      docker start \"$CONTAINER_NAME\"\n    else\n      echo \"Container $CONTAINER_NAME does not exist.\"\n    fi\n  else\n    echo \"$CONTAINER_NAME is already running.\"\n  fi\n}"}
{"instruction": "Create a Docker command to run a container named 'log-viewer' that mounts the host directory '/var/log' to '/logs' in read-only mode and removes the container upon exit.", "output": "docker run --rm -it --name log-viewer -v /var/log:/logs:ro ubuntu bash"}
{"instruction": "Write a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 10Gi of storage with 'ReadWriteOnce' access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: data-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Create a Bash script using 'curl' to perform a rolling restart of a web application by checking a health endpoint. It should wait for a 200 OK response before proceeding.", "output": "#!/bin/bash\nURL=\"http://localhost:8080/health\"\nMAX_RETRIES=30\nCOUNT=0\n\necho \"Waiting for service to be healthy...\"\nuntil $(curl --output /dev/null --silent --head --fail \"$URL\"); do\n    printf '.'\n    sleep 2\n    COUNT=$((COUNT+1))\n    if [ $COUNT -ge $MAX_RETRIES ]; then\n        echo \"Timeout waiting for health check.\"\n        exit 1\n    fi\ndone\necho \"Service is up!\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a liveness probe that checks the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that iterates through all mounted filesystems and sends a warning message to stdout if usage exceeds 80%.", "output": "#!/bin/bash\ndf -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 \" \" $1 }' | while read output;\ndo\n  usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )\n  partition=$(echo $output | awk '{ print $2 }' )\n  if [ $usep -ge 80 ]; then\n    echo \"Running out of space \\\"$partition ($usep%)\\\" on $(hostname) as on $(date)\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (building from the current directory) and a 'redis' service, ensuring the web service restarts always and depends on redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    restart: always\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file that builds a Docker image and pushes it to Docker Hub only when a push occurs on the 'main' branch.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Construct a Kubernetes Service manifest of type LoadBalancer to expose a deployment named 'backend-app' on external port 80 targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a Bash script to find and delete all log files ending in '.log' inside '/var/log/app' that are older than 7 days.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/app\"\nif [ -d \"$TARGET_DIR\" ]; then\n  find \"$TARGET_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;\n  echo \"Cleanup completed.\"\nelse\n  echo \"Directory $TARGET_DIR does not exist.\"\nfi"}
{"instruction": "Provide the Docker command to run a PostgreSQL container named 'postgres-db' in the background, setting the password environment variable and mounting a local volume.", "output": "docker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v $(pwd)/pgdata:/var/lib/postgresql/data \\\n  -p 5432:5432 \\\n  postgres:latest"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-config' that stores database host and debug mode settings.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DB_HOST: \"db.example.com\"\n  DB_PORT: \"5432\"\n  DEBUG_MODE: \"true\""}
{"instruction": "Write a Bash script that checks if a specific Docker container is running. If not, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-app-container\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Container does not exist or is not running.\"\n    fi\nelse\n    echo \"Container $CONTAINER_NAME is already running.\"\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to compile the binary in the first stage and run it in a lightweight Alpine container in the second stage.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe on port 80, and a resource limit of 256Mi RAM.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3\n        resources:\n          limits:\n            memory: \"256Mi\""}
{"instruction": "Write a bash script that checks if disk usage on the root partition ('/') exceeds 80% and prints a warning if it does.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is at ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a WordPress service depending on a MySQL service, with a persistent volume for the database.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: examplepass\n      MYSQL_DATABASE: wordpress\n  wordpress:\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    depends_on:\n      - db\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: root\n      WORDPRESS_DB_PASSWORD: examplepass\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow configuration to run 'npm install' and 'npm test' whenever code is pushed to the 'main' branch.", "output": "name: Node.js CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Create a Kubernetes Service manifest of type LoadBalancer to expose a deployment named 'backend-app' on port 80 targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash command using 'sed' to replace all occurrences of 'localhost' with '127.0.0.1' in a file named config.txt and save it in place.", "output": "sed -i 's/localhost/127.0.0.1/g' config.txt"}
{"instruction": "Generate a command to run a Docker container named 'temp-runner' that mounts the current directory to '/data' inside the container and removes itself after exiting.", "output": "docker run --rm -it -v $(pwd):/data --name temp-runner ubuntu:latest bash"}
{"instruction": "Write a bash script that loops through all '.log' files in a directory and archives them into a tar.gz file.", "output": "#!/bin/bash\nDATE=$(date +%F)\nARCHIVE_NAME=\"logs_archive_${DATE}.tar.gz\"\ntar -czf \"$ARCHIVE_NAME\" *.log\necho \"Logs archived to $ARCHIVE_NAME\""}
{"instruction": "Create a Kubernetes Ingress resource to route traffic from 'api.example.com' to a service named 'api-svc' on port 3000.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-svc\n            port:\n              number: 3000"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx container with 3 replicas and a NodePort Service exposing port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  type: NodePort\n  selector:\n    app: nginx\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a bash script that loops through all .log files in /var/log, compresses them with gzip, and moves them to /backup/logs with a date stamp.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backup/logs\"\nDATE=$(date +%F)\nmkdir -p \"$BACKUP_DIR\"\n\nfor file in /var/log/*.log; do\n  if [ -f \"$file\" ]; then\n    filename=$(basename \"$file\")\n    gzip -c \"$file\" > \"$BACKUP_DIR/${filename}_${DATE}.gz\"\n  fi\ndone"}
{"instruction": "Provide a GitHub Actions workflow file that builds a Docker image and pushes it to Docker Hub when a push occurs on the 'main' branch.", "output": "name: Build and Push\non:\n  push:\n    branches:\n      - main\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          push: true\n          tags: user/app:latest"}
{"instruction": "Write a Kubernetes YAML to create a Secret containing a database password and inject it as an environment variable into a Pod.", "output": "apiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  password: c3VwZXJzZWNyZXQ= # base64 encoded 'supersecret'\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: backend-pod\nspec:\n  containers:\n  - name: backend\n    image: my-backend:v1\n    env:\n      - name: DB_PASSWORD\n        valueFrom:\n          secretKeyRef:\n            name: db-secret\n            key: password"}
{"instruction": "Create a Docker Compose file that sets up a Python Flask web service and a Redis service, ensuring the web service restarts always and depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    restart: always\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a bash one-liner to parse an Nginx access log file named 'access.log', filter for HTTP 500 errors, and count the occurrences of each unique IP address, sorted by frequency.", "output": "awk '$9 == 500 {print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) YAML to scale a deployment named 'php-apache' between 1 and 10 replicas based on 50% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: php-apache\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: php-apache\n  minReplicas: 1\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Write a bash script to check if a specific URL (passed as an argument) is reachable (HTTP 200). If not, retry 3 times with a 5-second delay before failing.", "output": "#!/bin/bash\nURL=$1\nMAX_RETRIES=3\nCOUNT=0\n\nwhile [ $COUNT -lt $MAX_RETRIES ]; do\n  STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" \"$URL\")\n  if [ \"$STATUS\" -eq 200 ]; then\n    echo \"Site is up.\"\n    exit 0\n  fi\n  echo \"Check failed ($STATUS). Retrying...\"\n  ((COUNT++))\n  sleep 5\ndone\n\necho \"Site is down after $MAX_RETRIES attempts.\"\nexit 1"}
{"instruction": "Construct a Dockerfile that installs Nginx, removes default configuration files, copies custom configuration, and exposes port 8080.", "output": "FROM nginx:alpine\n\n# Remove default config\nRUN rm /etc/nginx/conf.d/default.conf\n\n# Copy custom config\nCOPY nginx.conf /etc/nginx/conf.d/\n\n# Expose non-privileged port\nEXPOSE 8080\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML manifest for an Nginx application with 3 replicas, a rolling update strategy, and resource limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a Bash script that iterates through a list of servers defined in a variable and checks their SSH connectivity.", "output": "#!/bin/bash\nSERVERS=(\"192.168.1.10\" \"192.168.1.11\" \"192.168.1.12\")\nUSER=\"admin\"\n\nfor server in \"${SERVERS[@]}\"; do\n  if ssh -q -o BatchMode=yes -o ConnectTimeout=5 \"$USER@$server\" exit; then\n    echo \"$server is reachable\"\n  else\n    echo \"$server is UNREACHABLE\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to spin up a Python Flask application (on port 5000) dependent on a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\"\n    restart: always"}
{"instruction": "Write a Bash script to delete all files in the directory '/var/log/app_logs' that end in '.log' and are older than 7 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app_logs\"\n\nif [ -d \"$LOG_DIR\" ]; then\n  find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm {} \\;\n  echo \"Cleanup completed.\"\nelse\n  echo \"Directory $LOG_DIR does not exist.\"\nfi"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer to expose a deployment labeled 'app: frontend' on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a GitHub Actions workflow file that builds a Docker image and pushes it to Docker Hub whenever code is pushed to the 'main' branch.", "output": "name: CI/CD Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Provide the Docker CLI commands to create a named volume 'db_data' and run a PostgreSQL container mounting that volume to persist data.", "output": "docker volume create db_data\ndocker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v db_data:/var/lib/postgresql/data \\\n  -p 5432:5432 \\\n  postgres:13"}
{"instruction": "Write a Bash script that monitors disk usage on the root partition and sends a warning message to stderr if usage exceeds 90%.", "output": "#!/bin/bash\nTHRESHOLD=90\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${USAGE}%\" >&2\n  # Optional: logic to send email or slack alert here\nfi"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' containing a JSON configuration file, and show how to mount it into a Pod at '/etc/config'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  settings.json: |\n    { \"debug\": true, \"theme\": \"dark\" }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-test-pod\nspec:\n  containers:\n    - name: app\n      image: busybox\n      command: [\"sleep\", \"3600\"]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx application with 3 replicas, resource limits, and a liveness probe.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a Bash script that iterates through all .log files in the /var/log directory and compresses them into a tar.gz archive with a timestamp.", "output": "#!/bin/bash\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nARCHIVE_NAME=\"logs_backup_$TIMESTAMP.tar.gz\"\nfind /var/log -name \"*.log\" -print0 | xargs -0 tar -czf $ARCHIVE_NAME\necho \"Backup created: $ARCHIVE_NAME\""}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a Redis database, ensuring Redis starts before the web service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow YAML that triggers on push to the 'main' branch, runs 'npm install', and then 'npm test'.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm install\n    - run: npm test"}
{"instruction": "Write a Bash one-liner to parse an Nginx access log file and output the top 10 most frequent IP addresses.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'api.example.com' to a service named 'api-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 80"}
{"instruction": "Write a script to check if a specific Docker container is running. If not, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-app-container\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Container does not exist.\"\n    fi\nelse\n    echo \"Container is already running.\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' with a key 'database_url' and show how to inject it as an environment variable in a Pod.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: k8s.gcr.io/busybox\n    command: [ \"/bin/sh\", \"-c\", \"env\" ]\n    env:\n      - name: DB_URL\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: database_url"}
{"instruction": "Write a Bash function that checks disk usage on the root partition and sends an alert message if usage exceeds 85%.", "output": "check_disk_usage() {\n  USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n  THRESHOLD=85\n  if [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"CRITICAL: Disk usage is at ${USAGE}%!\"\n    # Insert mail command here, e.g., mail -s \"Disk Alert\" admin@example.com\n  else\n    echo \"Disk usage is normal: ${USAGE}%\"\n  fi\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should use `golang:1.21` and the final stage should use `alpine:latest`.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Bash script that iterates through all `.log` files in `/var/log/myapp`, archives files older than 7 days into a tarball, and removes the original files.", "output": "#!/bin/bash\n\nLOG_DIR=\"/var/log/myapp\"\nARCHIVE_NAME=\"logs_archive_$(date +%F).tar.gz\"\n\n# Find files older than 7 days\nFILES=$(find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7)\n\nif [ -n \"$FILES\" ]; then\n    tar -czf \"$LOG_DIR/$ARCHIVE_NAME\" $FILES\n    rm $FILES\n    echo \"Archived and deleted old logs.\"\nelse\n    echo \"No logs older than 7 days found.\"\nfi"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a liveness probe that checks the `/healthz` endpoint on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.25\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Create a `docker-compose.yml` file that spins up a WordPress service on port 8080 and a MySQL 5.7 database with a persistent volume for the database data.", "output": "version: '3.8'\n\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpresspassword\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8080:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\n\nvolumes:\n  db_data:"}
{"instruction": "Write a GitLab CI/CD configuration (`.gitlab-ci.yml`) that builds a Docker image and pushes it to the registry only when changes are pushed to the `main` branch.", "output": "stages:\n  - build\n\nbuild-and-push:\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  stage: build\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main"}
{"instruction": "Write a shell script to check if the `docker` service is running. If it is not, attempt to start it and send an alert message to a hypothetical webhook.", "output": "#!/bin/bash\n\nSERVICE=\"docker\"\nWEBHOOK_URL=\"https://example.com/hooks/alert\"\n\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n    echo \"$SERVICE is not running. Attempting to start...\"\n    sudo systemctl start \"$SERVICE\"\n    \n    if systemctl is-active --quiet \"$SERVICE\"; then\n        STATUS=\"Restarted successfully\"\n    else\n        STATUS=\"Failed to restart\"\n    fi\n\n    curl -X POST -H \"Content-type: application/json\" \\\n         --data \"{\\\"text\\\": \\\"Alert: Docker service was down. Status: $STATUS\\\"}\" \\\n         \"$WEBHOOK_URL\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap named `app-settings` containing a key `max_connections` and a Pod definition that mounts this ConfigMap as a volume at `/etc/config`.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-settings\ndata:\n  max_connections: \"100\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-volume-pod\nspec:\n  containers:\n    - name: app-container\n      image: busybox\n      command: [\"sleep\", \"3600\"]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-settings"}
{"instruction": "Write the Docker CLI commands to create a custom bridge network named `isolated_net` with subnet `192.168.10.0/24` and run a Redis container with a static IP `192.168.10.5` attached to it.", "output": "docker network create --driver bridge --subnet 192.168.10.0/24 isolated_net\ndocker run -d --name my-redis --net isolated_net --ip 192.168.10.5 redis:alpine"}
{"instruction": "Create a GitHub Actions workflow file that runs `npm install` and `npm test` on Ubuntu whenever a pull request is opened against the `master` branch.", "output": "name: Node.js CI\n\non:\n  pull_request:\n    branches: [ \"master\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) YAML to automatically scale a deployment named `backend-api` between 2 and 10 replicas based on a target CPU utilization of 50%.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment manifest for an Nginx container with 3 replicas, resource limits (256Mi memory, 500m CPU), and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash script to recursively find and delete log files ending in .log in the /var/log/myapp directory that are older than 7 days.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/myapp\"\nfind \"$TARGET_DIR\" -type f -name \"*.log\" -mtime +7 -exec rm -f {} \\;"}
{"instruction": "Create a GitHub Actions workflow step to build a Docker image and push it to Docker Hub only when pushing to the main branch.", "output": "name: CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: user/app:latest"}
{"instruction": "Define a docker-compose.yml file that sets up a Node.js application service depending on a Redis service, sharing a custom network called 'backend'.", "output": "version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - redis\n    networks:\n      - backend\n  redis:\n    image: \"redis:alpine\"\n    networks:\n      - backend\nnetworks:\n  backend:\n    driver: bridge"}
{"instruction": "Create a Kubernetes Service manifest of type NodePort to expose a deployment labeled 'app: frontend' on port 80, mapping to target port 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n      nodePort: 30007"}
{"instruction": "Write a bash script that loops through a list of URLs and checks if they return a 200 HTTP status code using curl.", "output": "#!/bin/bash\nURLS=(\"http://example.com\" \"http://google.com\")\nfor url in \"${URLS[@]}\"; do\n  if curl --output /dev/null --silent --head --fail \"$url\"; then\n    echo \"$url is UP\"\n  else\n    echo \"$url is DOWN\"\n  fi\ndone"}
{"instruction": "Define a Kubernetes CronJob that runs a database backup script every day at midnight.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: db-backup\nspec:\n  schedule: \"0 0 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: backup\n            image: my-backup-image:latest\n            command: [\"/bin/sh\", \"-c\", \"/scripts/backup.sh\"]\n          restartPolicy: OnFailure"}
{"instruction": "Write a set of Linux commands to create a group 'devops', add the current user to it, and change ownership of '/opt/deploy' to this group with write permissions.", "output": "sudo groupadd devops\nsudo usermod -aG devops $USER\nsudo chown :devops /opt/deploy\nsudo chmod 775 /opt/deploy"}
{"instruction": "Write a Helm chart template snippet for a Deployment that allows the replica count to be parameterized via values.yaml.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ .Release.Name }}-app\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      app: {{ .Release.Name }}\n  template:\n    metadata:\n      labels:\n        app: {{ .Release.Name }}"}
{"instruction": "Write a multi-stage Dockerfile for a Node.js application to optimize image size by separating the build environment from the runtime environment.", "output": "FROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/package*.json ./\nRUN npm install --production\nCMD [\"node\", \"dist/main.js\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx container with 3 replicas, a liveness probe, and memory limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a bash script that parses an Apache access log file ('access.log') and outputs the top 5 IP addresses by request count.", "output": "#!/bin/bash\n# Extract IP (first column), sort, count unique occurrences, sort numerically descending, take top 5\nawk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service and a Postgres database, ensuring the web service restarts if it crashes and persists database data.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    restart: always\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: myappdb\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:"}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'example.com' to a service named 'web-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80"}
{"instruction": "Write a bash script to archive the '/var/www/html' directory into a tarball with the current date appended to the filename, and delete archives older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y-%m-%d)\nFILE_NAME=\"website-backup-$DATE.tar.gz\"\n\n# Create backup\ntar -czf \"$BACKUP_DIR/$FILE_NAME\" \"$SOURCE_DIR\"\n\n# Delete backups older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"website-backup-*.tar.gz\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a GitHub Actions workflow file that runs tests on push to the 'main' branch and logs into Docker Hub using secrets.", "output": "name: CI Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Run Tests\n      run: npm test\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}"}
{"instruction": "Provide a Linux command using 'lsof' to check which process is listening on TCP port 8080.", "output": "sudo lsof -i :8080 -sTCP:LISTEN"}
{"instruction": "Write a Kubernetes CronJob manifest that runs a database backup script every day at midnight.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: db-backup\nspec:\n  schedule: \"0 0 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: backup\n            image: my-backup-image:latest\n            command: [\"/bin/sh\", \"-c\", \"/scripts/backup.sh\"]\n          restartPolicy: OnFailure"}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network named 'app-net' and run a container attached to it.", "output": "docker network create --driver bridge app-net\ndocker run -d --name my-container --network app-net nginx:alpine"}
{"instruction": "Create a multi-stage Dockerfile for a Python application to minimize the final image size. The build stage should install dependencies, and the final stage should copy only necessary artifacts.", "output": "FROM python:3.9-slim as builder\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --user -r requirements.txt\n\nFROM python:3.9-slim\nWORKDIR /app\nCOPY --from=builder /root/.local /root/.local\nCOPY . .\nENV PATH=/root/.local/bin:$PATH\nCMD [\"python\", \"app.py\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a rolling update strategy that allows maximum 1 unavailable pod and 1 surge pod.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through all filesystems, checks if usage exceeds 80%, and prints a warning message if it does.", "output": "#!/bin/bash\ndf -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 \" \" $1 }' | while read output;\ndo\n  usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )\n  partition=$(echo $output | awk '{ print $2 }' )\n  if [ $usep -ge 80 ]; then\n    echo \"Running out of space \\\"$partition ($usep%)\\\" on $(hostname)\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to deploy a Node.js backend connected to a Redis database, ensuring the app restarts on failure.", "output": "version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - redis\n    restart: on-failure\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\"\n    restart: always"}
{"instruction": "Define a Kubernetes Pod YAML that injects a ConfigMap value as 'LOG_LEVEL' and a Secret value as 'API_KEY' into the environment variables.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sh\", \"-c\", \"env\" ]\n    env:\n      - name: LOG_LEVEL\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: log_level\n      - name: API_KEY\n        valueFrom:\n          secretKeyRef:\n            name: app-secret\n            key: api_key"}
{"instruction": "Write a Bash script snippet to pause execution until a database service on host 'db' and port '5432' is available using netcat.", "output": "#!/bin/bash\necho \"Waiting for postgres...\"\nwhile ! nc -z db 5432; do\n  sleep 0.1\ndone\necho \"PostgreSQL started\""}
{"instruction": "Create a .gitlab-ci.yml configuration to build a Docker image and push it to the registry only on the master branch.", "output": "stages:\n  - build\n\ndocker-build:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - master"}
{"instruction": "Write a Bash script to find all '.log' files in '/var/log/app' older than 7 days and delete them.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/app\"\nfind \"$TARGET_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;\necho \"Cleanup complete.\""}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'example.com' to a service named 'web-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80"}
{"instruction": "Write a Declarative Jenkinsfile to checkout code, run 'npm install', and archive the 'dist' directory as an artifact.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'npm install'\n                sh 'npm run build'\n            }\n        }\n    }\n    post {\n        success {\n            archiveArtifacts artifacts: 'dist/**/*', followSymlinks: false\n        }\n    }\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server that includes a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash script that finds log files in '/var/log/app' older than 7 days, compresses them into a backup directory, and removes the originals.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/mnt/backups/logs\"\nDATE=$(date +%Y%m%d)\n\nmkdir -p \"$BACKUP_DIR\"\n\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -print0 | while IFS= read -r -d '' file; do\n  filename=$(basename \"$file\")\n  tar -czf \"$BACKUP_DIR/$filename-$DATE.tar.gz\" \"$file\"\n  rm \"$file\"\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a PostgreSQL database with a persistent volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n    depends_on:\n      - db\n  db:\n    image: postgres:13-alpine\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: myapp\nvolumes:\n  postgres_data:"}
{"instruction": "Define a GitLab CI/CD configuration (.gitlab-ci.yml) to build a Docker image and push it to the registry only on the main branch.", "output": "stages:\n  - build\n\ndocker-build:\n  image: docker:latest\n  stage: build\n  services:\n    - docker:dind\n  before_script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n  script:\n    - docker build -t \"$CI_REGISTRY_IMAGE:latest\" .\n    - docker push \"$CI_REGISTRY_IMAGE:latest\"\n  only:\n    - main"}
{"instruction": "Write a bash script to check the HTTP status code of a list of URLs provided in a file named 'urls.txt'.", "output": "#!/bin/bash\ninput=\"urls.txt\"\nwhile IFS= read -r url\ndo\n  status_code=$(curl --write-out \"%{http_code}\" --silent --output /dev/null \"$url\")\n  echo \"$url - Status: $status_code\"\ndone < \"$input\""}
{"instruction": "Create a Kubernetes HorizontalPodAutoscaler (HPA) manifest to scale a deployment named 'api-gateway' between 2 and 10 replicas based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-gateway-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-gateway\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Show a Kubernetes Pod definition that injects environment variables from a ConfigMap named 'app-config' and a Secret named 'app-secret'.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: k8s.gcr.io/busybox\n    command: [ \"sh\", \"-c\", \"env\" ]\n    envFrom:\n    - configMapRef:\n        name: app-config\n    - secretRef:\n        name: app-secret"}
{"instruction": "Write a GitHub Actions workflow file that runs 'npm install' and 'npm test' on every pull request to the main branch.", "output": "name: Node.js CI\n\non:\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide a one-liner Docker command to backup a named volume 'my-data-vol' to a tar archive in the current directory.", "output": "docker run --rm -v my-data-vol:/volume -v $(pwd):/backup alpine tar cvf /backup/backup.tar /volume"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nEXPOSE 8080\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server running 3 replicas, including a liveness probe that checks the root path on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that iterates through a list of servers in a file named 'hosts.txt' and checks if they are reachable via ping.", "output": "#!/bin/bash\nwhile IFS= read -r server; do\n    if ping -c 1 -W 1 \"$server\" &> /dev/null; then\n        echo \"$server is UP\"\n    else\n        echo \"$server is DOWN\"\n    fi\ndone < hosts.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service dependent on a PostgreSQL database service, using a named volume for database persistence.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n  db:\n    image: postgres:13\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=myapp\nvolumes:\n  postgres_data:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, checks out the code, sets up Node.js, installs dependencies, and runs tests.", "output": "name: Node.js CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Bash command to find all files in the '/var/log' directory ending in '.log' that have not been modified in the last 30 days and delete them.", "output": "find /var/log -name \"*.log\" -type f -mtime +30 -exec rm -f {} \\;"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose a deployment labeled 'app: frontend' on port 80 inside the cluster and port 30080 on the node.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30080"}
{"instruction": "Write a Bash script to monitor memory usage and alert (echo a warning) if free memory drops below 500MB.", "output": "#!/bin/bash\nFREE_MEM=$(free -m | awk '/^Mem/ {print $4}')\nif [ \"$FREE_MEM\" -lt 500 ]; then\n  echo \"WARNING: Low memory! Only ${FREE_MEM}MB free.\"\nelse\n  echo \"Memory status OK: ${FREE_MEM}MB free.\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap YAML that injects a 'redis-config' file containing specific maxmemory settings.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: redis-config\ndata:\n  redis.conf: |\n    maxmemory 2mb\n    maxmemory-policy allkeys-lru"}
{"instruction": "Write a Docker CLI command to run a container named 'my-db' from the 'mysql:8.0' image, setting the root password via an environment variable and running it in detached mode.", "output": "docker run -d --name my-db -e MYSQL_ROOT_PASSWORD=my-secret-pw mysql:8.0"}
{"instruction": "Create a multi-stage Dockerfile for a Golang application to optimize image size. The build stage should compile the app, and the final stage should run the binary in a scratch image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML file that deploys 3 replicas of an Nginx container, forcing the pods to be scheduled only on nodes with the label 'disktype: ssd'.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n      nodeSelector:\n        disktype: ssd"}
{"instruction": "Write a Bash script that checks disk usage on the root partition. If usage exceeds 80%, send an alert message to the console.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${USAGE}%!\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a Redis database. The web service should depend on Redis and expose port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash script to parse an Nginx access log file ('access.log') and print the top 5 unique IP addresses by request count.", "output": "#!/bin/bash\ncat access.log | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment named 'backend-app' on port 8080, targeting port 80 on the container.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend-app\n  ports:\n    - port: 8080\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a GitHub Actions workflow YAML file that triggers on a push to the 'main' branch, checks out the code, and builds a Docker image tagged 'latest'.", "output": "name: Docker Build\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Build Docker Image\n        run: docker build -t my-app:latest ."}
{"instruction": "Construct a Docker command to run a container named 'db-test' from the 'postgres' image in the background, setting the password environment variable and mapping port 5432.", "output": "docker run -d --name db-test -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres"}
{"instruction": "Write a Bash script that loops through a list of servers provided in a text file named 'servers.txt' and attempts to SSH into them to check uptime.", "output": "#!/bin/bash\nwhile IFS= read -r server; do\n  echo \"Checking $server...\"\n  ssh -o ConnectTimeout=5 user@\"$server\" 'uptime'\ndone < servers.txt"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should compile the app, and the final stage should run it on Alpine Linux.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a bash script that parses an Nginx access log file named 'access.log' and outputs the top 5 IP addresses with the highest request count.", "output": "#!/bin/bash\nawk '{print $1}' access.log | sort | uniq -c | sort -nr | head -5"}
{"instruction": "Define a Kubernetes Deployment YAML for an application named 'web-server' running the 'nginx:latest' image with 3 replicas and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Create a docker-compose.yml file to deploy a Python Flask application (service name 'web') dependent on a PostgreSQL database (service name 'db') with a persistent volume for data.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydatabase\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:"}
{"instruction": "Write a shell script to automate rotating backups. It should create a tarball of the '/var/www/html' directory with a timestamp and delete archives older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y%m%d_%H%M%S)\nTAR_FILE=\"$BACKUP_DIR/backup_$DATE.tar.gz\"\n\n# Create backup\ntar -czf \"$TAR_FILE\" \"$SOURCE_DIR\"\n\n# Delete backups older than 7 days\nfind \"$BACKUP_DIR\" -name \"backup_*.tar.gz\" -type f -mtime +7 -delete"}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a GitHub Actions workflow file that runs on push to the 'main' branch, checks out the code, and builds a Docker image.", "output": "name: Docker Build CI\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Build Docker image\n      run: docker build -t my-app:${{ github.sha }} ."}
{"instruction": "Provide the Docker CLI command to run a container named 'redis-cache' in the background, mapping host port 6379 to container port 6379, and setting a memory limit of 512MB.", "output": "docker run -d --name redis-cache -p 6379:6379 --memory=\"512m\" redis:latest"}
{"instruction": "Write a bash script that checks if the disk usage of the root filesystem exceeds 90% and prints a warning to standard error if it does.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is above $THRESHOLD%. Current usage: $USAGE%\" >&2\nfi"}
{"instruction": "Create a Kubernetes ConfigMap YAML that contains a configuration file named 'app.properties' and a Secret YAML for a database password, then show how to inject them as environment variables in a Pod.", "output": "---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  app.properties: |\n    debug=true\n    log_level=info\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  password: cGFzc3dvcmQ= # base64 for 'password'\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-demo\nspec:\n  containers:\n  - name: demo-container\n    image: busybox\n    command: [\"sleep\", \"3600\"]\n    env:\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-secret\n          key: password\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to ensure the final image is as small as possible.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a readiness probe looking at the root path, and memory limits set to 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script to find and delete all log files in the directory '/var/log/app_logs' that are older than 7 days.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/app_logs\"\n\nif [ -d \"$TARGET_DIR\" ]; then\n  find \"$TARGET_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;\n  echo \"Cleanup completed.\"\nelse\n  echo \"Directory $TARGET_DIR does not exist.\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a Redis database service, ensuring the web service depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash script that waits for a specific HTTP endpoint (passed as an argument) to return a 200 OK status code before proceeding, useful for CI/CD pipeline dependencies.", "output": "#!/bin/bash\nURL=\"$1\"\n\necho \"Waiting for $URL to be ready...\"\nuntil [ \"$(curl -s -o /dev/null -w ''%{http_code}'' \"$URL\")\" == \"200\" ]; do\n  printf \".\"\n  sleep 2\ndone\n\necho \"\\n$URL is up and running!\""}
{"instruction": "Provide the Docker CLI command to create a volume named 'postgres_data' and then start a PostgreSQL container that mounts this volume to '/var/lib/postgresql/data'.", "output": "docker volume create postgres_data && \\\ndocker run -d \\\n  --name my-postgres \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v postgres_data:/var/lib/postgresql/data \\\n  -p 5432:5432 \\\n  postgres:13"}
{"instruction": "Create a Kubernetes Service YAML of type ClusterIP to expose an application labeled 'app: backend' on port 80, targeting the container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP"}
{"instruction": "Write a simple GitHub Actions workflow file that runs 'npm install' and 'npm test' whenever code is pushed to the 'main' branch.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Bash script to recursively set directory permissions to 755 and file permissions to 644 within a specific web root directory.", "output": "#!/bin/bash\nWEB_ROOT=\"/var/www/html\"\n\n# Set directory permissions\nfind \"$WEB_ROOT\" -type d -exec chmod 755 {} \\;\n\n# Set file permissions\nfind \"$WEB_ROOT\" -type f -exec chmod 644 {} \\;\n\necho \"Permissions updated for $WEB_ROOT\""}
{"instruction": "Generate a Kubernetes ConfigMap YAML named 'app-config' containing two literal key-value pairs: 'environment=production' and 'debug_mode=false'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  environment: \"production\"\n  debug_mode: \"false\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to build the binary in the first stage and run it in a lightweight Alpine image in the second stage.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, setting memory limits to 128Mi and defining a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 5"}
{"instruction": "Write a Bash script that checks the disk usage of the root directory and prints a warning if it exceeds 80%.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is high at ${USAGE}%\"\nelse\n  echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file to deploy a PostgreSQL database with a persistent volume and a custom password environment variable.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_PASSWORD: securepassword123\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n  postgres_data:"}
{"instruction": "Create a GitHub Actions workflow file that checks out the code and runs 'npm test' whenever a push is made to the 'main' branch.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment labeled 'app: frontend' using a NodePort on port 30080 targeting container port 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 3000\n      nodePort: 30080"}
{"instruction": "Write a Bash command to find all log files in '/var/log/myapp' that are older than 7 days and compress them using gzip.", "output": "find /var/log/myapp -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;"}
{"instruction": "Create a GitLab CI pipeline configuration (.gitlab-ci.yml) that builds a Docker image and pushes it to the registry using the project's default variables.", "output": "build_image:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest"}
{"instruction": "Write a Bash script loop using netcat (nc) to wait for a database service on localhost port 5432 to become available before proceeding.", "output": "#!/bin/bash\necho \"Waiting for database connection...\"\nwhile ! nc -z localhost 5432; do\n  sleep 1\ndone\necho \"Database is up - executing command\""}
{"instruction": "Create a Kubernetes Pod YAML that mounts a ConfigMap named 'app-settings' into the container at path '/etc/config' as a read-only volume.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app\n      image: my-app:1.0\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n        readOnly: true\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-settings"}
{"instruction": "Create a multi-stage Dockerfile for a Python application to minimize the final image size. The build stage should install dependencies, and the final stage should only contain the runtime environment.", "output": "FROM python:3.9-slim AS builder\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --user --no-cache-dir -r requirements.txt\n\nFROM python:3.9-slim\nWORKDIR /app\nCOPY --from=builder /root/.local /root/.local\nCOPY . .\nENV PATH=/root/.local/bin:$PATH\nCMD [\"python\", \"app.py\"]"}
{"instruction": "Write a bash script command to parse a standard Nginx access log file named 'access.log' and count the number of requests made by unique IP addresses that resulted in a 404 HTTP status code.", "output": "awk '($9 ~ /404/) {print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Generate a Kubernetes Deployment YAML manifest for an application named 'web-server' using the 'nginx:alpine' image. It must have 3 replicas, a memory limit of 128Mi, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-server\n  template:\n    metadata:\n      labels:\n        app: web-server\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:alpine\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n        livenessProbe:\n          tcpSocket:\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Create a docker-compose.yml file that sets up a WordPress service dependent on a MySQL 5.7 service. Ensure the database data is persisted in a named volume called 'db_data'.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: examplepass\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n  wordpress:\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a shell script that creates a compressed tarball of the directory '/var/www/html', appends the current date to the filename, and deletes backups older than 7 days from the backup directory.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y-%m-%d)\nFILENAME=\"backup-$DATE.tar.gz\"\n\n# Create backup\ntar -czf \"$BACKUP_DIR/$FILENAME\" \"$SOURCE_DIR\"\n\n# Delete backups older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"backup-*.tar.gz\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a GitHub Actions workflow YAML file that runs 'npm install' and 'npm test' whenever a pull request is opened or synchronized against the 'main' branch.", "output": "name: Node.js CI\n\non:\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide the command to force remove all dangling Docker images (images not tagged and not referenced by any container) to free up disk space.", "output": "docker rmi $(docker images -f \"dangling=true\" -q)"}
{"instruction": "Create a Kubernetes Service manifest of type LoadBalancer that exposes a deployment named 'backend-api' on port 80, targeting targetPort 8080 on the pods.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash function that checks if a specific Docker container is running. If it is not running, start it; if it doesn't exist, print an error message.", "output": "ensure_container_running() {\n  CONTAINER_NAME=$1\n  if [ \"$(docker ps -q -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n    echo \"Container $CONTAINER_NAME is running.\"\n  elif [ \"$(docker ps -aq -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n    echo \"Starting container $CONTAINER_NAME...\"\n    docker start \"$CONTAINER_NAME\"\n  else\n    echo \"Error: Container $CONTAINER_NAME does not exist.\"\n  fi\n}"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' with a key 'environment' set to 'production', and a Pod manifest that injects this value into an environment variable named 'APP_ENV'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  environment: \"production\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sh\", \"-c\", \"echo $APP_ENV && sleep 3600\" ]\n      env:\n        - name: APP_ENV\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: environment"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nEXPOSE 8080\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment manifest for an Nginx server with 3 replicas, a resource limit of 128Mi memory, and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a bash script that loops through a list of servers defined in a variable and checks if they are reachable via ping.", "output": "#!/bin/bash\nSERVERS=\"192.168.1.1 192.168.1.2 google.com\"\n\nfor server in $SERVERS; do\n    if ping -c 1 $server &> /dev/null; then\n        echo \"$server is UP\"\n    else\n        echo \"$server is DOWN\"\n    fi\ndone"}
{"instruction": "Create a GitHub Actions workflow file that runs tests on every push to the 'main' branch using Node.js.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x, 18.x]\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a bash one-liner to parse an Nginx access log and display the top 5 IP addresses by request count.", "output": "awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service and a Redis database, ensuring the web service restarts always.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    restart: always\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Kubernetes HorizontalPodAutoscaler manifest to scale a deployment named 'backend-api' between 2 and 10 pods based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Write a bash script to archive (tar+gzip) a specific directory and delete archives older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/var/backups/app_data\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y-%m-%d)\n\n# Create backup\nmkdir -p $BACKUP_DIR\ntar -czf \"$BACKUP_DIR/backup-$DATE.tar.gz\" \"$SOURCE_DIR\"\n\n# Delete files older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"*.tar.gz\" -mtime +7 -delete"}
{"instruction": "Create a Kubernetes ConfigMap and a Pod that mounts the ConfigMap content as a file at /etc/config/app.conf.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  app.conf: |\n    log_level=debug\n    feature_flag=true\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Write a bash script using 'sed' to replace the string 'localhost' with 'db-service' in a configuration file in place.", "output": "#!/bin/bash\nCONFIG_FILE=\"config.yaml\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n    sed -i 's/localhost/db-service/g' \"$CONFIG_FILE\"\n    echo \"Configuration updated.\"\nelse\n    echo \"Error: File not found.\"\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by using Alpine Linux.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a bash script that checks if a specific service (e.g., docker) is running. If not, attempt to start it.", "output": "#!/bin/bash\nSERVICE=\"docker\"\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n    echo \"$SERVICE is not running. Attempting to start...\"\n    sudo systemctl start \"$SERVICE\"\n    if systemctl is-active --quiet \"$SERVICE\"; then\n        echo \"$SERVICE started successfully.\"\n    else\n        echo \"Failed to start $SERVICE.\"\n        exit 1\n    fi\nelse\n    echo \"$SERVICE is running.\"\nfi"}
{"instruction": "Create a Docker Compose file that sets up a Python Flask web service dependent on a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a bash script to find all log files in `/var/log/myapp` older than 7 days and compress them.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nfind \"$LOG_DIR\" -type f -name \"*.log\" -mtime +7 -exec gzip {} \\;"}
{"instruction": "Define a GitHub Actions workflow that runs unit tests using npm whenever code is pushed to the 'main' branch.", "output": "name: Node.js CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Create a Kubernetes Service YAML to expose a deployment named 'backend' on NodePort 30007 mapping to container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a command to create a custom Docker bridge network named 'isolated_net' with a specific subnet.", "output": "docker network create --driver bridge --subnet 192.168.10.0/24 isolated_net"}
{"instruction": "Write a bash script that iterates through a list of servers in a text file and checks their connectivity using ping.", "output": "#!/bin/bash\nSERVER_LIST=\"servers.txt\"\nwhile IFS= read -r server; do\n    if ping -c 1 -W 1 \"$server\" &> /dev/null; then\n        echo \"$server is UP\"\n    else\n        echo \"$server is DOWN\"\n    fi\ndone < \"$SERVER_LIST\""}
{"instruction": "Create a Kubernetes Pod definition that mounts a ConfigMap named 'app-config' into the container at path `/etc/config`.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: configmap-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Create a Dockerfile for a Node.js application using multi-stage builds to minimize image size. The build stage installs dependencies and compiles TypeScript, while the production stage uses a distroless image and only copies necessary artifacts.", "output": "FROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM gcr.io/distroless/nodejs18-debian11\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCMD [\"dist/main.js\"]"}
{"instruction": "Write a bash script that checks if a specific Docker container is running. If it is not running, the script should restart it and log the event with a timestamp to 'restart.log'.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-app-container\"\n\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"$(date): Container $CONTAINER_NAME is stopped. Restarting...\" >> restart.log\n        docker start $CONTAINER_NAME\n    else\n        echo \"$(date): Container $CONTAINER_NAME does not exist.\" >> restart.log\n    fi\nfi"}
{"instruction": "Create a Kubernetes Deployment manifest for an Nginx server. It must have 3 replicas, a liveness probe checking path '/' on port 80, and resource limits set to 128Mi memory and 500m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a docker-compose.yml file to set up a development environment with a Python Flask web service and a Postgres database. The Flask app should depend on the database being healthy before starting.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: myapp\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5"}
{"instruction": "Create a GitHub Actions workflow file that triggers on push to the 'main' branch, builds a Docker image, logs into Docker Hub using secrets, and pushes the image with the tag 'latest'.", "output": "name: Docker Build and Push\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myrepo:latest"}
{"instruction": "Write a bash script to parse an Nginx access log file. The script should count the number of occurrences of each IP address and output the top 5 IP addresses with the highest request count.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Kubernetes Ingress resource to route traffic. Requests to 'api.example.com' should go to the 'backend-service' on port 8080, and requests to 'example.com' should go to the 'frontend-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: minimal-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80"}
{"instruction": "Write a GitLab CI configuration (.gitlab-ci.yml) that defines two stages: 'test' and 'deploy'. The deploy stage should only run when changes are pushed to the 'production' branch and should execute a script to update a Kubernetes cluster.", "output": "stages:\n  - test\n  - deploy\n\nrun_tests:\n  stage: test\n  image: python:3.9\n  script:\n    - pip install -r requirements.txt\n    - pytest\n\ndeploy_k8s:\n  stage: deploy\n  image: dtzar/helm-kubectl\n  script:\n    - kubectl config set-context --current --namespace=production\n    - kubectl set image deployment/myapp myapp=registry.gitlab.com/group/project:$CI_COMMIT_SHA\n  only:\n    - production"}
{"instruction": "Write a bash script that iterates through all files in the current directory ending in '.jpg', converts them to '.png' using the 'convert' tool (ImageMagick), and deletes the original file upon success.", "output": "#!/bin/bash\nfor file in *.jpg; do\n    [ -e \"$file\" ] || continue\n    filename=\"${file%.*}\"\n    if convert \"$file\" \"$filename.png\"; then\n        echo \"Converted $file to $filename.png\"\n        rm \"$file\"\n    else\n        echo \"Failed to convert $file\"\n    fi\ndone"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) manifest requesting 10Gi of storage with 'ReadWriteOnce' access mode using the 'standard' storage class.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-data-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: standard\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should compile the binary named 'app', and the second stage should use a minimal 'alpine' image to run the binary to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go mod download\nRUN CGO_ENABLED=0 GOOS=linux go build -o app .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. It must use a RollingUpdate strategy where maxSurge is 1 and maxUnavailable is 0.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script that iterates through all '.log' files in the '/var/log/myapp' directory. If a file is older than 7 days, compress it using gzip. If a compressed file (.gz) is older than 30 days, delete it.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\n# Compress logs older than 7 days\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\n\n# Delete compressed logs older than 30 days\nfind \"$LOG_DIR\" -name \"*.gz\" -type f -mtime +30 -exec rm {} \\;"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service using the current directory's Dockerfile and a 'db' service using PostgreSQL 13. The database data should be persisted in a named volume called 'postgres_data'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:"}
{"instruction": "Write a bash script to check if a specific Docker container named 'web_server' is running. If it is not running, start it. If it doesn't exist, print an error message.", "output": "#!/bin/bash\nCONTAINER_NAME=\"web_server\"\n\nif [ \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    echo \"Container $CONTAINER_NAME is already running.\"\nelif [ \"$(docker ps -aq -f name=$CONTAINER_NAME)\" ]; then\n    echo \"Starting container $CONTAINER_NAME...\"\n    docker start $CONTAINER_NAME\nelse\n    echo \"Error: Container $CONTAINER_NAME does not exist.\"\nfi"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) YAML to automatically scale a deployment named 'backend-api' between 2 and 10 replicas, targeting a CPU utilization of 50%.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Write a GitLab CI/CD pipeline configuration (.gitlab-ci.yml) with a 'deploy' stage. It should only run on the 'main' branch, log in to a Docker registry, build an image tagged with the commit SHA, and push it.", "output": "stages:\n  - deploy\n\ndocker-deploy:\n  stage: deploy\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  only:\n    - main"}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network named 'isolated_net' with subnet '172.20.0.0/16', and then run a Redis container named 'redis-cache' attached to that network.", "output": "docker network create --driver bridge --subnet 172.20.0.0/16 isolated_net\ndocker run -d --name redis-cache --network isolated_net redis:alpine"}
{"instruction": "Create a Bash script that acts as an entrypoint for a container. It should take a host and port as arguments and loop until `nc` (netcat) confirms the service is available, then execute the command passed as the rest of the arguments.", "output": "#!/bin/bash\n# Usage: ./wait-for-it.sh host port cmd...\nhost=\"$1\"\nport=\"$2\"\nshift 2\ncmd=\"$@\"\n\nuntil nc -z -v -w30 \"$host\" \"$port\"; do\n  echo \"Waiting for $host:$port...\"\n  sleep 2\ndone\n\necho \"$host:$port is up - executing command\"\nexec $cmd"}
{"instruction": "Write a Kubernetes ConfigMap YAML named 'app-config' containing a key 'database_url', and a Pod YAML that injects this key into the container as an environment variable named 'DB_CONNECTION_STRING'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sh\", \"-c\", \"env\" ]\n    env:\n      - name: DB_CONNECTION_STRING\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: database_url"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should use `golang:1.21` and the final stage should use `alpine:latest`.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the root path `/` on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that checks if a specific website (passed as an argument) is reachable (HTTP 200). If not, it should print an error message and exit with status 1.", "output": "#!/bin/bash\nURL=$1\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"Site $URL is up.\"\nelse\n  echo \"Site $URL is down (Status: $HTTP_STATUS).\"\n  exit 1\nfi"}
{"instruction": "Create a `docker-compose.yml` file to set up a WordPress environment linked to a MySQL 5.7 database. Ensure the database data is persisted in a named volume.", "output": "version: '3.8'\n\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: user\n      MYSQL_PASSWORD: password\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: user\n      WORDPRESS_DB_PASSWORD: password\n      WORDPRESS_DB_NAME: wordpress\n\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow file (`.github/workflows/ci.yml`) that triggers on a push to the `main` branch, sets up Node.js 16, installs dependencies, and runs tests.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 16.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Bash one-liner to find all files larger than 100MB in the `/var/log` directory and delete them.", "output": "find /var/log -type f -size +100M -exec rm -f {} \\;"}
{"instruction": "Create a Kubernetes Service of type `NodePort` that exposes pods labeled `app: frontend` on port 80 to port 30080 on the node.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30080"}
{"instruction": "Write a Dockerfile for a Python Flask application that creates a non-root user named `appuser` and runs the application as that user for security.", "output": "FROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt requirements.txt\nRUN pip install -r requirements.txt\n\nCOPY . .\n\nRUN useradd -m appuser\nUSER appuser\n\nCMD [ \"python3\", \"-m\" , \"flask\", \"run\", \"--host=0.0.0.0\"]"}
{"instruction": "Write a Bash script to parse an Nginx access log file (`access.log`) and output the top 5 IP addresses by request count.", "output": "#!/bin/bash\nawk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Define a Kubernetes Horizontal Pod Autoscaler (HPA) YAML that scales a deployment named `php-apache` between 1 and 10 replicas based on 50% CPU utilization.", "output": "apiVersion: autoscaling/v1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: php-apache\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: php-apache\n  minReplicas: 1\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 50"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary using 'golang:1.21', and the second stage should use a 'scratch' image to minimize the final image size.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML configuration for an Nginx application with 3 replicas, selecting pods with the label 'app: nginx', and exposing container port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that loops through all '.log' files in the '/var/log/myapp' directory, compresses them using gzip, and appends the current date to the filename.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/myapp\"\nDATE=$(date +%F)\n\nfor file in \"$TARGET_DIR\"/*.log; do\n  if [ -f \"$file\" ]; then\n    gzip -c \"$file\" > \"${file}_${DATE}.gz\"\n    rm \"$file\"\n  fi\ndone"}
{"instruction": "Create a Docker Compose file version 3.8 that defines two services: a 'web' service building from the current directory exposing port 5000, and a 'redis' service using the 'redis:alpine' image.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: redis:alpine\n    restart: always"}
{"instruction": "Write a Kubernetes Service YAML of type 'LoadBalancer' that exposes a deployment named 'my-web-app' on port 80, targeting port 8080 on the container.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: my-web-app-service\nspec:\n  selector:\n    app: my-web-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a Bash script to check if the disk usage of the root filesystem ('/') exceeds 90%. If it does, print a warning message.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is critical at ${USAGE}%\"\nfi"}
{"instruction": "Define a GitHub Actions workflow YAML that triggers on a push to the 'main' branch, checks out the code, and runs a 'docker build' command.", "output": "name: CI Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build Docker Image\n        run: docker build -t my-app:${{ github.sha }} ."}
{"instruction": "Write a command to create a Docker volume named 'db_data' and run a PostgreSQL container that mounts this volume to '/var/lib/postgresql/data'.", "output": "docker volume create db_data && \\\ndocker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v db_data:/var/lib/postgresql/data \\\n  postgres:13"}
{"instruction": "Create a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to a service named 'api-service' on port 3000.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 3000"}
{"instruction": "Write a Bash one-liner to kill all running processes matching the name 'zombie-process'.", "output": "ps aux | grep 'zombie-process' | grep -v grep | awk '{print $2}' | xargs -r kill -9"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary using the 'golang:1.21' image, and the second stage should copy the binary into a lightweight 'alpine:latest' image to minimize the final image size.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML configuration for an application named 'frontend'. It should run 3 replicas of the 'nginx:stable' image, expose container port 80, and include a liveness probe that checks the root path '/' every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:stable\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that iterates through all '.log' files in the '/var/log/app' directory. For each file, it should archive it into a '.tar.gz' format with a timestamp suffix and then delete the original log file.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\n\nfor file in \"$LOG_DIR\"/*.log; do\n  if [ -f \"$file\" ]; then\n    tar -czf \"${file}_${TIMESTAMP}.tar.gz\" \"$file\"\n    if [ $? -eq 0 ]; then\n      rm \"$file\"\n      echo \"Archived and removed $file\"\n    else\n      echo \"Failed to archive $file\"\n    fi\n  fi\ndone"}
{"instruction": "Create a 'docker-compose.yml' file to spin up a Python Flask web service and a Redis database. The web service should be built from the current directory, map port 5000 to 5000, and depend on the redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash one-liner to check if a specific Docker container named 'my-database' is currently running. If it is not running, the script should start it.", "output": "if [ \"$(docker inspect -f '{{.State.Running}}' my-database 2>/dev/null)\" != \"true\" ]; then docker start my-database; fi"}
{"instruction": "Define a Kubernetes Ingress resource named 'web-ingress' that routes traffic based on the hostname. Requests to 'api.example.com' should go to the 'api-service' on port 8080, and requests to 'www.example.com' should go to the 'web-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080\n  - host: www.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80"}
{"instruction": "Create a GitHub Actions workflow file ('.github/workflows/ci.yml') that triggers on a push to the 'main' branch. The job should check out the code, set up Node.js version 18, install dependencies with 'npm ci', and run 'npm test'.", "output": "name: CI Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Bash script to monitor disk usage. If the disk usage of the root filesystem ('/') exceeds 85%, print a warning message to stderr.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical: ${CURRENT_USAGE}%\" >&2\nfi"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML named 'mysql-pv-claim'. It should request 5Gi of storage with 'ReadWriteOnce' access mode using the 'standard' storage class.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mysql-pv-claim\nspec:\n  storageClassName: standard\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Write the Docker CLI command to run a container named 'temp-worker' using the 'ubuntu:22.04' image. The container should mount the host directory '/home/user/data' to '/data' inside the container, run in the background, and restart automatically if it fails.", "output": "docker run -d --name temp-worker --restart on-failure -v /home/user/data:/data ubuntu:22.04 tail -f /dev/null"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an application named 'web-server' with 3 replicas. Include a readiness probe that checks the '/health' endpoint on port 8080.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-server\n  template:\n    metadata:\n      labels:\n        app: web-server\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 8080\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a bash script that loops through all '.log' files in '/var/log/app', compresses them if they are older than 7 days, and removes the original file.", "output": "#!/bin/bash\nfind /var/log/app -name \"*.log\" -type f -mtime +7 -print0 | while IFS= read -r -d '' file; do\n    gzip \"$file\"\n    echo \"Compressed $file\"\ndone"}
{"instruction": "Create a docker-compose.yml file that defines a 'frontend' service using Nginx and a 'backend' service using Redis. Ensure they share a custom bridge network named 'app-network'.", "output": "version: '3.8'\nservices:\n  frontend:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    networks:\n      - app-network\n  backend:\n    image: redis:alpine\n    networks:\n      - app-network\n\nnetworks:\n  app-network:\n    driver: bridge"}
{"instruction": "Write a shell command to perform a rolling restart of a Kubernetes deployment named 'payment-service' in the 'production' namespace.", "output": "kubectl rollout restart deployment/payment-service -n production"}
{"instruction": "Provide a GitHub Actions workflow step to build a Docker image and push it to Docker Hub, only if the event is a push to the 'main' branch.", "output": "name: CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-push:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a bash script to check if a specific website (passed as an argument) returns an HTTP 200 status code. If not, print an error and exit with status 1.", "output": "#!/bin/bash\nURL=$1\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"Site is up!\"\nelse\n  echo \"Site is down (Status: $HTTP_STATUS)\"\n  exit 1\nfi"}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'api.example.com/v1' to a service named 'backend-service' on port 3000.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 3000"}
{"instruction": "Write a Docker command to run a temporary container that backs up a named volume 'db_data' to a tar archive in the current directory on the host.", "output": "docker run --rm -v db_data:/volume -v $(pwd):/backup alpine tar cvf /backup/db_data_backup.tar /volume"}
{"instruction": "Write a bash script that monitors memory usage. If free memory falls below 500MB, it should append the output of the 'top' command to a file named '/var/log/mem_alert.log'.", "output": "#!/bin/bash\nFREE_MEM=$(free -m | awk '/^Mem/ {print $4}')\n\nif [ \"$FREE_MEM\" -lt 500 ]; then\n    date >> /var/log/mem_alert.log\n    echo \"Memory critical: ${FREE_MEM}MB free\" >> /var/log/mem_alert.log\n    top -b -n 1 | head -n 20 >> /var/log/mem_alert.log\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage 'builder' should compile the binary, and the second stage should use a minimal Alpine image to run the binary to reduce image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the '/healthz' path on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that iterates through a list of servers defined in 'hosts.txt' and checks their disk usage using SSH. Alert if usage is above 80%.", "output": "#!/bin/bash\nTHRESHOLD=80\nwhile read server; do\n  usage=$(ssh user@$server \"df -h / | tail -1 | awk '{print \\$5}' | sed 's/%//'\")\n  if [ \"$usage\" -gt \"$THRESHOLD\" ]; then\n    echo \"Alert: Disk usage on $server is ${usage}%\"\n  fi\ndone < hosts.txt"}
{"instruction": "Create a docker-compose.yml file to deploy a Python Flask app (web) and a Redis database. The web service should depend on the redis service and map port 5000 to the host.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow YAML that triggers on a push to the 'main' branch, logs into Docker Hub, builds an image, and pushes it.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Create a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Bash one-liner to find all log files in '/var/log' modified more than 7 days ago and compress them using gzip.", "output": "find /var/log -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;"}
{"instruction": "Provide the command to create a Docker network named 'isolated_net' with a specific subnet range '172.20.0.0/16'.", "output": "docker network create --driver bridge --subnet 172.20.0.0/16 isolated_net"}
{"instruction": "Write a Kubernetes ConfigMap YAML that stores database configuration (host and port) and a Pod YAML that injects these as environment variables.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: db-config\ndata:\n  DB_HOST: \"db.example.com\"\n  DB_PORT: \"5432\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n    - name: app\n      image: my-app:1.0\n      envFrom:\n        - configMapRef:\n            name: db-config"}
{"instruction": "Write a Bash script to automate database backups. It should dump a PostgreSQL database to a timestamped file and delete backups older than 30 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups/postgres\"\nTIMESTAMP=$(date +\"%Y%m%d%H%M\")\nDB_NAME=\"production_db\"\n\n# Create backup\npg_dump $DB_NAME > \"$BACKUP_DIR/$DB_NAME-$TIMESTAMP.sql\"\n\n# Delete files older than 30 days\nfind $BACKUP_DIR -type f -name \"*.sql\" -mtime +30 -delete"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize image size. The first stage should build the binary, and the second stage should use a minimal Alpine image to run it.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:3.19\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Bash script that checks if a specific Docker container is running. If it is not running, start it; otherwise, print a message saying it is active.", "output": "#!/bin/bash\nCONTAINER_NAME=\"web_server\"\n\nif [ \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    echo \"Container $CONTAINER_NAME is already running.\"\nelse\n    echo \"Starting container $CONTAINER_NAME...\"\n    docker start $CONTAINER_NAME\nfi"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a liveness probe that checks the '/healthz' endpoint on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Create a docker-compose.yml file to set up a Python Flask web service and a Redis database service. The web service should depend on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'build' to compile code and 'deploy' which only runs on the 'main' branch.", "output": "stages:\n  - build\n  - deploy\n\nbuild_job:\n  stage: build\n  script:\n    - echo \"Compiling the code...\"\n    - make build\n\ndeploy_job:\n  stage: deploy\n  script:\n    - echo \"Deploying application...\"\n    - ./deploy_script.sh\n  only:\n    - main"}
{"instruction": "Write a Bash script to parse a log file, extract all IP addresses that have caused a '404' error, and count their occurrences, sorting by most frequent.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\n\ngrep \" 404 \" $LOG_FILE | awk '{print $1}' | sort | uniq -c | sort -nr"}
{"instruction": "Generate the command to create a Kubernetes generic secret named 'db-credentials' with a username and password using kubectl imperatively, without a YAML file.", "output": "kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password='S3cr3tP@ss' --dry-run=client -o yaml"}
{"instruction": "Create a Kubernetes HorizontalPodAutoscaler (HPA) YAML definition to scale a deployment named 'api-gateway' between 2 and 10 pods based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-gateway-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-gateway\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Write a declarative Jenkinsfile pipeline that builds a Docker image and pushes it to a registry, using credentials stored in Jenkins.", "output": "pipeline {\n    agent any\n    environment {\n        DOCKER_IMAGE = 'myrepo/myapp:latest'\n        REGISTRY_CREDS = credentials('docker-hub-credentials')\n    }\n    stages {\n        stage('Build') {\n            steps {\n                sh 'docker build -t $DOCKER_IMAGE .'\n            }\n        }\n        stage('Push') {\n            steps {\n                sh 'echo $REGISTRY_CREDS_PSW | docker login -u $REGISTRY_CREDS_USR --password-stdin'\n                sh 'docker push $DOCKER_IMAGE'\n            }\n        }\n    }\n}"}
{"instruction": "Write a Bash script to automate the backup of a directory. The script should compress the directory into a tarball with a timestamp and delete backups older than 7 days.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/www/html\"\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y-%m-%d-%H%M%S)\nBACKUP_FILE=\"$BACKUP_DIR/backup-$DATE.tar.gz\"\n\n# Create backup\ntar -czf $BACKUP_FILE $SOURCE_DIR\n\n# Delete files older than 7 days\nfind $BACKUP_DIR -type f -name \"*.tar.gz\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Bash script that checks if a specific website (passed as an argument) is reachable via HTTP status 200. If not, output an error message.", "output": "#!/bin/bash\nURL=$1\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" $URL)\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"Success: $URL is reachable.\"\nelse\n  echo \"Error: $URL returned status $HTTP_STATUS\"\n  exit 1\nfi"}
{"instruction": "Generate a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe checking path '/', and resource limits set.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Create a GitHub Actions workflow file that triggers on push to the 'main' branch, checks out the code, sets up Node.js, and runs 'npm test'.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a Docker Compose file to set up a PostgreSQL database with a persistent volume and a web service that depends on the database being healthy.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: example\n    volumes:\n      - db_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  web:\n    build: .\n    depends_on:\n      db:\n        condition: service_healthy\n\nvolumes:\n  db_data:"}
{"instruction": "Write a bash one-liner to find all files ending in '.log' in the '/var/log/app' directory that are older than 7 days and delete them.", "output": "find /var/log/app -name \"*.log\" -type f -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a Kubernetes Service of type LoadBalancer to expose a deployment named 'my-webapp' on port 80 targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: my-webapp-service\nspec:\n  selector:\n    app: my-webapp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a script to automate the backup of a MySQL Docker container database to a local file with a timestamp.", "output": "#!/bin/bash\nCONTAINER_NAME=\"mysql-prod\"\nDB_NAME=\"app_db\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nBACKUP_FILE=\"backup_${DB_NAME}_${TIMESTAMP}.sql\"\n\ndocker exec $CONTAINER_NAME /usr/bin/mysqldump -u root --password=secret $DB_NAME > $BACKUP_FILE\n\necho \"Backup saved to $BACKUP_FILE\""}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'api.example.com' to a service named 'backend-service' on port 3000.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 3000"}
{"instruction": "Write a bash function that loops until a specific TCP port is open on a host (useful for waiting for services to start in CI/CD pipelines).", "output": "wait_for_port() {\n  local host=$1\n  local port=$2\n  echo \"Waiting for $host:$port...\"\n  while ! nc -z $host $port; do\n    sleep 1\n  done\n  echo \"$host:$port is open!\"\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Golang application to optimize image size. The build stage should compile the binary named 'server', and the final stage should use a 'scratch' image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o server main.go\n\nFROM scratch\nCOPY --from=builder /app/server /server\nENTRYPOINT [\"/server\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a RollingUpdate strategy, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that checks disk usage for the root partition. If usage exceeds 85%, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is critical at ${USAGE}%\" >&2\nelse\n    echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Postgres database and a web service. The web service must depend on the database being healthy before starting.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: example\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n  web:\n    build: .\n    depends_on:\n      db:\n        condition: service_healthy"}
{"instruction": "Write a command to extract the IP address of a running Docker container named 'web_server' using docker inspect and Go templates.", "output": "docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web_server"}
{"instruction": "Define a GitHub Actions workflow (YAML) that triggers on a push to the 'main' branch, checks out the code, and builds a Docker image tagged with the commit SHA.", "output": "name: Docker Build\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Build Docker Image\n        run: docker build -t myapp:${{ github.sha }} ."}
{"instruction": "Write a Bash function to recursively change permissions in a directory: set all directories to 755 and all files to 644.", "output": "fix_perms() {\n    TARGET_DIR=\"$1\"\n    if [ -d \"$TARGET_DIR\" ]; then\n        find \"$TARGET_DIR\" -type d -exec chmod 755 {} \\;\n        find \"$TARGET_DIR\" -type f -exec chmod 644 {} \\;\n        echo \"Permissions fixed in $TARGET_DIR\"\n    else\n        echo \"Directory not found\"\n    fi\n}"}
{"instruction": "Create a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Docker command to run a temporary container that mounts the current directory to /app, runs a python script, and removes the container upon exit.", "output": "docker run --rm -v \"$(pwd)\":/app -w /app python:3.9-slim python script.py"}
{"instruction": "Create a Bash script that loops through a list of URLs in a file named 'urls.txt' and checks their HTTP status code using curl. If the status is not 200, log the failure.", "output": "#!/bin/bash\nwhile IFS= read -r url; do\n    code=$(curl -o /dev/null -s -w \"%{http_code}\" \"$url\")\n    if [ \"$code\" -ne 200 ]; then\n        echo \"FAIL: $url returned $code\"\n    else\n        echo \"OK: $url\"\n    fi\ndone < urls.txt"}
{"instruction": "Create a multi-stage Dockerfile for a Node.js application to minimize the final image size. The build stage should install dependencies and build the app, while the final stage should run on a lightweight Alpine image.", "output": "FROM node:18 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/package*.json ./\nRUN npm install --production\nCMD [\"node\", \"dist/main.js\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, ensuring a RollingUpdate strategy where maxUnavailable is 1 and maxSurge is 1.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through a list of servers defined in a variable, attempts to SSH into them to check uptime, and logs the result to a file named 'uptime_report.txt'.", "output": "#!/bin/bash\nSERVERS=(\"server1\" \"server2\" \"server3\")\nLOG_FILE=\"uptime_report.txt\"\n\n> \"$LOG_FILE\"\n\nfor server in \"${SERVERS[@]}\"; do\n  echo \"Checking $server...\"\n  if ssh -o BatchMode=yes -o ConnectTimeout=5 \"user@$server\" uptime >> \"$LOG_FILE\"; then\n    echo \"$server: Success\" \n  else\n    echo \"$server: Failed to connect\" >> \"$LOG_FILE\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service and a Redis database. The web service must depend on Redis and restart always if it fails.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    restart: always\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\"\n    restart: always"}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, builds a Docker image, and pushes it to Docker Hub using secrets for authentication.", "output": "name: Docker Build and Push\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: user/app:latest"}
{"instruction": "Construct a Kubernetes Service manifest of type LoadBalancer to expose a deployment labeled 'app: backend' on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a Bash command using 'sed' to replace all occurrences of 'http://old-api.com' with 'https://new-api.internal' in a configuration file named 'app.conf' in place (modifying the file).", "output": "sed -i 's|http://old-api.com|https://new-api.internal|g' app.conf"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) manifest requesting 10Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Write a bash script that checks if disk usage on the root partition ('/') exceeds 90%. If it does, print a warning to standard error.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical at ${USAGE}%\" >&2\nfi"}
{"instruction": "Provide the Docker command to remove all unused images (dangling images) and stopped containers to free up space without prompting for confirmation.", "output": "docker system prune -f"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary using the 'golang:1.21' image, and the second stage should produce a minimal image using 'alpine:latest' containing only the compiled binary.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML definition for an application named 'frontend'. It should run 3 replicas of the 'nginx:stable' image, expose port 80, and include a liveness probe checking the root path.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:stable\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that iterates through all files in the current directory. If a file ends with '.log', rename it by appending the current date (YYYY-MM-DD) to the filename.", "output": "#!/bin/bash\nDATE=$(date +%F)\nfor file in *.log; do\n  if [ -f \"$file\" ]; then\n    mv \"$file\" \"${file%.log}_$DATE.log\"\n    echo \"Renamed $file\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (building from the current directory) mapping port 5000 to 5000, and links it to a Redis service running on the default port.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file (YAML) that triggers on a push to the 'main' branch. It should check out the code, set up Node.js version 18, install dependencies, and run tests.", "output": "name: Node.js CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide the Docker CLI command to run a container named 'mysql-db' in the background using the 'mysql:8.0' image. Set the root password to 'secret123' via environment variables and mount a local volume named 'db_data' to '/var/lib/mysql'.", "output": "docker run -d --name mysql-db -e MYSQL_ROOT_PASSWORD=secret123 -v db_data:/var/lib/mysql mysql:8.0"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment named 'backend-app' internally within the cluster on port 80, targeting port 8080 on the pods.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP"}
{"instruction": "Write a Bash script that checks disk usage. If the usage of the root filesystem ('/') is greater than 80%, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is critical: $USAGE%\" >&2\nfi"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-config' containing two keys: 'DATABASE_URL' and 'DEBUG_MODE'. Then show a Pod YAML snippet demonstrating how to inject these as environment variables.", "output": "---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/mydb\"\n  DEBUG_MODE: \"false\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      envFrom:\n        - configMapRef:\n            name: app-config"}
{"instruction": "Write a Bash function that waits for a specific TCP port to become available on a host. It should retry every second for up to 30 seconds before failing.", "output": "wait_for_port() {\n  local host=$1\n  local port=$2\n  local retries=30\n  while [ $retries -gt 0 ]; do\n    nc -z \"$host\" \"$port\" > /dev/null 2>&1\n    if [ $? -eq 0 ]; then\n      echo \"Port $port on $host is open.\"\n      return 0\n    fi\n    echo \"Waiting for port $port...\"\n    sleep 1\n    ((retries--))\n  done\n  echo \"Timeout waiting for port $port\"\n  return 1\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should use 'golang:1.19' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.19 AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes YAML manifest for a Deployment named 'nginx-deploy' with 3 replicas, using the 'nginx:1.14.2' image, and include a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deploy\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that loops through all files in the current directory, checks if the file is a standard file (not a directory), and appends the current timestamp to the filename.", "output": "#!/bin/bash\n\nfor file in *; do\n  if [ -f \"$file\" ]; then\n    mv \"$file\" \"${file}_$(date +%Y%m%d_%H%M%S)\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service using a custom Dockerfile in the current directory and a 'redis' service using the official image. The web service should depend on redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash script to check if a specific process (e.g., 'nginx') is running. If it is not running, start it using systemctl.", "output": "#!/bin/bash\n\nSERVICE=\"nginx\"\nif ! pgrep -x \"$SERVICE\" >/dev/null\nthen\n    echo \"$SERVICE is not running. Starting...\"\n    sudo systemctl start \"$SERVICE\"\nelse\n    echo \"$SERVICE is running.\"\nfi"}
{"instruction": "Create a Kubernetes Service manifest of type LoadBalancer to expose a deployment labeled 'app: frontend' on port 80, targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a simple GitHub Actions workflow file (.github/workflows/ci.yml) that runs on push to the 'main' branch, checks out the code, and runs a script named 'test.sh'.", "output": "name: CI Pipeline\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      \n      - name: Run Tests\n        run: ./test.sh"}
{"instruction": "Write a Dockerfile for a Python Flask application that copies the 'requirements.txt', installs dependencies, copies the source code, and exposes port 5000.", "output": "FROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nEXPOSE 5000\nCMD [\"python\", \"app.py\"]"}
{"instruction": "Write a Bash script that parses the '/var/log/syslog' file, counts the occurrences of the word 'ERROR', and prints the count.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/syslog\"\nERROR_COUNT=$(grep -c \"ERROR\" \"$LOG_FILE\")\necho \"Number of errors found: $ERROR_COUNT\""}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) manifest requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary named 'app' from 'main.go', and the second stage should use a lightweight Alpine image to run the binary to minimize image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an nginx application with 3 replicas, ensuring a rolling update strategy where maxUnavailable is 1 and maxSurge is 1.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script that finds all '.log' files in '/var/log/myapp' older than 7 days, compresses them into a tar.gz archive with today's date, and deletes the original files.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/myapp\"\nARCHIVE_NAME=\"logs_archive_$(date +%F).tar.gz\"\n\n# Find files older than 7 days, tar them, then delete originals if tar succeeds\nfind \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -print0 | tar -czvf \"$ARCHIVE_NAME\" --null -T -\n\nif [ $? -eq 0 ]; then\n  find \"$SOURCE_DIR\" -name \"*.log\" -type f -mtime +7 -delete\n  echo \"Logs archived and cleaned up.\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a WordPress service depending on a MySQL 5.7 service, using environment variables to configure database credentials and persistence volumes.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: examplepass\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Create a Kubernetes Ingress resource definition that routes traffic from 'api.example.com/v1' to 'service-v1' and 'api.example.com/v2' to 'service-v2'.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: service-v1\n            port:\n              number: 80\n      - path: /v2\n        pathType: Prefix\n        backend:\n          service:\n            name: service-v2\n            port:\n              number: 80"}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, checks out the code, builds a Docker image using the commit SHA as the tag, and pushes it to Docker Hub.", "output": "name: Build and Push Docker Image\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:${{ github.sha }}"}
{"instruction": "Write a bash script that iterates through a list of servers defined in a text file 'servers.txt' and copies a local SSH key to each server's authorized_keys using ssh-copy-id.", "output": "#!/bin/bash\nSERVER_LIST=\"servers.txt\"\nSSH_KEY=\"$HOME/.ssh/id_rsa.pub\"\nUSER=\"deploy_user\"\n\nif [ ! -f \"$SERVER_LIST\" ]; then\n    echo \"Server list file not found!\"\n    exit 1\nfi\n\nwhile IFS= read -r server; do\n    echo \"Copying key to $server...\"\n    ssh-copy-id -i \"$SSH_KEY\" \"$USER@$server\"\ndone < \"$SERVER_LIST\""}
{"instruction": "Define a Kubernetes PersistentVolumeClaim (PVC) requesting 5Gi of storage with ReadWriteOnce access mode, and a Pod configuration that mounts this PVC to '/data'.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n    - name: my-container\n      image: alpine\n      command: [\"sleep\", \"3600\"]\n      volumeMounts:\n        - mountPath: \"/data\"\n          name: my-storage\n  volumes:\n    - name: my-storage\n      persistentVolumeClaim:\n        claimName: my-pvc"}
{"instruction": "Write a Docker CLI command to run a container named 'monitor' in the background, limiting it to 512MB of memory and 1.5 CPUs, mapping host port 8080 to container port 80.", "output": "docker run -d --name monitor --memory=\"512m\" --cpus=\"1.5\" -p 8080:80 my-image:latest"}
{"instruction": "Write a bash script to check if a specific Docker container is running. If it is not running, start it and send a notification message to a Slack webhook.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-app-container\"\nSLACK_WEBHOOK_URL=\"https://hooks.slack.com/services/EXAMPLE/PLACEHOLDER/TOKEN\"\n\n# Check if container is running\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting container...\"\n        docker start $CONTAINER_NAME\n        curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Container '$CONTAINER_NAME' was down and has been restarted.\"}' $SLACK_WEBHOOK_URL\n    else\n        echo \"Container does not exist.\"\n    fi\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary 'app', and the final stage should use 'alpine' to run it.", "output": "FROM golang:1.19-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a rolling update strategy ensuring at most 1 pod is unavailable during updates.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through a text file named 'servers.txt' (containing one IP per line) and uses SSH to check if the disk usage of the root partition ('/') is greater than 80%.", "output": "#!/bin/bash\nwhile read -r ip; do\n  usage=$(ssh -o BatchMode=yes user@\"$ip\" \"df -h / | awk 'NR==2 {print \\$5}' | tr -d '%'\")\n  if [ \"$usage\" -gt 80 ]; then\n    echo \"Alert: Disk usage on $ip is at ${usage}%\"\n  fi\ndone < servers.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask application (build context '.') and a Redis service. Ensure the Flask app restarts always and depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    restart: always\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a declarative Jenkinsfile that has three stages: 'Build', 'Test', and 'Deploy'. The Deploy stage should only run if the branch is 'main'.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                echo 'Building...'\n                sh 'make build'\n            }\n        }\n        stage('Test') {\n            steps {\n                echo 'Testing...'\n                sh 'make test'\n            }\n        }\n        stage('Deploy') {\n            when {\n                branch 'main'\n            }\n            steps {\n                echo 'Deploying...'\n                sh './deploy.sh'\n            }\n        }\n    }\n}"}
{"instruction": "Create a Kubernetes Pod YAML that mounts a ConfigMap named 'app-config' to '/etc/config' and injects a Secret named 'db-secret' as environment variables.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-secret-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-app:latest\n    envFrom:\n    - secretRef:\n        name: db-secret\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config"}
{"instruction": "Write a Bash command to find all log files inside '/var/log/myapp' that are older than 7 days, compress them into a .tar.gz archive, and remove the original files.", "output": "find /var/log/myapp -name \"*.log\" -mtime +7 -exec tar -rvf old_logs.tar {} \\; -exec rm {} \\; && gzip old_logs.tar"}
{"instruction": "Create a .gitlab-ci.yml configuration with a 'build' job that creates a Docker image and pushes it to the GitLab Container Registry.", "output": "image: docker:latest\nservices:\n  - docker:dind\n\nstages:\n  - build\n\nbuild_image:\n  stage: build\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer that exposes port 80 externally and maps it to target port 8080 on pods labeled 'app: backend'.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash script to perform a complete Docker cleanup: stop all running containers, remove all containers, and remove all dangling images.", "output": "#!/bin/bash\n# Stop all running containers\ndocker stop $(docker ps -aq)\n# Remove all containers\ndocker rm $(docker ps -aq)\n# Remove dangling images\ndocker rmi $(docker images -f \"dangling=true\" -q)"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary named 'app', and the second stage should use a lightweight Alpine image to run the binary.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a bash script that iterates through all files in the current directory with a '.log' extension, compresses them into a '.tar.gz' archive, and then deletes the original log files.", "output": "#!/bin/bash\n\nfor file in *.log; do\n    if [ -f \"$file\" ]; then\n        tar -czf \"${file}.tar.gz\" \"$file\"\n        rm \"$file\"\n        echo \"Archived and removed $file\"\n    fi\ndone"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (building from the current directory) and a 'redis' service using the alpine image. The web service should depend on redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: redis:alpine"}
{"instruction": "Write a shell script that checks if the disk usage of the root partition ('/') exceeds 85%. If it does, print a warning message to stderr.", "output": "#!/bin/bash\n\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is critical: ${USAGE}%\" >&2\nfi"}
{"instruction": "Provide the kubectl command to generate a generic secret named 'db-credentials' containing a username 'admin' and a password 's3cr3t' without using a YAML file.", "output": "kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=s3cr3t"}
{"instruction": "Create a GitHub Actions workflow step (YAML snippet) that logs into Docker Hub using secrets and pushes an image tagged 'latest'.", "output": "- name: Login to Docker Hub\n  uses: docker/login-action@v2\n  with:\n    username: ${{ secrets.DOCKERHUB_USERNAME }}\n    password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n- name: Build and push\n  uses: docker/build-push-action@v4\n  with:\n    push: true\n    tags: user/app:latest"}
{"instruction": "Write a bash function that checks if a specific TCP port is open on a remote server using netcat (nc), returning 0 for success and 1 for failure.", "output": "check_port() {\n    local host=$1\n    local port=$2\n    nc -z -v -w5 \"$host\" \"$port\" &> /dev/null\n    if [ $? -eq 0 ]; then\n        echo \"Port $port on $host is open.\"\n        return 0\n    else\n        echo \"Port $port on $host is closed.\"\n        return 1\n    fi\n}"}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Construct a Docker run command to start a PostgreSQL container named 'postgres-db' in the background, setting the password via an environment variable, and mounting a local directory 'pgdata' to the container's data volume.", "output": "docker run -d \\\n  --name postgres-db \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v $(pwd)/pgdata:/var/lib/postgresql/data \\\n  postgres:latest"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary named 'app', and the second stage should use a lightweight Alpine image to run the binary to minimize image size.", "output": "FROM golang:1.21 AS builder\nWORKDIR /src\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o app .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Bash script that monitors disk usage for the root partition. If usage exceeds 85%, print a warning message.", "output": "#!/bin/bash\nTHRESHOLD=85\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical at ${USAGE}%\"\nfi"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas, resource limits (256Mi memory, 500m CPU), and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a Docker Compose file to spin up a Python Flask web service (build from current directory) and a Redis database service, ensuring the web service depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash command to parse an Apache/Nginx access log file named 'access.log' and count the occurrences of HTTP 404 errors.", "output": "grep \" 404 \" access.log | wc -l"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment labeled 'app: frontend' on target port 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 3000\n      nodePort: 30080"}
{"instruction": "Write a Bash script that loops indefinitely to check if a specific website (passed as an argument) is up using curl. It should retry every 5 seconds until a 200 OK status is received.", "output": "#!/bin/bash\nURL=\"$1\"\n\nif [ -z \"$URL\" ]; then\n  echo \"Usage: $0 <url>\"\n  exit 1\nfi\n\nuntil curl --output /dev/null --silent --head --fail \"$URL\"; do\n  printf \"Waiting for $URL to be available...\\n\"\n  sleep 5\ndone\n\necho \"$URL is up!\""}
{"instruction": "Create a Kubernetes CronJob YAML that runs a database backup script (image: my-db-backup:latest) every day at 2:00 AM.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: db-backup\nspec:\n  schedule: \"0 2 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: backup\n            image: my-db-backup:latest\n            command: [\"/bin/sh\", \"-c\", \"/scripts/backup.sh\"]\n          restartPolicy: OnFailure"}
{"instruction": "Write a GitLab CI/CD configuration (.gitlab-ci.yml) stage to build a Docker image and push it to a registry, only on the 'main' branch.", "output": "build_image:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main"}
{"instruction": "Write a Bash command to find all files in the current directory (recursive) ending in '.log' that are older than 7 days and delete them.", "output": "find . -type f -name \"*.log\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should use 'golang:1.21-alpine' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a bash script that iterates through a list of servers defined in a variable, attempts to SSH into them to check uptime, and logs the result to 'uptime_report.txt'.", "output": "#!/bin/bash\nSERVERS=(\"server1.example.com\" \"server2.example.com\" \"server3.example.com\")\nLOG_FILE=\"uptime_report.txt\"\n\n> $LOG_FILE\n\nfor server in \"${SERVERS[@]}\"; do\n  echo \"Checking $server...\"\n  if ssh -o BatchMode=yes -o ConnectTimeout=5 user@$server \"uptime\"; then\n    echo \"$server is UP\" >> $LOG_FILE\n  else\n    echo \"$server is DOWN or unreachable\" >> $LOG_FILE\n  fi\ndone"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the root path on port 80 with an initial delay of 15 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.25\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Create a docker-compose.yml file that sets up a NodeJS application (building from the current directory) and a Redis service. The Node app should depend on Redis being started.", "output": "version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\"\n    ports:\n      - \"6379:6379\""}
{"instruction": "Write a bash one-liner to find all Docker containers with a status of 'exited' and remove them to clean up system resources.", "output": "docker ps -a -q -f status=exited | xargs -r docker rm"}
{"instruction": "Create a GitHub Actions workflow file that triggers on a push to the 'main' branch, logs into Docker Hub, builds an image tagged 'latest', and pushes it.", "output": "name: CI/CD Docker\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a Kubernetes Service YAML of type NodePort to expose a deployment labeled 'app: frontend' on port 80, mapping to target port 3000 inside the container.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 3000\n      nodePort: 30007"}
{"instruction": "Write a bash script to check if a specific SSL certificate file expires within the next 30 days.", "output": "#!/bin/bash\nCERT_FILE=\"/etc/ssl/certs/mycert.pem\"\nDAYS=30\nEXPIRY_DATE=$(openssl x509 -enddate -noout -in \"$CERT_FILE\" | cut -d= -f2)\nEXPIRY_EPOCH=$(date -d \"$EXPIRY_DATE\" +%s)\nCURRENT_EPOCH=$(date +%s)\nTHRESHOLD_EPOCH=$(date -d \"+$DAYS days\" +%s)\n\nif [ \"$EXPIRY_EPOCH\" -lt \"$THRESHOLD_EPOCH\" ]; then\n  echo \"Certificate expires within $DAYS days!\"\n  exit 1\nelse\n  echo \"Certificate is valid.\"\nfi"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 10Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Write a command to generate a self-signed SSL certificate and private key using OpenSSL, valid for 365 days, without a passphrase.", "output": "openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes -subj \"/CN=localhost\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe, and resource limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that loops through a list of servers (IPs) in a file named 'servers.txt' and checks if port 80 is open using netcat.", "output": "#!/bin/bash\nwhile read -r server; do\n  nc -z -v -w5 \"$server\" 80\n  if [ $? -eq 0 ]; then\n    echo \"$server: Port 80 is OPEN\"\n  else\n    echo \"$server: Port 80 is CLOSED\"\n  fi\ndone < servers.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a PostgreSQL database with a persistent volume and a custom environment variable for the password.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:"}
{"instruction": "Write a Linux command to find all files in the '/var/log' directory larger than 50MB and delete them.", "output": "find /var/log -type f -size +50M -exec rm -f {} \\;"}
{"instruction": "Define a Kubernetes Ingress resource to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Create a GitHub Actions workflow step (YAML) to build a Docker image and push it to Docker Hub, triggering only on a push to the 'main' branch.", "output": "name: CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a Bash command to parse a standard Nginx access log and display the top 5 IP addresses by request count.", "output": "awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Generate a command to create a Docker volume named 'web_data' and run an Apache container mounting that volume to '/usr/local/apache2/htdocs'.", "output": "docker volume create web_data && docker run -d -p 80:80 -v web_data:/usr/local/apache2/htdocs --name my-apache httpd:latest"}
{"instruction": "Write a Kubernetes HorizontalPodAutoscaler YAML to scale a deployment named 'php-app' between 2 and 10 replicas based on 50% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: php-app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: php-app\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should compile the app, and the final stage should use 'alpine:latest' to run the binary.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o server main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/server .\nCMD [\"./server\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an application named 'web-app' using image 'nginx:1.19'. Ensure high availability with 3 replicas and define a rolling update strategy allowing only 1 unavailable pod at a time.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.19"}
{"instruction": "Write a bash script that compresses log files in '/var/log/myapp' ending in .log that are older than 7 days, and deletes compressed .gz files older than 30 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\n# Compress logs older than 7 days\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\n\n# Delete compressed logs older than 30 days\nfind \"$LOG_DIR\" -name \"*.gz\" -type f -mtime +30 -delete"}
{"instruction": "Create a docker-compose.yml file that runs a 'web' service (build from current context, maps host port 80 to container port 5000) and a 'db' service (postgres:13-alpine), where 'web' depends on 'db'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"80:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13-alpine\n    environment:\n      POSTGRES_PASSWORD: example"}
{"instruction": "Define a Kubernetes ConfigMap named 'app-config' with a key 'ENV_TYPE' set to 'production', and a Pod spec that injects this value into the environment variable 'APP_ENV'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  ENV_TYPE: production\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sh\", \"-c\", \"env\" ]\n      env:\n        - name: APP_ENV\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: ENV_TYPE"}
{"instruction": "Create a GitHub Actions workflow file named 'ci.yml' that triggers on push to 'main'. It should check out code, set up Node.js 16, install dependencies, and run tests.", "output": "name: CI Pipeline\non:\n  push:\n    branches: [ main ]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a bash script that checks if a website passed as an argument returns an HTTP 200 status code. If not, print an error and exit with status 1.", "output": "#!/bin/bash\nURL=$1\n\nif [ -z \"$URL\" ]; then\n  echo \"Usage: $0 <url>\"\n  exit 1\nfi\n\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\\n\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" == \"200\" ]; then\n  echo \"Success: $URL is up.\"\nelse\n  echo \"Error: $URL returned $HTTP_STATUS\"\n  exit 1\nfi"}
{"instruction": "Provide a one-line Docker command to backup a named volume 'postgres_data' to a file named 'backup.tar.gz' in the current host directory using a temporary alpine container.", "output": "docker run --rm -v postgres_data:/volume -v $(pwd):/backup alpine tar -czvf /backup/backup.tar.gz -C /volume ."}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose an app labeled 'app: frontend' on node port 30007, mapping to container port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a job for .gitlab-ci.yml using the Docker-in-Docker service to build an image and push it to the GitLab registry.", "output": "build_image:\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest"}
{"instruction": "Create a multi-stage Dockerfile for a Node.js application to optimize image size. The build stage should install dependencies and build the app, while the production stage should use a lightweight Alpine image and only copy necessary artifacts.", "output": "FROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/package*.json ./\nRUN npm ci --production\nEXPOSE 3000\nCMD [\"node\", \"dist/main.js\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server with 3 replicas. Include a liveness probe that checks the root path on port 80 and resource limits restricting memory to 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a Bash script that checks if a specific service (e.g., 'postgresql') is active. If it is not active, attempt to restart it and log the event to a file named 'service_monitor.log'.", "output": "#!/bin/bash\nSERVICE=\"postgresql\"\nLOG_FILE=\"service_monitor.log\"\n\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n  echo \"$(date): $SERVICE is down. Attempting restart...\" >> \"$LOG_FILE\"\n  sudo systemctl restart \"$SERVICE\"\n  if systemctl is-active --quiet \"$SERVICE\"; then\n    echo \"$(date): $SERVICE successfully restarted.\" >> \"$LOG_FILE\"\n  else\n    echo \"$(date): Failed to restart $SERVICE.\" >> \"$LOG_FILE\"\n  fi\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service dependent on a Redis service. The web service should build from the current directory and map port 5000 to 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, runs unit tests using npm, and builds a Docker image.", "output": "name: CI Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16'\n    - name: Install dependencies\n      run: npm ci\n    - name: Run Tests\n      run: npm test\n    - name: Build Docker Image\n      run: docker build -t my-app:${{ github.sha }} ."}
{"instruction": "Provide the Kubernetes command to create a Secret named 'db-creds' containing a username and password from literal values, and then the YAML snippet to inject them as environment variables in a Pod.", "output": "# Command\nkubectl create secret generic db-creds --from-literal=username=admin --from-literal=password=secret123\n\n# YAML Snippet for Pod\nenv:\n  - name: DB_USER\n    valueFrom:\n      secretKeyRef:\n        name: db-creds\n        key: username\n  - name: DB_PASS\n    valueFrom:\n      secretKeyRef:\n        name: db-creds\n        key: password"}
{"instruction": "Write a Bash script to archive logs older than 7 days from the '/var/log/myapp' directory into a 'backups' folder and delete the original files.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/myapp\"\nBACKUP_DIR=\"/var/log/myapp/backups\"\nmkdir -p \"$BACKUP_DIR\"\n\n# Find logs older than 7 days, compress them to backup dir, and remove originals\nfind \"$SOURCE_DIR\" -maxdepth 1 -name \"*.log\" -type f -mtime +7 -exec bash -c 'gzip -c \"$1\" > \"$2/$(basename \"$1\").gz\" && rm \"$1\"' _ {} \"$BACKUP_DIR\" \\;"}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Docker command to run a container named 'db_container' from the 'postgres:13' image, setting the POSTGRES_PASSWORD environment variable, mounting a local volume 'pgdata' to '/var/lib/postgresql/data', and running in detached mode.", "output": "docker run -d \\\n  --name db_container \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -v pgdata:/var/lib/postgresql/data \\\n  -p 5432:5432 \\\n  postgres:13"}
{"instruction": "Write a Bash script using a 'while' loop to wait for a database on localhost port 5432 to become available before starting the application.", "output": "#!/bin/bash\necho \"Waiting for database to be ready...\"\n\n# Loop until nc (netcat) successfully connects to localhost port 5432\nwhile ! nc -z localhost 5432; do\n  sleep 1\ndone\n\necho \"Database is ready! Starting application...\"\n./start_app.sh"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary, and the final stage should use a scratch image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server with 3 replicas. Include a liveness probe that checks the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that loops through all `.log` files in the `/var/logs` directory, compresses them using gzip, and appends the current date to the filename.", "output": "#!/bin/bash\nDATE=$(date +%Y%m%d)\nLOG_DIR=\"/var/logs\"\n\nfor file in \"$LOG_DIR\"/*.log; do\n  if [ -f \"$file\" ]; then\n    gzip -c \"$file\" > \"${file}_${DATE}.gz\"\n    echo \"Compressed $file\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to set up a PostgreSQL database with a persistent volume and a specific user/password configuration.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: myuser\n      POSTGRES_PASSWORD: mypassword\n      POSTGRES_DB: mydatabase\n    volumes:\n      - db_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on push to the 'main' branch, checks out the code, sets up Node.js, installs dependencies, and runs tests.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Create a Kubernetes Service of type NodePort to expose a deployment named 'webapp' on port 30007 targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: NodePort\n  selector:\n    app: webapp\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a Bash one-liner to parse an Apache access log file named `access.log` and count the number of unique IP addresses.", "output": "awk '{print $1}' access.log | sort | uniq | wc -l"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' containing a 'config.json' key, and a Pod YAML that mounts this ConfigMap as a volume at '/etc/config'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  config.json: |\n    { \"env\": \"production\", \"debug\": false }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n  - name: app\n    image: my-app:latest\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config"}
{"instruction": "Write a Bash script that checks if a specific Docker container named 'web_server' is running. If not, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"web_server\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Container does not exist or is not running.\"\n    fi\nelse\n    echo \"Container $CONTAINER_NAME is already running.\"\nfi"}
{"instruction": "Define a Kubernetes HorizontalPodAutoscaler (HPA) to scale a deployment named 'api-gateway' between 2 and 10 replicas based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-gateway-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-gateway\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Write a multi-stage Dockerfile for a Go application. The first stage should build the binary using the 'golang:1.21' image, and the second stage should copy only the binary into a lightweight 'alpine:latest' image to minimize the final image size.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx application with 3 replicas. It must include resource limits (200m CPU, 256Mi Memory) and a liveness probe checking port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that finds all '.log' files in the directory '/var/log/app' that are older than 7 days, compresses them into a single tarball named with the current date, and then deletes the original log files.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nARCHIVE_NAME=\"logs_archive_$(date +%Y%m%d).tar.gz\"\n\n# Find files older than 7 days\nFILES=$(find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7)\n\nif [ -n \"$FILES\" ]; then\n  tar -czf \"$LOG_DIR/$ARCHIVE_NAME\" $FILES\n  # Remove original files after successful archive\n  if [ $? -eq 0 ]; then\n    rm $FILES\n    echo \"Logs archived and cleaned up.\"\n  else\n    echo \"Archiving failed.\"\n  fi\nelse\n  echo \"No logs older than 7 days found.\"\nfi"}
{"instruction": "Define a GitHub Actions workflow file (.github/workflows/docker-publish.yml) that triggers on a push to the 'main' branch, logs into Docker Hub using secrets, builds a Docker image, and pushes it with the tag 'latest'.", "output": "name: Build and Push Docker Image\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myrepo:latest"}
{"instruction": "Create a 'docker-compose.yml' file that defines two services: 'web' (built from the current directory) and 'db' (using the postgres:13 image). The web service should depend on the db service and expose port 5000 to the host.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n      - DB_USER=postgres\n      - DB_PASSWORD=example\n  db:\n    image: postgres:13\n    environment:\n      - POSTGRES_PASSWORD=example\n    volumes:\n      - db_data:/var/lib/postgresql/data\n\nvolumes:\n  db_data:"}
{"instruction": "Write a Kubernetes Service manifest to expose a deployment named 'backend-api'. The service should be of type 'LoadBalancer', accept traffic on port 80, and target port 8080 on the pods.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a Bash script to check if a specific HTTP endpoint (http://localhost:8080/health) returns a 200 status code. If it fails, restart the systemd service named 'app-service'.", "output": "#!/bin/bash\nURL=\"http://localhost:8080/health\"\nSERVICE=\"app-service\"\n\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\\n\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -ne 200 ]; then\n  echo \"Health check failed (Status: $HTTP_STATUS). Restarting $SERVICE...\"\n  systemctl restart \"$SERVICE\"\nelse\n  echo \"Service is healthy.\"\nfi"}
{"instruction": "Generate a Kubernetes Pod manifest that mounts a ConfigMap named 'app-settings' as a volume. The ConfigMap data should appear as files in the directory '/etc/config' inside the container.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-settings"}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network named 'isolated_nw' and run a container named 'secure_app' attached to that network with the static IP 172.20.0.5.", "output": "docker network create --subnet=172.20.0.0/16 isolated_nw\ndocker run -d --net isolated_nw --ip 172.20.0.5 --name secure_app nginx:alpine"}
{"instruction": "Write a shell script that monitors disk usage on the root partition ('/'). If usage exceeds 85%, print an alert message to Standard Error.", "output": "#!/bin/bash\nTHRESHOLD=85\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"ALERT: Disk usage is at ${USAGE}% which exceeds the threshold of ${THRESHOLD}%\" >&2\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size using the 'scratch' base image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nEXPOSE 8080\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx container that includes a liveness probe checking the root path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a bash script that finds and deletes all log files ending in '.log' in the '/var/log/myapp' directory that are older than 7 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\nif [ -d \"$LOG_DIR\" ]; then\n    find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;\n    echo \"Cleanup completed for files older than 7 days in $LOG_DIR\"\nelse\n    echo \"Directory $LOG_DIR does not exist.\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Node.js application service and a PostgreSQL database service, ensuring the app depends on the db and they share a custom network.", "output": "version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n    networks:\n      - app-network\n\n  db:\n    image: postgres:13-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydb\n    volumes:\n      - db-data:/var/lib/postgresql/data\n    networks:\n      - app-network\n\nnetworks:\n  app-network:\n    driver: bridge\n\nvolumes:\n  db-data:"}
{"instruction": "Write a bash script to check if the disk usage of the root partition ('/') exceeds 90% and print a warning message if it does.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"WARNING: Disk usage on root is critical: ${USAGE}%\"\nelse\n    echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a Kubernetes Pod definition that mounts a ConfigMap named 'app-config' to the path '/etc/config' inside the container.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app-container\n      image: busybox\n      command: [\"sleep\", \"3600\"]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network named 'isolated_net' and run a container named 'secure_app' attached to that network.", "output": "docker network create --driver bridge isolated_net\ndocker run -d --name secure_app --network isolated_net nginx:alpine"}
{"instruction": "Write a GitLab CI (.gitlab-ci.yml) job definition to build a Docker image and push it to the GitLab Container Registry.", "output": "build_image:\n  stage: build\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"}
{"instruction": "Write a bash script that performs a MySQL database backup, compresses the output with gzip, and appends the current timestamp to the filename.", "output": "#!/bin/bash\nDB_USER=\"root\"\nDB_PASS=\"password\"\nDB_NAME=\"production_db\"\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y-%m-%d_%H%M%S)\n\nmysqldump -u \"$DB_USER\" -p\"$DB_PASS\" \"$DB_NAME\" | gzip > \"$BACKUP_DIR/db_backup_$DATE.sql.gz\""}
{"instruction": "Update a Kubernetes Deployment spec to use a RollingUpdate strategy, ensuring only 1 pod is unavailable at a time and only 1 extra pod is created during the update.", "output": "spec:\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to ensure a small final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx container with 3 replicas, resource limits (CPU: 500m, Memory: 128Mi), and a liveness probe.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 5"}
{"instruction": "Write a Bash script to archive logs in '/var/log/app' that are older than 7 days by compressing them into .gz files and removing the originals.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;"}
{"instruction": "Generate a docker-compose.yml file that sets up a Python web service depending on a Redis service, sharing a network called 'backend-net'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    networks:\n      - backend-net\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\"\n    networks:\n      - backend-net\nnetworks:\n  backend-net:"}
{"instruction": "Create a GitHub Actions workflow step to log in to Docker Hub and push an image named 'my-org/my-app:latest' when a push occurs on the main branch.", "output": "name: Docker Build and Push\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: my-org/my-app:latest"}
{"instruction": "Write a Bash one-liner to extract the IP address of the 'eth0' interface using 'ip addr', 'grep', 'awk', and 'sed'.", "output": "ip addr show eth0 | grep \"inet \" | awk '{print $2}' | sed 's/\\/.*//'"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose a deployment labeled 'app: backend' on node port 30050 targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30050"}
{"instruction": "Provide the Docker CLI command to run a temporary Alpine container that mounts a named volume 'pg-data' and creates a tar backup of it in the current host directory.", "output": "docker run --rm -v pg-data:/volume -v $(pwd):/backup alpine tar cvf /backup/backup.tar /volume"}
{"instruction": "Write the Helm command to install a chart located at './charts/my-app' with the release name 'prod-release' and override the 'replicaCount' value to 5.", "output": "helm install prod-release ./charts/my-app --set replicaCount=5"}
{"instruction": "Write a Bash script that checks if a specific URL (http://localhost:8080) is available using curl, retrying every 5 seconds until it returns a 200 status code.", "output": "#!/bin/bash\nuntil curl -s -o /dev/null -w \"%{http_code}\" http://localhost:8080 | grep -q \"200\"; do\n  echo \"Waiting for service...\"\n  sleep 5\ndone\necho \"Service is up!\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile 'main.go', and the final stage should use a scratch image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server with 3 replicas, resource limits (256Mi memory, 500m CPU), and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash script command to parse an Apache access log file named 'access.log', count the occurrences of requests per IP address (first column), and display the top 10 IPs sorted by frequency.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (build from current context) and a PostgreSQL database. The database data must persist in a named volume called 'db_data'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:"}
{"instruction": "Write a shell script that iterates through all Docker containers with the status 'exited' and removes them to clean up system resources.", "output": "#!/bin/bash\ncontainers=$(docker ps -q -f status=exited)\nif [ -n \"$containers\" ]; then\n  docker rm $containers\n  echo \"Removed exited containers.\"\nelse\n  echo \"No exited containers found.\"\nfi"}
{"instruction": "Define a Kubernetes Service YAML of type LoadBalancer to expose a deployment labeled 'app: backend' on external port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a GitLab CI configuration (.gitlab-ci.yml) with two stages: 'test' and 'deploy'. The test job runs on every push, but the deploy job runs only when a tag is pushed.", "output": "stages:\n  - test\n  - deploy\n\nunit_test:\n  stage: test\n  script:\n    - npm install\n    - npm test\n\nproduction_deploy:\n  stage: deploy\n  script:\n    - ./deploy_script.sh\n  only:\n    - tags"}
{"instruction": "Write a bash script that creates a backup of the folder '/var/www/html' into a tar.gz file with a timestamp, and then deletes any backup files in the backup directory older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y-%m-%d-%H%M%S)\n\n# Create backup\ntar -czf \"$BACKUP_DIR/backup-$DATE.tar.gz\" \"$SOURCE_DIR\"\n\n# Delete backups older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"*.tar.gz\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a Docker command to run a temporary Alpine container that mounts the host directory '/tmp/data' to '/data' inside the container and prints the contents of that directory.", "output": "docker run --rm -v /tmp/data:/data alpine ls -la /data"}
{"instruction": "Write a bash one-liner to check if a specific website (e.g., google.com) is reachable via curl, returning 'Up' if the HTTP status code is 200, and 'Down' otherwise.", "output": "if [ $(curl -s -o /dev/null -w \"%{http_code}\" https://google.com) -eq 200 ]; then echo \"Up\"; else echo \"Down\"; fi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, liveness probes, and resource limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash one-liner to parse a standard Apache/Nginx access log and display the top 10 requesting IP addresses by frequency.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Generate a docker-compose.yml file to deploy a Python Flask app alongside a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Create a GitHub Actions workflow file that runs npm tests on every push to the 'main' branch using an Ubuntu runner.", "output": "name: CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a shell script to iterate through all .jpg files in the current directory, rename them with a prefix 'img_', and append a counter.", "output": "#!/bin/bash\ncount=1\nfor file in *.jpg; do\n  if [ -f \"$file\" ]; then\n    mv \"$file\" \"img_$count.jpg\"\n    ((count++))\n  fi\ndone"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment labeled 'app: my-app' on node port 30005.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  type: NodePort\n  selector:\n    app: my-app\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30005"}
{"instruction": "Write a command to run a Docker container named 'db-server' from the 'postgres' image, setting the password environment variable and mapping port 5432.", "output": "docker run -d --name db-server -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres"}
{"instruction": "Write a bash script to check if a specific systemd service (e.g., nginx) is active, and start it if it is stopped.", "output": "#!/bin/bash\nSERVICE=\"nginx\"\nif ! systemctl is-active --quiet $SERVICE; then\n  echo \"$SERVICE is not running. Starting...\"\n  sudo systemctl start $SERVICE\nelse\n  echo \"$SERVICE is running.\"\nfi"}
{"instruction": "Define a Kubernetes PersistentVolumeClaim (PVC) requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should compile the binary named 'app', and the final stage should use a minimal Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a rolling update strategy, and resource limits set to 128Mi memory and 500m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through all files in the directory '/var/log/myapp', compresses any file older than 7 days using gzip, and removes the original file.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\nfind \"$LOG_DIR\" -type f -mtime +7 -name \"*.log\" -exec gzip {} \\;"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (building from the current directory) and a PostgreSQL database. Ensure the web service depends on the database and they share a network called 'backend'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - db\n    networks:\n      - backend\n    environment:\n      - DB_HOST=db\n\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: myappdb\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - backend\n\nnetworks:\n  backend:\n\nvolumes:\n  postgres_data:"}
{"instruction": "Write a GitHub Actions workflow file that triggers on a push to the 'main' branch, builds a Docker image, and pushes it to Docker Hub. Assume secrets DOCKER_USERNAME and DOCKER_PASSWORD are set.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Create a Kubernetes Service manifest of type LoadBalancer that exposes an application labeled 'app: frontend' on port 80, targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a Bash script to perform a health check on a local endpoint. It should curl 'http://localhost:8080/health' every 5 seconds. If the HTTP status code is 200, print 'Healthy' and exit. If it fails 5 times, print 'Unhealthy' and exit with error code 1.", "output": "#!/bin/bash\nURL=\"http://localhost:8080/health\"\nMAX_RETRIES=5\nCOUNT=0\n\nwhile [ $COUNT -lt $MAX_RETRIES ]; do\n  STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" $URL)\n  if [ \"$STATUS\" -eq 200 ]; then\n    echo \"Healthy\"\n    exit 0\n  fi\n  echo \"Check failed ($STATUS), retrying...\"\n  sleep 5\n  ((COUNT++))\ndone\n\necho \"Unhealthy\"\nexit 1"}
{"instruction": "Define a GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'test' and 'deploy'. The test stage runs 'npm test', and the deploy stage runs a custom deployment script, only for the master branch.", "output": "image: node:16\n\nstages:\n  - test\n  - deploy\n\nrun_tests:\n  stage: test\n  script:\n    - npm install\n    - npm test\n\ndeploy_production:\n  stage: deploy\n  script:\n    - ./deploy_script.sh\n  only:\n    - master"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' with a key 'DATABASE_URL', and a Pod manifest that injects this ConfigMap value as an environment variable named 'DB_CONN_STRING'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-pod\nspec:\n  containers:\n  - name: app-container\n    image: my-app:1.0\n    env:\n      - name: DB_CONN_STRING\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: DATABASE_URL"}
{"instruction": "Write a Linux command chain to recursively find all directories in the current path and set their permissions to 755, and find all files and set their permissions to 644.", "output": "find . -type d -exec chmod 755 {} + && find . -type f -exec chmod 644 {} +"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML configuration for an Nginx server. It should have 3 replicas, match labels 'app: nginx', and enforce a memory limit of 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a bash one-liner to parse an Apache access log file named 'access.log', extract the IP addresses (assumed to be the first column), count unique occurrences, and sort them in descending order.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Create a docker-compose.yml file to deploy a PostgreSQL database. It must use the 'postgres:13' image, persist data to a named volume 'pgdata', and set the POSTGRES_PASSWORD environment variable.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: mysecretpassword\n      POSTGRES_USER: myuser\n      POSTGRES_DB: mydb\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n  pgdata:"}
{"instruction": "Write a bash script that iterates through all Docker containers with the status 'exited' and removes them to clean up system resources.", "output": "#!/bin/bash\n# Get IDs of exited containers\nEXITED_CONTAINERS=$(docker ps -q -f status=exited)\n\nif [ -z \"$EXITED_CONTAINERS\" ]; then\n  echo \"No exited containers found.\"\nelse\n  docker rm $EXITED_CONTAINERS\n  echo \"Removed exited containers.\"\nfi"}
{"instruction": "Define a GitHub Actions workflow YAML file that triggers on a push to the 'main' branch, checks out the code, and builds a Docker image named 'my-app'.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build the Docker image\n      run: docker build . --file Dockerfile --tag my-app:$(date +%s)"}
{"instruction": "Create a Kubernetes Service YAML of type 'NodePort' to expose a deployment with label 'app: web' on target port 80 and node port 30007.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  type: NodePort\n  selector:\n    app: web\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a shell script to verify if a specific URL (passed as an argument) returns a HTTP 200 status code using curl. If not, exit with an error.", "output": "#!/bin/bash\nURL=$1\n\nif [ -z \"$URL\" ]; then\n  echo \"Usage: $0 <url>\"\n  exit 1\nfi\n\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"Success: $URL is reachable.\"\nelse\n  echo \"Error: $URL returned status $HTTP_STATUS\"\n  exit 1\nfi"}
{"instruction": "Provide the Docker CLI command to create a custom bridge network named 'isolated_net' with a subnet of '172.20.0.0/16', and then run an Alpine container attached to that network.", "output": "docker network create --driver bridge --subnet 172.20.0.0/16 isolated_net && docker run -dit --name alpine-net-test --network isolated_net alpine:latest sh"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-config' containing a key 'database_url', and a Pod YAML that mounts this ConfigMap as a file at '/etc/config/database_url'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"jdbc:mysql://db-host:3306/mydb\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-test-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should use 'golang:1.19' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.19 AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a resource limit of 256Mi memory, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that checks if a specific Docker container named 'web-server' is running. If it is not running, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"web-server\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Container does not exist.\"\n    fi\nelse\n    echo \"Container is already running.\"\nfi"}
{"instruction": "Create a docker-compose.yml file to deploy a Python Flask app (listening on port 5000) and a Redis service. The Flask app depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash script to find all files in '/var/www/html' modified in the last 7 days and create a tar archive of them.", "output": "#!/bin/bash\nfind /var/www/html -mtime -7 -type f -print0 | tar -czvf recent_changes.tar.gz --null -T -"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose a deployment named 'backend-app' on port 30007 targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend-app\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a GitHub Actions workflow YAML that builds a Docker image and pushes it to Docker Hub whenever a commit is pushed to the 'main' branch.", "output": "name: Docker Build and Push\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      - name: Login to Docker Hub\n        uses: docker/login-action@v1\n        with:\n          username: ${{ secrets.DOCKER_HUB_USERNAME }}\n          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v2\n        with:\n          context: .\n          push: true\n          tags: myuser/myrepo:latest"}
{"instruction": "Write a Bash script that parses an Nginx access log file and prints the top 5 IP addresses with the most requests.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -rn | head -n 5"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 10Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-data-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Write a Docker command to run a container named 'db-prod' from image 'postgres:13', setting the environment variable POSTGRES_PASSWORD to 'securepass' and mounting a local volume.", "output": "docker run -d \\\n  --name db-prod \\\n  -e POSTGRES_PASSWORD=securepass \\\n  -v postgres-data:/var/lib/postgresql/data \\\n  postgres:13"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should compile the binary 'app', and the final stage should use 'alpine' to run the binary.", "output": "FROM golang:1.19-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/app .\nCMD [\"./app\"]"}
{"instruction": "Write a bash script that checks if a specific website (passed as an argument) returns an HTTP 200 status code. If it fails, retry 3 times with a 5-second delay between attempts.", "output": "#!/bin/bash\nURL=$1\nMAX_RETRIES=3\nCOUNT=0\n\nwhile [ $COUNT -lt $MAX_RETRIES ]; do\n  STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" $URL)\n  if [ \"$STATUS\" -eq 200 ]; then\n    echo \"Success: $URL is up.\"\n    exit 0\n  fi\n  echo \"Attempt $((COUNT+1)) failed. Retrying...\"\n  sleep 5\n  ((COUNT++))\ndone\n\necho \"Failed to reach $URL after $MAX_RETRIES attempts.\"\nexit 1"}
{"instruction": "Define a Kubernetes Deployment manifest for an Nginx server running 3 replicas. It must include a liveness probe checking the root path on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Create a docker-compose.yml file that spins up a 'web' service (building from the current directory) and a 'db' service (using postgres:13), connected via a custom bridge network named 'backend-net'.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"8000:8000\"\n    networks:\n      - backend-net\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: example\n    networks:\n      - backend-net\n\nnetworks:\n  backend-net:\n    driver: bridge"}
{"instruction": "Write a one-liner Linux command using 'find' to locate all log files ending in '.log' in the '/var/logs' directory that are older than 7 days and delete them.", "output": "find /var/logs -type f -name \"*.log\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a GitHub Actions workflow YAML file that triggers on a push to the 'main' branch, checks out the code, and builds a Docker image tagged 'latest'.", "output": "name: Docker Build\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      \n      - name: Build Docker image\n        run: docker build -t my-app:latest ."}
{"instruction": "Write a Kubernetes Service manifest of type 'LoadBalancer' to expose a deployment labeled 'app: frontend' on external port 80, targeting container port 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000"}
{"instruction": "Write a bash script that parses a log file named 'access.log' and counts the number of occurrences of each unique IP address (assumed to be the first column), sorting them in descending order.", "output": "#!/bin/bash\nawk '{print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Create a Docker command to run a container named 'dev-db' using the 'mysql:8.0' image. It must set the root password to 'secret', mount a local directory './data' to '/var/lib/mysql', and run in the background.", "output": "docker run -d --name dev-db -e MYSQL_ROOT_PASSWORD=secret -v $(pwd)/data:/var/lib/mysql mysql:8.0"}
{"instruction": "Define a Kubernetes ConfigMap manifest named 'app-config' containing two keys: 'DATABASE_URL' and 'DEBUG_MODE' set to 'false'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_URL: \"postgres://user:pass@db:5432/myapp\"\n  DEBUG_MODE: \"false\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The first stage should build the binary, and the second stage should be an Alpine image that runs the binary.", "output": "FROM golang:1.19 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a RollingUpdate strategy where maxUnavailable is 1 and maxSurge is 1.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through a text file named 'servers.txt' (containing one IP per line) and checks if port 80 is open using netcat (nc).", "output": "#!/bin/bash\nwhile read -r server; do\n  nc -z -w 2 \"$server\" 80\n  if [ $? -eq 0 ]; then\n    echo \"$server: Port 80 is OPEN\"\n  else\n    echo \"$server: Port 80 is CLOSED\"\n  fi\ndone < servers.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (Flask) and a 'db' service (PostgreSQL). Ensure the web service depends on the db service and persists database data to a volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: example\nvolumes:\n  postgres_data:"}
{"instruction": "Write a declarative Jenkinsfile pipeline that builds a Docker image, tests it, and pushes it to a registry only if the branch is 'main'.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'docker build -t myapp:${BUILD_NUMBER} .'\n            }\n        }\n        stage('Test') {\n            steps {\n                sh 'docker run --rm myapp:${BUILD_NUMBER} npm test'\n            }\n        }\n        stage('Push') {\n            when {\n                branch 'main'\n            }\n            steps {\n                withCredentials([usernamePassword(credentialsId: 'docker-hub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {\n                    sh 'docker login -u $USER -p $PASS'\n                    sh 'docker push myapp:${BUILD_NUMBER}'\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Kubernetes Ingress resource that routes traffic based on paths: '/api' to 'backend-service' and '/' to 'frontend-service'.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80"}
{"instruction": "Write a Bash script to monitor disk usage. If the usage of the root partition ('/') exceeds 85%, send an alert message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${USAGE}%\" >&2\nfi"}
{"instruction": "Define a GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'test' and 'deploy'. The deploy stage should only run manually on production tags.", "output": "stages:\n  - test\n  - deploy\n\nrun_tests:\n  stage: test\n  image: node:14\n  script:\n    - npm install\n    - npm test\n\ndeploy_prod:\n  stage: deploy\n  script:\n    - ./deploy_to_k8s.sh\n  only:\n    - tags\n  when: manual"}
{"instruction": "Add a HEALTHCHECK instruction to a Dockerfile for a web server running on port 3000. It should try every 30 seconds and fail after 3 retries.", "output": "FROM node:16-alpine\nWORKDIR /app\nCOPY . .\nCMD [\"node\", \"server.js\"]\nHEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1"}
{"instruction": "Create a Kubernetes ConfigMap named 'app-config' containing a key 'debug_mode' set to 'true', and show how to inject it into a Pod as an environment variable.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  debug_mode: \"true\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: debug-pod\nspec:\n  containers:\n    - name: my-container\n      image: my-image\n      env:\n        - name: DEBUG_MODE\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: debug_mode"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size. The build stage should compile the binary, and the final stage should use a minimal alpine image to run the binary.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes YAML manifest for a Deployment running 3 replicas of an Nginx container. Include a RollingUpdate strategy with maxSurge and maxUnavailable set to 1.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script that checks if the disk usage of the root filesystem ('/') exceeds 90%. If it does, print a critical warning message.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL: Disk usage is at ${USAGE}%\"\nelse\n  echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file to deploy a WordPress environment linked with a MySQL 5.7 database. Configure necessary environment variables for database connection.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a GitHub Actions workflow YAML file that triggers on push to the 'main' branch. The job should checkout code, log in to Docker Hub using secrets, and build/push an image tagged 'latest'.", "output": "name: CI Pipeline\non:\n  push:\n    branches:\n      - main\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      \n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      \n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myapp:latest"}
{"instruction": "Create a Kubernetes Pod manifest that mounts a ConfigMap named 'app-config' as a volume at path '/etc/config'.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: configmap-pod\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Write a bash script to archive log files ending in .log in the '/var/log/myapp' directory that are older than 7 days. Compress them into a tar.gz file and remove the originals.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nARCHIVE_DIR=\"$LOG_DIR/archive\"\nmkdir -p \"$ARCHIVE_DIR\"\n\n# Find logs older than 7 days\nfind \"$LOG_DIR\" -maxdepth 1 -name \"*.log\" -mtime +7 -print0 | while IFS= read -r -d '' file; do\n  filename=$(basename \"$file\")\n  tar -czf \"$ARCHIVE_DIR/${filename}_$(date +%F).tar.gz\" \"$file\" && rm \"$file\"\n  echo \"Archived and removed $file\"\ndone"}
{"instruction": "Create a Dockerfile for a Python Flask application. It should copy 'requirements.txt', install dependencies avoiding cache, copy the source code, and set the entry command.", "output": "FROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nENV FLASK_APP=app.py\nENV FLASK_RUN_HOST=0.0.0.0\n\nCMD [\"flask\", \"run\"]"}
{"instruction": "Write a Kubernetes HorizontalPodAutoscaler (HPA) manifest to scale a deployment named 'backend-api' between 2 and 10 replicas based on 50% average CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 50"}
{"instruction": "Write a bash script that waits for a database service on localhost port 5432 to become available using netcat (nc), retrying every 2 seconds for a maximum of 30 seconds.", "output": "#!/bin/bash\nHOST=\"localhost\"\nPORT=\"5432\"\nRETRIES=15\n\necho \"Waiting for Postgres at $HOST:$PORT...\"\n\nfor ((i=1; i<=RETRIES; i++)); do\n  if nc -z \"$HOST\" \"$PORT\"; then\n    echo \"Database is up!\"\n    exit 0\n  fi\n  echo \"Waiting... ($i/$RETRIES)\"\n  sleep 2\ndone\n\necho \"Database failed to start within timeout.\"\nexit 1"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx container with a readiness probe and memory limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.25\n        ports:\n        - containerPort: 80\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        resources:\n          requests:\n            memory: \"64Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a bash script to check if the root filesystem usage exceeds 80% and print a warning.", "output": "#!/bin/bash\nTHRESHOLD=80\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is critical: ${USAGE}%\"\nelse\n  echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a GitHub Actions workflow step to log in to Docker Hub, build an image, and push it.", "output": "name: Docker Build and Push\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: user/app:latest"}
{"instruction": "Write a docker-compose.yml file to deploy a Node.js application linked with a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REDIS_URL=redis://cache:6379\n    depends_on:\n      - cache\n  cache:\n    image: redis:alpine\n    volumes:\n      - redis_data:/data\nvolumes:\n  redis_data:"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose a deployment labeled 'app: frontend' on port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a one-liner bash command to extract the top 5 requesting IP addresses from an Nginx access log.", "output": "awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Kubernetes CronJob manifest that runs a curl command every 15 minutes.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: health-pinger\nspec:\n  schedule: \"*/15 * * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: curl\n            image: curlimages/curl\n            args:\n            - /bin/sh\n            - -c\n            - curl -s http://example-service/health\n          restartPolicy: OnFailure"}
{"instruction": "Write a bash script that waits for a specific service (e.g., localhost:8080) to become available before proceeding.", "output": "#!/bin/bash\nHOST=\"localhost\"\nPORT=\"8080\"\n\necho \"Waiting for $HOST:$PORT...\"\nuntil curl --output /dev/null --silent --head --fail http://$HOST:$PORT; do\n    printf '.'\n    sleep 2\ndone\necho \"\\nService is up!\""}
{"instruction": "Write a Docker entrypoint script that runs database migrations before starting the main Python application.", "output": "#!/bin/sh\n\n# Stop on error\nset -e\n\necho \"Applying database migrations...\"\npython manage.py migrate\n\necho \"Starting application...\"\nexec \"$@\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to compile the binary in a builder stage and run it in a lightweight Alpine container.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server that includes a liveness probe checking the /healthz endpoint on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that checks if the disk usage of the root filesystem exceeds 90% and prints a warning message.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"CRITICAL: Disk usage is at ${USAGE}%\"\nelse\n    echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file to set up a LAMP stack (Apache/PHP and MySQL) with persistent storage for the database.", "output": "version: '3.8'\nservices:\n  web:\n    image: php:8.0-apache\n    ports:\n      - \"8080:80\"\n    volumes:\n      - ./src:/var/www/html\n  db:\n    image: mysql:5.7\n    environment:\n      MYSQL_ROOT_PASSWORD: rootpassword\n      MYSQL_DATABASE: mydatabase\n    volumes:\n      - db_data:/var/lib/mysql\nvolumes:\n  db_data:"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment named 'backend-app' externally using a LoadBalancer on port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000"}
{"instruction": "Write a Bash script to find all log files in /var/log/myapp older than 7 days and compress them using gzip.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\n# Find files ending in .log modified more than 7 days ago and gzip them\nfind \"$LOG_DIR\" -name \"*.log\" -mtime +7 -exec gzip {} \\;"}
{"instruction": "Create a GitHub Actions workflow file (.yaml) that builds a Docker image and pushes it to Docker Hub on every push to the main branch.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a Kubernetes Pod definition that mounts a ConfigMap named 'app-config' to the path /etc/config inside the container.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: demo-container\n      image: busybox\n      command: [ \"sleep\", \"3600\" ]\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-config"}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network and run a Redis container attached to that network.", "output": "# Create the network\ndocker network create --driver bridge my-custom-net\n\n# Run Redis attached to the network\ndocker run -d --name my-redis --network my-custom-net redis:alpine"}
{"instruction": "Write a Bash script often used in entrypoints to wait for a database (PostgreSQL on port 5432) to be ready before starting the application.", "output": "#!/bin/bash\nHOST=\"db\"\nPORT=\"5432\"\n\necho \"Waiting for PostgreSQL at $HOST:$PORT...\"\n\nwhile ! nc -z $HOST $PORT; do\n  sleep 1\ndone\n\necho \"PostgreSQL is up - executing command\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to ensure the final image is minimal, using 'golang:alpine' for the build stage and 'scratch' for the final stage.", "output": "FROM golang:alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an application named 'web-app' that runs 3 replicas of the 'nginx:latest' image, includes a readiness probe on port 80, and limits memory usage to 256Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that iterates through a list of servers defined in a variable, checks if they are reachable via SSH on port 22 using netcat, and outputs the status.", "output": "#!/bin/bash\nSERVERS=(\"192.168.1.10\" \"192.168.1.11\" \"192.168.1.12\")\n\nfor server in \"${SERVERS[@]}\"; do\n  if nc -z -w 2 \"$server\" 22; then\n    echo \"[OK] SSH is open on $server\"\n  else\n    echo \"[FAIL] SSH is unreachable on $server\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to deploy a NodeJS application service named 'app' that depends on a Redis service named 'cache', mapping port 3000 to the host.", "output": "version: '3.8'\nservices:\n  app:\n    image: node:14-alpine\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - cache\n    environment:\n      - REDIS_HOST=cache\n  cache:\n    image: redis:alpine"}
{"instruction": "Write a Bash one-liner to parse an Nginx access log file named 'access.log' and display the top 5 IP addresses with the highest number of requests.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Kubernetes HorizontalPodAutoscaler (HPA) manifest to automatically scale a deployment named 'api-server' between 2 and 10 replicas based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-server-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-server\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Write a simple GitHub Actions workflow file (.github/workflows/ci.yml) that triggers on a push to the 'main' branch, checks out the code, and runs a script named 'test.sh'.", "output": "name: CI Pipeline\non:\n  push:\n    branches:\n      - main\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Run Tests\n        run: chmod +x test.sh && ./test.sh"}
{"instruction": "Write a Bash script to automate the backup of a running Docker container's MySQL database. The script should execute mysqldump inside the container and save the output to a timestamped file on the host.", "output": "#!/bin/bash\nCONTAINER_NAME=\"mysql-prod\"\nDB_NAME=\"appdb\"\nDB_USER=\"root\"\nDB_PASS=\"password\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nBACKUP_FILE=\"backup_${DB_NAME}_${TIMESTAMP}.sql\"\n\ndocker exec \"$CONTAINER_NAME\" /usr/bin/mysqldump -u \"$DB_USER\" --password=\"$DB_PASS\" \"$DB_NAME\" > \"$BACKUP_FILE\"\n\nif [ $? -eq 0 ]; then\n  echo \"Backup successful: $BACKUP_FILE\"\nelse\n  echo \"Backup failed\"\nfi"}
{"instruction": "Create a Kubernetes Ingress resource to route traffic from 'myapp.example.com' to an internal service named 'frontend-service' on port 80.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: myapp-ingress\nspec:\n  rules:\n  - host: myapp.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80"}
{"instruction": "Write a Bash script that monitors disk usage on the root partition. If usage exceeds 90%, it should print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical: ${USAGE}%\" >&2\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to ensure a small final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a bash script that checks if disk usage on the root partition is greater than 80% and prints a warning if true.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is high ($USAGE%).\"\nfi"}
{"instruction": "Provide a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe, and resource limits.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Docker Compose file to set up a web service (Python) linked with a Redis database service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Create a bash one-liner to find all log files in /var/log modified in the last 7 days and archive them into a tarball.", "output": "find /var/log -name \"*.log\" -mtime -7 -print0 | tar -czvf logs_archive.tar.gz --null -T -"}
{"instruction": "Define a GitHub Actions workflow step to build a Docker image and push it to Docker Hub only on pushes to the main branch.", "output": "name: Docker Image CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build the Docker image\n      run: docker build . --file Dockerfile --tag myuser/myrepo:latest\n    - name: Log in to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    - name: Push the Docker image\n      run: docker push myuser/myrepo:latest"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment named 'my-app' on port 80 via a LoadBalancer.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: my-app-service\nspec:\n  selector:\n    app: my-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Construct a Docker command to run a container in detached mode, mapping host port 8080 to container port 80, and mounting the current directory to /var/www/html.", "output": "docker run -d -p 8080:80 -v $(pwd):/var/www/html --name my-web-server nginx:latest"}
{"instruction": "Write a bash script that loops through a list of servers defined in a text file and checks their connectivity via ping.", "output": "#!/bin/bash\nSERVER_FILE=\"servers.txt\"\nwhile IFS= read -r server\ndo\n    if ping -c 1 \"$server\" &> /dev/null; then\n        echo \"$server is UP\"\n    else\n        echo \"$server is DOWN\"\n    fi\ndone < \"$SERVER_FILE\""}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 10Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should use 'golang:1.21' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include a liveness probe that checks the '/healthz' path on port 80 every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 10"}
{"instruction": "Write a bash script that iterates through all mounted filesystems and sends a warning message to stderr if usage exceeds 80%.", "output": "#!/bin/bash\ndf -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 \" \" $1 }' | while read output;\ndo\n  usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )\n  partition=$(echo $output | awk '{ print $2 }' )\n  if [ $usep -ge 80 ]; then\n    echo \"Running out of space \\\"$partition ($usep%)\\\"\" >&2\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to set up a Python Flask web service (build from current directory) dependent on a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file (.github/workflows/deploy.yml) that builds a Docker image and pushes it to Docker Hub on every push to the 'main' branch.", "output": "name: CI to Docker Hub\non:\n  push:\n    branches: [ main ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Repo \n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_HUB_USERNAME }}\n          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: myuser/myrepo:latest"}
{"instruction": "Create a Kubernetes Service YAML of type NodePort to expose a deployment labeled 'app: backend' on port 8080 targeting container port 80.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 8080\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a bash script to find all log files (*.log) in '/var/log/myapp' older than 7 days and compress them using gzip.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;"}
{"instruction": "Provide the Docker CLI command to create a custom bridge network named 'isolated_net' and run a container named 'db_secure' attached to that network.", "output": "docker network create --driver bridge isolated_net && \\\ndocker run -d --name db_secure --network isolated_net postgres:13"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Write a bash script that checks if a specific website (passed as an argument) is up using curl. If it returns a non-200 status code, exit with an error.", "output": "#!/bin/bash\nURL=$1\nif [ -z \"$URL\" ]; then\n  echo \"Usage: $0 <url>\"\n  exit 1\nfi\n\nHTTP_STATUS=$(curl -o /dev/null -s -w \"%{http_code}\\n\" \"$URL\")\n\nif [ \"$HTTP_STATUS\" -eq 200 ]; then\n  echo \"$URL is up.\"\nelse\n  echo \"$URL is down (Status: $HTTP_STATUS)\"\n  exit 1\nfi"}
{"instruction": "Create a Dockerfile for a Go application using multi-stage builds to compile the binary in a builder stage and run it in a lightweight Alpine container.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML to deploy an Nginx server with 3 replicas, setting memory limits to 128Mi and CPU limits to 500m.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a bash script that checks if the disk usage of the root filesystem ('/') exceeds 90% and prints a warning if it does.", "output": "#!/bin/bash\nTHRESHOLD=90\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"CRITICAL WARNING: Disk usage is at ${USAGE}%\"\nelse\n  echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file to set up a WordPress environment linked to a MySQL 5.7 database with persistent volume storage.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n  wordpress:\n    depends_on:\n      - db\n    image: wordpress:latest\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\nvolumes:\n  db_data:"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment labeled 'app: backend' on port 80 via a LoadBalancer.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash script that iterates through a file named 'users.txt' and creates a system user for each name found if the user does not already exist.", "output": "#!/bin/bash\nUSER_FILE=\"users.txt\"\n\nif [ ! -f \"$USER_FILE\" ]; then\n  echo \"File not found!\"\n  exit 1\nfi\n\nwhile IFS= read -r username; do\n  if id \"$username\" &>/dev/null; then\n    echo \"User $username already exists.\"\n  else\n    useradd -m \"$username\"\n    echo \"User $username created.\"\n  fi\ndone < \"$USER_FILE\""}
{"instruction": "Define a simple GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'build' and 'test', using a Node.js image.", "output": "image: node:16\n\nstages:\n  - build\n  - test\n\nbuild_job:\n  stage: build\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n\ntest_job:\n  stage: test\n  script:\n    - npm test"}
{"instruction": "Write a Kubernetes ConfigMap YAML to store database connection variables (DB_HOST and DB_PORT).", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DB_HOST: \"postgres-db.default.svc.cluster.local\"\n  DB_PORT: \"5432\""}
{"instruction": "Provide the Docker CLI commands to create a named volume 'app_data' and run a container that mounts this volume to '/var/lib/data'.", "output": "docker volume create app_data\ndocker run -d --name my-container -v app_data:/var/lib/data my-image:latest"}
{"instruction": "Write a bash script to find all log files in '/var/log/myapp' older than 7 days, compress them into a tar archive, and move them to a backup directory.", "output": "#!/bin/bash\nSOURCE=\"/var/log/myapp\"\nDEST=\"/mnt/backup\"\nDATE=$(date +%F)\n\nmkdir -p \"$DEST\"\n\n# Find files older than 7 days and append to archive\nfind \"$SOURCE\" -name \"*.log\" -type f -mtime +7 -exec tar -rvf \"$DEST/logs_$DATE.tar\" {} + -exec rm {} \\;"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML configuration for an Nginx server running 3 replicas, including a liveness probe that checks the root path on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a Bash script that iterates through a list of servers defined in an array and checks if they are reachable via ping.", "output": "#!/bin/bash\nSERVERS=(\"192.168.1.10\" \"192.168.1.11\" \"google.com\")\n\nfor server in \"${SERVERS[@]}\"; do\n  if ping -c 1 \"$server\" &> /dev/null; then\n    echo \"$server is UP\"\n  else\n    echo \"$server is DOWN\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (building from the current directory) and a Redis database service, ensuring the web service depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Kubernetes HorizontalPodAutoscaler (HPA) YAML to automatically scale a deployment named 'backend-api' between 2 and 10 replicas based on 70% CPU utilization.", "output": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: backend-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: backend-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"}
{"instruction": "Create a GitLab CI/CD configuration (.gitlab-ci.yml) with two stages: 'build' and 'test', using a node:latest image.", "output": "stages:\n  - build\n  - test\n\nbuild_app:\n  stage: build\n  image: node:latest\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n\ntest_app:\n  stage: test\n  image: node:latest\n  script:\n    - npm install\n    - npm test"}
{"instruction": "Write a Bash script to find all log files in '/var/log/app' modified more than 7 days ago and compress them.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nfind \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;"}
{"instruction": "Provide the Docker CLI command to run a MySQL container in the background, setting the root password via an environment variable and mapping port 3306 to the host.", "output": "docker run -d --name mysql-db -e MYSQL_ROOT_PASSWORD=secret -p 3306:3306 mysql:latest"}
{"instruction": "Write a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'api-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080"}
{"instruction": "Create a simple Jenkinsfile (Declarative Pipeline) that checks out code, runs a shell build script, and archives the 'target' directory.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh './build.sh'\n            }\n        }\n    }\n    post {\n        success {\n            archiveArtifacts artifacts: 'target/**/*', fingerprint: true\n        }\n    }\n}"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas and a RollingUpdate strategy.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script that checks if the disk usage of the root filesystem exceeds 80% and prints a warning.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=80\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is at ${USAGE}%\"\nfi"}
{"instruction": "Create a docker-compose.yml file to set up a Python Flask web service and a Redis service.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a GitHub Actions workflow file to build and push a Docker image to Docker Hub on push to the 'main' branch.", "output": "name: CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Create a Kubernetes Service YAML to expose a deployment named 'backend' on port 8080 using a LoadBalancer.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash one-liner to find all files larger than 100MB in the /var/log directory and delete them.", "output": "find /var/log -type f -size +100M -exec rm -f {} \\;"}
{"instruction": "Define a Kubernetes ConfigMap containing database credentials and show how to inject them as environment variables in a Pod.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: db-config\ndata:\n  DB_HOST: \"db.example.com\"\n  DB_PORT: \"5432\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n    - name: app\n      image: my-app:1.0\n      envFrom:\n        - configMapRef:\n            name: db-config"}
{"instruction": "Write a Docker command to run a MySQL container with a root password set and data persisted to a named volume.", "output": "docker run -d --name mysql-db -e MYSQL_ROOT_PASSWORD=secret -v mysql_data:/var/lib/mysql -p 3306:3306 mysql:8.0"}
{"instruction": "Write a bash script to parse an Nginx access log and count the number of requests from unique IP addresses.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr"}
{"instruction": "Create a Dockerfile using a multi-stage build to compile a Go application and package it into a minimal Alpine Linux image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for a container named 'frontend' running 'nginx:latest'. It must have 3 replicas, resource requests of 100m CPU and 128Mi memory, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: frontend\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n        livenessProbe:\n          tcpSocket:\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a Bash script that loops through all '.log' files in the '/var/log/app' directory and compresses them into '.tar.gz' archives, removing the original log files afterwards.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\n\nfind \"$LOG_DIR\" -name \"*.log\" -type f | while read logfile; do\n  echo \"Compressing $logfile...\"\n  tar -czf \"$logfile.tar.gz\" \"$logfile\"\n  if [ $? -eq 0 ]; then\n    rm \"$logfile\"\n  else\n    echo \"Failed to compress $logfile\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service using a custom Dockerfile and a 'redis' service using the official image, ensuring the web service depends on redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash function to check if a specific TCP port is open on a remote host, retrying up to 5 times with a 2-second delay between attempts.", "output": "check_port() {\n  local host=$1\n  local port=$2\n  local retries=5\n  local wait=2\n\n  for ((i=1; i<=retries; i++)); do\n    nc -z -w 1 \"$host\" \"$port\" &> /dev/null\n    if [ $? -eq 0 ]; then\n      echo \"Port $port on $host is open.\"\n      return 0\n    fi\n    echo \"Attempt $i: Port $port on $host is closed. Retrying in $wait seconds...\"\n    sleep $wait\n  done\n  echo \"Failed to connect to $host:$port after $retries attempts.\"\n  return 1\n}"}
{"instruction": "Define a GitHub Actions workflow YAML that triggers on a push to the 'main' branch, checks out the code, and runs a 'make test' command on an Ubuntu runner.", "output": "name: CI Pipeline\non:\n  push:\n    branches:\n      - main\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Run Tests\n        run: make test"}
{"instruction": "Create a Kubernetes Service YAML of type 'ClusterIP' to expose a deployment labeled 'app: backend' on port 80, targeting targetPort 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP"}
{"instruction": "Write a Bash one-liner to parse an Nginx access log (access.log) and display the top 10 most frequent IP addresses sorted by count.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Construct a Kubernetes Ingress resource YAML that routes traffic from 'api.example.com' to a service named 'api-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080"}
{"instruction": "Create a Bash script that checks disk usage and sends a warning message to stderr if the usage of the root partition ('/') exceeds 85%.", "output": "#!/bin/bash\nTHRESHOLD=85\nCURRENT=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT\" -gt \"$THRESHOLD\" ]; then\n    echo \"WARNING: Disk usage is critical: ${CURRENT}%\" >&2\n    exit 1\nelse\n    echo \"Disk usage is normal: ${CURRENT}%\"\nfi"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to optimize image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o server main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/server .\nEXPOSE 8080\nCMD [\"./server\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a resource limit of 512Mi memory, and a liveness probe checking path /healthz.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"512Mi\"\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that checks disk usage and sends a warning message to stderr if the usage on the root partition exceeds 85%.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Warning: Disk usage is at ${USAGE}%\" >&2\nfi"}
{"instruction": "Provide a Docker Compose configuration to run a Python web service that depends on a Redis database, persisting Redis data to a local volume.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\"\n    volumes:\n      - redis_data:/data\nvolumes:\n  redis_data:"}
{"instruction": "Write a Kubernetes Service YAML to expose a deployment named 'backend-app' internally within the cluster on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP"}
{"instruction": "Create a Bash function that iterates through a list of servers in a text file and attempts to SSH into them to check their uptime.", "output": "check_uptime() {\n  while read -r server; do\n    echo \"Checking $server...\"\n    ssh -o ConnectTimeout=5 user@\"$server\" 'uptime'\n  done < servers.txt\n}"}
{"instruction": "Write a GitHub Actions workflow step to log in to Docker Hub and build/push an image tagged with the commit SHA.", "output": "- name: Login to Docker Hub\n  uses: docker/login-action@v2\n  with:\n    username: ${{ secrets.DOCKERHUB_USERNAME }}\n    password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n- name: Build and push\n  uses: docker/build-push-action@v4\n  with:\n    push: true\n    tags: myuser/myrepo:${{ github.sha }}"}
{"instruction": "Construct a Docker command to run a MySQL container in the background, mapping port 3306, setting the root password via environment variable, and naming the container 'prod-db'.", "output": "docker run -d --name prod-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw mysql:8.0"}
{"instruction": "Write a Kubernetes CronJob YAML that runs a script located at /scripts/backup.sh inside a busybox container every day at midnight.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: daily-backup\nspec:\n  schedule: \"0 0 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: backup\n            image: busybox\n            command:\n            - /bin/sh\n            - -c\n            - \"/scripts/backup.sh\"\n          restartPolicy: OnFailure"}
{"instruction": "Write a Bash script to parse an Nginx access log and count the number of 404 errors encountered.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\nERROR_COUNT=$(grep \" 404 \" \"$LOG_FILE\" | wc -l)\necho \"Total 404 errors: $ERROR_COUNT\""}
{"instruction": "Write a multi-stage Dockerfile for a Go application. The first stage should build the binary named 'app' from 'main.go', and the second stage should use a minimal Alpine image to run the binary to reduce image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /src/app .\nCMD [\"./app\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a liveness probe on port 80, and memory limits set to 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that checks if the disk usage of the root filesystem ('/') exceeds 85%. If it does, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=85\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"Warning: Disk usage is at ${USAGE}%\" >&2\nfi"}
{"instruction": "Create a docker-compose.yml file that spins up a 'web' service using the current directory's Dockerfile and a 'db' service using the postgres:13 image, connected via a dedicated bridge network.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    networks:\n      - app-net\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: example\n    networks:\n      - app-net\nnetworks:\n  app-net:\n    driver: bridge"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose the 'frontend' deployment on port 80, mapping it to target port 3000 on the container.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n      nodePort: 30007"}
{"instruction": "Write a Bash one-liner to find all '.log' files in '/var/log/app' that are older than 7 days and delete them.", "output": "find /var/log/app -name \"*.log\" -type f -mtime +7 -exec rm -f {} \\;"}
{"instruction": "Create a GitHub Actions workflow file (.yml) that runs on push to 'main', checks out code, sets up Node.js version 18, and runs 'npm install' followed by 'npm test'.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide the Docker CLI command to run a container named 'mysql-db' using the 'mysql:8' image, setting the root password to 'secret', and persisting data to a named volume called 'db_data'.", "output": "docker run -d \\\n  --name mysql-db \\\n  -e MYSQL_ROOT_PASSWORD=secret \\\n  -v db_data:/var/lib/mysql \\\n  mysql:8"}
{"instruction": "Write a Kubernetes Ingress resource that routes traffic from 'api.example.com' to a service named 'api-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080"}
{"instruction": "Write a Bash script snippet that uses 'jq' to extract the value of the 'version' key from a file named 'package.json' and assigns it to a variable.", "output": "if ! command -v jq &> /dev/null; then\n    echo \"jq is required but not installed.\"\n    exit 1\nfi\n\nAPP_VERSION=$(jq -r '.version' package.json)\necho \"Detected version: $APP_VERSION\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size using a scratch base image for the final stage.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a bash script to compress logs older than 7 days in '/var/log/app' and delete compressed archives older than 30 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\n# Compress logs older than 7 days\nfind \"$LOG_DIR\" -type f -name \"*.log\" -mtime +7 -exec gzip {} \\;\n\n# Delete archives older than 30 days\nfind \"$LOG_DIR\" -type f -name \"*.gz\" -mtime +30 -exec rm {} \\;"}
{"instruction": "Generate a Kubernetes Deployment YAML for an Nginx server with 3 replicas, resource limits (CPU: 500m, Mem: 128Mi), and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Create a GitHub Actions workflow file that runs 'npm test' on push events to the 'main' branch.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a docker-compose.yml file to spin up a WordPress instance linked to a MySQL 5.7 database.", "output": "version: '3.8'\nservices:\n  db:\n    image: mysql:5.7\n    volumes:\n      - db_data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: examplepass\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    image: wordpress:latest\n    depends_on:\n      - db\n    ports:\n      - \"8000:80\"\n    environment:\n      WORDPRESS_DB_HOST: db\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordpress\n      WORDPRESS_DB_NAME: wordpress\n\nvolumes:\n  db_data:"}
{"instruction": "Write a bash script that checks if the root partition usage exceeds 90%. If it does, print a warning message to stderr.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n    echo \"CRITICAL: Disk usage is at ${USAGE}%\" >&2\nfi"}
{"instruction": "Create a Kubernetes ConfigMap manifest named 'app-config' containing two keys: 'database_url' and 'debug_mode'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://user:pass@db:5432/mydb\"\n  debug_mode: \"true\""}
{"instruction": "Provide the Docker CLI commands to create a custom bridge network named 'isolated_net' and run a container attached to it.", "output": "docker network create --driver bridge isolated_net\ndocker run -d --name secure-app --network isolated_net nginx:alpine"}
{"instruction": "Write a command to recursively set directory permissions to 755 and file permissions to 644 within the current folder.", "output": "find . -type d -exec chmod 755 {} \\;\nfind . -type f -exec chmod 644 {} \\;"}
{"instruction": "Write a sample values.yaml file for a Helm chart to override the replica count and image tag.", "output": "replicaCount: 2\n\nimage:\n  repository: my-app/backend\n  pullPolicy: IfNotPresent\n  tag: \"v1.2.0\"\n\nservice:\n  type: ClusterIP\n  port: 80"}
{"instruction": "Create a Dockerfile for a Go application using a multi-stage build to compile the binary in the first stage and run it in a scratch container to minimize image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod ./\nCOPY go.sum ./\nRUN go mod download\nCOPY *.go ./\nRUN CGO_ENABLED=0 GOOS=linux go build -o /docker-gs-ping\n\nFROM scratch\nWORKDIR /\nCOPY --from=builder /docker-gs-ping /docker-gs-ping\nEXPOSE 8080\nENTRYPOINT [\"/docker-gs-ping\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a rolling update strategy, and resource limits set to 256Mi RAM and 500m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\""}
{"instruction": "Write a bash script that parses an Nginx access log (`access.log`), counts the occurrences of each unique IP address, and outputs the top 10 IPs with the most requests.", "output": "#!/bin/bash\nLOG_FILE=\"access.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a `docker-compose.yml` file to spin up a PostgreSQL database with a persistent volume named `pgdata` and environment variables for the user, password, and database name.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:14-alpine\n    restart: always\n    environment:\n      POSTGRES_USER: myuser\n      POSTGRES_PASSWORD: mypassword\n      POSTGRES_DB: mydatabase\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitHub Actions workflow file (`.github/workflows/ci.yml`) that triggers on a push to the `main` branch, installs Node.js dependencies, runs tests, and builds the project.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n        cache: 'npm'\n    - run: npm ci\n    - run: npm test\n    - run: npm run build"}
{"instruction": "Create a Kubernetes Service manifest of type `LoadBalancer` to expose a deployment labeled `app: backend` on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a bash script that creates a tar.gz backup of the `/var/www/html` directory with a timestamp in the filename and deletes local backups older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%Y-%m-%d_%H-%M-%S)\nFILENAME=\"site_backup_$DATE.tar.gz\"\n\n# Create backup\nmkdir -p \"$BACKUP_DIR\"\ntar -czf \"$BACKUP_DIR/$FILENAME\" \"$SOURCE_DIR\"\n\n# Delete backups older than 7 days\nfind \"$BACKUP_DIR\" -type f -name \"site_backup_*.tar.gz\" -mtime +7 -delete"}
{"instruction": "Write the Docker CLI commands to create a custom bridge network named `app-net` and run a Redis container named `cache` attached to that network.", "output": "docker network create app-net && \\\ndocker run -d --name cache --network app-net redis:alpine"}
{"instruction": "Define a Kubernetes CronJob that runs every 5 minutes and executes a curl command to check the health of an internal service.", "output": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: health-check-job\nspec:\n  schedule: \"*/5 * * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: curl\n            image: curlimages/curl\n            args:\n            - /bin/sh\n            - -c\n            - curl -f http://internal-service/health || exit 1\n          restartPolicy: OnFailure"}
{"instruction": "Write a bash one-liner to check if the disk usage of the root partition (`/`) exceeds 85% and print a warning message if true.", "output": "USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g'); [ \"$USAGE\" -gt 85 ] && echo \"WARNING: Disk usage is critical at ${USAGE}%\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should compile the binary 'app', and the final stage should use 'alpine:latest' and run the binary.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o app main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/app .\nCMD [\"./app\"]"}
{"instruction": "Write a Kubernetes Deployment YAML configuration for an application named 'web-server' using the 'nginx:1.25' image. It should run 3 replicas and include a liveness probe checking path '/' on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-server\n  template:\n    metadata:\n      labels:\n        app: web-server\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.25\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a Bash script that finds all '.log' files in '/var/log/app' that are older than 7 days, compresses them into a tar.gz archive with the current date, and deletes the original files.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/app\"\nARCHIVE_NAME=\"logs_archive_$(date +%F).tar.gz\"\n\nfind \"$TARGET_DIR\" -name \"*.log\" -mtime +7 -print0 | xargs -0 tar -czf \"$ARCHIVE_NAME\" --remove-files\n\necho \"Archived old logs to $ARCHIVE_NAME\""}
{"instruction": "Create a docker-compose.yml file that sets up a 'frontend' service (build from current directory) and a 'db' service (postgres:15-alpine). The frontend must depend on the db, and they should share a network named 'app-net'.", "output": "version: '3.8'\nservices:\n  frontend:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n    networks:\n      - app-net\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_PASSWORD: example\n    networks:\n      - app-net\nnetworks:\n  app-net:\n    driver: bridge"}
{"instruction": "Write a GitHub Actions workflow step (YAML) to build a Docker image and push it to a registry. The step should only run if the event is a push to the 'main' branch.", "output": "name: Build and Push Docker Image\non:\n  push:\n    branches:\n      - main\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          push: true\n          tags: user/app:latest"}
{"instruction": "Write a Kubernetes Service YAML to expose a set of pods labeled 'app: backend' internally within the cluster on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP"}
{"instruction": "Write a Bash one-liner to check if the disk usage of the root partition ('/') is greater than 85%. If it is, print 'Disk Critical', otherwise print 'Disk OK'.", "output": "usage=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g'); if [ \"$usage\" -gt 85 ]; then echo \"Disk Critical\"; else echo \"Disk OK\"; fi"}
{"instruction": "Provide the Docker command to remove all stopped containers, all unused networks, and all dangling images (prune system) without prompting for confirmation.", "output": "docker system prune -f"}
{"instruction": "Write a Kubernetes ConfigMap YAML named 'app-config' containing two keys: 'database_url' and 'debug_mode'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://user:pass@db:5432/mydb\"\n  debug_mode: \"false\""}
{"instruction": "Write a bash script that loops through a list of servers defined in a text file 'servers.txt' and checks if they are reachable via SSH. It should output the status for each server.", "output": "#!/bin/bash\nwhile IFS= read -r server; do\n  if ssh -q -o BatchMode=yes -o ConnectTimeout=5 \"$server\" exit; then\n    echo \"$server is reachable\"\n  else\n    echo \"$server is UNREACHABLE\"\n  fi\ndone < servers.txt"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o main .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nEXPOSE 8080\nCMD [\"./main\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for a web application with 3 replicas, ensuring a RollingUpdate strategy where maxSurge is 1 and maxUnavailable is 0.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n      - name: web-app\n        image: my-web-app:v1\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that checks if the disk usage of the root filesystem exceeds 80% and sends an alert to a mock webhook if it does.", "output": "#!/bin/bash\nTHRESHOLD=80\nCURRENT_USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$CURRENT_USAGE\" -gt \"$THRESHOLD\" ]; then\n  curl -X POST -H \"Content-type: application/json\" --data \"{\\\"text\\\": \\\"Disk usage is critical: ${CURRENT_USAGE}%\\\"}\" https://hooks.slack.com/services/EXAMPLE/PLACEHOLDER/TOKEN\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Node.js application service and a Redis service, connecting them via a custom bridge network.", "output": "version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REDIS_HOST=redis\n    networks:\n      - backend-net\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:alpine\n    networks:\n      - backend-net\n\nnetworks:\n  backend-net:\n    driver: bridge"}
{"instruction": "Write a declarative Jenkinsfile that defines a pipeline with three stages: Build, Test, and Deploy, where the Deploy stage only runs on the 'main' branch.", "output": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                echo 'Building...'\n                sh 'make build'\n            }\n        }\n        stage('Test') {\n            steps {\n                echo 'Testing...'\n                sh 'make test'\n            }\n        }\n        stage('Deploy') {\n            when {\n                branch 'main'\n            }\n            steps {\n                echo 'Deploying...'\n                sh './deploy.sh'\n            }\n        }\n    }\n}"}
{"instruction": "Create a Kubernetes Ingress resource YAML to route traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a Bash script to find all log files in '/var/log/app' modified more than 7 days ago, compress them, and remove the original files.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\n\n# Find files ending in .log older than 7 days\nfind \"$LOG_DIR\" -name \"*.log\" -mtime +7 -print0 | while IFS= read -r -d '' file; do\n  # Compress the file\n  gzip \"$file\"\n  echo \"Compressed and removed: $file\"\ndone"}
{"instruction": "Add a HEALTHCHECK instruction to a Dockerfile for a web service running on port 3000, checking every 30 seconds with a timeout of 5 seconds.", "output": "FROM node:14-alpine\nWORKDIR /app\nCOPY . .\nRUN npm install\nEXPOSE 3000\n\nHEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \\\n  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1\n\nCMD [\"node\", \"server.js\"]"}
{"instruction": "Define a GitLab CI/CD configuration (.gitlab-ci.yml) that uses a Docker-in-Docker service to build a container image and push it to the GitLab Container Registry.", "output": "image: docker:20.10.16\nservices:\n  - docker:20.10.16-dind\n\nstages:\n  - build\n\nbuild_image:\n  stage: build\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"}
{"instruction": "Create a Kubernetes Pod definition that mounts a ConfigMap named 'app-config' as a volume at '/etc/config' and populates environment variables from a Secret named 'app-secrets'.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: config-secret-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-app:latest\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n    envFrom:\n    - secretRef:\n        name: app-secrets\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config"}
{"instruction": "Write a multi-stage Dockerfile for a Go application to optimize the final image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.20 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Create a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a rolling update strategy, and resource limits defined.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            cpu: \"500m\"\n            memory: \"256Mi\"\n          requests:\n            cpu: \"250m\"\n            memory: \"128Mi\""}
{"instruction": "Write a Bash script that iterates through all files in a specific directory (`/var/log/app`), compresses files older than 7 days, and moves them to an archive folder.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nARCHIVE_DIR=\"/var/log/app/archive\"\nmkdir -p \"$ARCHIVE_DIR\"\n\nfind \"$SOURCE_DIR\" -maxdepth 1 -type f -mtime +7 -name \"*.log\" | while read FILE; do\n    gzip \"$FILE\"\n    mv \"$FILE.gz\" \"$ARCHIVE_DIR/\"\n    echo \"Archived: $FILE\"\ndone"}
{"instruction": "Create a `docker-compose.yml` file to spin up a PostgreSQL database and a Redis instance, ensuring the database data is persisted in a volume.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:14-alpine\n    environment:\n      POSTGRES_USER: admin\n      POSTGRES_PASSWORD: secretpassword\n      POSTGRES_DB: myappdb\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n  cache:\n    image: redis:6-alpine\n    ports:\n      - \"6379:6379\"\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitHub Actions CI workflow file that triggers on push to the `main` branch, checks out code, sets up Node.js, and runs tests.", "output": "name: Node.js CI\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Provide the Kubernetes YAML to create a ConfigMap from a literal value and inject it as an environment variable into a Pod.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  APP_ENV: \"production\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: env-test-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sh\", \"-c\", \"echo $APP_ENV && sleep 3600\" ]\n    env:\n      - name: APP_ENV\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: APP_ENV"}
{"instruction": "Write a Bash script to wait for a database service (host: db, port: 5432) to become available before continuing execution (useful for entrypoint scripts).", "output": "#!/bin/bash\nhost=\"db\"\nport=\"5432\"\n\necho \"Waiting for postgres...\"\n\nuntil nc -z -v -w30 \"$host\" \"$port\"; do\n  echo \"Waiting for database connection...\"\n  sleep 2\ndone\n\necho \"Database is up - executing command\""}
{"instruction": "Create a Docker command to create a custom bridge network and run a container attached to that network with a specific static IP.", "output": "docker network create --subnet=172.18.0.0/16 mynet && \\\ndocker run --net mynet --ip 172.18.0.22 -d --name my-container nginx"}
{"instruction": "Generate a Kubernetes Ingress resource YAML to route traffic from `api.example.com` to a service named `api-service` on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080"}
{"instruction": "Write a Bash function to check disk usage and send an alert message if usage exceeds 90% on the root partition.", "output": "#!/bin/bash\ncheck_disk() {\n    USAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n    THRESHOLD=90\n    if [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n        echo \"ALERT: Root partition usage is at ${USAGE}%!\"\n        # mail -s \"Disk Alert\" admin@example.com <<< \"Root partition at ${USAGE}%\"\n    else\n        echo \"Disk usage normal: ${USAGE}%\"\n    fi\n}\ncheck_disk"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to compile the binary in the first stage and run it in a lightweight Alpine container.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server that includes a liveness probe checking the root path on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a Bash script that loops through all '.log' files in the current directory, compresses them using gzip, and appends the current date to the filename.", "output": "#!/bin/bash\nDATE=$(date +%Y-%m-%d)\nfor file in *.log; do\n  if [ -f \"$file\" ]; then\n    gzip -c \"$file\" > \"${file}_${DATE}.gz\"\n    echo \"Compressed $file\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a Redis service, ensuring the web service depends on Redis.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Write a Bash one-liner to parse a JSON file named 'config.json' and extract the value of the key 'database_ip' using 'jq'.", "output": "jq -r '.database_ip' config.json"}
{"instruction": "Define a Kubernetes Service of type LoadBalancer to expose a deployment named 'backend-api' on port 80 targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a GitHub Actions CI workflow step (YAML) to build a Docker image and push it to Docker Hub, triggered on a push to the main branch.", "output": "name: Build and Push\non:\n  push:\n    branches:\n      - main\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          push: true\n          tags: user/app:latest"}
{"instruction": "Write a Bash script to check if a specific Docker container is running. If not, start it.", "output": "#!/bin/bash\nCONTAINER_NAME=\"my-database\"\nif [ ! \"$(docker ps -q -f name=$CONTAINER_NAME)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=$CONTAINER_NAME)\" ]; then\n        echo \"Starting existing container...\"\n        docker start $CONTAINER_NAME\n    else\n        echo \"Container does not exist.\"\n    fi\nelse\n    echo \"Container is already running.\"\nfi"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 5Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi"}
{"instruction": "Write a Docker command to run a temporary container that mounts the current directory to '/data' inside the container and lists the files.", "output": "docker run --rm -v \"$(pwd):/data\" alpine ls -la /data"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage should build the binary using 'golang:1.21-alpine', and the final stage should use a scratch image to run the binary to minimize size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nCOPY --from=builder /app/myapp /myapp\nENTRYPOINT [\"/myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas, requiring a liveness probe on port 80 and resource limits of 128Mi memory and 250m CPU.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"250m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3"}
{"instruction": "Write a bash script that iterates through all log files in `/var/log/app/`, archives them into a tar.gz file with a timestamp, and deletes the original files older than 7 days.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/var/backups/app\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\n\nmkdir -p \"$BACKUP_DIR\"\n\n# Compress logs\ntar -czf \"$BACKUP_DIR/logs_$TIMESTAMP.tar.gz\" -C \"$LOG_DIR\" .\n\n# Delete logs older than 7 days from the source directory\nfind \"$LOG_DIR\" -type f -name \"*.log\" -mtime +7 -exec rm {} \\;"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (building from the current directory) and a 'db' service (using Postgres 13), connecting them via a custom bridge network.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    networks:\n      - app-network\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydatabase\n    volumes:\n      - db-data:/var/lib/postgresql/data\n    networks:\n      - app-network\n\nnetworks:\n  app-network:\n    driver: bridge\n\nvolumes:\n  db-data:"}
{"instruction": "Write a bash one-liner to parse an Nginx access log (`access.log`) and print the top 5 IP addresses by request count.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Define a Kubernetes Service of type NodePort to expose a deployment named 'backend-app' on port 8080, targeting container port 3000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: NodePort\n  selector:\n    app: backend-app\n  ports:\n    - protocol: TCP\n      port: 8080\n      targetPort: 3000\n      nodePort: 30007"}
{"instruction": "Create a GitHub Actions workflow file (`.github/workflows/ci.yml`) that triggers on push to the main branch, installs Node.js 18, runs `npm install`, and executes `npm test`.", "output": "name: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n    - run: npm ci\n    - run: npm test"}
{"instruction": "Write a bash function that checks if a specific Docker container is running. If not, start it. If it doesn't exist, print an error.", "output": "ensure_container_running() {\n  CONTAINER_NAME=$1\n  if [ \"$(docker ps -q -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n    echo \"Container $CONTAINER_NAME is already running.\"\n  elif [ \"$(docker ps -aq -f name=\"^${CONTAINER_NAME}$\")\" ]; then\n    echo \"Starting container $CONTAINER_NAME...\"\n    docker start \"$CONTAINER_NAME\"\n  else\n    echo \"Error: Container $CONTAINER_NAME does not exist.\"\n  fi\n}"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-config' containing two keys: 'database_url' and 'debug_mode'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://user:pass@db:5432/mydb\"\n  debug_mode: \"true\""}
{"instruction": "Write a command to run a temporary Docker container using the Alpine image that mounts the host directory `/opt/data` to `/data` inside the container and opens an interactive shell.", "output": "docker run --rm -it -v /opt/data:/data alpine:latest /bin/sh"}
{"instruction": "Create a multi-stage Dockerfile for a Go application. The first stage (builder) should compile the binary named 'server', and the second stage should use a minimal Alpine image to run the binary.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o server main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/server .\nCMD [\"./server\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application with 3 replicas. Include resource limits (CPU: 500m, Memory: 256Mi) and a liveness probe on port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 15\n          periodSeconds: 20"}
{"instruction": "Write a bash script that loops through a list of servers in 'hosts.txt' and checks if they are reachable via ping. If a host is down, echo the hostname to 'downtime.log'.", "output": "#!/bin/bash\nwhile IFS= read -r host; do\n  if ! ping -c 1 \"$host\" &> /dev/null; then\n    echo \"$host is down at $(date)\" >> downtime.log\n  fi\ndone < hosts.txt"}
{"instruction": "Create a docker-compose.yml file that sets up a Python web service (port 5000) and a PostgreSQL database. The database must use a named volume for persistence.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_PASSWORD: example\n    volumes:\n      - pgdata:/var/lib/postgresql/data\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitLab CI/CD configuration (.gitlab-ci.yml) that builds a docker image and pushes it to the registry only when changes are pushed to the 'main' branch.", "output": "stages:\n  - build\n\ndocker-build:\n  image: docker:latest\n  services:\n    - docker:dind\n  stage: build\n  script:\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main"}
{"instruction": "Create a Kubernetes Service YAML of type LoadBalancer to expose an application labeled 'app: frontend' on port 80, targeting container port 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a bash script to archive log files older than 7 days from /var/log/app to /backup/logs, compressing them into a tarball with the current date.", "output": "#!/bin/bash\nSOURCE_DIR=\"/var/log/app\"\nBACKUP_DIR=\"/backup/logs\"\nDATE=$(date +%F)\n\nmkdir -p \"$BACKUP_DIR\"\nfind \"$SOURCE_DIR\" -name \"*.log\" -mtime +7 -print0 | tar -czvf \"$BACKUP_DIR/logs-$DATE.tar.gz\" --null -T -\nfind \"$SOURCE_DIR\" -name \"*.log\" -mtime +7 -delete"}
{"instruction": "Write the Docker CLI command to create a custom bridge network named 'my-net' and run a container named 'redis-cache' connected to that network.", "output": "docker network create my-net && docker run -d --name redis-cache --network my-net redis:alpine"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-settings' containing two keys: 'DATABASE_HOST' and 'DEBUG_MODE'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-settings\ndata:\n  DATABASE_HOST: \"db.example.com\"\n  DEBUG_MODE: \"false\""}
{"instruction": "Write a bash script that checks if a specific process (passed as an argument) is running. If not, it attempts to start it using systemctl.", "output": "#!/bin/bash\nSERVICE=$1\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n  echo \"$SERVICE is not running. Attempting to start...\"\n  sudo systemctl start \"$SERVICE\"\nelse\n  echo \"$SERVICE is running.\"\nfi"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size. The build stage should use 'golang:1.21-alpine' and the final stage should use 'scratch'.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM scratch\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx application named 'web-server' with 3 replicas, exposing port 80, and including a liveness probe that checks the root path every 10 seconds.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 10"}
{"instruction": "Write a bash script that iterates through all log files ending in '.log' in the '/var/logs/app' directory. If a file is older than 7 days, compress it into a .tar.gz file and remove the original.", "output": "#!/bin/bash\nLOG_DIR=\"/var/logs/app\"\nfind \"$LOG_DIR\" -name \"*.log\" -mtime +7 -print0 | while IFS= read -r -d '' file; do\n  tar -czf \"${file}.tar.gz\" \"$file\"\n  if [ $? -eq 0 ]; then\n    rm \"$file\"\n    echo \"Compressed and removed: $file\"\n  else\n    echo \"Failed to compress: $file\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (building from the current directory) and a 'db' service (using postgres:13). The web service must depend on the db service and expose port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydatabase\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:"}
{"instruction": "Write a GitHub Actions workflow file (.github/workflows/deploy.yml) that triggers on a push to the 'main' branch, builds a Docker image, and pushes it to Docker Hub using secrets for authentication.", "output": "name: CI/CD Pipeline\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a bash script to check if the 'nginx' service is running on a Linux server. If it is not running, attempt to start it using systemctl and send an alert message to a hypothetical slack webhook.", "output": "#!/bin/bash\nSERVICE=\"nginx\"\nWEBHOOK_URL=\"https://hooks.slack.com/services/EXAMPLE/PLACEHOLDER/TOKEN\"\n\nif ! systemctl is-active --quiet \"$SERVICE\"; then\n  echo \"$SERVICE is down. Attempting restart...\"\n  systemctl start \"$SERVICE\"\n  if systemctl is-active --quiet \"$SERVICE\"; then\n    curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Nginx was down but successfully restarted.\"}' \"$WEBHOOK_URL\"\n  else\n    curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"CRITICAL: Nginx is down and failed to restart.\"}' \"$WEBHOOK_URL\"\n  fi\nfi"}
{"instruction": "Create a Kubernetes Service manifest of type 'LoadBalancer' to expose a deployment with the selector 'app: backend' on port 80, targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080"}
{"instruction": "Write a Docker command to run a container named 'dev-db' using the 'mysql:8.0' image. It should set the root password to 'secret', create a database named 'inventory', run in the background, and restart automatically unless stopped.", "output": "docker run -d --name dev-db \\\n  --restart unless-stopped \\\n  -e MYSQL_ROOT_PASSWORD=secret \\\n  -e MYSQL_DATABASE=inventory \\\n  mysql:8.0"}
{"instruction": "Write a bash script that monitors disk usage on the root partition ('/'). If usage exceeds 90%, it should print a warning to stderr.", "output": "#!/bin/bash\nTHRESHOLD=90\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"WARNING: Disk usage is critical: ${USAGE}%\" >&2\nelse\n  echo \"Disk usage is normal: ${USAGE}%\"\nfi"}
{"instruction": "Create a Kubernetes ConfigMap YAML named 'app-config' containing two keys: 'database_url' and 'debug_mode'.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"jdbc:postgresql://db-service:5432/mydb\"\n  debug_mode: \"false\""}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize the final image size. The first stage should build the binary, and the second stage should run it using a minimal Alpine image.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nEXPOSE 8080\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML for an Nginx server that includes a liveness probe (checking /healthz) and a readiness probe (checking /), ensuring high availability with 3 replicas.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 5"}
{"instruction": "Write a Bash script that finds all log files in '/var/log/myapp' ending in '.log' that are older than 7 days, compresses them using gzip, and removes the original files.", "output": "#!/bin/bash\nLOG_DIR=\"/var/log/myapp\"\n\nif [ -d \"$LOG_DIR\" ]; then\n  find \"$LOG_DIR\" -name \"*.log\" -type f -mtime +7 -exec gzip {} \\;\n  echo \"Log rotation complete.\"\nelse\n  echo \"Directory $LOG_DIR does not exist.\"\nfi"}
{"instruction": "Create a docker-compose.yml file that sets up a Python Flask web service and a PostgreSQL database. The database data must persist in a named volume called 'pgdata'.", "output": "version: '3.8'\n\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - db\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n\n  db:\n    image: postgres:13\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=myapp\n\nvolumes:\n  pgdata:"}
{"instruction": "Write a GitLab CI/CD pipeline job (in .gitlab-ci.yml syntax) that builds a Docker image and pushes it to the GitLab Container Registry only when changes are pushed to the 'main' branch.", "output": "build_and_push:\n  image: docker:latest\n  services:\n    - docker:dind\n  stage: build\n  script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main"}
{"instruction": "Write a Bash one-liner to list the top 5 processes consuming the most memory on a Linux server, formatted to show the user, PID, percentage of memory, and the command.", "output": "ps aux --sort=-%mem | awk 'NR<=6 {print $1, $2, $4, $11}'"}
{"instruction": "Define a Kubernetes Ingress resource that routes traffic from 'api.example.com' to a service named 'backend-service' on port 8080.", "output": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080"}
{"instruction": "Write a shell script to automate a simple deployment: pull the latest changes from a Git repository, rebuild the Docker container named 'webapp', and restart it.", "output": "#!/bin/bash\nREPO_DIR=\"/opt/webapp\"\nCONTAINER_NAME=\"webapp\"\n\ncd \"$REPO_DIR\" || exit\n\n# Fetch latest changes\ngit fetch origin\n\n# Check if local is behind upstream\nif [ $(git rev-parse HEAD) != $(git rev-parse @{u}) ]; then\n    echo \"New code found. Updating...\"\n    git pull\n    \n    echo \"Rebuilding Docker image...\"\n    docker build -t my-webapp .\n    \n    echo \"Restarting container...\"\n    docker stop \"$CONTAINER_NAME\" || true\n    docker rm \"$CONTAINER_NAME\" || true\n    docker run -d --name \"$CONTAINER_NAME\" -p 80:80 my-webapp\nelse\n    echo \"No changes detected.\"\nfi"}
{"instruction": "Create a Kubernetes Pod definition that securely injects database credentials using a Secret named 'db-secret' as environment variables.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: backend-pod\nspec:\n  containers:\n  - name: backend\n    image: my-backend-image\n    env:\n      - name: DB_USERNAME\n        valueFrom:\n          secretKeyRef:\n            name: db-secret\n            key: username\n      - name: DB_PASSWORD\n        valueFrom:\n          secretKeyRef:\n            name: db-secret\n            key: password"}
{"instruction": "Provide the Docker CLI commands to create a user-defined bridge network named 'isolated-net' and run a container named 'secure-app' attached to that network.", "output": "docker network create --driver bridge isolated-net && \\\ndocker run -d --name secure-app --network isolated-net nginx:alpine"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to ensure a small final image size. The build stage should use 'golang:1.19' and the final stage should use 'alpine:latest'.", "output": "FROM golang:1.19 AS builder\nWORKDIR /app\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o myapp .\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a bash script that loops through all '.log' files in the '/var/logs/app' directory, compresses them into '.gz' files, and removes the original log file.", "output": "#!/bin/bash\nLOG_DIR=\"/var/logs/app\"\n\nif [ -d \"$LOG_DIR\" ]; then\n  for file in \"$LOG_DIR\"/*.log; do\n    if [ -f \"$file\" ]; then\n      gzip \"$file\"\n      echo \"Compressed $file\"\n    fi\n  done\nelse\n  echo \"Directory not found.\"\nfi"}
{"instruction": "Define a Kubernetes Deployment YAML for an Nginx application with 3 replicas, a resource limit of 256Mi memory, and a liveness probe checking port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 30\n          periodSeconds: 10"}
{"instruction": "Create a docker-compose.yml file that sets up a 'web' service (Node.js) and a 'db' service (PostgreSQL). The web service should depend on the db service and expose port 3000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n    environment:\n      - DB_HOST=db\n      - DB_USER=postgres\n      - DB_PASS=password\n  db:\n    image: postgres:13-alpine\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - db-data:/var/lib/postgresql/data\n\nvolumes:\n  db-data:"}
{"instruction": "Write a bash command to check if a specific Docker container named 'production-api' is running, and if not, start it.", "output": "if [ ! \"$(docker ps -q -f name=production-api)\" ]; then\n    if [ \"$(docker ps -aq -f status=exited -f name=production-api)\" ]; then\n        docker start production-api\n    else\n        echo \"Container does not exist or is not stopped.\"\n    fi\nelse\n    echo \"Container is already running.\"\nfi"}
{"instruction": "Create a Kubernetes Service of type NodePort to expose a deployment labeled 'app: frontend' on target port 80 and node port 30007.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30007"}
{"instruction": "Write a GitHub Actions workflow step to build a Docker image and push it to Docker Hub, triggered only on a push to the 'main' branch.", "output": "name: CI/CD Docker\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: user/app:latest"}
{"instruction": "Write a bash script that parses a JSON file named 'config.json' using 'jq' to extract the value of the key 'database_url' and exports it as an environment variable.", "output": "#!/bin/bash\nif command -v jq &> /dev/null; then\n  DB_URL=$(jq -r '.database_url' config.json)\n  export DATABASE_URL=\"$DB_URL\"\n  echo \"Exported DATABASE_URL: $DATABASE_URL\"\nelse\n  echo \"jq is not installed.\"\nfi"}
{"instruction": "Provide the command to create a Docker volume named 'app_data' and run a container mounting that volume to '/data'.", "output": "docker volume create app_data && docker run -d -v app_data:/data --name my-container alpine tail -f /dev/null"}
{"instruction": "Create a Kubernetes PersistentVolumeClaim (PVC) YAML requesting 10Gi of storage with ReadWriteOnce access mode.", "output": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi"}
{"instruction": "Write a multi-stage Dockerfile for a Go application. The first stage should use 'golang:1.19' to build the binary named 'app', and the second stage should use 'gcr.io/distroless/static' to run the binary to minimize image size.", "output": "FROM golang:1.19 AS builder\nWORKDIR /src\nCOPY . .\nRUN CGO_ENABLED=0 go build -o app main.go\n\nFROM gcr.io/distroless/static\nCOPY --from=builder /src/app /\nCMD [\"/app\"]"}
{"instruction": "Create a Kubernetes YAML manifest for a Deployment named 'nginx-deployment'. It should run 3 replicas of the 'nginx:alpine' image and expose container port 80.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:alpine\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through all '.log' files in the '/var/log/app' directory and deletes files that have not been modified in the last 7 days.", "output": "#!/bin/bash\nTARGET_DIR=\"/var/log/app\"\n\nif [ -d \"$TARGET_DIR\" ]; then\n  find \"$TARGET_DIR\" -name \"*.log\" -type f -mtime +7 -exec rm {} \\;\n  echo \"Cleanup completed.\"\nelse\n  echo \"Directory not found.\"\nfi"}
{"instruction": "Write a docker-compose.yml file to spin up a NodeJS application (service name 'api') that depends on a Redis service. The API should expose port 3000 to the host.", "output": "version: '3.8'\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOST=redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Provide a kubectl command to create a generic Secret named 'db-credentials' containing a username 'admin' and a password 's3cr3t' from literal values.", "output": "kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=s3cr3t"}
{"instruction": "Write a Bash function that checks if a specific website is reachable (returns HTTP 200). It should take the URL as an argument.", "output": "check_site() {\n  local url=$1\n  local status=$(curl -o /dev/null -s -w \"%{http_code}\" \"$url\")\n  if [ \"$status\" -eq 200 ]; then\n    echo \"$url is UP\"\n  else\n    echo \"$url is DOWN (Status: $status)\"\n  fi\n}"}
{"instruction": "Create a GitHub Actions workflow step (YAML) to build a Docker image and push it to Docker Hub, assuming secrets DOCKER_USERNAME and DOCKER_PASSWORD are set.", "output": "- name: Login to Docker Hub\n  uses: docker/login-action@v2\n  with:\n    username: ${{ secrets.DOCKER_USERNAME }}\n    password: ${{ secrets.DOCKER_PASSWORD }}\n\n- name: Build and push\n  uses: docker/build-push-action@v4\n  with:\n    push: true\n    tags: user/app:latest"}
{"instruction": "Write a Kubernetes Service manifest of type NodePort to expose a deployment with label 'app: frontend' on port 80, targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007"}
{"instruction": "Write a Bash one-liner using 'sed' to replace all occurrences of 'localhost' with '127.0.0.1' in a file named 'config.json' and save it in place.", "output": "sed -i 's/localhost/127.0.0.1/g' config.json"}
{"instruction": "Write a Docker command to run a container named 'temp-worker' from image 'python:3.9-slim' in the background, limiting it to 512MB of memory and 1 CPU core.", "output": "docker run -d --name temp-worker --memory=\"512m\" --cpus=\"1.0\" python:3.9-slim"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to optimize image size by separating the build environment from the runtime environment.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment YAML file for an Nginx application with 3 replicas, a label selector 'app: nginx', and a memory limit of 128Mi.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        resources:\n          limits:\n            memory: \"128Mi\"\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a bash script command to parse an Apache access log file named 'access.log', extract the client IP addresses (assumed to be the first column), count unique occurrences, and sort them in descending order.", "output": "awk '{print $1}' access.log | sort | uniq -c | sort -nr"}
{"instruction": "Create a docker-compose.yml file to set up a Python Flask web service dependent on a Redis service, exposing the web service on port 5000.", "output": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - redis\n  redis:\n    image: \"redis:alpine\""}
{"instruction": "Provide the command to create a Docker volume named 'db_data' and start a PostgreSQL container that mounts this volume to '/var/lib/postgresql/data' with a password environment variable.", "output": "docker volume create db_data\ndocker run -d --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword -v db_data:/var/lib/postgresql/data postgres:latest"}
{"instruction": "Write a GitHub Actions workflow YAML configuration that triggers on a push to the 'main' branch and runs a linter (flake8) on a Python project.", "output": "name: Python Lint\non:\n  push:\n    branches: [ \"main\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: \"3.10\"\n    - name: Install dependencies\n      run: | \n        pip install flake8\n    - name: Lint with flake8\n      run: | \n        flake8 ."}
{"instruction": "Write a bash script that archives the contents of the '/var/www/html' directory into a tar.gz file with the current date in the filename, and deletes archives older than 7 days.", "output": "#!/bin/bash\nBACKUP_DIR=\"/backups\"\nSOURCE_DIR=\"/var/www/html\"\nDATE=$(date +%F)\nTAR_NAME=\"website-backup-$DATE.tar.gz\"\n\n# Create backup\ntar -czf $BACKUP_DIR/$TAR_NAME $SOURCE_DIR\n\n# Delete backups older than 7 days\nfind $BACKUP_DIR -name \"website-backup-*.tar.gz\" -type f -mtime +7 -delete"}
{"instruction": "Define a Kubernetes Service of type 'LoadBalancer' to expose a deployment with the selector 'app: my-app' on port 80, targeting targetPort 8080.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: my-app-service\nspec:\n  selector:\n    app: my-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: LoadBalancer"}
{"instruction": "Write a bash one-liner to check if the disk usage of the root partition ('/') is greater than 85% and print a warning message if true.", "output": "df -h / | awk 'NR==2 { print $5 }' | sed 's/%//' | awk '{ if($1 > 85) print \"Warning: Disk usage is above 85%\" }'"}
{"instruction": "Create a Kubernetes ConfigMap definition named 'app-settings' containing a key 'config.json' with some JSON content, and show how to mount it as a volume in a Pod spec.", "output": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-settings\ndata:\n  config.json: |\n    {\n      \"debug\": true,\n      \"theme\": \"dark\"\n    }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: config-pod\nspec:\n  containers:\n    - name: app\n      image: my-app:latest\n      volumeMounts:\n      - name: config-volume\n        mountPath: /etc/config\n  volumes:\n    - name: config-volume\n      configMap:\n        name: app-settings"}
{"instruction": "Create a multi-stage Dockerfile for a Go application to minimize the final image size.", "output": "FROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp main.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/myapp .\nCMD [\"./myapp\"]"}
{"instruction": "Write a Kubernetes Deployment manifest for an nginx application with 3 replicas and a specific rolling update strategy.", "output": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n        ports:\n        - containerPort: 80"}
{"instruction": "Write a Bash script that iterates through a list of URLs and checks if they return a 200 HTTP status code.", "output": "#!/bin/bash\nURLS=(\"http://example.com\" \"http://google.com\")\n\nfor url in \"${URLS[@]}\"; do\n  STATUS=$(curl -o /dev/null -s -w \"%{http_code}\" \"$url\")\n  if [ \"$STATUS\" -eq 200 ]; then\n    echo \"$url is UP\"\n  else\n    echo \"$url is DOWN (Status: $STATUS)\"\n  fi\ndone"}
{"instruction": "Create a docker-compose.yml file to deploy a PostgreSQL database with a persistent volume and custom credentials.", "output": "version: '3.8'\nservices:\n  db:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydb\n    volumes:\n      - db_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n  db_data:"}
{"instruction": "Define a Kubernetes Service to expose a deployment named 'backend' internally within the cluster on port 80 targeting container port 5000.", "output": "apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 5000\n  type: ClusterIP"}
{"instruction": "Write a one-liner Bash command to find and delete all '.log' files in '/var/log/myapp' that are older than 30 days.", "output": "find /var/log/myapp -name \"*.log\" -type f -mtime +30 -exec rm {} \\;"}
{"instruction": "Create a GitHub Actions workflow file to build and push a Docker image to Docker Hub when a push occurs on the 'main' branch.", "output": "name: Docker Image CI\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Login to Docker Hub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    - name: Build and push\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: user/app:latest"}
{"instruction": "Create a Kubernetes Pod manifest that injects environment variables from a ConfigMap named 'app-config'.", "output": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: env-pod\nspec:\n  containers:\n  - name: test-container\n    image: busybox\n    command: [ \"sh\", \"-c\", \"env\" ]\n    envFrom:\n    - configMapRef:\n        name: app-config"}
{"instruction": "Provide the Docker CLI command to run a Redis container with a named volume 'redis_data' mounted to '/data'.", "output": "docker run -d --name my-redis -v redis_data:/data -p 6379:6379 redis:alpine"}
{"instruction": "Write a Bash script to alert (echo message) if the disk usage of the root partition exceeds 90%.", "output": "#!/bin/bash\nUSAGE=$(df / | grep / | awk '{ print $5 }' | sed 's/%//g')\nTHRESHOLD=90\n\nif [ \"$USAGE\" -gt \"$THRESHOLD\" ]; then\n  echo \"Disk usage is critical: ${USAGE}%\"\nfi"}
