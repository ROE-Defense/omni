{"instruction": "Create a simple counter application using the `provider` package. The solution should include a `ChangeNotifier` class for the counter state and a main widget that consumes this state to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw fill\n    canvas.drawCircle(center, radius, fillPaint);\n    // Draw border\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Using `flutter_riverpod`, create a `StateNotifier` to manage a list of Todo strings. Include a method to add a todo and a method to remove a todo. Display the list using a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\n// Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Todos')),\n        body: ListView.builder(\n          itemCount: todos.length,\n          itemBuilder: (context, index) {\n            return ListTile(\n              title: Text(todos[index]),\n              trailing: IconButton(\n                icon: const Icon(Icons.delete),\n                onPressed: () => ref.read(todoListProvider.notifier).remove(todos[index]),\n              ),\n            );\n          },\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(todoListProvider.notifier).add('New Task ${todos.length + 1}'),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`. Handle the `PlatformException` if the platform interaction fails.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `FutureProvider` using `flutter_riverpod` that simulates fetching a user's name from an API with a 2-second delay. Consume this provider in a widget handling loading, error, and data states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nvoid main() => runApp(const ProviderScope(child: MaterialApp(home: UserProfile())));\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Async Value Example')),\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data', style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (error, stack) => Text('Error: $error', style: const TextStyle(color: Colors.red)),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` to draw a dotted line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DottedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const double dashWidth = 5.0;\n    const double dashSpace = 5.0;\n    double startX = 0;\n    \n    // Draw horizontal dotted line across the width\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\n// Usage\nclass DottedLineWidget extends StatelessWidget {\n  const DottedLineWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(300, 20),\n      painter: DottedLinePainter(),\n    );\n  }\n}"}
{"instruction": "Demonstrate how to use `MultiProvider` from the `provider` package to inject two separate ChangeNotifiers (`AuthModel` and `ThemeModel`) into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  bool isLoggedIn = false;\n  void login() { isLoggedIn = true; notifyListeners(); }\n}\n\nclass ThemeModel extends ChangeNotifier {\n  bool isDark = false;\n  void toggleTheme() { isDark = !isDark; notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Accessing providers to demonstrate they are available\n    final theme = context.watch<ThemeModel>();\n    return MaterialApp(\n      theme: theme.isDark ? ThemeData.dark() : ThemeData.light(),\n      home: const Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Create a Flutter widget that listens to a platform-specific stream of events (e.g., sensor data) using `EventChannel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorListener extends StatefulWidget {\n  const SensorListener({super.key});\n\n  @override\n  State<SensorListener> createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(dynamic event) {\n    setState(() {\n      _sensorData = \"Sensor Value: $event\";\n    });\n  }\n\n  void _onError(dynamic error) {\n    setState(() {\n      _sensorData = \"Sensor Error: $error\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Using `flutter_riverpod`, demonstrate the `family` modifier to create a provider that accepts an integer ID as an argument to fetch a specific item string.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Provider family accepting an int ID\nfinal itemProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Item Details for ID: $id';\n});\n\nclass ItemDetailWidget extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailWidget({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the specific provider instance based on itemId\n    final itemAsync = ref.watch(itemProvider(itemId));\n\n    return itemAsync.when(\n      data: (label) => Text(label),\n      loading: () => const CircularProgressIndicator(),\n      error: (e, st) => const Text('Failed to load'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a Quadratic Bezier Curve (a smooth curve) from the bottom-left to the top-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    \n    // Draw curve to top right\n    // Control point is at top left (0,0), End point is bottom right (size.width, size.height)\n    // Actually, let's do bottom-left to top-right visually\n    // Start: (0, height)\n    // Control: (width / 2, 0) -> Pulls the curve up towards the top center\n    // End: (width, height * 0.5)\n    path.quadraticBezierTo(\n      size.width / 2, \n      0, \n      size.width, \n      size.height / 2\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass CurveWidget extends StatelessWidget {\n  const CurveWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(300, 200),\n      painter: CurvePainter(),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod 2.0 (Annotation syntax) with a Notifier class.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'counter.g.dart';\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('Count: $count')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'WavePainter' using CustomPainter to draw a bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WaveWidget extends StatelessWidget {\n  const WaveWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: WavePainter(),\n    );\n  }\n}\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.7);\n    path.quadraticBezierTo(\n      size.width * 0.25,\n      size.height * 0.8,\n      size.width * 0.5,\n      size.height * 0.7,\n    );\n    path.quadraticBezierTo(\n      size.width * 0.75,\n      size.height * 0.6,\n      size.width,\n      size.height * 0.7,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a Todo List manager using Provider with a `ChangeNotifier` that supports adding and toggling tasks.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Todo {\n  String title;\n  bool isDone;\n  Todo({required this.title, this.isDone = false});\n}\n\nclass TodoProvider extends ChangeNotifier {\n  final List<Todo> _todos = [];\n  List<Todo> get todos => _todos;\n\n  void addTodo(String title) {\n    _todos.add(Todo(title: title));\n    notifyListeners();\n  }\n\n  void toggleTodo(int index) {\n    _todos[index].isDone = !_todos[index].isDone;\n    notifyListeners();\n  }\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => TodoProvider(),\n      child: MaterialApp(\n        home: Scaffold(\n          body: Consumer<TodoProvider>(\n            builder: (context, todoProvider, child) {\n              return ListView.builder(\n                itemCount: todoProvider.todos.length,\n                itemBuilder: (context, index) {\n                  final todo = todoProvider.todos[index];\n                  return ListTile(\n                    title: Text(todo.title),\n                    leading: Checkbox(\n                      value: todo.isDone,\n                      onChanged: (_) => todoProvider.toggleTodo(index),\n                    ),\n                  );\n                },\n              );\n            },\n          ),\n          floatingActionButton: Builder(builder: (context) {\n             return FloatingActionButton(\n               onPressed: () => context.read<TodoProvider>().addTodo('New Task'),\n               child: const Icon(Icons.add),\n             );\n          }),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display a list of strings (simulating an API call) with loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<List<String>> fetchUsers() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return ['Alice', 'Bob', 'Charlie'];\n}\n\nfinal userProvider = FutureProvider<List<String>>((ref) async {\n  return fetchUsers();\n});\n\nclass UserListScreen extends ConsumerWidget {\n  const UserListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User List')),\n      body: asyncValue.when(\n        data: (users) => ListView.builder(\n          itemCount: users.length,\n          itemBuilder: (context, index) => ListTile(title: Text(users[index])),\n        ),\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (err, stack) => Center(child: Text('Error: $err')),\n      ),\n    );\n  }\n}"}
{"instruction": "Create an animated CustomPainter that draws a pulsing circle based on an AnimationController value.", "output": "import 'package:flutter/material.dart';\n\nclass PulsingCircle extends StatefulWidget {\n  const PulsingCircle({super.key});\n\n  @override\n  State<PulsingCircle> createState() => _PulsingCircleState();\n}\n\nclass _PulsingCircleState extends State<PulsingCircle>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 2),\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      builder: (context, child) {\n        return CustomPaint(\n          painter: CirclePainter(_controller.value),\n          size: const Size(200, 200),\n        );\n      },\n    );\n  }\n}\n\nclass CirclePainter extends CustomPainter {\n  final double value;\n  CirclePainter(this.value);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue.withOpacity(1.0 - value)\n      ..style = PaintingStyle.fill;\n\n    final radius = (size.width / 2) * value;\n    canvas.drawCircle(size.center(Offset.zero), radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CirclePainter oldDelegate) {\n    return oldDelegate.value != value;\n  }\n}"}
{"instruction": "Use the `Selector` widget from the Provider package to listen only to a specific property (age) of a User model to prevent rebuilding when the name changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds if 'age' changes, ignores 'name' changes\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement an EventChannel in Flutter to listen to a continuous stream of data from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  Stream<double>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    _sensorStream = _eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder<double>(\n          stream: _sensorStream,\n          builder: (context, snapshot) {\n            if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n            if (!snapshot.hasData) return const Text('Waiting for sensor data...');\n            return Text('Sensor Value: ${snapshot.data}');\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n    final double endX = size.width;\n\n    while (startX < endX) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Setup a MultiProvider to provide both an Authentication service and a Theme settings service to the app tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthService extends ChangeNotifier {\n  bool isLoggedIn = false;\n  void login() { isLoggedIn = true; notifyListeners(); }\n}\n\nclass ThemeService extends ChangeNotifier {\n  bool isDarkMode = false;\n  void toggleTheme() { isDarkMode = !isDarkMode; notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => ThemeService()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = Provider.of<ThemeService>(context);\n    return MaterialApp(\n      theme: theme.isDarkMode ? ThemeData.dark() : ThemeData.light(),\n      home: const Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod for state management. Define a `StateProvider` and a `ConsumerWidget` to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text('$count', style: Theme.of(context).textTheme.headlineMedium),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a simple red circle with a blue stroke in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Stroke\n    final strokePaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, strokePaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a basic `ChangeNotifier` using the Provider package to toggle between light and dark themes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 2. Listen to the provider for theme changes\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: themeNotifier.isDark ? ThemeData.dark() : ThemeData.light(),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: Switch(\n            value: themeNotifier.isDark,\n            onChanged: (_) => themeNotifier.toggleTheme(),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a list of strings asynchronously and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define FutureProvider\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network\n  return ['Apple', 'Banana', 'Orange'];\n});\n\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the async value\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Async Data')),\n      body: Center(\n        child: asyncValue.when(\n          data: (items) => ListView.builder(\n            itemCount: items.length,\n            itemBuilder: (ctx, index) => ListTile(title: Text(items[index])),\n          ),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a sine wave path across the canvas.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 3.0;\n\n    final path = Path();\n    final double midY = size.height / 2;\n    path.moveTo(0, midY);\n\n    for (double x = 0; x <= size.width; x++) {\n      // Calculate Y based on Sine function\n      double y = midY + 30 * sin((x / size.width) * 2 * pi * 2);\n      path.lineTo(x, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the Provider package to manage a shopping cart list. Create a `CartModel` that allows adding items and computing total price.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Item {\n  final String name;\n  final double price;\n  Item(this.name, this.price);\n}\n\nclass CartModel extends ChangeNotifier {\n  final List<Item> _items = [];\n\n  List<Item> get items => _items;\n\n  double get totalPrice => _items.fold(0, (total, current) => total + current.price);\n\n  void addItem(Item item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void removeAll() {\n    _items.clear();\n    notifyListeners();\n  }\n}\n\n// Usage example widget\nclass CartScreen extends StatelessWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<CartModel>(\n      builder: (context, cart, child) {\n        return Column(\n          children: [\n            Text('Total: \\$${cart.totalPrice}'),\n            ElevatedButton(\n              onPressed: () => cart.addItem(Item('Product', 10.0)),\n              child: const Text('Add Item'),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Implement a `MethodChannel` call in Dart to send a string message to the native platform (e.g., to show a native Toast).", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass ToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      debugPrint(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}\n\n// Usage inside a widget\nclass ToastButton extends StatelessWidget {\n  const ToastButton({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () => ToastService().showToast('Hello from Flutter!'),\n      child: const Text('Show Native Toast'),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches user details based on a user ID passed as an argument.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Dummy User model\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// 1. Define the family provider\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network request\n  await Future.delayed(const Duration(seconds: 1));\n  return User(userId, 'User #$userId');\n});\n\n// 2. Usage in ConsumerWidget\nimport 'package:flutter/material.dart';\n\nclass UserProfile extends ConsumerWidget {\n  final int userId;\n  const UserProfile({super.key, required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider(userId));\n\n    return userAsync.when(\n      data: (user) => Text('Hello, ${user.name}'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` to draw a 5-pointed star shape.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass StarPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.amber\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    final double cx = size.width / 2;\n    final double cy = size.height / 2;\n    final double radius = min(size.width, size.height) / 2;\n    final double innerRadius = radius / 2.5;\n\n    double rot = -pi / 2 * 3; \n    double step = pi / 5;\n\n    path.moveTo(cx, cy - radius);\n    \n    for (int i = 0; i < 5; i++) {\n      double x = cx + cos(rot) * radius;\n      double y = cy + sin(rot) * radius;\n      path.lineTo(x, y);\n      rot += step;\n\n      x = cx + cos(rot) * innerRadius;\n      y = cy + sin(rot) * innerRadius;\n      path.lineTo(x, y);\n      rot += step;\n    }\n    \n    path.close();\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod. Define a `StateProvider` for the integer count and a `ConsumerWidget` that displays the count and increments it via a FloatingActionButton.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a custom painter in Flutter that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass MyCircleWidget extends StatelessWidget {\n  const MyCircleWidget({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Setup the Flutter side of a MethodChannel to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a Todo List manager using the `Provider` package with `ChangeNotifier`. Include a method to add a task and a method to toggle the completion status.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Todo {\n  String title;\n  bool isDone;\n  Todo({required this.title, this.isDone = false});\n}\n\nclass TodoProvider extends ChangeNotifier {\n  final List<Todo> _todos = [];\n\n  List<Todo> get todos => _todos;\n\n  void addTodo(String title) {\n    _todos.add(Todo(title: title));\n    notifyListeners();\n  }\n\n  void toggleTodo(int index) {\n    _todos[index].isDone = !_todos[index].isDone;\n    notifyListeners();\n  }\n}\n\n// Usage in main:\n// ChangeNotifierProvider(create: (_) => TodoProvider(), child: MyApp());"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a configuration string from a simulated asynchronous API and display the result using `.when` to handle loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchConfig() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Dark Mode Enabled';\n}\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  return await fetchConfig();\n});\n\nclass ConfigScreen extends ConsumerWidget {\n  const ConfigScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: configAsync.when(\n          data: (config) => Text('Config: $config'),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    \n    // Draw curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate how to use `ProxyProvider` from the `provider` package to inject a value from an `AuthModel` into a `DatabaseModel` whenever the auth state changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? userId = 'user_123';\n}\n\nclass DatabaseModel {\n  final String? userId;\n  DatabaseModel(this.userId);\n\n  String getData() => 'Data for user: $userId';\n}\n\nclass AppSetup extends StatelessWidget {\n  const AppSetup({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, DatabaseModel>(\n          update: (context, auth, previousDb) => DatabaseModel(auth.userId),\n        ),\n      ],\n      child: const MaterialApp(home: HomeScreen()),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    final db = Provider.of<DatabaseModel>(context);\n    return Text(db.getData());\n  }\n}"}
{"instruction": "Create a `StateNotifier` and `StateNotifierProvider` using Riverpod to manage a list of strings (e.g., a shopping list). Include a method to add an item immutably.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier managing an immutable List<String>\nclass ShoppingListNotifier extends StateNotifier<List<String>> {\n  ShoppingListNotifier() : super([]);\n\n  void addItem(String item) {\n    // Update state immutably by creating a new list\n    state = [...state, item];\n  }\n\n  void removeItem(String item) {\n    state = state.where((element) => element != item).toList();\n  }\n}\n\nfinal shoppingListProvider = StateNotifierProvider<ShoppingListNotifier, List<String>>((ref) {\n  return ShoppingListNotifier();\n});"}
{"instruction": "Implement the Flutter side of an `EventChannel` to listen to a continuous stream of events (e.g., sensor data) from native code.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorListener();\n  }\n\n  void _enableSensorListener() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = event as double;\n        });\n      },\n      onError: (dynamic error) {\n        debugPrint('Received error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a circular progress indicator using a SweepGradient to create a colorful arc.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n    final rect = Rect.fromCircle(center: center, radius: radius);\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round;\n\n    // Define gradient\n    final gradient = const SweepGradient(\n      startAngle: -pi / 2,\n      endAngle: 3 * pi / 2,\n      colors: [Colors.blue, Colors.purple, Colors.red],\n      tileMode: TileMode.repeated,\n    );\n\n    paint.shader = gradient.createShader(rect);\n\n    // Draw arc starting from top (-pi/2)\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a simple Counter implementation using the 'provider' package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) => Text('${counter.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'FutureProvider' using Riverpod to fetch a String asynchronously and display the loading, error, or data state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Data Loaded';\n});\n\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), size: Size(200, 200))"}
{"instruction": "Set up a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result%.';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}';\n    }\n  }\n}"}
{"instruction": "Use Riverpod's StateNotifier to manage a Todo List (adding and toggling items).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a smooth arch).", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Control point at top center, end point at bottom right\n    path.quadraticBezierTo(size.width / 2, 0, size.width, size.height);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Provider 'Selector' to only rebuild a widget when a specific property of the model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds if 'age' changes, ignores 'name' changes\n    return Selector<UserModel, int>(\n      selector: (_, model) => model.age,\n      builder: (_, age, __) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a generic EventChannel in Dart to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double> get sensorDataStream {\n    return _eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that accepts an argument (e.g., fetching user by ID).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that takes an integer ID and returns a string\nfinal userProvider = Provider.family<String, int>((ref, userId) {\n  return 'User $userId';\n});\n\n// Usage in a ConsumerWidget:\n// final userName = ref.watch(userProvider(42));"}
{"instruction": "Create a CustomPainter to draw a dotted line.", "output": "import 'package:flutter/material.dart';\n\nclass DottedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(Offset(startX, 0), Offset(startX + dashWidth, 0), paint);\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic Flutter counter application using the `provider` package, employing a `ChangeNotifier` to manage the count state.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a string from a simulated API and display it using a `ConsumerWidget`, handling loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create the provider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Data fetched from API';\n});\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: DataScreen())));\n}\n\n// 2. Consume the provider\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class named `CirclePainter` that draws a blue circle with a radius of 50 and a red stroke border of width 4 in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n\n    // Paint for the fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Paint for the border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw filled circle\n    canvas.drawCircle(center, 50, fillPaint);\n    // Draw border\n    canvas.drawCircle(center, 50, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel` and handle potential `PlatformException`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Todo list manager using Riverpod's `StateNotifier` and `StateNotifierProvider`. Include a method to add a todo string.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier to manage the List<String>\nclass TodoNotifier extends StateNotifier<List<String>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// The provider definition\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<String>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (wave) at the bottom of the canvas using the `Path` class.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    \n    // Create a curve to the other side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate how to initialize a Flutter app with multiple providers (`AuthService` and `ThemeService`) using the `MultiProvider` widget from the `provider` package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthService extends ChangeNotifier {}\nclass ThemeService extends ChangeNotifier {}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => ThemeService()),\n      ],\n      child: const MaterialApp(\n        home: Scaffold(body: Center(child: Text('MultiProvider App'))),\n      ),\n    ),\n  );\n}"}
{"instruction": "Implement the Dart side of an `EventChannel` to listen to a continuous stream of events (e.g., sensor data) named 'com.example.sensors/stream'.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.sensors/stream');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() {\n        _sensorValue = event as double;\n      });\n    }, onError: (dynamic error) {\n      debugPrint('Received error: ${error.message}');\n    });\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Create a `CustomPainter` that fills the canvas with a linear gradient from top-left (red) to bottom-right (blue).", "output": "import 'package:flutter/material.dart';\nimport 'dart:ui' as ui;\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = ui.Gradient.linear(\n        rect.topLeft,\n        rect.bottomRight,\n        [\n          Colors.red,\n          Colors.blue,\n        ],\n      );\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches user details based on a specific user ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Define a FutureProvider family that takes an int (userId) as an argument\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network delay\n  await Future.delayed(const Duration(milliseconds: 500));\n  // Return fake data based on ID\n  return User(userId, 'User #$userId');\n});\n\n// Usage in ConsumerWidget:\n// ref.watch(userProvider(123));"}
{"instruction": "Create a simple counter application using Riverpod for state management. Define a StateProvider and a ConsumerWidget to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\n// 3. Use ConsumerWidget to listen to provider changes\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Paint for the fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Paint for the border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw filled circle\n    canvas.drawCircle(center, radius, fillPaint);\n    \n    // Draw border\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Create the channel\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use the Provider package to create a simple Theme Switcher using ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Provide the notifier\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 3. Listen to changes for the MaterialApp theme\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: themeNotifier.currentTheme,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // 4. Trigger the toggle\n              context.read<ThemeNotifier>().toggleTheme();\n            },\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod FutureProvider to fetch a list of strings (simulated API) and display them using .when().", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the FutureProvider\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return ['Apple', 'Banana', 'Cherry', 'Date'];\n});\n\nclass DataListScreen extends ConsumerWidget {\n  const DataListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the AsyncValue\n    final asyncData = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Async Data')),\n      body: asyncData.when(\n        // 3. Handle data state\n        data: (items) => ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (_, index) => ListTile(title: Text(items[index])),\n        ),\n        // 4. Handle error state\n        error: (err, stack) => Center(child: Text('Error: $err')),\n        // 5. Handle loading state\n        loading: () => const Center(child: CircularProgressIndicator()),\n      ),\n    );\n  }\n}"}
{"instruction": "Develop a CustomPainter to draw a dashed line horizontally across the screen.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..style = PaintingStyle.stroke;\n\n    const dashWidth = 10.0;\n    const dashSpace = 5.0;\n    double startX = 0;\n\n    // Loop to draw dashes\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass DashedLineWidget extends StatelessWidget {\n  const DashedLineWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 20),\n      painter: DashedLinePainter(),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod StateNotifier to manage a complex object state (e.g., a User model with name and age).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the model\nclass User {\n  final String name;\n  final int age;\n  User(this.name, this.age);\n\n  User copyWith({String? name, int? age}) {\n    return User(name ?? this.name, age ?? this.age);\n  }\n}\n\n// 2. Define the StateNotifier\nclass UserNotifier extends StateNotifier<User> {\n  UserNotifier() : super(User('Guest', 0));\n\n  void updateName(String newName) {\n    state = state.copyWith(name: newName);\n  }\n\n  void incrementAge() {\n    state = state.copyWith(age: state.age + 1);\n  }\n}\n\n// 3. Define the provider\nfinal userProvider = StateNotifierProvider<UserNotifier, User>((ref) {\n  return UserNotifier();\n});\n\n// Usage in Widget (Abstracted)\n// ref.watch(userProvider).name\n// ref.read(userProvider.notifier).incrementAge()"}
{"instruction": "Implement a CustomPainter that draws a simple smiley face (yellow circle, two eyes, and an arc for the mouth).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math' as math;\n\nclass SmileyPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Face\n    final facePaint = Paint()..color = Colors.yellow;\n    canvas.drawCircle(center, radius, facePaint);\n\n    // Eyes\n    final eyePaint = Paint()..color = Colors.black;\n    canvas.drawCircle(\n        Offset(center.dx - radius / 3, center.dy - radius / 3), 10, eyePaint);\n    canvas.drawCircle(\n        Offset(center.dx + radius / 3, center.dy - radius / 3), 10, eyePaint);\n\n    // Mouth (Arc)\n    final mouthPaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5\n      ..strokeCap = StrokeCap.round;\n\n    final rect = Rect.fromCircle(center: center, radius: radius / 1.5);\n    // Draw arc from 0 to PI (semi-circle), starting from PI/12 to center it slightly\n    canvas.drawArc(rect, 0.1 * math.pi, 0.8 * math.pi, false, mouthPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Dart function to send data (a map) to the native platform using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass NativeBridge {\n  static const platform = MethodChannel('com.example.app/data');\n\n  Future<void> sendUserData(String name, int id) async {\n    try {\n      final arguments = <String, dynamic>{\n        'name': name,\n        'id': id,\n      };\n      \n      // Invoke method with arguments\n      await platform.invokeMethod('sendUserData', arguments);\n      print('Data sent successfully');\n    } on PlatformException catch (e) {\n      print(\"Failed to send data: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Use Provider to create a simple Shopping Cart where items can be added and the total count is displayed.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n\n  List<String> get items => _items;\n  int get count => _items.length;\n\n  void addItem(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\nclass CartScreen extends StatelessWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CartModel(),\n      child: Scaffold(\n        appBar: AppBar(\n          title: Consumer<CartModel>(\n            builder: (context, cart, child) => Text('Cart Items: ${cart.count}'),\n          ),\n        ),\n        body: Consumer<CartModel>(\n          builder: (context, cart, child) {\n            return ListView.builder(\n              itemCount: cart.items.length,\n              itemBuilder: (ctx, i) => ListTile(title: Text(cart.items[i])),\n            );\n          },\n        ),\n        floatingActionButton: Consumer<CartModel>(\n          builder: (context, cart, child) => FloatingActionButton(\n            onPressed: () => cart.addItem('Item ${cart.count + 1}'),\n            child: const Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple Counter application using the Provider package for state management. Define a `ChangeNotifier` class and wrap the app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel'. Return 'Unknown battery level' if the platform code fails.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod (specifically `StateNotifierProvider` or `NotifierProvider`) to manage a simple Todo list where you can add strings to the list.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the Notifier\nclass TodoList extends Notifier<List<String>> {\n  @override\n  List<String> build() => [];\n\n  void add(String description) {\n    state = [...state, description];\n  }\n}\n\n// 2. Define the Provider\nfinal todoListProvider = NotifierProvider<TodoList, List<String>>(TodoList.new);\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: TodoScreen())));\n}\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todo')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (_, index) => ListTile(title: Text(todos[index])),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a smile arc) on the screen.", "output": "import 'package:flutter/material.dart';\n\nclass SmilePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    final path = Path();\n    // Start point (left side of smile)\n    path.moveTo(size.width * 0.2, size.height * 0.5);\n    \n    // Control point (bottom center) and End point (right side)\n    path.quadraticBezierTo(\n      size.width * 0.5, \n      size.height * 0.8, \n      size.width * 0.8, \n      size.height * 0.5\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod `FutureProvider` to simulate fetching user data asynchronously and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUser();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> user = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: user.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use `Selector` from the Provider package to optimize a widget so it only rebuilds when a specific property (`age`) of the model changes, ignoring other property changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Person extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void growOlder() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeWidget extends StatelessWidget {\n  const AgeWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // This widget only rebuilds when 'age' changes\n    return Selector<Person, int>(\n      selector: (context, person) => person.age,\n      builder: (context, age, child) {\n        print('AgeWidget rebuilding');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('samples.flutter.dev/sensor');\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    // Listen to the stream\n    eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(Object? event) {\n    setState(() {\n      _sensorData = \"Sensor: $event\";\n    });\n  }\n\n  void _onError(Object error) {\n    setState(() {\n      _sensorData = \"Error: $error\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress bar with a gradient fill.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBarPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientBarPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    \n    // Background\n    final bgPaint = Paint()..color = Colors.grey[300]!;\n    canvas.drawRect(rect, bgPaint);\n\n    // Foreground Gradient\n    final gradientRect = Rect.fromLTWH(0, 0, size.width * progress, size.height);\n    final gradientPaint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.blue, Colors.purple],\n      ).createShader(gradientRect);\n\n    canvas.drawRect(gradientRect, gradientPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientBarPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Demonstrate the use of Riverpod's `.family` modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific data.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Provider that accepts an integer ID\nfinal itemProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Item Details for ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific ID\n    final itemAsync = ref.watch(itemProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Family Modifier')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, st) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod (v2) with a StateProvider to manage the count integer.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\n// 3. Extend ConsumerWidget to access the ref\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider state\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 5. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Calculate center and radius\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // No dynamic state to repaint\n  }\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: BlueCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a basic Provider (ChangeNotifier) implementation to handle switching between Light and Dark themes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Provide the notifier\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 3. Consume the theme mode\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeNotifier.mode,\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Theme Switcher')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // 4. Trigger the toggle\n            context.read<ThemeNotifier>().toggleTheme();\n          },\n          child: const Text('Toggle Theme'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Flutter-side code to invoke a Platform Channel method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching a user name asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the AsyncValue\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Async User Fetch')),\n      body: Center(\n        // 3. Handle states using .when\n        child: userAsync.when(\n          data: (name) => Text('User: $name', style: const TextStyle(fontSize: 24)),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a rectangle with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    // Define the rectangle area\n    final rect = Offset.zero & size;\n\n    // Create a linear gradient shader\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.orange],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    // Draw the rectangle\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass GradientBox extends StatelessWidget {\n  const GradientBox({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(300, 150),\n      painter: GradientRectPainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Shopping Cart using the Provider package. Include methods to add items, remove items, and calculate the total price.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Item {\n  final String name;\n  final double price;\n  Item(this.name, this.price);\n}\n\nclass CartModel extends ChangeNotifier {\n  final List<Item> _items = [];\n\n  List<Item> get items => List.unmodifiable(_items);\n\n  double get totalPrice => _items.fold(0, (total, current) => total + current.price);\n\n  void add(Item item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(Item item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n}\n\n// Usage example inside a build method:\n// final cart = context.watch<CartModel>();\n// Text(\"Total: \\${cart.totalPrice}\");"}
{"instruction": "Set up an EventChannel in Flutter to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  // 1. Define EventChannel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No Data';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    // 2. Listen to the stream\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: $error';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an ID argument to fetch specific data.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define family provider expecting an int ID\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch provider with specific argument\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Family Modifier')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, st) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a path representing a simple Sine Wave.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n\n    final path = Path();\n    final double midY = size.height / 2;\n    bool firstPoint = true;\n\n    // Loop through width to calculate Sine values\n    for (double x = 0; x <= size.width; x++) {\n      // Frequency and Amplitude logic\n      double y = midY + 50 * sin((x / size.width) * 4 * pi);\n      \n      if (firstPoint) {\n        path.moveTo(x, y);\n        firstPoint = false;\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter app using the `Provider` package. Include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<Counter>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a filled blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod `StateNotifier` and `StateNotifierProvider` to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// The StateNotifier class\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((todo) => todo != description).toList();\n  }\n}\n\n// The Provider definition\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch data asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Fake API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUser();\n});\n\nclass UserWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> user = ref.watch(userProvider);\n\n    return user.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a bezier curve wave at the bottom of the container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Line to start of wave (left side, slightly up)\n    path.lineTo(0, size.height * 0.8);\n    \n    // Bezier curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Line to bottom right\n    path.lineTo(size.width, size.height);\n    // Close the path\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Setup a `MultiProvider` to inject two different ChangeNotifiers (AuthModel and CartModel) into the app.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {}\nclass CartModel extends ChangeNotifier {}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => CartModel()),\n      ],\n      child: const MaterialApp(\n        home: Scaffold(body: Text('App with MultiProvider')),\n      ),\n    ),\n  );\n}"}
{"instruction": "Implement the Dart side of an `EventChannel` to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  Stream<double>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    // Map dynamic events to double\n    _sensorStream = eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<double>(\n      stream: _sensorStream,\n      builder: (context, snapshot) {\n        if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n        if (snapshot.hasData) return Text('Sensor Value: ${snapshot.data}');\n        return const Text('Waiting for sensor data...');\n      },\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches a specific item based on an ID parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock fetch function\nFuture<String> fetchItemById(int id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Item #$id';\n}\n\n// Family provider definition\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemById(id);\n});\n\n// Usage\n// ref.watch(itemFamilyProvider(42));"}
{"instruction": "Create a CustomPainter that draws a radial gradient arc (progress bar style).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 3 * pi / 2; // 75% progress\n    final useCenter = false;\n    \n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: pi * 2,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, startAngle, sweepAngle, useCenter, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic counter application using Flutter Riverpod's `StateProvider`. Include the `ProviderScope` and a `ConsumerWidget` to read and modify the state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: CounterApp()),\n    ),\n  );\n}\n\nclass CounterApp extends ConsumerWidget {\n  const CounterApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a `CustomPainter` class named `BlueCirclePainter` that draws a filled blue circle in the center of the available space.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.shortestSide / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel` and handle potential `PlatformException`s.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher extends StatefulWidget {\n  const BatteryLevelFetcher({super.key});\n\n  @override\n  State<BatteryLevelFetcher> createState() => _BatteryLevelFetcherState();\n}\n\nclass _BatteryLevelFetcherState extends State<BatteryLevelFetcher> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a `CounterModel` using `ChangeNotifier` and show how to provide it to the app using `ChangeNotifierProvider` from the `provider` package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, model, child) => Text('${model.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Provider.of<CounterModel>(context, listen: false).increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching data and handle the loading, error, and data states in the UI using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a thick red line from the top-left corner to the bottom-right corner of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass DiagonalLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..strokeWidth = 5.0\n      ..strokeCap = StrokeCap.round;\n\n    canvas.drawLine(\n      Offset.zero,\n      Offset(size.width, size.height),\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up an `EventChannel` in a StatefulWidget to listen to a stream of events (e.g., sensor readings) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensor();\n  }\n\n  void _enableSensor() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() {\n        _sensorValue = event as double;\n      });\n    }, onError: (dynamic error) {\n      debugPrint('Received error: ${error.message}');\n    });\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Implement a `ThemeNotifier` using Riverpod's `StateNotifier` to toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass ThemeNotifier extends StateNotifier<ThemeMode> {\n  ThemeNotifier() : super(ThemeMode.light);\n\n  void toggleTheme() {\n    state = state == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n  }\n}\n\nfinal themeProvider = StateNotifierProvider<ThemeNotifier, ThemeMode>((ref) {\n  return ThemeNotifier();\n});\n\n// Usage in App:\n// final themeMode = ref.watch(themeProvider);\n// MaterialApp(themeMode: themeMode, ...)"}
{"instruction": "Write a `CustomPainter` that paints the text 'Hello Flutter' in the center of the canvas using `TextPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    const textStyle = TextStyle(color: Colors.black, fontSize: 20);\n    const textSpan = TextSpan(text: 'Hello Flutter', style: textStyle);\n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n    \n    textPainter.layout(minWidth: 0, maxWidth: size.width);\n    \n    final xCenter = (size.width - textPainter.width) / 2;\n    final yCenter = (size.height - textPainter.height) / 2;\n    \n    textPainter.paint(canvas, Offset(xCenter, yCenter));\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Show how to use `MultiProvider` to inject two providers, `AuthModel` and `CartModel`, at the root of the application.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {}\nclass CartModel extends ChangeNotifier {}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => CartModel()),\n      ],\n      child: const MaterialApp(\n        home: Scaffold(body: Center(child: Text('MultiProvider App'))),\n      ),\n    ),\n  );\n}"}
{"instruction": "Create a simple Counter feature using `flutter_riverpod` with a `StateProvider`. Include the `ProviderScope`, the provider definition, and a `ConsumerWidget` to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.shortestSide / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Dart function to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Set up a `ChangeNotifier` class for a User Profile and wrap the app with a `ChangeNotifierProvider` using the `provider` package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserProfile extends ChangeNotifier {\n  String _name = 'Guest';\n  String get name => _name;\n\n  void updateName(String newName) {\n    _name = newName;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => UserProfile(),\n      child: const MaterialApp(home: HomeScreen()),\n    ),\n  );\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(/* ... */);\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a list of strings asynchronously and display the loading, error, and data states in a Widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal listProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return ['Apple', 'Banana', 'Orange'];\n});\n\nclass FruitListScreen extends ConsumerWidget {\n  const FruitListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(listProvider);\n\n    return asyncValue.when(\n      data: (items) => ListView.builder(\n        itemCount: items.length,\n        itemBuilder: (c, i) => ListTile(title: Text(items[i])),\n      ),\n      error: (err, stack) => Center(child: Text('Error: $err')),\n      loading: () => const Center(child: CircularProgressIndicator()),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height * 1.0,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a class to listen to a stream of events (e.g., sensor data) from native code using `EventChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('com.example.app/sensor');\n\n  Stream<double> get sensorDataStream {\n    return _channel.receiveBroadcastStream().map((event) => event as double);\n  }\n}"}
{"instruction": "Use Riverpod's `StateNotifier` to manage a Todo list, including a method to add a new Todo item immutably.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  Todo(this.id, this.description);\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    final newTodo = Todo(DateTime.now().toString(), description);\n    state = [...state, newTodo];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a `CustomPainter` that renders text directly onto the canvas using `TextPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    const textStyle = TextStyle(color: Colors.black, fontSize: 24);\n    const textSpan = TextSpan(text: 'Hello Canvas', style: textStyle);\n    \n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n\n    textPainter.layout(minWidth: 0, maxWidth: size.width);\n    \n    // Draw text centered\n    final x = (size.width - textPainter.width) / 2;\n    final y = (size.height - textPainter.height) / 2;\n    \n    textPainter.paint(canvas, Offset(x, y));\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate how to use `ProxyProvider` from the `provider` package to inject a value from one provider (AuthToken) into another (ApiService).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel {\n  String? token = 'secret_token_123';\n}\n\nclass ApiService {\n  final String? token;\n  ApiService(this.token);\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        Provider<AuthModel>(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, ApiService>(\n          update: (_, auth, __) => ApiService(auth.token),\n        ),\n      ],\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Implement a simple counter application using Flutter Riverpod's `StateProvider` and a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(child: Text('Count: $count')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` class that draws a blue circle with a red border in the center of the available size.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Flutter function that uses `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handles potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a `ChangeNotifier` class for managing a list of Todo items and wrap the app with a `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoNotifier extends ChangeNotifier {\n  final List<String> _todos = [];\n  List<String> get todos => _todos;\n\n  void add(String item) {\n    _todos.add(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => TodoNotifier(),\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch data asynchronously and display the Loading, Error, or Data state using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a triangle path filled with green color.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(size.width / 2, 0);\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a theme toggler using Riverpod's `StateNotifier` and `StateNotifierProvider` to manage a boolean state.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass ThemeNotifier extends StateNotifier<bool> {\n  ThemeNotifier() : super(false); // false = light, true = dark\n\n  void toggleTheme() {\n    state = !state;\n  }\n}\n\nfinal themeProvider = StateNotifierProvider<ThemeNotifier, bool>((ref) {\n  return ThemeNotifier();\n});"}
{"instruction": "Demonstrate how to send parameters (a URL) to the native platform using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nFuture<void> openNativeBrowser(String url) async {\n  const platform = MethodChannel('com.example.browser');\n  try {\n    await platform.invokeMethod('openBrowser', {'url': url});\n  } on PlatformException catch (e) {\n    print(\"Failed to open browser: '${e.message}'.\");\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 3;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width / 2, size.height / 4, size.width, size.height * 0.75);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use `MultiProvider` to inject two different providers (`UserProvider` and `CartProvider`) into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserProvider extends ChangeNotifier {}\nclass CartProvider extends ChangeNotifier {}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => UserProvider()),\n        ChangeNotifierProvider(create: (_) => CartProvider()),\n      ],\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Create a simple counter application using Riverpod's `StateProvider` and a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('Count: $count', style: const TextStyle(fontSize: 24))),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // 3. Update the state\n            ref.read(counterProvider.notifier).state++;\n          },\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red triangle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Top point\n    path.moveTo(size.width / 2, 0);\n    // Bottom right\n    path.lineTo(size.width, size.height);\n    // Bottom left\n    path.lineTo(0, size.height);\n    // Close path to form triangle\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass TriangleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(100, 100),\n      painter: TrianglePainter(),\n    );\n  }\n}"}
{"instruction": "Create a `MethodChannel` implementation in Dart to invoke a native platform method named 'getBatteryLevel'. Include error handling.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Implement a Theme Switcher using the `Provider` package with a `ChangeNotifier`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the Model\nclass ThemeModel extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\n// 2. Wrap App with ChangeNotifierProvider\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeModel>(\n      builder: (context, themeModel, child) {\n        return MaterialApp(\n          theme: themeModel.currentTheme,\n          home: Scaffold(\n            body: Center(\n              child: ElevatedButton(\n                onPressed: themeModel.toggleTheme,\n                child: Text('Switch to ${themeModel.isDark ? \"Light\" : \"Dark\"} Mode'),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Create a `FutureProvider` using Riverpod to fetch a user name after a simulated delay, and handle the loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the AsyncValue\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsync.when(\n          data: (name) => Text('User: $name'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a circular progress arc with a specific percentage.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ArcPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  ArcPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n\n    // Draw background circle\n    canvas.drawCircle(center, radius, paint);\n\n    // Draw progress arc\n    final progressPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    final sweepAngle = 2 * pi * percentage;\n    // -pi/2 to start from top\n    canvas.drawArc(Rect.fromCircle(center: center, radius: radius), -pi / 2, sweepAngle, false, progressPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant ArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Implement a simple Todo List manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the StateNotifier\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. Define the Provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});\n\n// Usage example (inside a ConsumerWidget build method):\n// final todos = ref.watch(todoListProvider);\n// ref.read(todoListProvider.notifier).addTodo('New Task');"}
{"instruction": "Set up an `EventChannel` in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _sensorData = \"No Data\";\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = \"Sensor: $event\";\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = \"Error: ${error.message}\";\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Optimize a Provider rebuild by using a `Selector` to only update a widget when a specific field ('age') in a `UserModel` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = \"John\";\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Selector only rebuilds if the return value of the selector function changes\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age Widget');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..style = PaintingStyle.stroke;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic counter application using Riverpod 2.0 with a `NotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the Notifier\nclass Counter extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\n// 2. Define the Provider\nfinal counterProvider = NotifierProvider<Counter, int>(Counter.new);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('Count: $count')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a theme switcher (Light/Dark mode) using the `provider` package and `ChangeNotifier`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeProvider = Provider.of<ThemeProvider>(context);\n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeProvider.mode,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => themeProvider.toggleTheme(),\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` widget that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()..color = Colors.blue;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a Platform Channel (`MethodChannel`) to invoke a native method called 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display async data (e.g., a username) with loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsync.when(\n          data: (data) => Text('User: $data'),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress arc based on a percentage value (0.0 to 1.0).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass ProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  ProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final rect = Rect.fromCircle(center: center, radius: radius);\n\n    final backgroundPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10;\n\n    canvas.drawArc(rect, 0, 2 * pi, false, backgroundPaint);\n\n    final progressPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    // -pi/2 to start from top\n    canvas.drawArc(rect, -pi / 2, 2 * pi * percentage, false, progressPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Set up a `MultiProvider` with the `provider` package to manage a Shopping Cart list and a User Authentication status.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n  List<String> get items => _items;\n  void add(String item) { _items.add(item); notifyListeners(); }\n}\n\nclass UserModel extends ChangeNotifier {\n  String? username;\n  void login(String name) { username = name; notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => CartModel()),\n        ChangeNotifierProvider(create: (_) => UserModel()),\n      ],\n      child: const MaterialApp(home: HomeScreen()),\n    ),\n  );\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    // Access providers via context\n    return Scaffold(body: Container()); \n  }\n}"}
{"instruction": "Implement an `EventChannel` on the Dart side to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() => _sensorData = 'Sensor: $event');\n      },\n      onError: (dynamic error) {\n        setState(() => _sensorData = 'Error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches data based on a dynamic argument (e.g., an Item ID).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Provider that accepts an integer ID argument\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({required this.itemId, super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific family argument\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Item Details')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, _) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a widget that uses `CustomPainter` to draw a line connecting two points where the user taps on the screen.", "output": "import 'package:flutter/material.dart';\n\nclass LinePainter extends CustomPainter {\n  final Offset? p1;\n  final Offset? p2;\n\n  LinePainter(this.p1, this.p2);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()..color = Colors.black..strokeWidth = 4.0;\n    if (p1 != null && p2 != null) {\n      canvas.drawLine(p1!, p2!, paint);\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant LinePainter oldDelegate) => true;\n}\n\nclass DrawLineScreen extends StatefulWidget {\n  const DrawLineScreen({super.key});\n  @override\n  State<DrawLineScreen> createState() => _DrawLineScreenState();\n}\n\nclass _DrawLineScreenState extends State<DrawLineScreen> {\n  Offset? start;\n  Offset? end;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTapDown: (details) {\n        setState(() {\n          if (start == null) start = details.localPosition;\n          else if (end == null) end = details.localPosition;\n          else { start = details.localPosition; end = null; }\n        });\n      },\n      child: CustomPaint(\n        painter: LinePainter(start, end),\n        child: Container(color: Colors.white, width: double.infinity, height: double.infinity),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter state management solution using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: TextStyle(fontSize: 24));\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a circle filled with a radial gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    final paint = Paint()\n      ..shader = RadialGradient(\n        colors: [Colors.blue, Colors.purple],\n      ).createShader(Rect.fromCircle(center: center, radius: radius));\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass GradientCircle extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(200, 200),\n      painter: GradientCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's StateNotifier to manage a list of Todo items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Implement a MethodChannel in Dart to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a Riverpod FutureProvider that fetches user data asynchronously and handles loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Draw a quadratic Bezier curve using CustomPainter.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    // Start point\n    path.moveTo(0, size.height * 0.75);\n    \n    // Control point (x1, y1) and End point (x2, y2)\n    path.quadraticBezierTo(\n      size.width / 2, // Control Point X\n      size.height / 4, // Control Point Y\n      size.width,      // End Point X\n      size.height * 0.75 // End Point Y\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the Selector widget from the Provider package to optimize rebuilds by listening to only a specific property of a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Guest';\n  int age = 25;\n\n  void updateName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass NameDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds if 'name' changes, ignores changes to 'age'\n    return Selector<UserModel, String>(\n      selector: (context, user) => user.name,\n      builder: (context, name, child) {\n        return Text('User Name: $name');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel to listen to a stream of events from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() {\n        _sensorValue = event as double;\n      });\n    }, onError: (dynamic error) {\n      print('Received error: ${error.message}');\n    });\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Use Riverpod's .family modifier to pass an argument (userID) to a provider.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that accepts an integer ID and returns a string\nfinal userByIdProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'User $id Details';\n});\n\n// Usage in a Widget\nclass UserDetailWidget extends ConsumerWidget {\n  final int userId;\n  UserDetailWidget({required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userByIdProvider(userId));\n\n    return userAsync.when(\n      data: (name) => Text(name),\n      loading: () => CircularProgressIndicator(),\n      error: (e, s) => Text('Error loading user'),\n    );\n  }\n}"}
{"instruction": "Create an animated CustomPainter that draws an expanding circle using an AnimationController.", "output": "import 'package:flutter/material.dart';\n\nclass RipplePainter extends CustomPainter {\n  final double animationValue;\n\n  RipplePainter(this.animationValue);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue.withOpacity(1.0 - animationValue)\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4;\n\n    final maxRadius = size.width / 2;\n    final radius = maxRadius * animationValue;\n\n    canvas.drawCircle(Offset(size.width / 2, size.height / 2), radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(RipplePainter oldDelegate) {\n    return oldDelegate.animationValue != animationValue;\n  }\n}\n\nclass RippleAnimation extends StatefulWidget {\n  @override\n  _RippleAnimationState createState() => _RippleAnimationState();\n}\n\nclass _RippleAnimationState extends State<RippleAnimation> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this, duration: Duration(seconds: 2))..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      builder: (context, child) {\n        return CustomPaint(\n          painter: RipplePainter(_controller.value),\n          size: Size(200, 200),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Create a basic counter application using the 'provider' package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: Theme.of(context).textTheme.headlineMedium);\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a simple Todo list state manager using Riverpod's StateNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Model\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\n// StateNotifier\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\n// Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});\n\n// UI Widget snippet\nclass TodoPage extends ConsumerWidget {\n  const TodoPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n    return ListView(\n      children: [\n        for (final todo in todos)\n          CheckboxListTile(\n            value: todo.completed,\n            onChanged: (value) => ref.read(todoListProvider.notifier).toggle(todo.id),\n            title: Text(todo.description),\n          ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter widget that draws a blue circle with a red border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paintBlue = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final paintRedBorder = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw fill\n    canvas.drawCircle(center, radius, paintBlue);\n    // Draw border\n    canvas.drawCircle(center, radius, paintRedBorder);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage\nclass MyCircleWidget extends StatelessWidget {\n  const MyCircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a Dart MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data asynchronously and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Fake API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUser();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> user = ref.watch(userProvider);\n\n    return Center(\n      child: user.when(\n        data: (data) => Text('User: $data'),\n        loading: () => const CircularProgressIndicator(),\n        error: (err, stack) => Text('Error: $err'),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a curved header background using a Quadratic Bezier Curve.", "output": "import 'package:flutter/material.dart';\n\nclass CurvedHeaderPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.deepPurple\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at top-left\n    path.lineTo(0, size.height - 50);\n    \n    // Control point (bottom-left area) and End point (bottom-right area)\n    path.quadraticBezierTo(\n      size.width / 2, \n      size.height, \n      size.width, \n      size.height - 50\n    );\n    \n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass HeaderWidget extends StatelessWidget {\n  const HeaderWidget({super.key});\n  \n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: CurvedHeaderPainter(),\n    );\n  }\n}"}
{"instruction": "Optimize a Provider rebuild using the 'Selector' widget to listen only to a specific integer property from a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ComplexModel extends ChangeNotifier {\n  int _counter = 0;\n  String _name = 'Test';\n\n  int get counter => _counter;\n  String get name => _name;\n\n  void increment() {\n    _counter++;\n    notifyListeners();\n  }\n\n  void changeName() {\n    _name = 'Updated';\n    notifyListeners();\n  }\n}\n\nclass OptimizedWidget extends StatelessWidget {\n  const OptimizedWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // This widget only rebuilds when 'counter' changes, ignoring 'name' changes\n        Selector<ComplexModel, int>(\n          selector: (_, model) => model.counter,\n          builder: (_, counter, __) {\n            print('Building Counter Text');\n            return Text('Count: $counter');\n          },\n        ),\n        ElevatedButton(\n          onPressed: () => context.read<ComplexModel>().increment(),\n          child: const Text('Increment'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Implement a Flutter EventChannel to listen to a stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = event as double;\n        });\n      },\n      onError: (dynamic error) {\n        debugPrint('Received error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Sensor Value: $_sensorValue'));\n  }\n}"}
{"instruction": "Animate a CustomPainter by passing an AnimationController value to the painter to create a pulsing effect.", "output": "import 'package:flutter/material.dart';\n\nclass PulsingCirclePainter extends CustomPainter {\n  final double animationValue;\n  \n  PulsingCirclePainter(this.animationValue);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue.withOpacity(1 - animationValue) // Fade out\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    // Grow size\n    final radius = (size.width / 4) + (animationValue * 20);\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant PulsingCirclePainter oldDelegate) {\n    return oldDelegate.animationValue != animationValue;\n  }\n}\n\nclass PulsingWidget extends StatefulWidget {\n  const PulsingWidget({super.key});\n\n  @override\n  State<PulsingWidget> createState() => _PulsingWidgetState();\n}\n\nclass _PulsingWidgetState extends State<PulsingWidget> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 1),\n    )..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      builder: (context, child) {\n        return CustomPaint(\n          size: const Size(100, 100),\n          painter: PulsingCirclePainter(_controller.value),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific data.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that takes an integer ID and returns a string\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item ID: $id';\n});\n\nclass ItemDetailPage extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailPage({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific parameter\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Item Details')),\n      body: Center(\n        child: itemAsync.when(\n          data: (details) => Text(details),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, st) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod 2.0. Define a StateProvider for the integer count and a ConsumerWidget to display and increment it.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass CounterPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: Theme.of(context).textTheme.headlineMedium)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a blue circle with a red border in the center of the available space.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel' and handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a ChangeNotifier class for managing a ThemeMode and a Consumer widget that toggles a Switch based on that state using the Provider package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nclass ThemeSwitch extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeNotifier>(\n      builder: (context, notifier, child) => SwitchListTile(\n        title: const Text('Dark Mode'),\n        value: notifier.isDark,\n        onChanged: (val) => notifier.toggleTheme(),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to simulate fetching user data asynchronously and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Jane Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Go up to 70% height\n    path.lineTo(0, size.height * 0.7);\n    // Curve to the right edge\n    path.quadraticBezierTo(\n      size.width / 2, // Control point x\n      size.height * 0.9, // Control point y (dip down)\n      size.width, // End point x\n      size.height * 0.7 // End point y\n    );\n    // Close path\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod StateNotifier to manage a Todo list (List<String>) where you can add and remove items immutably.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Set up a Flutter EventChannel to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatelessWidget {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder( \n      stream: _eventChannel.receiveBroadcastStream(),\n      builder: (context, snapshot) {\n        if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n        if (snapshot.hasData) return Text('Sensor Data: ${snapshot.data}');\n        return const Text('Waiting for data...');\n      },\n    );\n  }\n}"}
{"instruction": "Use the Provider package's ProxyProvider to inject a value from an AuthModel into a DatabaseModel whenever the auth state changes.", "output": "import 'package:provider/provider.dart';\n\nclass AuthModel with ChangeNotifier {\n  String? userId;\n}\n\nclass DatabaseModel {\n  final String? userId;\n  DatabaseModel(this.userId);\n}\n\n// Usage inside MultiProvider:\n// ProxyProvider<AuthModel, DatabaseModel>(\n//   update: (context, auth, previousDb) => DatabaseModel(auth.userId),\n// )"}
{"instruction": "Create a CustomPainter that draws a gradient arc (progress indicator style) using a SweepGradient shader.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final gradient = SweepGradient(\n      startAngle: 0.0,\n      endAngle: pi * 1.5,\n      colors: [Colors.blue.withOpacity(0.1), Colors.blue],\n      stops: const [0.0, 1.0],\n    );\n\n    final paint = Paint()\n      ..shader = gradient.createShader(rect)\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10.0;\n\n    // Draw 75% of a circle\n    canvas.drawArc(rect, -pi / 2, pi * 1.5, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod with a `StateProvider` and a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: const TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class that draws a blue circle in the center of the available canvas space.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Draw circle at the center\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.shortestSide / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // No dynamic state to repaint\n  }\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use the `provider` package to create a `ChangeNotifier` for a Todo list and display the list using a `Consumer`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoNotifier extends ChangeNotifier {\n  final List<String> _items = [];\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => TodoNotifier(),\n      child: const MaterialApp(home: TodoListScreen()),\n    ),\n  );\n}\n\nclass TodoListScreen extends StatelessWidget {\n  const TodoListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Todo')),\n      body: Consumer<TodoNotifier>(\n        builder: (context, todo, child) {\n          return ListView.builder(\n            itemCount: todo.items.length,\n            itemBuilder: (ctx, index) => ListTile(title: Text(todo.items[index])),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<TodoNotifier>().add('New Task'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a Flutter `MethodChannel` to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Fetch asynchronous data using Riverpod's `FutureProvider` and handle the loading, error, and data states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchConfig() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n}\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  return fetchConfig();\n});\n\nclass ConfigScreen extends ConsumerWidget {\n  const ConfigScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: configAsync.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 20)),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomClipper` that clips the bottom-right corner of a container diagonally.", "output": "import 'package:flutter/material.dart';\n\nclass DiagonalClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    final path = Path();\n    path.lineTo(size.width, 0.0);\n    path.lineTo(size.width, size.height - 50.0); // Start cut 50px from bottom\n    path.lineTo(size.width - 50.0, size.height); // End cut 50px from right\n    path.lineTo(0.0, size.height);\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}\n\n// Usage\nclass ClippedBox extends StatelessWidget {\n  const ClippedBox({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return ClipPath(\n      clipper: DiagonalClipper(),\n      child: Container(\n        height: 200,\n        width: 200,\n        color: Colors.red,\n      ),\n    );\n  }\n}"}
{"instruction": "Demonstrate how to listen to a stream of events from native code using `EventChannel` in Dart.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    // Listen to the stream\n    _subscription = eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() {\n        _sensorValue = event as double;\n      });\n    }, onError: (dynamic error) {\n      debugPrint('Received error: ${error.message}');\n    });\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Create a `StateNotifier` and `StateNotifierProvider` in Riverpod to manage a list of immutable Todo objects.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  TodosNotifier() : super([]);\n\n  void addTodo(String desc) {\n    state = [...state, Todo(id: DateTime.now().toString(), description: desc)];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo\n    ];\n  }\n}\n\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});"}
{"instruction": "Draw a loading arc (spinner) using `CustomPainter` with a stroke style and `drawArc`.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.purple\n      ..strokeWidth = 5\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    \n    // Draw an arc from -90 degrees (top), sweeping 270 degrees\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2, // Start angle\n      3 * pi / 2, // Sweep angle\n      false, // Use center\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the `provider` package's `MultiProvider` to inject two different providers at the root of the application.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  bool loggedIn = false;\n}\n\nclass ThemeModel extends ChangeNotifier {\n  bool isDark = false;\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer2<AuthModel, ThemeModel>(\n            builder: (context, auth, theme, child) {\n              return Text('Auth: ${auth.loggedIn}, DarkMode: ${theme.isDark}');\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider` and a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text('$count', style: Theme.of(context).textTheme.headlineMedium),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    \n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass MyCanvas extends StatelessWidget {\n  const MyCanvas({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a `ChangeNotifier` with the Provider package to manage a list of Todo strings, including adding and removing items.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoModel extends ChangeNotifier {\n  final List<String> _todos = [];\n\n  List<String> get todos => List.unmodifiable(_todos);\n\n  void add(String task) {\n    _todos.add(task);\n    notifyListeners();\n  }\n\n  void remove(int index) {\n    _todos.removeAt(index);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => TodoModel(),\n      child: const MaterialApp(home: TodoListScreen()),\n    ),\n  );\n}\n\nclass TodoListScreen extends StatelessWidget {\n  const TodoListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Todos')),\n      body: Consumer<TodoModel>(\n        builder: (context, todoModel, child) {\n          return ListView.builder(\n            itemCount: todoModel.todos.length,\n            itemBuilder: (context, index) {\n              return ListTile(\n                title: Text(todoModel.todos[index]),\n                trailing: IconButton(\n                  icon: const Icon(Icons.delete),\n                  onPressed: () => todoModel.remove(index),\n                ),\n              );\n            },\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<TodoModel>().add('New Task'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a Dart method using `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  // 1. Create the channel with a unique name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch data asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\n// Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return await fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        // Handle the 3 states\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a smooth arc) from the bottom-left to the bottom-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    \n    // Control point (top center) and End point (bottom right)\n    path.quadraticBezierTo(\n      size.width / 2, size.height * 0.5, // Control point\n      size.width, size.height            // End point\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize a Provider implementation using `Selector` to only rebuild a widget when a specific property (age) of the model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Selector only listens to the integer return value\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age Widget'); // Verifies rebuilds\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod `NotifierProvider` (Riverpod 2.0) to manage a complex state object (User class) with immutable updates.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Immutable State Object\nclass User {\n  final String name;\n  final int age;\n  User({required this.name, required this.age});\n\n  User copyWith({String? name, int? age}) {\n    return User(\n      name: name ?? this.name,\n      age: age ?? this.age,\n    );\n  }\n}\n\n// Notifier Class\nclass UserNotifier extends Notifier<User> {\n  @override\n  User build() {\n    return User(name: 'Guest', age: 0);\n  }\n\n  void updateName(String newName) {\n    state = state.copyWith(name: newName);\n  }\n\n  void incrementAge() {\n    state = state.copyWith(age: state.age + 1);\n  }\n}\n\n// The Provider\nfinal userProvider = NotifierProvider<UserNotifier, User>(UserNotifier.new);"}
{"instruction": "Create a CustomPainter that creates a clipping mask to clip an image into a triangular shape.", "output": "import 'package:flutter/material.dart';\n\nclass TriangleClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    final path = Path();\n    // Top center\n    path.moveTo(size.width / 2, 0);\n    // Bottom Left\n    path.lineTo(0, size.height);\n    // Bottom Right\n    path.lineTo(size.width, size.height);\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}\n\n// Usage\nclass TriangleImage extends StatelessWidget {\n  const TriangleImage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ClipPath(\n      clipper: TriangleClipper(),\n      child: Image.network('https://via.placeholder.com/150'),\n    );\n  }\n}"}
{"instruction": "Establish an `EventChannel` in Dart to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorService {\n  // Define the EventChannel\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double>? _sensorStream;\n\n  Stream<double> get sensorStream {\n    // Initialize stream only once\n    _sensorStream ??= _eventChannel\n        .receiveBroadcastStream()\n        .map((dynamic event) => event as double);\n    \n    return _sensorStream!;\n  }\n}"}
{"instruction": "Create a simple Counter application using the 'Provider' package for state management. Include the ChangeNotifier class and the UI implementation.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a custom painter in Flutter that draws a red circle with a blue border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paintFill = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final paintBorder = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, paintFill);\n    canvas.drawCircle(center, radius, paintBorder);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod to manage a list of Todo items. Create a StateNotifierProvider and a ConsumerWidget to display the list.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          return ListTile(title: Text(todos[index].description));\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.battery/level');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod FutureProvider to fetch user data asynchronously and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUser();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave pattern) across the screen.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.5);\n    \n    path.quadraticBezierTo(\n      size.width * 0.25, size.height * 0.3, // Control point 1\n      size.width * 0.5, size.height * 0.5,  // End point 1\n    );\n    \n    path.quadraticBezierTo(\n      size.width * 0.75, size.height * 0.7, // Control point 2\n      size.width, size.height * 0.5,        // End point 2\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Provider's 'Selector' widget to optimize performance by listening only to a specific property of a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass SettingsModel extends ChangeNotifier {\n  String _username = 'Guest';\n  bool _darkMode = false;\n\n  String get username => _username;\n  bool get darkMode => _darkMode;\n\n  void toggleTheme() {\n    _darkMode = !_darkMode;\n    notifyListeners();\n  }\n\n  void updateName(String name) {\n    _username = name;\n    notifyListeners();\n  }\n}\n\nclass ThemeToggler extends StatelessWidget {\n  const ThemeToggler({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'darkMode' changes, ignores 'username' changes\n    return Selector<SettingsModel, bool>(\n      selector: (context, settings) => settings.darkMode,\n      builder: (context, isDark, child) {\n        return Switch(\n          value: isDark,\n          onChanged: (val) => context.read<SettingsModel>().toggleTheme(),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Set up a Flutter EventChannel to listen to a continuous stream of events (e.g., sensor data) from native code.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('com.example.sensors/stream');\n  StreamSubscription? _streamSubscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensor();\n  }\n\n  void _enableSensor() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = event as double;\n        });\n      },\n      onError: (dynamic error) {\n        debugPrint('Received error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Sensor Value: $_sensorValue'));\n  }\n}"}
{"instruction": "Using Riverpod, create a 'family' provider that accepts an ID as an argument to fetch specific item details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// Simulating a database fetch\nFuture<String> fetchItemById(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Item Details for ID: $id';\n}\n\n// Family provider accepting an int ID\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemById(id);\n});\n\nclass ItemDetailWidget extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailWidget({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final itemAsync = ref.watch(itemFamilyProvider(itemId));\n\n    return itemAsync.when(\n      data: (details) => Text(details),\n      loading: () => const CircularProgressIndicator(),\n      error: (e, s) => const Text('Failed to load'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a 5-pointed star.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass StarPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.amber\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    final double cx = size.width / 2;\n    final double cy = size.height / 2;\n    final double outerRadius = size.width / 2;\n    final double innerRadius = outerRadius / 2.5;\n    double rot = -pi / 2 * 3;\n    final double step = pi / 5;\n\n    path.moveTo(cx, cy - outerRadius);\n    \n    for (int i = 0; i < 5; i++) {\n      double x = cx + cos(rot) * outerRadius;\n      double y = cy + sin(rot) * outerRadius;\n      path.lineTo(x, y);\n      rot += step;\n\n      x = cx + cos(rot) * innerRadius;\n      y = cy + sin(rot) * innerRadius;\n      path.lineTo(x, y);\n      rot += step;\n    }\n    \n    path.close();\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using the `provider` package. Define a `ChangeNotifier` class and a widget that consumes it to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a circular progress indicator with a specific percentage and color.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass CircularProgressPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  CircularProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10.0\n      ..strokeCap = StrokeCap.round;\n\n    // Draw background circle\n    paint.color = Colors.grey.shade300;\n    canvas.drawCircle(center, radius, paint);\n\n    // Draw progress arc\n    paint.color = color;\n    final sweepAngle = 2 * pi * (percentage / 100);\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2, // Start from top\n      sweepAngle,\n      false,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircularProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage || oldDelegate.color != color;\n  }\n}"}
{"instruction": "Use `flutter_riverpod` to create a StateNotifier that manages a list of Todo strings. Include methods to add and remove todos, and a ConsumerWidget to display them.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text(todos[index]),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete),\n              onPressed: () => ref.read(todoListProvider.notifier).remove(todos[index]),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Task ${todos.length + 1}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a `MethodChannel` to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `FutureProvider` using Riverpod to fetch user data asynchronously and handle the Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return await fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a `CustomPainter` that draws a sine wave across the width of the canvas.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n\n    final path = Path();\n    final double midHeight = size.height / 2;\n    path.moveTo(0, midHeight);\n\n    for (double x = 0; x <= size.width; x++) {\n      // Calculate y = A * sin(B * x) + C\n      double y = midHeight + 30 * sin((x / size.width) * 4 * pi);\n      path.lineTo(x, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No Data';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Optimize a Provider implementation using `Selector` to ensure a widget only rebuilds when a specific property of the model changes, rather than any change in the model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ComplexModel extends ChangeNotifier {\n  int _counter = 0;\n  String _name = 'Flutter';\n\n  int get counter => _counter;\n  String get name => _name;\n\n  void increment() {\n    _counter++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    _name = newName;\n    notifyListeners();\n  }\n}\n\nclass OptimizedWidget extends StatelessWidget {\n  const OptimizedWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // This widget only rebuilds when 'counter' changes\n        Selector<ComplexModel, int>(\n          selector: (context, model) => model.counter,\n          builder: (context, counter, child) {\n            print('Building Counter Text');\n            return Text('Count: $counter');\n          },\n        ),\n        ElevatedButton(\n          onPressed: () => context.read<ComplexModel>().increment(),\n          child: const Text('Increment'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a rectangle filled with a linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    \n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific item details.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock data fetcher\nFuture<String> fetchItemTitle(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Item #$id';\n}\n\n// Family provider accepting an int ID\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItemTitle(id);\n});\n\nclass ItemDetailWidget extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailWidget({required this.itemId, super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the specific provider based on itemId\n    final itemAsync = ref.watch(itemFamilyProvider(itemId));\n\n    return itemAsync.when(\n      data: (title) => Text(title),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => const Text('Failed to load'),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod's StateProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass RiverpodCounter extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Counter')),\n      body: Center(child: Text('$count', style: TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Todo list state manager using the Provider package and ChangeNotifier.", "output": "import 'package:flutter/material.dart';\n\nclass Todo {\n  final String title;\n  bool isDone;\n  Todo(this.title, {this.isDone = false});\n}\n\nclass TodoNotifier extends ChangeNotifier {\n  final List<Todo> _todos = [];\n  List<Todo> get todos => _todos;\n\n  void addTodo(String title) {\n    _todos.add(Todo(title));\n    notifyListeners();\n  }\n\n  void toggleTodo(int index) {\n    _todos[index].isDone = !_todos[index].isDone;\n    notifyListeners();\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' from the channel 'samples.flutter.dev/battery'.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}';\n    }\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch and display data from a simulated API.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass AsyncDataWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress arc (loading indicator style) based on a percentage value.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass ProgressArcPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  ProgressArcPainter(this.percentage);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..strokeWidth = 8.0\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      2 * pi * percentage,\n      false,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Use the Selector widget from the Provider package to optimize rebuilds by listening only to a specific string property of a User object.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n  // ... update methods\n}\n\nclass UserNameDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, String>(\n      selector: (context, user) => user.name,\n      builder: (context, name, child) {\n        print('Building Name Widget');\n        return Text('User Name: $name');\n      },\n    );\n  }\n}"}
{"instruction": "Define a Riverpod provider using the .family modifier to fetch user details based on a user ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Family provider accepting an integer ID\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network request\n  await Future.delayed(Duration(milliseconds: 500));\n  return User(userId, 'User $userId');\n});"}
{"instruction": "Implement a Dart function to send a message to the native platform to display a Toast, using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass ToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    double dashWidth = 5;\n    double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the `provider` package. Define a `ChangeNotifier` class called `CounterModel` and a widget that consumes this provider to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `StateNotifier` and `StateNotifierProvider` using Riverpod to manage a simple list of strings (To-Do items). Create a ConsumerWidget to display the list and add items.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String item) {\n    state = [...state, item];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) => ListTile(title: Text(todos[index])),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` class named `GradientBallPainter` that draws a circle in the center of the canvas with a radial gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBallPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paint = Paint()\n      ..shader = RadialGradient(\n        colors: [Colors.blueAccent, Colors.blue],\n      ).createShader(Rect.fromCircle(center: center, radius: radius));\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass BallWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(200, 200),\n      painter: GradientBallPainter(),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform method named `getBatteryLevel` using `MethodChannel`. Handle the `PlatformException` if the platform code fails.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching a user configuration from an API. Create a widget that handles the `AsyncValue` (data, loading, error) states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Dark Mode Enabled';\n});\n\nclass ConfigScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: configAsync.when(\n          data: (config) => Text(config),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` called `WavePainter` that draws a quadratic bezier curve (a wave) at the bottom of the provided size.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate the use of the `Selector` widget from the `provider` package to optimize rebuilds. Assume a `UserModel` with `name` and `age`, and rebuild the widget only when `name` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void updateName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass NameWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, String>(\n      selector: (context, user) => user.name,\n      builder: (context, name, child) {\n        print('Building NameWidget');\n        return Text('User Name: $name');\n      },\n    );\n  }\n}"}
{"instruction": "Create a Dart class that listens to a platform `EventChannel` named `com.example.app/sensor` to receive a stream of double values (e.g., accelerometer data) and exposes it as a Dart Stream.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n\n  Stream<double>? _sensorStream;\n\n  Stream<double> get sensorStream {\n    if (_sensorStream == null) {\n      _sensorStream = _eventChannel\n          .receiveBroadcastStream()\n          .map((event) => event as double);\n    }\n    return _sensorStream!;\n  }\n}"}
{"instruction": "Create a `CustomPainter` named `ArcProgressPainter` that draws a progress arc. It should take a `percentage` (0.0 to 1.0) and draw a background circle and a foreground arc indicating progress.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ArcProgressPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  ArcProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    final bgPaint = Paint()\n      ..color = Colors.grey.shade300\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n\n    canvas.drawCircle(center, radius, bgPaint);\n\n    final fgPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    final angle = 2 * pi * percentage;\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      angle,\n      false,\n      fgPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ArcProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Use Riverpod's `family` modifier to create a `FutureProvider` that accepts a user ID (int) as an argument and fetches specific user data.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate a User model\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Family provider accepting an integer ID\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  await Future.delayed(Duration(seconds: 1)); // Simulate network request\n  return User(userId, 'User $userId');\n});\n\n// Usage example (conceptual)\n// ref.watch(userProvider(42));"}
{"instruction": "Create a simple counter application using the `Provider` package (ChangeNotifier).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, model, child) => Text(\n              '${model.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, model, child) => FloatingActionButton(\n            onPressed: model.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a basic Todo List state manager using Riverpod's `StateNotifier`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a `CustomPainter` that draws a circular progress indicator based on a percentage value (0.0 to 1.0).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircleProgressPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  CircleProgressPainter({required this.percentage, this.color = Colors.blue});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n    canvas.drawCircle(center, radius - strokeWidth / 2, bgPaint);\n\n    // Foreground Arc\n    final fgPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius - strokeWidth / 2),\n      -pi / 2, // Start at top\n      2 * pi * percentage,\n      false,\n      fgPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircleProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Write a Dart method using `MethodChannel` to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch user data asynchronously and display it using `AsyncValue`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` to draw a curved header background using `Path` and `quadraticBezierTo`.", "output": "import 'package:flutter/material.dart';\n\nclass CurvedHeaderPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.deepPurple\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    path.lineTo(0, size.height - 50);\n    // Control point is bottom-left, End point is bottom-right\n    path.quadraticBezierTo(\n        size.width / 2, size.height, size.width, size.height - 50);\n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Theme Switcher (Light/Dark mode) using the `Provider` package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    return MaterialApp(\n      themeMode: themeNotifier.mode,\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeNotifier.toggleTheme,\n            child: Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Set up a Flutter `EventChannel` to listen to a continuous stream of events (e.g., sensor data) from the native side.", "output": "import 'package:flutter/services.dart';\n\nclass SensorStreamService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double> get sensorDataStream {\n    return _eventChannel.receiveBroadcastStream().map((event) {\n      // Assuming native side sends a double\n      return event as double;\n    });\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a polygon (e.g., for a radar chart) based on a number of sides.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass PolygonPainter extends CustomPainter {\n  final int sides;\n  final double radius;\n\n  PolygonPainter({required this.sides, required this.radius});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final path = Path();\n    final anglePerSide = (2 * pi) / sides;\n\n    path.moveTo(\n      center.dx + radius * cos(0),\n      center.dy + radius * sin(0),\n    );\n\n    for (int i = 1; i <= sides; i++) {\n      path.lineTo(\n        center.dx + radius * cos(anglePerSide * i),\n        center.dy + radius * sin(anglePerSide * i),\n      );\n    }\n    path.close();\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches specific item details based on an ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulating a database fetch\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Details for Item #$id';\n}\n\n// Family provider definition\nfinal itemDetailsProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\n// Usage inside a ConsumerWidget\n// final asyncValue = ref.watch(itemDetailsProvider(42));"}
{"instruction": "Create a basic Counter state management implementation using the Provider package (ChangeNotifier).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// Usage inside a widget build method:\n// Consumer<CounterModel>(builder: (context, model, child) => Text('${model.count}'));"}
{"instruction": "Implement a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\n\nclass PlatformService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, size.width / 4, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Define a Riverpod StateNotifier to manage a list of Todo items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  Todo(this.id, this.description);\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [...state, Todo(DateTime.now().toString(), description)];\n  }\n\n  void removeTodo(String id) {\n    state = state.where((todo) => todo.id != id).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a linear progress bar with a gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientProgressPainter extends CustomPainter {\n  final double progress; // Value between 0.0 and 1.0\n\n  GradientProgressPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width * progress, size.height);\n    final paint = Paint()\n      ..shader = LinearGradient(\n        colors: [Colors.blue, Colors.purple],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(GradientProgressPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Implement a Riverpod FutureProvider to fetch configuration data asynchronously.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<Map<String, dynamic>>((ref) async {\n  // Simulate network delay\n  await Future.delayed(const Duration(seconds: 2));\n  return {'theme': 'dark', 'version': '1.0.0'};\n});\n\n// Usage in Widget:\n// ref.watch(configProvider).when(\n//   data: (config) => Text(config['theme']),\n//   loading: () => CircularProgressIndicator(),\n//   error: (err, stack) => Text('Error: $err'),\n// );"}
{"instruction": "Set up a Flutter EventChannel to listen to a stream of events from native code.", "output": "import 'package:flutter/services.dart';\n\nclass SensorStreamService {\n  static const eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double> get sensorDataStream {\n    return eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n}"}
{"instruction": "Use the 'family' modifier in Riverpod to create a provider that accepts an argument (User ID) to fetch specific user data.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User { final int id; final String name; User(this.id, this.name); }\n\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate fetching user by ID\n  await Future.delayed(const Duration(milliseconds: 500));\n  return User(userId, 'User $userId');\n});\n\n// Usage: ref.watch(userProvider(42));"}
{"instruction": "Create a CustomPainter that draws a Sine wave path across the canvas.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n\n    final path = Path();\n    for (double x = 0; x <= size.width; x++) {\n      // Calculate y based on sine function\n      double y = size.height / 2 + 30 * sin((x / size.width) * 2 * pi);\n      if (x == 0) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Configure a MultiProvider to inject multiple dependent providers into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier { /* ... */ }\nclass DatabaseService { /* ... */ }\n\n// Usage in main app\nWidget build(BuildContext context) {\n  return MultiProvider(\n    providers: [\n      ChangeNotifierProvider(create: (_) => AuthModel()),\n      Provider(create: (_) => DatabaseService()),\n      ProxyProvider<DatabaseService, String>(\n        update: (_, db, __) => 'Active DB Connection',\n      ),\n    ],\n    child: MaterialApp(home: Scaffold()),\n  );\n}"}
{"instruction": "Create a simple counter application using the 'provider' package in Flutter. Include the ChangeNotifier class and the UI implementation using Consumer.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier class\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app (or scope) with ChangeNotifierProvider\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          // 3. Use Consumer to listen to changes\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                'Count: ${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // 4. Access the provider via context to call methods\n            context.read<CounterModel>().increment();\n          },\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'FutureProvider' using Riverpod to fetch a string asynchronously (simulating an API call) and display the result with loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the FutureProvider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Fetched Data from API';\n});\n\nvoid main() {\n  // 2. Wrap the app in ProviderScope\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider\n    final asyncValue = ref.watch(dataProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod FutureProvider')),\n        body: Center(\n          child: asyncValue.when(\n            // 4. Handle states\n            data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n            loading: () => const CircularProgressIndicator(),\n            error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Paint for the fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Paint for the border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw fill\n    canvas.drawCircle(center, radius, fillPaint);\n    // Draw border\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // Static drawing, no repaint needed\n  }\n}\n\n// Usage Widget\nclass MyCustomCircle extends StatelessWidget {\n  const MyCustomCircle({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel'. Provide the Dart-side code.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's 'StateNotifier' to manage a simple Todo list (add and remove items).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the StateNotifier\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. Define the provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});\n\nclass TodoApp extends ConsumerWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the list state\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          final todo = todos[index];\n          return ListTile(\n            title: Text(todo),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete),\n              onPressed: () => ref.read(todoListProvider.notifier).removeTodo(todo),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).addTodo('Task ${todos.length + 1}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a Bezier curve (wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at top-left\n    path.moveTo(0, 0);\n    // Line to bottom-left (start of wave)\n    path.lineTo(0, size.height * 0.8);\n\n    // Create a quadratic bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height,      // Control point y (peak of wave at bottom)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Line to top-right\n    path.lineTo(size.width, 0);\n    // Close the path\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass WaveHeader extends StatelessWidget {\n  const WaveHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: 200,\n      width: double.infinity,\n      child: CustomPaint(\n        painter: WavePainter(),\n      ),\n    );\n  }\n}"}
{"instruction": "Setup a 'MultiProvider' using the provider package to inject a ThemeNotifier and a UserNotifier into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n  void toggleTheme() { _isDark = !_isDark; notifyListeners(); }\n}\n\nclass UserNotifier extends ChangeNotifier {\n  String _username = 'Guest';\n  String get username => _username;\n  void login(String name) { _username = name; notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    // Using MultiProvider to inject multiple dependencies\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => ThemeNotifier()),\n        ChangeNotifierProvider(create: (_) => UserNotifier()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final isDark = context.watch<ThemeNotifier>().isDark;\n    return MaterialApp(\n      theme: isDark ? ThemeData.dark() : ThemeData.light(),\n      home: const Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter EventChannel to listen to a stream of events sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass EventStreamWidget extends StatefulWidget {\n  const EventStreamWidget({super.key});\n\n  @override\n  State<EventStreamWidget> createState() => _EventStreamWidgetState();\n}\n\nclass _EventStreamWidgetState extends State<EventStreamWidget> {\n  // 1. Define the EventChannel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _eventData = 'Waiting for events...';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    // 2. Listen to the broadcast stream\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _eventData = 'Received: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _eventData = 'Error: $error';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    // 3. Cancel subscription to prevent leaks\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_eventData));\n  }\n}"}
{"instruction": "Create a CustomPainter that renders a circular progress bar using a SweepGradient.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass GradientProgressPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientProgressPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n    final rect = Rect.fromCircle(center: center, radius: radius);\n\n    // Background circle\n    final bgPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10;\n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Gradient Arc\n    final gradient = const SweepGradient(\n      startAngle: -pi / 2,\n      endAngle: 3 * pi / 2,\n      colors: [Colors.blue, Colors.purple],\n      tileMode: TileMode.clamp,\n    );\n\n    final paint = Paint()\n      ..shader = gradient.createShader(rect)\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    // Draw arc starting from top (-pi/2)\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientProgressPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific data.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create a FutureProvider with the .family modifier\n// The second type parameter (int) is the argument type\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Pass the argument when watching the provider\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Item $itemId')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, _) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using the 'Provider' package for state management. Include the ChangeNotifier class and the UI widget wrapped in a ChangeNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\n// 1. The State Class\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// 2. The UI\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'Riverpod' StateNotifier to manage a list of strings (Todo items). Create a provider and a ConsumerWidget to display the list and add items.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. StateNotifier\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n}\n\n// 2. Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\n// 3. UI\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Todos')),\n        body: ListView.builder(\n          itemCount: todos.length,\n          itemBuilder: (context, index) => ListTile(title: Text(todos[index])),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a simple red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Flutter MethodChannel to invoke a platform-specific method named 'getBatteryLevel'. Include error handling.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's 'FutureProvider' to fetch data asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\n// FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return await fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a smooth arch) from the bottom-left to the bottom-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass ArchPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    \n    // Control point at top center, End point at bottom right\n    path.quadraticBezierTo(\n      size.width / 2, 0, // Control point (x, y)\n      size.width, size.height, // End point (x, y)\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement an EventChannel in Flutter to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (error) {\n        setState(() {\n          _sensorData = 'Error: $error';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a Theme Switcher using Provider. The provider should hold a ThemeMode and toggle between light and dark.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeNotifier.mode,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeNotifier.toggleTheme,\n            child: const Text('Toggle Dark Mode'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress arc (partial circle) based on a percentage value passed to the constructor.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ProgressArc extends StatelessWidget {\n  final double percentage; // 0.0 to 1.0\n\n  const ProgressArc({super.key, required this.percentage});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(100, 100),\n      painter: ArcPainter(percentage),\n    );\n  }\n}\n\nclass ArcPainter extends CustomPainter {\n  final double percentage;\n  ArcPainter(this.percentage);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.orange\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 8.0;\n\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2; // Start at top\n    final sweepAngle = 2 * pi * percentage;\n\n    canvas.drawArc(rect, startAngle, sweepAngle, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(ArcPainter oldDelegate) => \n      oldDelegate.percentage != percentage;\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that accepts an ID argument to fetch specific details.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated data fetcher\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item $id';\n}\n\n// Family Provider accepting an int ID\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItemDetails(id);\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific ID\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Item $itemId')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, _) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterPage()),\n    ),\n  );\n}\n\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider value\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: const TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a filled blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a `ChangeNotifier` using the `provider` package to manage a User Profile (name and age) and display it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// Model\nclass UserProfile extends ChangeNotifier {\n  String name = 'Guest';\n  int age = 0;\n\n  void updateUser(String newName, int newAge) {\n    name = newName;\n    age = newAge;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => UserProfile(),\n      child: const MaterialApp(home: ProfileScreen()),\n    ),\n  );\n}\n\nclass ProfileScreen extends StatelessWidget {\n  const ProfileScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<UserProfile>(\n          builder: (context, user, child) {\n            return Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text('Name: ${user.name}'),\n                Text('Age: ${user.age}'),\n                ElevatedButton(\n                  onPressed: () {\n                    context.read<UserProfile>().updateUser('Alice', 25);\n                  },\n                  child: const Text('Login as Alice'),\n                )\n              ],\n            );\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `MethodChannel` in a Flutter widget to invoke a platform-specific method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display a string from a simulated async operation.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API\nFuture<String> fetchConfig() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n}\n\n// Provider\nfinal configProvider = FutureProvider<String>((ref) async {\n  return await fetchConfig();\n});\n\nclass ConfigPage extends ConsumerWidget {\n  const ConfigPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: configAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Line to start of curve (left side, slightly up)\n    path.lineTo(0, size.height * 0.8);\n    \n    // Quadratic Bezier: Control point (middle, up), End point (right side, down)\n    path.quadraticBezierTo(\n      size.width / 2, size.height * 0.6, // Control Point\n      size.width, size.height * 0.8      // End Point\n    );\n\n    // Close shape\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Todo List manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define State Object\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n// 2. Define Notifier\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\n// 3. Define Provider\nfinal todoListProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Use `EventChannel` to listen to a stream of events sent from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Setup `MultiProvider` from the `provider` package to inject multiple services into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthService extends ChangeNotifier { /* ... */ }\nclass DatabaseService extends ChangeNotifier { /* ... */ }\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => DatabaseService()),\n        // Example of a provider dependent on another\n        ProxyProvider<AuthService, String>(\n          update: (_, auth, __) => auth.isLoggedIn ? 'User Active' : 'Guest',\n        ),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) => const MaterialApp(home: Scaffold());\n}\n\nextension on AuthService {\n  bool get isLoggedIn => true; // Dummy getter\n}"}
{"instruction": "Create a `CustomPainter` to draw a circular progress indicator with a gradient sweep (SweepGradient).", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * progress;\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple, Colors.red],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, startAngle, sweepAngle, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a simple Counter implementation using the `Provider` package. Include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) => Text('${counter.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), child: Container())"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a string of data asynchronously and display it using `.when` to handle loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Dart code for a Flutter `MethodChannel` to invoke a native platform method named 'getBatteryLevel'. Handle potential `PlatformException`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<void> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    debugPrint(batteryLevel);\n  }\n}"}
{"instruction": "Create a Riverpod `StateNotifier` to manage a list of Todo strings, including methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve (a wave shape) at the bottom of the widget.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a `Selector` using the `Provider` package to rebuild a widget only when a specific property (`age`) of a `User` model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age Widget');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Write the Dart code to listen to a stream of events from native code using `EventChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening() {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        print('Received event: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches a user's name based on a passed `userId` integer.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated database fetch\nFuture<String> fetchUserName(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'User #$id';\n}\n\nfinal userProvider = FutureProvider.family<String, int>((ref, userId) async {\n  return await fetchUserName(userId);\n});\n\n// Usage in Widget:\n// ref.watch(userProvider(123));"}
{"instruction": "Create a `CustomPainter` that draws a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    const dashWidth = 5.0;\n    const dashSpace = 3.0;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's StateProvider. Include the ProviderScope and a ConsumerWidget to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a yellow circle with a black stroke in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.yellow\n      ..style = PaintingStyle.fill;\n\n    final strokePaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, strokePaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel. Include error handling.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Implement a simple ShoppingCart class extending ChangeNotifier and wrap it in a ChangeNotifierProvider using the Provider package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ShoppingCart extends ChangeNotifier {\n  final List<String> _items = [];\n\n  List<String> get items => _items;\n\n  void addItem(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void clear() {\n    _items.clear();\n    notifyListeners();\n  }\n}\n\n// Usage in main or widget tree\nfinal cartProvider = ChangeNotifierProvider((ref) => ShoppingCart());"}
{"instruction": "Use Riverpod's FutureProvider to fetch a string from a simulated API and handle the AsyncValue states (data, loading, error) in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic Bezier curve (a wave shape) at the bottom of the provided size.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5, size.height * 1.0,\n      size.width, size.height * 0.8,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Todo list manager using Riverpod's StateNotifier to handle immutable state updates.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) => TodoNotifier());"}
{"instruction": "Implement the Dart side of an EventChannel to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a partial arc (progress indicator style) based on a percentage value passed to the constructor.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ProgressArcPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  ProgressArcPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10.0;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2 - 10;\n\n    // Draw background circle\n    canvas.drawCircle(center, radius, paint..color = Colors.grey.shade300);\n\n    // Draw progress arc\n    paint.color = color;\n    const startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * percentage;\n    \n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      startAngle,\n      sweepAngle,\n      false,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Demonstrate how to use ProxyProvider from the Provider package to inject a value from one provider (AuthToken) into another (APIService).", "output": "import 'package:provider/provider.dart';\n\nclass AuthToken {\n  final String token;\n  AuthToken(this.token);\n}\n\nclass ApiService {\n  final String token;\n  ApiService(this.token);\n\n  void fetchData() => print('Fetching with $token');\n}\n\n// In your MultiProvider list:\n/*\n[\n  Provider<AuthToken>(create: (_) => AuthToken('12345')),\n  ProxyProvider<AuthToken, ApiService>(\n    update: (_, authToken, __) => ApiService(authToken.token),\n  ),\n]\n*/"}
{"instruction": "Implement a basic counter application using Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('$count', style: const TextStyle(fontSize: 24))),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` class that draws a filled blue circle in the center of the available space.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.shortestSide / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: BlueCirclePainter(), child: Container())"}
{"instruction": "Write a Dart function to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use the `Provider` package with `ChangeNotifier` to create a simple Theme toggler implementation.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeModel extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(create: (_) => ThemeModel(), child: const MyApp()),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: Provider.of<ThemeModel>(context).isDark ? ThemeData.dark() : ThemeData.light(),\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => context.read<ThemeModel>().toggleTheme(),\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Fetch data asynchronously using Riverpod's `FutureProvider` and handle the loading, data, and error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a smooth arch).", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width / 2, size.height / 4, size.width, size.height * 0.75);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Todo List manager using Riverpod's `StateNotifier` to handle immutable state updates.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = [for (final todo in state) if (todo != description) todo];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\n// Usage: ref.read(todoListProvider.notifier).add('New Item');"}
{"instruction": "Set up a Flutter `EventChannel` to listen to a stream of events (e.g., sensor data) sent from native code.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening() {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        print('Received event: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a rectangle filled with a linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use `ProxyProvider` to inject a dependency that relies on another provider (e.g., a CartModel that depends on AuthModel).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel {\n  String? userId = 'user_123';\n}\n\nclass CartModel {\n  final AuthModel _auth;\n  CartModel(this._auth);\n  \n  String get status => 'Cart for user: ${_auth.userId}';\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        Provider(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, CartModel>(\n          update: (_, auth, __) => CartModel(auth),\n        ),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) => Container();\n}"}
{"instruction": "Create a Theme Switcher using the Provider package. Implement a `ThemeService` class extending `ChangeNotifier` that toggles a boolean `isDarkMode`. Wrap the `MaterialApp` with `ChangeNotifierProvider` and use a `Consumer` to update the `themeMode` dynamically.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeService extends ChangeNotifier {\n  bool _isDarkMode = false;\n  bool get isDarkMode => _isDarkMode;\n\n  void toggleTheme() {\n    _isDarkMode = !_isDarkMode;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeService(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeService>(\n      builder: (context, themeService, child) {\n        return MaterialApp(\n          themeMode: themeService.isDarkMode ? ThemeMode.dark : ThemeMode.light,\n          theme: ThemeData.light(),\n          darkTheme: ThemeData.dark(),\n          home: const HomeScreen(),\n        );\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Theme Switcher')),\n      body: Center(\n        child: Switch(\n          value: Provider.of<ThemeService>(context).isDarkMode,\n          onChanged: (val) {\n            Provider.of<ThemeService>(context, listen: false).toggleTheme();\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a random user name from a simulated asynchronous operation. Handle the `loading`, `error`, and `data` states using the `.when` syntax in a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: UserScreen())));\n}\n\nclass UserScreen extends ConsumerWidget {\n  const UserScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod FutureProvider')),\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data', style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a localized 'Target' symbol. It should consist of three concentric circles: a filled red center, a white ring, and a red outer ring. Use `Canvas.drawCircle`.", "output": "import 'package:flutter/material.dart';\n\nclass TargetPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    final Paint paint = Paint()..style = PaintingStyle.fill;\n\n    // Outer Red Circle\n    paint.color = Colors.red;\n    canvas.drawCircle(center, radius, paint);\n\n    // Middle White Circle\n    paint.color = Colors.white;\n    canvas.drawCircle(center, radius * 0.7, paint);\n\n    // Inner Red Circle\n    paint.color = Colors.red;\n    canvas.drawCircle(center, radius * 0.4, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass TargetWidget extends StatelessWidget {\n  const TargetWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: TargetPainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel named 'com.example.app/battery' to invoke a method 'getBatteryLevel' on the native platform. Wrap the call in a try-catch block to handle `PlatformException`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `StateNotifier` to manage a simple Todo list. Create a `Todo` class, a `TodoNotifier` class that extends `StateNotifier<List<Todo>>`, and a provider to expose it.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave) at the bottom of a container. Use the `Path` class and `quadraticBezierTo`.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.8);\n    \n    // Control point (x,y) and End point (x,y)\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control X\n      size.height,      // Control Y\n      size.width,       // End X\n      size.height * 0.8 // End Y\n    );\n    \n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement `ChangeNotifierProxyProvider` (Provider package) to update a `ShoppingCart` model whenever the `AuthModel` changes (e.g., clear the cart when the user logs out).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel with ChangeNotifier {\n  bool _isLoggedIn = false;\n  bool get isLoggedIn => _isLoggedIn;\n  void login() { _isLoggedIn = true; notifyListeners(); }\n  void logout() { _isLoggedIn = false; notifyListeners(); }\n}\n\nclass ShoppingCart with ChangeNotifier {\n  final AuthModel _auth;\n  List<String> _items = [];\n\n  ShoppingCart(this._auth, this._items);\n\n  List<String> get items => _items;\n\n  void add(String item) { _items.add(item); notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProxyProvider<AuthModel, ShoppingCart>(\n          create: (context) => ShoppingCart(Provider.of<AuthModel>(context, listen: false), []),\n          update: (context, auth, previousCart) {\n             // If user logs out, clear items, otherwise keep previous items\n             final items = auth.isLoggedIn ? (previousCart?._items ?? []) : <String>[];\n             return ShoppingCart(auth, items);\n          },\n        ),\n      ],\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Create a Dart class to listen to a stream of events from native code using `EventChannel`. The channel name is 'com.example.app/sensor'. Listen to the stream in `initState` and cancel it in `dispose`.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorListener extends StatefulWidget {\n  const SensorListener({super.key});\n\n  @override\n  State<SensorListener> createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No Data';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorListening();\n  }\n\n  void _enableSensorListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Riverpod's `family` modifier to create a provider that accepts an integer ID and returns a string formatted as 'Item #ID'. Consume this provider in a widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Family provider accepting an int id\nfinal itemTitleProvider = Provider.family<String, int>((ref, id) {\n  return 'Item #$id';\n});\n\nclass ItemDetailWidget extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailWidget({required this.itemId, super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watching the provider with the specific family argument\n    final title = ref.watch(itemTitleProvider(itemId));\n\n    return Text(title, style: const TextStyle(fontSize: 20));\n  }\n}"}
{"instruction": "Create an animated CustomPainter that draws a circle whose radius pulses based on an `Animation<double>`. Pass the animation to the painter and call `super(repaint: animation)` to automatically redraw on ticks.", "output": "import 'package:flutter/material.dart';\n\nclass PulsePainter extends CustomPainter {\n  final Animation<double> animation;\n\n  PulsePainter(this.animation) : super(repaint: animation);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = Colors.blue.withOpacity(1.0 - animation.value)\n      ..style = PaintingStyle.fill;\n\n    final double radius = (size.width / 2) * animation.value;\n    canvas.drawCircle(Offset(size.width / 2, size.height / 2), radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(PulsePainter oldDelegate) => false;\n}\n\nclass PulseWidget extends StatefulWidget {\n  const PulseWidget({super.key});\n  @override\n  State<PulseWidget> createState() => _PulseWidgetState();\n}\n\nclass _PulseWidgetState extends State<PulseWidget> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 2),\n    )..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: PulsePainter(_controller),\n      size: const Size(100, 100),\n    );\n  }\n}"}
{"instruction": "Implement a basic counter using the Provider package. Create a Counter model extending ChangeNotifier and a widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: TextStyle(fontSize: 24));\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Todo list manager using Riverpod's StateNotifier. Define a Todo class, a StateNotifier, and the provider.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Write a CustomPainter class named 'ShapePainter' that draws a red rectangle and a blue circle on the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass ShapePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    // Draw Red Rectangle\n    final rectPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    \n    final rect = Rect.fromLTWH(50, 50, 100, 100);\n    canvas.drawRect(rect, rectPaint);\n\n    // Draw Blue Circle\n    final circlePaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    \n    canvas.drawCircle(Offset(size.width / 2, size.height / 2), 40, circlePaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of a MethodChannel to retrieve the current battery level from native code.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to simulate fetching user data and display 'Loading', 'Error', or the data using the .when syntax.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a curved line using a Quadratic Bezier curve.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 3;\n\n    var path = Path();\n    // Start point\n    path.moveTo(0, size.height * 0.5);\n    \n    // Control point (x1, y1) and End point (x2, y2)\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control X (center width)\n      0,                // Control Y (top)\n      size.width,       // End X\n      size.height * 0.5 // End Y\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize a Provider consumer using the 'Selector' widget to only rebuild when a specific property 'age' changes in the UserModel.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age Widget'); // Only prints when age changes\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a continuous stream of time updates from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass TimeStreamWidget extends StatefulWidget {\n  @override\n  _TimeStreamWidgetState createState() => _TimeStreamWidgetState();\n}\n\nclass _TimeStreamWidgetState extends State<TimeStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/time');\n  String _timer = 'Waiting...';\n  StreamSubscription? _streamSubscription;\n\n  @override\n  void initState() {\n    super.initState();\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() {\n        _timer = event.toString();\n      });\n    }, onError: (error) {\n      setState(() {\n        _timer = 'Error: $error';\n      });\n    });\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Native Time: $_timer');\n  }\n}"}
{"instruction": "Show how to initialize a Flutter app using Riverpod by wrapping the root widget in a ProviderScope.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(\n    // ProviderScope is required for Riverpod to work\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(body: Center(child: Text('Hello Riverpod'))),\n    );\n  }\n}"}
{"instruction": "Create a widget that animates a CustomPainter. It should take an AnimationController and pass the value to the painter to draw a growing circle.", "output": "import 'package:flutter/material.dart';\n\nclass GrowingCircle extends StatefulWidget {\n  @override\n  _GrowingCircleState createState() => _GrowingCircleState();\n}\n\nclass _GrowingCircleState extends State<GrowingCircle> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: Duration(seconds: 2),\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      builder: (context, child) {\n        return CustomPaint(\n          painter: CirclePainter(_controller.value),\n          size: Size(200, 200),\n        );\n      },\n    );\n  }\n}\n\nclass CirclePainter extends CustomPainter {\n  final double progress;\n  CirclePainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()..color = Colors.blue;\n    final maxRadius = size.width / 2;\n    canvas.drawCircle(\n      Offset(size.width / 2, size.height / 2),\n      maxRadius * progress,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(CirclePainter oldDelegate) => oldDelegate.progress != progress;\n}"}
{"instruction": "Create a simple Counter class using the Provider package's ChangeNotifier and a widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => Counter(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: Builder(\n          builder: (context) => FloatingActionButton(\n            onPressed: () => context.read<Counter>().increment(),\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod StateNotifier to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((todo) => todo != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Dart function that uses MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a red quadratic bezier curve.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width / 2, size.height / 4, size.width, size.height * 0.75);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the Provider package's Selector widget to only rebuild a widget when a specific property of the model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement a Dart class that listens to a stream of events from native code using EventChannel.", "output": "import 'package:flutter/services.dart';\n\nclass SensorListener {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double> get sensorDataStream {\n    return _eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n\n  void listenToSensor() {\n    sensorDataStream.listen(\n      (data) => print('Sensor value: $data'),\n      onError: (error) => print('Error: $error'),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod provider using the .family modifier to fetch details based on an ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal itemDetailsProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Details for item ID: $id';\n});\n\n// Usage inside a widget:\n// final asyncItem = ref.watch(itemDetailsProvider(42));"}
{"instruction": "Create a CustomPainter that applies a Shader (SweepGradient) to draw a colorful arc.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final gradient = SweepGradient(\n      startAngle: 0.0,\n      endAngle: pi * 2,\n      colors: [Colors.blue, Colors.green, Colors.red, Colors.blue],\n    );\n\n    final paint = Paint()\n      ..shader = gradient.createShader(rect)\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round;\n\n    canvas.drawArc(rect, 0.0, pi * 1.5, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application state using the 'provider' package. Define a `Counter` class extending `ChangeNotifier` and wrap the app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<Counter>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Todo list state manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a `CustomPainter` that draws a filled blue circle in the center of the canvas with a radius of 50.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: BlueCirclePainter(),\n      size: Size(200, 200),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a Flutter MethodChannel to invoke a platform-specific method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a string from a simulated API and handle the `AsyncValue` (loading, error, data) in a ConsumerWidget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n});\n\nclass ConfigView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> config = ref.watch(configProvider);\n\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (data) => Text(data),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a simple wave shape using `Path` and `quadraticBezierTo`.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    var path = Path();\n    path.moveTo(0, size.height / 2);\n    path.quadraticBezierTo(\n      size.width / 2, \n      size.height / 2 - 100, \n      size.width, \n      size.height / 2\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Setup a `MultiProvider` at the root of a Flutter app to provide two distinct ChangeNotifiers: `AuthModel` and `ThemeModel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {/*...*/}\nclass ThemeModel extends ChangeNotifier {/*...*/}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) => const MaterialApp(home: Scaffold());\n}"}
{"instruction": "Implement the Dart side of an `EventChannel` to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorListener {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n\n  void startListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        print('Received sensor data: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _streamSubscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches user details based on a specific user ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Simulating API call\nFuture<User> fetchUser(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return User(id, 'User $id');\n}\n\n// Provider with family modifier\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  return await fetchUser(userId);\n});\n\n// Usage: ref.watch(userProvider(123));"}
{"instruction": "Create a `CustomPainter` that fills a rectangle with a linear gradient shader from top-left to bottom-right.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n        colors: [Colors.purple, Colors.orange],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Riverpod for state management. Define a `StateProvider` for the integer count and a `ConsumerWidget` to display and increment it.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterApp()),\n    ),\n  );\n}\n\nclass CounterApp extends ConsumerWidget {\n  const CounterApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Todo List manager using the `provider` package. Create a `ChangeNotifier` class that holds a list of strings and methods to add/remove items.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoNotifier extends ChangeNotifier {\n  final List<String> _todos = [];\n  List<String> get todos => _todos;\n\n  void addTodo(String task) {\n    _todos.add(task);\n    notifyListeners();\n  }\n\n  void removeTodo(int index) {\n    _todos.removeAt(index);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => TodoNotifier(),\n      child: const MaterialApp(home: TodoScreen()),\n    ),\n  );\n}\n\nclass TodoScreen extends StatelessWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Todo')),\n      body: Consumer<TodoNotifier>(\n        builder: (context, todoNotifier, child) {\n          return ListView.builder(\n            itemCount: todoNotifier.todos.length,\n            itemBuilder: (context, index) {\n              return ListTile(\n                title: Text(todoNotifier.todos[index]),\n                trailing: IconButton(\n                  icon: const Icon(Icons.delete),\n                  onPressed: () => todoNotifier.removeTodo(index),\n                ),\n              );\n            },\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          context.read<TodoNotifier>().addTodo('New Task ${DateTime.now().second}');\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a red circle in the center of the canvas with a blue border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: CustomPaint(\n          size: const Size(200, 200),\n          painter: MyCirclePainter(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Draw filled red circle\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw blue border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Flutter `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel'. Handle the result and potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a simulated list of data asynchronously and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return ['Apple', 'Banana', 'Orange'];\n});\n\nclass AsyncDataWidget extends ConsumerWidget {\n  const AsyncDataWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('FutureProvider Example')),\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => ListView.builder(\n            itemCount: data.length,\n            itemBuilder: (_, index) => ListTile(title: Text(data[index])),\n          ),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainterWidget extends StatelessWidget {\n  const WavePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: BezierWavePainter(),\n    );\n  }\n}\n\nclass BezierWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n\n    // Draw quadratic bezier\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.4, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize a Provider implementation using `Selector`. Create a model with `name` and `age`, but ensure the widget only rebuilds when `age` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName() {\n    name = name == 'John' ? 'Doe' : 'John';\n    notifyListeners();\n  }\n}\n\nclass SelectorExample extends StatelessWidget {\n  const SelectorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => UserModel(),\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Selector Optimization')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Only rebuilds if 'age' changes\n              Selector<UserModel, int>(\n                selector: (_, model) => model.age,\n                builder: (_, age, __) {\n                  return Text('Age: $age (Rebuilds only on age change)');\n                },\n              ),\n              Consumer<UserModel>(\n                builder: (_, model, __) => ElevatedButton(\n                  onPressed: model.incrementAge,\n                  child: const Text('Increment Age'),\n                ),\n              ),\n              Consumer<UserModel>(\n                builder: (_, model, __) => ElevatedButton(\n                  onPressed: model.changeName,\n                  child: const Text('Change Name (No Age Rebuild)'),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `NotifierProvider` (Riverpod 2.0 syntax) to manage a complex state object (e.g., a filter configuration class).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Immutable state class\nclass FilterState {\n  final bool showCompleted;\n  final String searchQuery;\n\n  FilterState({this.showCompleted = false, this.searchQuery = ''});\n\n  FilterState copyWith({bool? showCompleted, String? searchQuery}) {\n    return FilterState(\n      showCompleted: showCompleted ?? this.showCompleted,\n      searchQuery: searchQuery ?? this.searchQuery,\n    );\n  }\n}\n\n// Notifier\nclass FilterNotifier extends Notifier<FilterState> {\n  @override\n  FilterState build() => FilterState();\n\n  void toggleShowCompleted() {\n    state = state.copyWith(showCompleted: !state.showCompleted);\n  }\n\n  void updateSearch(String query) {\n    state = state.copyWith(searchQuery: query);\n  }\n}\n\nfinal filterProvider = NotifierProvider<FilterNotifier, FilterState>(FilterNotifier.new);\n\nclass FilterScreen extends ConsumerWidget {\n  const FilterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final filter = ref.watch(filterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('NotifierProvider Example')),\n      body: Column(\n        children: [\n          SwitchListTile(\n            title: const Text('Show Completed'),\n            value: filter.showCompleted,\n            onChanged: (_) => ref.read(filterProvider.notifier).toggleShowCompleted(),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              onChanged: (val) => ref.read(filterProvider.notifier).updateSearch(val),\n              decoration: const InputDecoration(labelText: 'Search'),\n            ),\n          ),\n          Text('Current Search: ${filter.searchQuery}'),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `MethodChannel` implementation that sends a map of arguments (e.g., coordinates) to the native platform to open a map application.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass OpenMapButton extends StatelessWidget {\n  const OpenMapButton({super.key});\n\n  static const platform = MethodChannel('com.example.app/maps');\n\n  Future<void> _openMap() async {\n    try {\n      await platform.invokeMethod('openMap', <String, double>{\n        'latitude': 37.7749,\n        'longitude': -122.4194,\n      });\n    } on PlatformException catch (e) {\n      debugPrint(\"Failed to open map: '${e.message}'.\");\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: _openMap,\n      child: const Text('Open Native Map'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a gradient progress arc.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcWidget extends StatelessWidget {\n  const GradientArcWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: 150,\n      height: 150,\n      child: CustomPaint(\n        painter: GradientArcPainter(progress: 0.75),\n      ),\n    );\n  }\n}\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * progress;\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple, Colors.red],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    // Draw background circle\n    final bgPaint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..color = Colors.grey.shade300;\n    canvas.drawArc(rect, 0, 2 * pi, false, bgPaint);\n\n    // Draw progress\n    canvas.drawArc(rect, startAngle, sweepAngle, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: CounterPage()),\n    ),\n  );\n}\n\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider state\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Theme Switcher (Light/Dark mode) using the `Provider` package and `ChangeNotifier`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme(bool isDark) {\n    _themeMode = isDark ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: Provider.of<ThemeProvider>(context).themeMode,\n      home: const SettingsPage(),\n    );\n  }\n}\n\nclass SettingsPage extends StatelessWidget {\n  const SettingsPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeProvider = Provider.of<ThemeProvider>(context);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Theme Switcher')),\n      body: Center(\n        child: SwitchListTile(\n          title: const Text('Dark Mode'),\n          value: themeProvider.themeMode == ThemeMode.dark,\n          onChanged: (val) => themeProvider.toggleTheme(val),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a target pattern (concentric circles) with alternating colors.", "output": "import 'package:flutter/material.dart';\n\nclass TargetPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final maxRadius = size.width / 2;\n    final paint = Paint()..style = PaintingStyle.fill;\n\n    // Draw 5 concentric circles\n    for (int i = 0; i < 5; i++) {\n      paint.color = i % 2 == 0 ? Colors.red : Colors.white;\n      double radius = maxRadius - (i * (maxRadius / 5));\n      canvas.drawCircle(center, radius, paint);\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass TargetWidget extends StatelessWidget {\n  const TargetWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: TargetPainter(),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a Platform Channel (`MethodChannel`) to retrieve the battery level from native code.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Create the channel with a unique name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to handle async data fetching with loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'User: John Doe';\n}\n\n// 2. Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        // 3. Handle states using .when\n        child: userAsync.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` to draw a simple sine wave graph based on a list of data points.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..strokeWidth = 3\n      ..style = PaintingStyle.stroke;\n\n    final path = Path();\n    \n    // Start at middle left\n    path.moveTo(0, size.height / 2);\n\n    for (double x = 0; x <= size.width; x++) {\n      // Calculate Y based on sine function\n      double y = size.height / 2 + 50 * sin((x / size.width) * 2 * pi);\n      path.lineTo(x, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass WaveWidget extends StatelessWidget {\n  const WaveWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: SineWavePainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Shopping Cart logic using `Provider` where items can be added and the total price updates automatically.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Product {\n  final String name;\n  final double price;\n  Product(this.name, this.price);\n}\n\nclass CartModel extends ChangeNotifier {\n  final List<Product> _items = [];\n\n  List<Product> get items => _items;\n\n  double get totalPrice => _items.fold(0, (sum, item) => sum + item.price);\n\n  void add(Product item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(Product item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n}\n\nclass CartScreen extends StatelessWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Cart')),\n      body: Consumer<CartModel>(\n        builder: (context, cart, child) {\n          return Column(\n            children: [\n              Expanded(\n                child: ListView.builder(\n                  itemCount: cart.items.length,\n                  itemBuilder: (context, index) => ListTile(\n                    title: Text(cart.items[index].name),\n                    trailing: IconButton(\n                      icon: const Icon(Icons.remove_circle),\n                      onPressed: () => cart.remove(cart.items[index]),\n                    ),\n                  ),\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text('Total: \\$${cart.totalPrice}'),\n              )\n            ],\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          Provider.of<CartModel>(context, listen: false)\n              .add(Product('Apple', 1.50));\n        },\n        child: const Icon(Icons.add_shopping_cart),\n      ),\n    );\n  }\n}"}
{"instruction": "Use a `MethodChannel` to invoke a native method named 'showToast' passing a message string argument.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}\n\n// Usage inside a button callback:\n// await NativeToastService().showToast(\"Hello from Flutter!\");"}
{"instruction": "Implement a Riverpod provider using the `.family` modifier to fetch details based on an ID.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define family provider expecting an int ID\nfinal itemDetailsProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch provider with specific parameter\n    final itemAsync = ref.watch(itemDetailsProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Item Details')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, s) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a circular progress indicator with a custom gradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * progress;\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple, Colors.red],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, startAngle, sweepAngle, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}\n\n// Usage:\n// CustomPaint(size: Size(100, 100), painter: GradientArcPainter(0.75))"}
{"instruction": "Create a basic counter application using the 'Provider' package. Define a `ChangeNotifier` class for the state and wrap the app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              'Count: ${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel (Dart side) to invoke a platform-specific method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod to fetch asynchronous data. Create a `FutureProvider` that simulates a network request and a `ConsumerWidget` to handle Loading, Error, and Data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userDataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'User Data Loaded';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> user = ref.watch(userDataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: user.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a simple smiley face (a yellow circle, two black eyes, and an arc for the mouth).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass SmileyPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n\n    // Face\n    final facePaint = Paint()..color = Colors.yellow;\n    canvas.drawCircle(center, radius, facePaint);\n\n    // Eyes\n    final eyePaint = Paint()..color = Colors.black;\n    canvas.drawCircle(Offset(center.dx - radius / 3, center.dy - radius / 3), 10, eyePaint);\n    canvas.drawCircle(Offset(center.dx + radius / 3, center.dy - radius / 3), 10, eyePaint);\n\n    // Mouth\n    final mouthPaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n    \n    final mouthRect = Rect.fromCircle(center: center, radius: radius / 1.5);\n    canvas.drawArc(mouthRect, 0, pi, false, mouthPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod `StateNotifier` to manage a Todo list. Include methods to add a todo and toggle its completion status.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a Bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    \n    path.quadraticBezierTo(\n      size.width * 0.25, size.height * 0.7,\n      size.width * 0.5, size.height * 0.8,\n    );\n    \n    path.quadraticBezierTo(\n      size.width * 0.75, size.height * 0.9,\n      size.width, size.height * 0.8,\n    );\n\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Provider's `ChangeNotifierProxyProvider` to update a `CartModel` whenever the `AuthModel` changes (e.g., clearing the cart on logout).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  bool _isAuthenticated = false;\n  bool get isAuthenticated => _isAuthenticated;\n\n  void login() { _isAuthenticated = true; notifyListeners(); }\n  void logout() { _isAuthenticated = false; notifyListeners(); }\n}\n\nclass CartModel extends ChangeNotifier {\n  final AuthModel _auth;\n  List<String> _items = [];\n\n  CartModel(this._auth);\n\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  // Called by ProxyProvider update\n  void update() {\n    if (!_auth.isAuthenticated) {\n      _items.clear();\n      notifyListeners();\n    }\n  }\n}\n\n// Usage in MultiProvider\n/*\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider(create: (_) => AuthModel()),\n    ChangeNotifierProxyProvider<AuthModel, CartModel>(\n      create: (ctx) => CartModel(ctx.read<AuthModel>()),\n      update: (ctx, auth, cart) => cart!..update(),\n    ),\n  ],\n  child: MyApp(),\n)\n*/"}
{"instruction": "Implement a Flutter EventChannel to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = event as double;\n        });\n      },\n      onError: (dynamic error) {\n        debugPrint('Received error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Sensor Value: $_sensorValue'));\n  }\n}"}
{"instruction": "Using Riverpod, use the `.family` modifier to create a provider that fetches details for a specific item ID passed as an argument.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A mock service\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item #$id';\n}\n\n// The family provider\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\n// Usage inside a Widget\n/*\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({required this.itemId, super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return itemAsync.when(\n      data: (details) => Text(details),\n      loading: () => const CircularProgressIndicator(),\n      error: (e, st) => Text('Error: $e'),\n    );\n  }\n}\n*/"}
{"instruction": "Create a CustomPainter that draws a radial gradient progress bar (circular progress indicator with a gradient).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * progress;\n    \n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    // Draw background circle\n    final bgPaint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..color = Colors.grey.withOpacity(0.2);\n    canvas.drawArc(rect, 0, 2 * pi, false, bgPaint);\n\n    // Draw gradient progress\n    canvas.save();\n    // Rotate canvas to start from top\n    canvas.translate(size.width / 2, size.height / 2);\n    canvas.rotate(-pi / 2);\n    canvas.translate(-size.width / 2, -size.height / 2);\n    \n    // Note: Shader rotation logic is simplified here; usually requires Matrix4 for perfect alignment\n    canvas.drawArc(rect, 0, 2 * pi * progress, false, paint);\n    canvas.restore();\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a simple Counter state management class using the Provider package (ChangeNotifier) and show how to consume it in a widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// Usage in Widget\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => Counter(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: Consumer<Counter>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod StateNotifier to manage a list of Todo items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = 50.0;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of a MethodChannel to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data asynchronously and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2)); // Simulate API call\n  return 'Configuration Loaded';\n});\n\nclass ConfigView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final config = ref.watch(configProvider);\n\n    return config.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.75);\n    // Draw quadratic curve to bottom right\n    path.quadraticBezierTo(\n        size.width / 2, size.height, size.width, size.height * 0.75);\n    // Close path\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod provider using the '.family' modifier to fetch specific user details based on a User ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Mock API call\nFuture<User> fetchUser(int id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return User(id, 'User $id');\n}\n\n// Family provider accepting an integer ID\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n\n// Usage: ref.watch(userProvider(123));"}
{"instruction": "Setup an EventChannel in Dart to listen to a continuous stream of events from the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n\n  Stream<double> get sensorDataStream {\n    return _eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n\n  void listenToSensor() {\n    sensorDataStream.listen(\n      (data) => print('Sensor data: $data'),\n      onError: (error) => print('Error: $error'),\n    );\n  }\n}"}
{"instruction": "Demonstrate how to paint text explicitly onto a Canvas using TextPainter within a CustomPainter.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final textSpan = TextSpan(\n      text: 'Hello CustomPainter',\n      style: TextStyle(color: Colors.black, fontSize: 24),\n    );\n    \n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n    \n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n    \n    // Draw text at offset (10, 10)\n    textPainter.paint(canvas, Offset(10, 10));\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the 'Selector' widget from the Provider package to optimize rebuilds by listening only to a specific property of a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void updateName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass NameDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'name' changes, ignores 'age' changes\n    return Selector<UserModel, String>(\n      selector: (_, model) => model.name,\n      builder: (_, name, __) => Text('User Name: $name'),\n    );\n  }\n}"}
{"instruction": "Implement a basic counter state using the Provider package's ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// Usage in main:\n// ChangeNotifierProvider(create: (_) => CounterModel(), child: MyApp());\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) => Text('${counter.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a simple filled circle with a contrasting border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's StateNotifier to manage a list of Todo items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement the Dart side of a MethodChannel to invoke a native platform method called 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}.';\n    }\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch async data and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a triangle using the Path class.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Top center\n    path.moveTo(size.width / 2, 0);\n    // Bottom right\n    path.lineTo(size.width, size.height);\n    // Bottom left\n    path.lineTo(0, size.height);\n    // Close the path to form a triangle\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate the usage of Provider's Selector widget to rebuild a widget only when a specific property changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'age' changes, ignoring 'name' changes\n    return Selector<UserModel, int>(\n      selector: (_, model) => model.age,\n      builder: (_, age, __) {\n        print('Age widget rebuilt');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void cancel() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's .family modifier to create a provider that fetches user details based on a User ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// A fake API call\nFuture<User> fetchUserById(int id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return User(id, 'User $id');\n}\n\n// Family provider accepting an int parameter\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  return fetchUserById(userId);\n});\n\n// Usage: ref.watch(userProvider(123));"}
{"instruction": "Implement a CustomPainter that fills the available area with a linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = LinearGradient(\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n        colors: [Colors.purple, Colors.orange],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a simple counter state management system using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) => Text('${counter.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Dart function to invoke a native platform method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a StateNotifierProvider using Riverpod to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement a CustomPainter to draw a quadratic Bezier curve (a wave) at the bottom of the widget.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width / 2, size.height, size.width, size.height * 0.75);\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data asynchronously and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n});\n\nclass ConfigView extends ConsumerWidget {\n  const ConfigView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncConfig = ref.watch(configProvider);\n\n    return asyncConfig.when(\n      data: (config) => Text(config),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a continuous stream of sensor data from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Optimize a Provider rebuild by using the Selector widget to only listen to a specific property (age) of a User model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n  // ... methods to update state\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      selector: (_, user) => user.age,\n      builder: (_, age, __) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress arc with a SweepGradient.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect)\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(GradientArcPainter oldDelegate) => oldDelegate.progress != progress;\n}"}
{"instruction": "Demonstrate the use of Riverpod's '.family' modifier to pass an argument (userID) to a FutureProvider.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUsername(int userId) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'User_$userId';\n}\n\n// Provider with family modifier\nfinal userProvider = FutureProvider.family<String, int>((ref, userId) async {\n  return await fetchUsername(userId);\n});\n\n// Usage inside a Widget build method:\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a basic counter implementation using the `provider` package. Define a `ChangeNotifier` class and wrap the app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Consumer<Counter>(\n          builder: (context, counter, child) => Text('${counter.count}'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<Counter>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a filled blue circle with a radius of 50 in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: BlueCirclePainter(),\n      size: const Size(200, 200),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `StateNotifier` to manage a list of Todo strings. Create the provider and the notifier class.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Set up a Flutter `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel'. Handle potential `PlatformException`s.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a `FutureProvider` using Riverpod to fetch a random user name asynchronously, and a widget that handles the loading, error, and data states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserWidget extends ConsumerWidget {\n  const UserWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Write a `CustomPainter` to draw a quadratic bezier curve (a wave) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement an `EventChannel` in Flutter to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorListener {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use `ProxyProvider` from the Provider package to inject a value from one model (`AuthModel`) into another (`CartModel`).", "output": "import 'package:provider/provider.dart';\n\nclass AuthModel with ChangeNotifier {\n  String? userId = 'user_123';\n}\n\nclass CartModel with ChangeNotifier {\n  final AuthModel _auth;\n  CartModel(this._auth);\n\n  String get status => 'Cart for user: ${_auth.userId}';\n}\n\n// In main or setup:\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider(create: (_) => AuthModel()),\n    ChangeNotifierProxyProvider<AuthModel, CartModel>(\n      create: (context) => CartModel(context.read<AuthModel>()),\n      update: (context, auth, previousCart) => CartModel(auth),\n    ),\n  ],\n  child: const MyApp(),\n);"}
{"instruction": "Create a Riverpod provider using the `.family` modifier that accepts an integer ID and returns a formatted string.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// The provider accepts an int (id) and returns a String\nfinal itemTitleProvider = Provider.family<String, int>((ref, id) {\n  return 'Item #$id';\n});\n\nclass ItemWidget extends ConsumerWidget {\n  final int itemId;\n  const ItemWidget({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final title = ref.watch(itemTitleProvider(itemId));\n    return Text(title);\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a progress arc (stroke) with a gradient shader.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final gradient = const SweepGradient(\n      startAngle: 0.0,\n      endAngle: pi * 2,\n      colors: [Colors.blue, Colors.purple, Colors.blue],\n    ).createShader(rect);\n\n    final paint = Paint()\n      ..shader = gradient\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 8.0\n      ..strokeCap = StrokeCap.round;\n\n    // Draw 75% of a circle\n    canvas.drawArc(rect, -pi / 2, pi * 1.5, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the `provider` package. Define a `ChangeNotifier` class for the counter state and a widget that consumes this state to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: MaterialApp(\n        home: Scaffold(\n          appBar: AppBar(title: Text('Provider Counter')),\n          body: Center(\n            child: Consumer<CounterModel>(\n              builder: (context, counter, child) {\n                return Text('${counter.count}', style: TextStyle(fontSize: 24));\n              },\n            ),\n          ),\n          floatingActionButton: Consumer<CounterModel>(\n            builder: (context, counter, child) => FloatingActionButton(\n              onPressed: counter.increment,\n              child: Icon(Icons.add),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: CirclePainter(),\n      child: Container(height: 200, width: 200),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display a string from a simulated asynchronous API call. Handle the loading, error, and data states using `.when()`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass AsyncDataWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data, style: TextStyle(fontSize: 20)),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(ProviderScope(child: MaterialApp(home: AsyncDataWidget())));\n}"}
{"instruction": "Create a MethodChannel in Flutter to invoke a native platform method named 'getBatteryLevel'. Include error handling for PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.battery/level');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Demonstrate the use of Provider's `Selector` to optimize rebuilds. Create a model with two properties (name, age), but have a widget that only rebuilds when 'age' changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, int>(\n      selector: (_, model) => model.age,\n      builder: (_, age, __) {\n        print('Building Age Widget'); // Only prints when age changes\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a smooth curve) from the bottom-left to the top-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    \n    // Control point at top left, end point at top right\n    path.quadraticBezierTo(\n      size.width * 0.25, // Control point X\n      size.height * 0.25, // Control point Y\n      size.width, // End point X\n      0, // End point Y\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod `StateNotifier` to manage a list of Todo items. Include methods to add a todo and toggle its completion status.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Establish an EventChannel in Flutter to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('com.example.sensors/stream');\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(Object? event) {\n    setState(() {\n      _sensorData = \"Sensor: $event\";\n    });\n  }\n\n  void _onError(Object error) {\n    setState(() {\n      _sensorData = \"Error: $error\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a CustomPainter that applies a linear gradient shader to a rectangle.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final Paint paint = Paint()\n      ..shader = LinearGradient(\n        colors: [Colors.orange, Colors.deepPurple],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use `ref.listen` in a Riverpod ConsumerWidget to show a SnackBar when a state counter reaches the value 5.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass CounterListenerWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Listen for side effects\n    ref.listen<int>(counterProvider, (previous, next) {\n      if (next == 5) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Counter reached 5! DING!')),\n        );\n      }\n    });\n\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      body: Center(child: Text('$count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple Counter application using the `provider` package. The output should include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a simple red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paintCircle = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final paintBorder = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, paintCircle);\n    canvas.drawCircle(center, radius, paintBorder);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Write a Dart class that uses `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handles the result or error.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}\n\n// Usage example inside a StatefulWidget logic:\n// String _level = await BatteryService().getBatteryLevel();"}
{"instruction": "Create a `StateNotifier` and `StateNotifierProvider` using Riverpod to manage a list of Todo strings (add and remove functionality).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) => ListTile(\n          title: Text(todos[index]),\n          onTap: () => ref.read(todoListProvider.notifier).remove(todos[index]),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Todo ${todos.length}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` to draw a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    // Draw curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n    // Close the path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a simple string data asynchronously and display it using the `.when` syntax.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n});\n\nclass ConfigScreen extends ConsumerWidget {\n  const ConfigScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: configAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Set up a `MultiProvider` configuration that provides two independent ChangeNotifiers (`UserProvider` and `ThemeModel`) to the app.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserProvider extends ChangeNotifier {\n  String name = 'Guest';\n}\n\nclass ThemeModel extends ChangeNotifier {\n  bool isDark = false;\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => UserProvider()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MaterialApp(home: HomeScreen()),\n    ),\n  );\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(body: Center(child: Text('MultiProvider Setup')));\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a dotted line connecting two points.", "output": "import 'package:flutter/material.dart';\n\nclass DottedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n    final double endX = size.width;\n\n    while (startX < endX) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Dart method using `MethodChannel` that accepts arguments (a Map) to send data to the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message, bool isLong) async {\n    try {\n      await platform.invokeMethod('showToast', <String, dynamic>{\n        'message': message,\n        'duration': isLong ? 1 : 0, // 1 for Long, 0 for Short\n      });\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Use Riverpod's `family` modifier to create a provider that fetches a specific user by their ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Family provider accepting an integer ID\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network request\n  await Future.delayed(const Duration(seconds: 1));\n  return User(userId, 'User $userId');\n});\n\n// Usage in ConsumerWidget\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a simple counter application using Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterPage()),\n    ),\n  );\n}\n\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a `ChangeNotifier` class for a Theme Switcher using the Provider package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeProvider with ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme(bool isDark) {\n    _themeMode = isDark ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\n// Usage Example\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: Consumer<ThemeProvider>(\n        builder: (context, themeProvider, child) {\n          return MaterialApp(\n            themeMode: themeProvider.themeMode,\n            theme: ThemeData.light(),\n            darkTheme: ThemeData.dark(),\n            home: Scaffold(\n              body: Center(\n                child: Switch(\n                  value: themeProvider.themeMode == ThemeMode.dark,\n                  onChanged: (val) => themeProvider.toggleTheme(val),\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}"}
{"instruction": "Write a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching user data asynchronously.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate network request\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    \n    // Draw curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x (center)\n      size.height * 0.6, // Control point y (higher up)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n    \n    // Close path to bottom right corner\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Shopping Cart model using `ChangeNotifier` (Provider) that allows adding and removing items.", "output": "import 'package:flutter/material.dart';\n\nclass CartItem {\n  final String id;\n  final String name;\n  CartItem(this.id, this.name);\n}\n\nclass CartModel extends ChangeNotifier {\n  final List<CartItem> _items = [];\n\n  List<CartItem> get items => List.unmodifiable(_items);\n\n  int get totalPrice => _items.length * 10; // Dummy price logic\n\n  void add(CartItem item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(CartItem item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n\n  void clear() {\n    _items.clear();\n    notifyListeners();\n  }\n}"}
{"instruction": "Set up an `EventChannel` to listen to a stream of events from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nclass EventStreamWidget extends StatefulWidget {\n  const EventStreamWidget({super.key});\n\n  @override\n  State<EventStreamWidget> createState() => _EventStreamWidgetState();\n}\n\nclass _EventStreamWidgetState extends State<EventStreamWidget> {\n  static const eventChannel = EventChannel('samples.flutter.dev/stream');\n  StreamSubscription? _subscription;\n  String _eventData = 'Waiting for events...';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _eventData = 'Event received: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _eventData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(_eventData);\n  }\n}"}
{"instruction": "Create a Riverpod provider using `.family` to fetch details based on an argument (ID).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item #$id';\n}\n\n// Family provider definition\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItemDetails(id);\n});\n\n// Usage in ConsumerWidget\n// Widget build(BuildContext context, WidgetRef ref) {\n//   final itemAsync = ref.watch(itemDetailProvider(42));\n//   return itemAsync.when(\n//     data: (data) => Text(data),\n//     loading: () => const CircularProgressIndicator(),\n//     error: (e, s) => Text('Error: $e'),\n//   );\n// }"}
{"instruction": "Create a `CustomPainter` to draw a horizontal dotted line.", "output": "import 'package:flutter/material.dart';\n\nclass DottedLinePainter extends CustomPainter {\n  final Color color;\n  final double dotRadius;\n  final double spacing;\n\n  DottedLinePainter({\n    this.color = Colors.black,\n    this.dotRadius = 2.0,\n    this.spacing = 5.0,\n  });\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = color\n      ..style = PaintingStyle.fill;\n\n    double startX = 0;\n    final y = size.height / 2;\n\n    while (startX < size.width) {\n      canvas.drawCircle(Offset(startX, y), dotRadius, paint);\n      startX += (dotRadius * 2) + spacing;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a simple Counter state using the 'provider' package, including the ChangeNotifier class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Todo list manager using Riverpod's StateNotifierProvider. Include methods to add and toggle todos.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a filled circle in the center of the canvas with a specific radius and color.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  final Color color;\n  final double radius;\n\n  CirclePainter({this.color = Colors.blue, this.radius = 50.0});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = color\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CirclePainter oldDelegate) {\n    return oldDelegate.color != color || oldDelegate.radius != radius;\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Demonstrate how to fetch data asynchronously using Riverpod's FutureProvider and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n});\n\nclass ConfigWidget extends ConsumerWidget {\n  const ConfigWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final config = ref.watch(configProvider);\n\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (data) => Text(data),\n    );\n  }\n}"}
{"instruction": "Write a CustomPainter class that draws a sine wave across the width of the widget.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n\n    final path = Path();\n    final midY = size.height / 2;\n    \n    path.moveTo(0, midY);\n    \n    for (double x = 0; x <= size.width; x++) {\n      // y = A * sin(kx)\n      double y = midY + 30 * sin((x / size.width) * 2 * pi);\n      path.lineTo(x, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement an EventChannel in Dart to listen to a continuous stream of sensor data events from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void cancel() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use ProxyProvider to inject a dependency from an AuthModel into a CartModel within the provider setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel with ChangeNotifier {\n  String? userId = 'user_123';\n}\n\nclass CartModel with ChangeNotifier {\n  final AuthModel _auth;\n  CartModel(this._auth);\n  \n  void checkout() {\n    print('Checking out for user: ${_auth.userId}');\n  }\n}\n\nWidget buildProviderTree() {\n  return MultiProvider(\n    providers: [\n      ChangeNotifierProvider(create: (_) => AuthModel()),\n      ChangeNotifierProxyProvider<AuthModel, CartModel>(\n        create: (context) => CartModel(context.read<AuthModel>()),\n        update: (context, auth, previousCart) => CartModel(auth),\n      ),\n    ],\n    child: const MaterialApp(),\n  );\n}"}
{"instruction": "Create a CustomPainter that paints a rectangle filled with a linear gradient from top-left to bottom-right.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.orange, Colors.purple],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's .family modifier to create a provider that fetches user details based on a user ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock User model\nclass User { final String name; User(this.name); }\n\n// The provider accepts an integer (userId) as the family argument\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network request\n  await Future.delayed(const Duration(milliseconds: 500));\n  return User('User #$userId');\n});\n\n// Usage in a Widget\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a simple counter application using Riverpod 2.0 (NotifierProvider). Define the state, the notifier, and a ConsumerWidget to display and update the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the Notifier\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\n// 2. Define the Provider\nfinal counterProvider = NotifierProvider<CounterNotifier, int>(() => CounterNotifier());\n\n// 3. Create the Widget\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: Theme.of(context).textTheme.headlineMedium)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a filled circle with a 2px red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = (size.width < size.height ? size.width : size.height) / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), child: Container())"}
{"instruction": "Create a theme switcher using the Provider package. Include a ChangeNotifier that toggles a boolean for dark mode and a widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  bool _isDarkMode = false;\n  bool get isDarkMode => _isDarkMode;\n\n  void toggleTheme() {\n    _isDarkMode = !_isDarkMode;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: Consumer<ThemeProvider>(\n        builder: (context, themeProvider, child) {\n          return MaterialApp(\n            theme: themeProvider.isDarkMode ? ThemeData.dark() : ThemeData.light(),\n            home: Scaffold(\n              body: Center(\n                child: Switch(\n                  value: themeProvider.isDarkMode,\n                  onChanged: (val) => themeProvider.toggleTheme(),\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a MethodChannel to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a list of strings asynchronously and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return ['Apple', 'Banana', 'Cherry'];\n});\n\nclass DataListScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => ListView(children: data.map((e) => ListTile(title: Text(e))).toList()),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a smooth curve) from the bottom-left to the top-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    path.moveTo(0, size.height);\n    // Control point (bottom-right), End point (top-right)\n    path.quadraticBezierTo(size.width * 0.75, size.height, size.width, 0);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a 'Shopping Cart' logic using Provider. Create a `CartModel` that holds a list of items and calculates the total price.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Item {\n  final String name;\n  final double price;\n  Item(this.name, this.price);\n}\n\nclass CartModel extends ChangeNotifier {\n  final List<Item> _items = [];\n\n  List<Item> get items => _items;\n\n  double get totalPrice => _items.fold(0, (total, current) => total + current.price);\n\n  void add(Item item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void removeAll() {\n    _items.clear();\n    notifyListeners();\n  }\n}\n\n// Usage in main: ChangeNotifierProvider(create: (_) => CartModel(), child: ...)"}
{"instruction": "Set up a Flutter EventChannel to listen to a continuous stream of data (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(Object? event) {\n    setState(() {\n      _sensorValue = (event as num).toDouble();\n    });\n  }\n\n  void _onError(Object error) {\n    print('Received error: $error');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Sensor Value: $_sensorValue');\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches user details based on a specific User ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Define a family provider accepting an int (userId)\nfinal userProvider = FutureProvider.family<User, int>((ref, userId) async {\n  // Simulate network request\n  await Future.delayed(const Duration(milliseconds: 500));\n  return User(userId, 'User #$userId');\n});\n\n// Usage in Widget:\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a CustomPainter that fills the canvas with a vertical linear gradient from blue to green.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n        colors: [Colors.blue, Colors.green],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic counter application using Flutter Riverpod (v2) with a StateProvider. The widget should update the UI when the counter increments.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('Count: $count')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a yellow smiley face with two black eyes and a mouth.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass SmileyPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n\n    // Face\n    final facePaint = Paint()..color = Colors.yellow;\n    canvas.drawCircle(center, radius, facePaint);\n\n    // Eyes\n    final eyePaint = Paint()..color = Colors.black;\n    canvas.drawCircle(Offset(center.dx - radius / 3, center.dy - radius / 3), 10, eyePaint);\n    canvas.drawCircle(Offset(center.dx + radius / 3, center.dy - radius / 3), 10, eyePaint);\n\n    // Mouth\n    final mouthPaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n    \n    final mouthRect = Rect.fromCircle(center: center, radius: radius / 1.5);\n    canvas.drawArc(mouthRect, 0, pi, false, mouthPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a MethodChannel in Dart to invoke a native platform method named 'getBatteryLevel' and handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a simple Todo list state management logic using the 'provider' package with ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoModel extends ChangeNotifier {\n  final List<String> _todos = [];\n\n  List<String> get todos => _todos;\n\n  void add(String task) {\n    _todos.add(task);\n    notifyListeners();\n  }\n\n  void remove(int index) {\n    _todos.removeAt(index);\n    notifyListeners();\n  }\n}\n\n// Usage in main:\n// ChangeNotifierProvider(create: (context) => TodoModel(), child: MyApp());"}
{"instruction": "Use Riverpod's StateNotifier to manage a complex state object (a User class) immutably.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final String name;\n  final int age;\n  User({required this.name, required this.age});\n\n  User copyWith({String? name, int? age}) {\n    return User(\n      name: name ?? this.name,\n      age: age ?? this.age,\n    );\n  }\n}\n\nclass UserNotifier extends StateNotifier<User> {\n  UserNotifier() : super(User(name: 'Guest', age: 0));\n\n  void updateName(String newName) {\n    state = state.copyWith(name: newName);\n  }\n\n  void incrementAge() {\n    state = state.copyWith(age: state.age + 1);\n  }\n}\n\nfinal userProvider = StateNotifierProvider<UserNotifier, User>((ref) {\n  return UserNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a quadratic Bezier curve (a wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of an EventChannel to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch and display data from an asynchronous source (simulated API).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a circular progress indicator with a rounded stroke cap.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass ProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  ProgressPainter(this.percentage);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n    \n    final bgPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10;\n      \n    canvas.drawCircle(center, radius, bgPaint);\n\n    final progressPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    final angle = 2 * pi * percentage;\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2, // Start from top\n      angle,\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Demonstrate how to use ProxyProvider from the 'provider' package to inject a dependency (AuthModel) into another model (CartModel).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel with ChangeNotifier {\n  String userId = 'user_123';\n}\n\nclass CartModel with ChangeNotifier {\n  final AuthModel _auth;\n  List<String> items = [];\n\n  CartModel(this._auth);\n\n  void addItem(String item) {\n    print('Adding $item to cart for user ${_auth.userId}');\n    items.add(item);\n    notifyListeners();\n  }\n}\n\n// Usage inside MultiProvider:\n/*\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider(create: (_) => AuthModel()),\n    ChangeNotifierProxyProvider<AuthModel, CartModel>(\n      create: (context) => CartModel(Provider.of<AuthModel>(context, listen: false)),\n      update: (context, auth, previousCart) => CartModel(auth),\n    ),\n  ],\n  child: MyApp(),\n)\n*/"}
{"instruction": "Create a simple Counter application using Riverpod's StateProvider to manage the integer state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterPage()),\n    ),\n  );\n}\n\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider state\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a custom painter that draws a red circle with a blue border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled red circle\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw blue border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage widget\nclass MyCircleWidget extends StatelessWidget {\n  const MyCircleWidget({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use the Provider package to create a ThemeChanger that toggles between light and dark mode.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create ChangeNotifier\nclass ThemeChanger with ChangeNotifier {\n  ThemeData _themeData;\n\n  ThemeChanger(this._themeData);\n\n  get getTheme => _themeData;\n\n  void setTheme(ThemeData theme) {\n    _themeData = theme;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeChanger(ThemeData.light()),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    final themeChanger = Provider.of<ThemeChanger>(context);\n    return MaterialApp(\n      theme: themeChanger.getTheme,\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n  @override\n  Widget build(BuildContext context) {\n    final themeChanger = Provider.of<ThemeChanger>(context, listen: false);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Theme Switcher')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            themeChanger.setTheme(ThemeData.dark());\n          },\n          child: const Text('Switch to Dark Mode'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the MethodChannel\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch and display a string asynchronously.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define FutureProvider\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Configuration Loaded';\n});\n\nclass ConfigPage extends ConsumerWidget {\n  const ConfigPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the future\n    final AsyncValue<String> config = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        child: config.when(\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n          data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    Paint paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    Path path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.75);\n    \n    // Draw curve to bottom right\n    path.quadraticBezierTo(\n      size.width / 2,   // Control point (middle x, bottom y)\n      size.height, \n      size.width,       // End point (right x)\n      size.height * 0.75 // End point (y)\n    );\n    \n    // Close the path\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize a Provider rebuild using the 'Selector' widget to only rebuild when a specific property changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User with ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void growOlder() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds if 'age' changes, ignores 'name' changes\n    return Selector<User, int>(\n      selector: (_, user) => user.age,\n      builder: (_, age, __) {\n        print('Building Age Widget');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Flutter to listen to a stream of events from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  // 1. Define EventChannel\n  static const eventChannel = EventChannel('samples.flutter.dev/sensor');\n  StreamSubscription? _subscription;\n  double _sensorValue = 0.0;\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    // 2. Listen to the stream\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = event as double;\n        });\n      },\n      onError: (dynamic error) {\n        debugPrint('Received error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text('Sensor Value: $_sensorValue'));\n  }\n}"}
{"instruction": "Manage a complex Todo list state using Riverpod's StateNotifierProvider.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the Model\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\n// 2. Define the StateNotifier\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\n// 3. Define the Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a rectangle with a Linear Gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    \n    // Define Gradient\n    final gradient = LinearGradient(\n      begin: Alignment.topLeft,\n      end: Alignment.bottomRight,\n      colors: [Colors.purple, Colors.blue],\n    );\n\n    final paint = Paint()\n      ..shader = gradient.createShader(rect);\n\n    // Draw Rectangle with Gradient Shader\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier class\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app in a ChangeNotifierProvider\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: CounterScreen(),\n    );\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        // 3. Use Consumer to listen to changes\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Access the provider to call methods\n          Provider.of<CounterModel>(context, listen: false).increment();\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a basic Todo list state management using Riverpod's StateNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the State\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\n// 2. Create the StateNotifier\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\n// 3. Create the Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider\n    final todos = ref.watch(todoListProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Todos')),\n        body: ListView.builder(\n          itemCount: todos.length,\n          itemBuilder: (context, index) {\n            final todo = todos[index];\n            return CheckboxListTile(\n              value: todo.completed,\n              title: Text(todo.description),\n              onChanged: (value) => \n                  ref.read(todoListProvider.notifier).toggle(todo.id),\n            );\n          },\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Paint for the fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Paint for the border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    // Draw filled circle\n    canvas.drawCircle(center, radius, fillPaint);\n    \n    // Draw border\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(300, 300),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Implement the Flutter side of a MethodChannel to invoke a native method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name (must match native side)\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch a string from an asynchronous source and display it using the .when syntax.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define a FutureProvider\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Configuration Loaded Successfully';\n});\n\nclass ConfigPage extends ConsumerWidget {\n  const ConfigPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the future provider\n    final configAsyncValue = ref.watch(configProvider);\n\n    return Scaffold(\n      body: Center(\n        // 3. Handle loading, error, and data states\n        child: configAsyncValue.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 20)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a CustomPainter that draws a quadratic Bezier curve representing a wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    \n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Go up to 80% of height\n    path.lineTo(0, size.height * 0.8);\n\n    // Draw quadratic bezier to create a wave\n    // Control point is at (50% width, 100% height)\n    // End point is at (100% width, 80% height)\n    path.quadraticBezierTo(\n      size.width * 0.5, \n      size.height, \n      size.width, \n      size.height * 0.8\n    );\n\n    // Close path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Configure a MultiProvider at the root of the application to provide both an AuthModel and a ThemeModel.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  bool _isLoggedIn = false;\n  bool get isLoggedIn => _isLoggedIn;\n}\n\nclass ThemeModel extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n}\n\nvoid main() {\n  runApp(\n    // Using MultiProvider to inject multiple dependencies\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Flutter to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  // 1. Define EventChannel\n  static const eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorStream();\n  }\n\n  void _enableSensorStream() {\n    // 2. Listen to the stream\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a CustomPainter widget that draws a progress arc based on a given percentage (0.0 to 1.0).", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ProgressArcPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  ProgressArcPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final rect = Rect.fromCircle(center: center, radius: radius);\n\n    final backgroundPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10;\n\n    final progressPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    // Draw background circle\n    canvas.drawArc(rect, 0, 2 * pi, false, backgroundPaint);\n\n    // Draw progress arc (starting from top: -pi/2)\n    final sweepAngle = 2 * pi * percentage;\n    canvas.drawArc(rect, -pi / 2, sweepAngle, false, progressPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Demonstrate how to use Riverpod's .family modifier to pass an argument (userID) to a provider fetching user details.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated User Model\nclass User {\n  final String name;\n  User(this.name);\n}\n\n// 1. Create a FutureProvider with .family to accept an argument (String id)\nfinal userProvider = FutureProvider.family<User, String>((ref, userId) async {\n  await Future.delayed(const Duration(seconds: 1)); // Mock API call\n  return User('User Name for ID: $userId');\n});\n\nclass UserProfile extends ConsumerWidget {\n  final String userId;\n\n  const UserProfile({super.key, required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Pass the argument when watching the provider\n    final userAsync = ref.watch(userProvider(userId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Profile')),\n      body: Center(\n        child: userAsync.when(\n          data: (user) => Text(user.name),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => const Text('Failed to load user'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod with a StateProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text('Count: $count', style: Theme.of(context).textTheme.headlineMedium),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 4. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a filled blue circle with a red border stroke.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a ChangeNotifier class for managing a ThemeMode (Light/Dark) and set up the Provider.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Provide the notifier\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 3. Listen to changes\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeNotifier.mode,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeNotifier.toggleTheme,\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a Flutter function to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  // Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the method on the native side\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data from a simulated API and handle loading, data, and error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'User: John Doe';\n}\n\n// Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        // Handle states\n        child: userAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomClipper that clips a widget into a generic 'Wave' shape at the bottom.", "output": "import 'package:flutter/material.dart';\n\nclass WaveHeader extends StatelessWidget {\n  const WaveHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ClipPath(\n      clipper: WaveClipper(),\n      child: Container(\n        height: 200,\n        color: Colors.deepPurple,\n        child: const Center(child: Text('Wave', style: TextStyle(color: Colors.white))),\n      ),\n    );\n  }\n}\n\nclass WaveClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    var path = Path();\n    // Start at top-left\n    path.lineTo(0, size.height - 40);\n    \n    // Create a quadratic bezier curve\n    var firstControlPoint = Offset(size.width / 4, size.height);\n    var firstEndPoint = Offset(size.width / 2, size.height - 40);\n    path.quadraticBezierTo(firstControlPoint.dx, firstControlPoint.dy, firstEndPoint.dx, firstEndPoint.dy);\n\n    var secondControlPoint = Offset(size.width - (size.width / 4), size.height - 80);\n    var secondEndPoint = Offset(size.width, size.height - 40);\n    path.quadraticBezierTo(secondControlPoint.dx, secondControlPoint.dy, secondEndPoint.dx, secondEndPoint.dy);\n\n    // Close path\n    path.lineTo(size.width, 0);\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}"}
{"instruction": "Implement a 'Selector' using the Provider package to rebuild a widget ONLY when a specific integer field in the model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass MyModel extends ChangeNotifier {\n  int _counter = 0;\n  String _name = 'Test';\n\n  int get counter => _counter;\n  String get name => _name;\n\n  void increment() {\n    _counter++;\n    notifyListeners();\n  }\n}\n\nclass OptimizedWidget extends StatelessWidget {\n  const OptimizedWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        // Selector ensures rebuild ONLY when 'counter' changes, ignoring 'name' changes\n        child: Selector<MyModel, int>(\n          selector: (context, model) => model.counter,\n          builder: (context, counter, child) {\n            print('Building counter text');\n            return Text('Count: $counter');\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Provider.of<MyModel>(context, listen: false).increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\n// Usage\n// CustomPaint(painter: DashedLinePainter(), size: Size(300, 1))"}
{"instruction": "Set up a Riverpod StateNotifier to manage a List of Strings (e.g., a Todo list) with methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. The StateNotifier class\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. The Provider definition\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});\n\n// Usage in Widget:\n// ref.watch(todoListProvider) -> gets the List<String>\n// ref.read(todoListProvider.notifier).addTodo('New Task') -> updates state"}
{"instruction": "Implement an EventChannel in Flutter to listen to a stream of events from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorListener extends StatefulWidget {\n  const SensorListener({super.key});\n\n  @override\n  State<SensorListener> createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  // Define the EventChannel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    // Listen to the stream\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: $error';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`. The widget should display the count and a floating action button to increment it.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: CounterApp())));\n}\n\nclass CounterApp extends ConsumerWidget {\n  const CounterApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: const TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class that draws a blue circle with a red border centered within the available canvas space.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel` and handle potential platform exceptions.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Use the `Provider` package to create a `ChangeNotifier` for a Todo list that allows adding items, and wrap the app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoModel extends ChangeNotifier {\n  final List<String> _items = [];\n  List<String> get items => _items;\n\n  void addItem(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => TodoModel(),\n      child: const MaterialApp(home: TodoListScreen()),\n    ),\n  );\n}\n\nclass TodoListScreen extends StatelessWidget {\n  const TodoListScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Consumer<TodoModel>(\n        builder: (context, todo, child) => ListView.builder(\n          itemCount: todo.items.length,\n          itemBuilder: (context, index) => ListTile(title: Text(todo.items[index])),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Provider.of<TodoModel>(context, listen: false).addItem('New Task'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve to simulate a wave pattern at the bottom of the widget.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width / 2, size.height,\n      size.width, size.height * 0.8\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Utilize Riverpod's `FutureProvider` to fetch data asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data Successfully';\n});\n\nclass AsyncDataWidget extends ConsumerWidget {\n  const AsyncDataWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter widget that listens to a continuous stream of events (e.g., sensor data) from native code using `EventChannel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('samples.flutter.dev/sensors');\n  Stream<dynamic>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    _sensorStream = eventChannel.receiveBroadcastStream();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder<dynamic>(\n          stream: _sensorStream,\n          builder: (context, snapshot) {\n            if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n            if (snapshot.hasData) return Text('Sensor Value: ${snapshot.data}');\n            return const Text('Waiting for sensor data...');\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Configure a `MultiProvider` at the root of a Flutter app to inject two distinct providers: `AuthService` and `ThemeService`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthService extends ChangeNotifier { /* ... */ }\nclass ThemeService extends ChangeNotifier { /* ... */ }\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => ThemeService()),\n      ],\n      child: const MaterialApp(home: Scaffold(body: Center(child: Text('MultiProvider App')))),\n    ),\n  );\n}"}
{"instruction": "Create a `CustomPainter` that draws a rectangle filled with a linear gradient from top-left to bottom-right.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.orange],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod `StateNotifier` to manage a list of immutable User objects, providing a method to add a new user.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final String name;\n  final int age;\n  User(this.name, this.age);\n}\n\nclass UserListNotifier extends StateNotifier<List<User>> {\n  UserListNotifier() : super([]);\n\n  void addUser(String name, int age) {\n    // State is immutable, so we create a new list\n    state = [...state, User(name, age)];\n  }\n\n  void removeUser(User user) {\n    state = state.where((u) => u != user).toList();\n  }\n}\n\nfinal userListProvider = StateNotifierProvider<UserListNotifier, List<User>>((ref) {\n  return UserListNotifier();\n});"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('$count', style: const TextStyle(fontSize: 24))),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: BlueCirclePainter(), child: Container())"}
{"instruction": "Use the `Provider` package to create a `ChangeNotifier` for toggling theme mode and consume it in the main app.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(create: (_) => ThemeNotifier(), child: const MyApp()),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeNotifier>(\n      builder: (context, theme, child) {\n        return MaterialApp(\n          theme: theme.isDark ? ThemeData.dark() : ThemeData.light(),\n          home: Scaffold(\n            body: Center(\n              child: ElevatedButton(\n                onPressed: () => theme.toggleTheme(),\n                child: const Text('Toggle Theme'),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Fetch data asynchronously using Riverpod's `FutureProvider` and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) => fetchUserData());\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` to draw a quadratic bezier curve (wave) at the bottom of a widget.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use `Selector` from the Provider package to optimize rebuilds by listening only to a specific property (`age`) of a user model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeWidget extends StatelessWidget {\n  const AgeWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        // This builder runs ONLY when 'age' changes, ignoring 'name' changes.\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement a `StateNotifier` and `StateNotifierProvider` in Riverpod to manage a list of Todo items (immutable state updates).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\n// Usage in Widget:\n// final todos = ref.watch(todoListProvider);\n// ref.read(todoListProvider.notifier).add('New Task');"}
{"instruction": "Set up a Dart `EventChannel` to listen to a continuous stream of events (e.g., sensor data) from native code.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  Stream<dynamic>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    _sensorStream = eventChannel.receiveBroadcastStream();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<dynamic>(\n      stream: _sensorStream,\n      builder: (context, snapshot) {\n        if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n        if (snapshot.hasData) return Text('Sensor Data: ${snapshot.data}');\n        return const Text('Waiting for data...');\n      },\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a progress arc with a sweep gradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    // Draw background circle\n    canvas.drawCircle(rect.center, size.width / 2, Paint()..style=PaintingStyle.stroke..color=Colors.grey[200]!..strokeWidth=10);\n\n    // Draw progress arc (-pi/2 to start from top)\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) => oldDelegate.progress != progress;\n}"}
{"instruction": "Create a basic counter state management setup using the `provider` package. Include a `ChangeNotifier` class and the `Consumer` widget implementation.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return FloatingActionButton(\n              onPressed: counter.increment,\n              child: Icon(Icons.add),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Todo list manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});\n\nclass TodoWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) => Text(todos[index].description),\n    );\n  }\n}"}
{"instruction": "Write a `CustomPainter` class named `CirclePainter` that draws a red circle with a radius of 50 in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of a `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handle the result or exception.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Create a Riverpod `FutureProvider` to fetch a string from an API and display the Loading, Error, or Data state using `.when` in a widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Fetched Data';\n});\n\nclass DataWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a triangle path filled with the color blue.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(size.width / 2, 0); // Top center\n    path.lineTo(0, size.height); // Bottom left\n    path.lineTo(size.width, size.height); // Bottom right\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate optimization in the `provider` package using the `Selector` widget to only rebuild a widget when a specific property 'count' changes, ignoring other properties.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ComplexModel extends ChangeNotifier {\n  int count = 0;\n  String name = 'Test';\n\n  void increment() {\n    count++;\n    notifyListeners();\n  }\n}\n\nclass OptimizedWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<ComplexModel, int>(\n      selector: (_, model) => model.count,\n      builder: (_, count, __) {\n        print('Building only when count changes');\n        return Text('Count: $count');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an `EventChannel` in Dart to listen to a continuous stream of events from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('com.example.app/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening() {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        print('Sensor reading: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void cancel() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an argument (e.g., fetching user details by ID).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A fake API call\nFuture<String> fetchUserById(int id) async {\n  return 'User $id';\n}\n\n// Family provider accepting an integer ID\nfinal userProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchUserById(id);\n});\n\n// Usage in a ConsumerWidget\n// ref.watch(userProvider(1));"}
{"instruction": "Implement a `CustomPainter` that draws text directly onto the canvas using `TextPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final textSpan = TextSpan(\n      text: 'Hello Canvas',\n      style: TextStyle(color: Colors.black, fontSize: 24),\n    );\n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n    \n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n    \n    final offset = Offset(\n      (size.width - textPainter.width) / 2,\n      (size.height - textPainter.height) / 2,\n    );\n    \n    textPainter.paint(canvas, offset);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using the `Provider` package. Define a `ChangeNotifier` class and a widget that consumes it to increment a value.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: TextStyle(fontSize: 24));\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), child: Container())"}
{"instruction": "Use Riverpod to create a `StateNotifier` that manages a list of Todo strings, including methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\n// Usage in Widget:\n// final todos = ref.watch(todoListProvider);\n// ref.read(todoListProvider.notifier).add('New Task');"}
{"instruction": "Set up a Flutter Platform Channel (MethodChannel) on the Dart side to invoke a native method named 'getBatteryLevel'. Include error handling.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a `FutureProvider` using Riverpod that simulates fetching a user's name from an API with a 2-second delay.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\n// Usage in ConsumerWidget:\n// final userAsyncValue = ref.watch(userProvider);\n// return userAsyncValue.when(\n//   data: (data) => Text('User: $data'),\n//   loading: () => CircularProgressIndicator(),\n//   error: (err, stack) => Text('Error: $err'),\n// );"}
{"instruction": "Implement a `CustomPainter` to draw a quadratic bezier curve (a wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height * 1.0,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Theme Switcher using `Provider`. The model should toggle between light and dark `ThemeMode`.", "output": "import 'package:flutter/material.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  bool get isDarkMode => _themeMode == ThemeMode.dark;\n\n  void toggleTheme(bool isOn) {\n    _themeMode = isOn ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\n// Usage in MaterialApp:\n// ChangeNotifierProvider(create: (_) => ThemeProvider(), child: Consumer<ThemeProvider>(builder: (ctx, theme, _) => MaterialApp(themeMode: theme.themeMode, ...)));"}
{"instruction": "Write the Dart code for a Platform Channel that sends a map of data (name and age) to the native platform using `invokeMethod`.", "output": "import 'package:flutter/services.dart';\n\nclass UserSyncService {\n  static const platform = MethodChannel('com.example.app/user');\n\n  Future<void> syncUserData(String name, int age) async {\n    try {\n      await platform.invokeMethod('syncUser', <String, dynamic>{\n        'name': name,\n        'age': age,\n      });\n    } on PlatformException catch (e) {\n      print(\"Failed to sync user: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Use `Riverpod`'s `family` modifier to create a provider that accepts an integer ID and returns a formatted string based on that ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal itemTitleProvider = Provider.family<String, int>((ref, id) {\n  return 'Item Title for ID: $id';\n});\n\n// Usage:\n// final title = ref.watch(itemTitleProvider(42));\n// Text(title);"}
{"instruction": "Create a `CustomPainter` that draws a dashed line horizontally across the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    double dashWidth = 5.0;\n    double dashSpace = 5.0;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the `provider` package. Define a `ChangeNotifier` class for the counter and wrap the main app with a `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: Theme.of(context).textTheme.headlineMedium);\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use `Riverpod` to create a `StateNotifierProvider` for a simple Todo list that allows adding strings to a list.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) => ListTile(title: Text(todos[index])),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement the Dart side of a Flutter MethodChannel to invoke a platform-specific method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a `FutureProvider` using Riverpod to simulate fetching user data asynchronously and display the loading, data, and error states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter to draw a progress arc (a partial circle stroke) based on a percentage value.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass ArcPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  ArcPainter({required this.percentage, this.color = Colors.green});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 8.0\n      ..strokeCap = StrokeCap.round;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    const startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * percentage;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      startAngle,\n      sweepAngle,\n      false,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Set up a `MultiProvider` at the root of a Flutter app to provide two distinct ChangeNotifier models: `AuthModel` and `ThemeModel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  bool isLoggedIn = false;\n}\n\nclass ThemeModel extends ChangeNotifier {\n  bool isDarkMode = false;\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'Waiting for data...';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an integer ID argument and returns a formatted string.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that takes an int argument (id) and returns a string\nfinal itemTitleProvider = Provider.family<String, int>((ref, id) {\n  return 'Item #$id';\n});\n\nclass ItemDetail extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetail({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific family argument\n    final title = ref.watch(itemTitleProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: Text(title)),\n      body: const Center(child: Text('Details View')),\n    );\n  }\n}"}
{"instruction": "Create an interactive CustomPainter where a user can drag a rectangle around the canvas using a `GestureDetector`.", "output": "import 'package:flutter/material.dart';\n\nclass DraggableBoxPainter extends CustomPainter {\n  final Offset offset;\n\n  DraggableBoxPainter(this.offset);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()..color = Colors.red;\n    // Draw a 50x50 rectangle at the current offset\n    canvas.drawRect(Rect.fromLTWH(offset.dx, offset.dy, 50, 50), paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant DraggableBoxPainter oldDelegate) {\n    return oldDelegate.offset != offset;\n  }\n}\n\nclass InteractiveCanvas extends StatefulWidget {\n  const InteractiveCanvas({super.key});\n\n  @override\n  State<InteractiveCanvas> createState() => _InteractiveCanvasState();\n}\n\nclass _InteractiveCanvasState extends State<InteractiveCanvas> {\n  Offset _offset = Offset.zero;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (details) {\n        setState(() {\n          _offset += details.delta;\n        });\n      },\n      child: CustomPaint(\n        size: Size.infinite,\n        painter: DraggableBoxPainter(_offset),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a basic counter application using the `Provider` package for state management. Include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Write a Dart method that uses `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel' and handles potential errors.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod `StateNotifier` to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement a `CustomPainter` that draws a quadratic Bezier curve.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.75);\n    path.quadraticBezierTo(size.width / 2, size.height / 4, size.width, size.height * 0.75);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch asynchronous data and display it using a `ConsumerWidget` handling loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Configuration Loaded';\n});\n\nclass ConfigView extends ConsumerWidget {\n  const ConfigView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final config = ref.watch(configProvider);\n\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (config) => Text(config),\n    );\n  }\n}"}
{"instruction": "Create a `ProxyProvider` setup using the `provider` package where an `ApiService` depends on an `AuthModel` token.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? token = 'secret_token';\n}\n\nclass ApiService {\n  final String? token;\n  ApiService(this.token);\n\n  void fetchData() => print('Fetching with $token');\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, ApiService>(\n          update: (_, auth, __) => ApiService(auth.token),\n        ),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) => Container();\n}"}
{"instruction": "Establish an `EventChannel` in Dart to listen to a stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n\n  Stream<double> get sensorStream {\n    return _eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n}\n\n// Usage\nvoid listenToSensor() {\n  SensorService().sensorStream.listen(\n    (data) => print('Sensor data: $data'),\n    onError: (error) => print('Error: $error'),\n  );\n}"}
{"instruction": "Create a `CustomPainter` that draws a rectangle with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Rect rect = Offset.zero & size;\n    final Paint paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Widget that animates a `CustomPainter` by passing an `AnimationController` to the painter's `repaint` argument.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass AnimatedPainter extends CustomPainter {\n  final Animation<double> animation;\n\n  AnimatedPainter(this.animation) : super(repaint: animation);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()..color = Colors.green;\n    // Draw an arc that grows with the animation value\n    canvas.drawArc(\n      Rect.fromLTWH(0, 0, size.width, size.height),\n      -pi / 2,\n      2 * pi * animation.value,\n      true,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant AnimatedPainter oldDelegate) => false;\n}\n\nclass LoadingWidget extends StatefulWidget {\n  const LoadingWidget({super.key});\n  @override\n  State<LoadingWidget> createState() => _LoadingWidgetState();\n}\n\nclass _LoadingWidgetState extends State<LoadingWidget> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this, duration: const Duration(seconds: 2))..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(100, 100),\n      painter: AnimatedPainter(_controller),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod using a StateProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app in ProviderScope\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: CounterPage(),\n    );\n  }\n}\n\n// 3. Extend ConsumerWidget to access the ref\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider value\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 5. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Theme Switcher using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Provide the notifier\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeNotifier>(\n      builder: (context, themeNotifier, child) {\n        return MaterialApp(\n          theme: themeNotifier.isDark ? ThemeData.dark() : ThemeData.light(),\n          home: const HomePage(),\n        );\n      },\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Theme Switcher')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // 3. Access the provider to call methods\n            Provider.of<ThemeNotifier>(context, listen: false).toggleTheme();\n          },\n          child: const Text('Toggle Theme'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a circle with a radial gradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math' as math;\n\nclass GradientCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = math.min(size.width, size.height) / 2;\n\n    final paint = Paint()\n      ..shader = RadialGradient(\n        colors: [Colors.blue, Colors.purple],\n      ).createShader(Rect.fromCircle(center: center, radius: radius));\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage Widget\nclass GradientCircleWidget extends StatelessWidget {\n  const GradientCircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: GradientCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Demonstrate how to set up a MethodChannel in Dart to invoke a platform-specific method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to handle asynchronous data fetching and display Loading, Error, or Data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the FutureProvider\nfinal userDataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'User Data Loaded';\n  // To test error, throw Exception('Failed to load');\n});\n\nclass AsyncDataPage extends ConsumerWidget {\n  const AsyncDataPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final asyncValue = ref.watch(userDataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('AsyncValue Example')),\n      body: Center(\n        child: asyncValue.when(\n          // 3. Handle data state\n          data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n          // 4. Handle error state\n          error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n          // 5. Handle loading state\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a Bezier curve (a wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    \n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n\n    // Create a quadratic bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path to bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage\nclass WaveWidget extends StatelessWidget {\n  const WaveWidget({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: WavePainter(),\n    );\n  }\n}"}
{"instruction": "Use Provider's `Selector` widget to optimize rebuilds by listening only to a specific property of a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserSettings extends ChangeNotifier {\n  String _name = 'John';\n  int _age = 25;\n\n  String get name => _name;\n  int get age => _age;\n\n  void incrementAge() {\n    _age++;\n    notifyListeners();\n  }\n  \n  void changeName(String newName) {\n    _name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplayWidget extends StatelessWidget {\n  const AgeDisplayWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Selector only rebuilds if the return value of 'selector' changes\n    return Selector<UserSettings, int>(\n      selector: (context, settings) => settings.age,\n      builder: (context, age, child) {\n        // This print proves optimization: it won't trigger on name change\n        print('Building Age Widget');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement a Platform Channel using EventChannel to listen to a stream of events from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass EventChannelExample extends StatefulWidget {\n  const EventChannelExample({super.key});\n\n  @override\n  State<EventChannelExample> createState() => _EventChannelExampleState();\n}\n\nclass _EventChannelExampleState extends State<EventChannelExample> {\n  // 1. Define the EventChannel\n  static const eventChannel = EventChannel('com.example.app/events');\n  String _eventData = 'Waiting for events...';\n\n  @override\n  void initState() {\n    super.initState();\n    // 2. Listen to the stream\n    eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _eventData = 'Event received: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _eventData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_eventData));\n  }\n}"}
{"instruction": "Implement a Todo List using Riverpod's StateNotifier and StateNotifierProvider for immutable state management.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the model\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\n// 2. Define the StateNotifier\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\n// 3. Define the provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});\n\nclass TodoPage extends ConsumerWidget {\n  const TodoPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          final todo = todos[index];\n          return CheckboxListTile(\n            value: todo.completed,\n            title: Text(todo.description),\n            onChanged: (_) => ref.read(todoListProvider.notifier).toggle(todo.id),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create an animated CustomPainter that redraws based on an AnimationController.", "output": "import 'package:flutter/material.dart';\n\nclass AnimatedPainterWidget extends StatefulWidget {\n  const AnimatedPainterWidget({super.key});\n\n  @override\n  State<AnimatedPainterWidget> createState() => _AnimatedPainterWidgetState();\n}\n\nclass _AnimatedPainterWidgetState extends State<AnimatedPainterWidget>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 2),\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      // Pass the controller (Listenable) to the painter\n      painter: ExpandingCirclePainter(_controller),\n    );\n  }\n}\n\nclass ExpandingCirclePainter extends CustomPainter {\n  final Animation<double> animation;\n\n  ExpandingCirclePainter(this.animation) : super(repaint: animation);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    // Radius varies from 0 to half width based on animation value (0.0 to 1.0)\n    final radius = (size.width / 2) * animation.value;\n    \n    canvas.drawCircle(Offset(size.width / 2, size.height / 2), radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant ExpandingCirclePainter oldDelegate) {\n    // Since we passed 'repaint: animation' to super, this can be false usually,\n    // but explicitly checking helps logic clarity.\n    return false;\n  }\n}"}
{"instruction": "Create a simple Counter app using the `Provider` package. Define a `ChangeNotifier` model and a widget that consumes it to display and increment a counter.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Consumer<CounterModel>(\n          builder: (context, model, child) => Center(\n            child: Text('Count: ${model.count}', style: TextStyle(fontSize: 24)),\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, model, child) => FloatingActionButton(\n            onPressed: model.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Using `flutter_riverpod`, create a `FutureProvider` that simulates fetching a list of strings from an API, and a `ConsumerWidget` that handles the loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal itemListProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(Duration(seconds: 1)); // Simulate network delay\n  return ['Apple', 'Banana', 'Cherry'];\n});\n\nclass ItemListScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(itemListProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (items) => ListView.builder(\n            itemCount: items.length,\n            itemBuilder: (_, index) => ListTile(title: Text(items[index])),\n          ),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a filled blue circle in the center of the available canvas space.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: BlueCirclePainter(), child: Container())"}
{"instruction": "Set up a `MethodChannel` on the Dart side to invoke a platform-specific method named 'getBatteryLevel' and handle potential `PlatformException`s.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Using Riverpod, implement a `StateNotifier` and `StateNotifierProvider` to manage a simple Todo list (adding items only).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  Todo(this.id, this.description);\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(DateTime.now().toString(), description),\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a `CustomPainter` that draws a progress arc (stroked) based on a percentage value passed to the constructor.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass ProgressArcPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  ProgressArcPainter({required this.percentage, this.color = Colors.green});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 8.0\n      ..strokeCap = StrokeCap.round;\n\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    // Start at top (-pi/2), draw based on percentage\n    canvas.drawArc(rect, -pi / 2, 2 * pi * percentage, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(ProgressArcPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Implement a Theme Switcher using the `Provider` package. Create a `ThemeNotifier` that toggles a boolean and updates the `MaterialApp` theme data.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: Consumer<ThemeNotifier>(\n        builder: (context, themeNotifier, child) {\n          return MaterialApp(\n            theme: themeNotifier.currentTheme,\n            home: Scaffold(\n              body: Center(\n                child: ElevatedButton(\n                  onPressed: themeNotifier.toggleTheme,\n                  child: Text('Toggle Theme'),\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    ),\n  );\n}"}
{"instruction": "Write a Dart function utilizing `MethodChannel` to send data (a Map) to the native platform to show a native toast message.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showNativeToast(String message, bool isLong) async {\n    try {\n      await platform.invokeMethod('showToast', <String, dynamic>{\n        'message': message,\n        'isLong': isLong,\n      });\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Create a `CustomPainter` that fills the canvas with a vertical linear gradient from Orange to Purple.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = LinearGradient(\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n        colors: [Colors.orange, Colors.purple],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches a user's name based on a specific integer User ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock database lookup\nFuture<String> fetchUserName(int id) async {\n  await Future.delayed(Duration(milliseconds: 500));\n  return 'User #$id';\n}\n\n// Family provider definition\nfinal userProvider = FutureProvider.family<String, int>((ref, userId) async {\n  return await fetchUserName(userId);\n});\n\n// Usage in a ConsumerWidget:\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a simple Counter application using the `Provider` package for state management. The solution should include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier class\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app with ChangeNotifierProvider\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          // 3. Consume the state\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // 4. Access the provider to call methods\n            Provider.of<CounterModel>(context, listen: false).increment();\n          },\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a circular progress indicator with a background circle and a foreground arc indicating the percentage.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass RadialProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  RadialProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey.shade300\n      ..strokeWidth = strokeWidth\n      ..style = PaintingStyle.stroke;\n    \n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Foreground Arc\n    final fgPaint = Paint()\n      ..color = color\n      ..strokeWidth = strokeWidth\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    // -pi/2 to start from top\n    final sweepAngle = 2 * pi * percentage;\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2, \n      sweepAngle, \n      false, \n      fgPaint\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant RadialProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a list of strings (simulating an API call) and display them in a widget using `.when` to handle loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the FutureProvider\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return ['Apple', 'Banana', 'Cherry', 'Date'];\n});\n\nclass DataListScreen extends ConsumerWidget {\n  const DataListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod FutureProvider')),\n      body: asyncValue.when(\n        data: (items) => ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (context, index) => ListTile(title: Text(items[index])),\n        ),\n        error: (err, stack) => Center(child: Text('Error: $err')),\n        loading: () => const Center(child: CircularProgressIndicator()),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter method to invoke a native platform channel named 'com.example.app/device' to retrieve the device model string.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass DeviceInfoService {\n  static const platform = MethodChannel('com.example.app/device');\n\n  Future<String> getDeviceModel() async {\n    try {\n      final String result = await platform.invokeMethod('getDeviceModel');\n      return result;\n    } on PlatformException catch (e) {\n      return \"Failed to get device model: '${e.message}'.\";\n    }\n  }\n}\n\n// Usage inside a widget:\n// String model = await DeviceInfoService().getDeviceModel();"}
{"instruction": "Create a `StateNotifier` and `StateNotifierProvider` using Riverpod to manage a simple Todo list (add and toggle completion status).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo\n    ];\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a Bezier curve (sine wave style) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Line up to the start of the wave\n    path.lineTo(0, size.height * 0.8);\n\n    // Quadratic Bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.25, size.height * 0.7, // Control point\n      size.width * 0.5, size.height * 0.8,  // End point of first curve\n    );\n    path.quadraticBezierTo(\n      size.width * 0.75, size.height * 0.9, // Control point\n      size.width, size.height * 0.8,        // End point of second curve\n    );\n\n    // Close the path\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use `MultiProvider` to provide two separate simple change notifiers (User and Settings) to the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'Guest';\n  void login(String newName) { name = newName; notifyListeners(); }\n}\n\nclass Settings extends ChangeNotifier {\n  bool isDark = false;\n  void toggleTheme() { isDark = !isDark; notifyListeners(); }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => User()),\n        ChangeNotifierProvider(create: (_) => Settings()),\n      ],\n      child: const MaterialApp(home: Scaffold(body: Center(child: Text('MultiProvider App')))),\n    ),\n  );\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorService {\n  // 1. Define the EventChannel name\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n\n  Stream<double>? _sensorStream;\n\n  // 2. Create a getter for the stream\n  Stream<double> get sensorStream {\n    _sensorStream ??= _eventChannel.receiveBroadcastStream().map((event) {\n        // Convert dynamic event to double\n        return (event as num).toDouble();\n      });\n    return _sensorStream!;\n  }\n}\n\n// Usage inside a StreamBuilder:\n// StreamBuilder<double>(\n//   stream: SensorService().sensorStream,\n//   builder: (context, snapshot) { ... }\n// )"}
{"instruction": "Use Riverpod's `family` modifier to create a provider that fetches a specific item based on an ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchItemById(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Item #$id Details';\n}\n\n// Provider with .family modifier\n// The first type is the return type (AsyncValue<String>), the second is the parameter type (int)\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItemById(id);\n});\n\n// Usage in Widget:\n// ref.watch(itemDetailProvider(42)).when(...)"}
{"instruction": "Create a `CustomPainter` that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    double dashWidth = 5;\n    double dashSpace = 5;\n    double startX = 0;\n    final double endX = size.width;\n\n    // Draw dashes horizontally\n    while (startX < endX) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter app implementation using the Provider package. Include the ChangeNotifier class and the UI widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) => Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel in Dart to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a simple red circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass RedCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(200, 200),\n      painter: RedCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch a list of strings (simulated API) and display the loading, error, and data states in a Widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(Duration(seconds: 2)); // Simulate network delay\n  return ['Apple', 'Banana', 'Orange'];\n});\n\nclass DataListScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod FutureProvider')),\n      body: asyncValue.when(\n        data: (items) => ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (context, index) => ListTile(title: Text(items[index])),\n        ),\n        loading: () => Center(child: CircularProgressIndicator()),\n        error: (err, stack) => Center(child: Text('Error: $err')),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5, size.height * 1.0,\n      size.width, size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass WaveHeader extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(double.infinity, 200),\n      painter: WavePainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod StateNotifier to manage a simple Todo list (add and toggle completion).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Setup an EventChannel in Dart to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel eventChannel = EventChannel('samples.flutter.dev/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'Waiting for data...';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorStream();\n  }\n\n  void _enableSensorStream() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor reading: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Provider's ProxyProvider to inject a dependency from one provider (Auth) into another (Database).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? userId = 'user_123'; // Simulated logged in user\n}\n\nclass DatabaseService {\n  final String? userId;\n  DatabaseService(this.userId);\n\n  String getData() => userId != null ? 'Data for $userId' : 'No User';\n}\n\nclass ProxyExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, DatabaseService>(\n          update: (_, auth, __) => DatabaseService(auth.userId),\n        ),\n      ],\n      child: Consumer<DatabaseService>(\n        builder: (context, db, child) => Text(db.getData()),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line horizontally across the widget.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    var max = size.width;\n    var dashWidth = 5;\n    var dashSpace = 5;\n    double startX = 0;\n\n    while (startX < max) {\n      canvas.drawLine(Offset(startX, 0), Offset(startX + dashWidth, 0), paint);\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass DashedLine extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(double.infinity, 1),\n      painter: DashedLinePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's .family modifier to create a provider that accepts an argument (e.g., a User ID) to fetch specific data.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A simulated API call\nFuture<String> fetchUserById(int id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'User $id';\n}\n\n// Family provider accepting an int ID\nfinal userProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchUserById(id);\n});\n\n// Usage in a ConsumerWidget (assumes usage inside a build method)\n// final userAsync = ref.watch(userProvider(42));"}
{"instruction": "Create a basic counter state management class using the Provider package that notifies listeners when the count increments.", "output": "import 'package:flutter/material.dart';\n\nclass CounterNotifier extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}"}
{"instruction": "Implement a Flutter Riverpod provider using StateNotifier to manage a simple list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write a CustomPainter class that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final fillPaint = Paint()..color = Colors.blue;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Dart method that uses a MethodChannel to invoke a native platform method named 'getBatteryLevel' and handles potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to simulate fetching user data asynchronously with a 2-second delay.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\n// Usage in ConsumerWidget:\n// final userAsync = ref.watch(userProvider);\n// userAsync.when(\n//   data: (data) => Text(data),\n//   loading: () => CircularProgressIndicator(),\n//   error: (e, st) => Text('Error: $e'),\n// );"}
{"instruction": "Create a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the widget.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height * 1.0,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a ThemeNotifier class using Provider to toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme() {\n    _themeMode = _themeMode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}"}
{"instruction": "Set up a Flutter EventChannel to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<dynamic> get sensorEvents {\n    return _eventChannel.receiveBroadcastStream();\n  }\n}"}
{"instruction": "Create a CustomPainter that fills the canvas with a linear gradient from top-left to bottom-right.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n        colors: [Colors.purple, Colors.orange],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's 'family' modifier to create a FutureProvider that accepts an integer ID to fetch specific item details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  // Simulate network request using the id\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item ID: $id';\n});\n\n// Usage: ref.watch(itemDetailProvider(42));"}
{"instruction": "Create a simple Counter app using the 'provider' package. Include the ChangeNotifier class and the main widget structure wrapping the app in a ChangeNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Todo List logic using Riverpod's StateNotifierProvider. Define a Todo class, a StateNotifier to manage the list, and the provider definition.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a CustomPainter widget that draws a blue circle with a red border centered on the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paintFill = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final paintBorder = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, paintFill);\n    canvas.drawCircle(center, radius, paintBorder);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of a MethodChannel to retrieve the battery level from native code. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch a string from a simulated API and display the result (data, loading, error) in a widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass DataWidget extends ConsumerWidget {\n  const DataWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a progress arc with a SweepGradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final gradient = SweepGradient(\n      startAngle: -pi / 2,\n      endAngle: 3 * pi / 2,\n      colors: [Colors.blue, Colors.purple],\n      tileMode: TileMode.repeated,\n    );\n\n    final paint = Paint()\n      ..shader = gradient.createShader(rect)\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10;\n\n    // Draw arc starting from top (-pi/2)\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a ThemeProvider using the Provider package to toggle between light and dark themes.", "output": "import 'package:flutter/material.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  bool get isDarkMode => _themeMode == ThemeMode.dark;\n\n  void toggleTheme(bool isOn) {\n    _themeMode = isOn ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\n// Usage in MaterialApp:\n// ChangeNotifierProvider(create: (_) => ThemeProvider(), child: Consumer<ThemeProvider>(builder: (c, theme, _) => MaterialApp(themeMode: theme.themeMode, ...)));"}
{"instruction": "Set up an EventChannel in Dart to listen to a stream of accelerometer events coming from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/accelerometer');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Create a CustomPainter to draw a Bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.8);\n    \n    // Quadratic Bezier curve to bottom right\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 1.0, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's 'family' modifier to create a provider that fetches details based on a specific Item ID passed as an argument.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulating an API call\nFuture<String> fetchItemDetails(String id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item ID: $id';\n}\n\n// Family provider definition\nfinal itemDetailProvider = FutureProvider.family<String, String>((ref, itemId) async {\n  return await fetchItemDetails(itemId);\n});\n\n// Usage inside a Widget build method:\n// final asyncValue = ref.watch(itemDetailProvider('123'));"}
{"instruction": "Create a basic counter application using Riverpod's `StateProvider`. The widget should display the count and have a floating action button to increment it.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterApp()),\n    ),\n  );\n}\n\n// 3. Extend ConsumerWidget instead of StatelessWidget\nclass CounterApp extends ConsumerWidget {\n  const CounterApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider to rebuild on changes\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 5. Read the provider to update state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a yellow smiley face (circle head, two black eyes, and an arc mouth).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass SmileyFacePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n\n    // Draw Face\n    final facePaint = Paint()..color = Colors.yellow;\n    canvas.drawCircle(center, radius, facePaint);\n\n    // Draw Eyes\n    final eyePaint = Paint()..color = Colors.black;\n    final leftEyePos = Offset(center.dx - radius / 3, center.dy - radius / 3);\n    final rightEyePos = Offset(center.dx + radius / 3, center.dy - radius / 3);\n    canvas.drawCircle(leftEyePos, radius / 10, eyePaint);\n    canvas.drawCircle(rightEyePos, radius / 10, eyePaint);\n\n    // Draw Mouth\n    final mouthPaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0\n      ..strokeCap = StrokeCap.round;\n    \n    final mouthRect = Rect.fromCircle(center: center, radius: radius / 1.5);\n    canvas.drawArc(mouthRect, 0.1 * pi, 0.8 * pi, false, mouthPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a service class that uses `MethodChannel` to invoke a native platform method called 'getBatteryLevel' and handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  // Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the method on the native side\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = 'Failed to get battery level: ${e.message}.';\n    } catch (e) {\n      batteryLevel = 'Unknown error occurred.';\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Implement a `TodoListModel` using `ChangeNotifier` (Provider package) that allows adding tasks and toggling their completion status.", "output": "import 'package:flutter/material.dart';\n\nclass TodoItem {\n  String title;\n  bool isDone;\n  TodoItem({required this.title, this.isDone = false});\n}\n\nclass TodoListModel extends ChangeNotifier {\n  final List<TodoItem> _items = [];\n\n  List<TodoItem> get items => List.unmodifiable(_items);\n\n  void add(String title) {\n    _items.add(TodoItem(title: title));\n    notifyListeners();\n  }\n\n  void toggle(int index) {\n    if (index >= 0 && index < _items.length) {\n      _items[index].isDone = !_items[index].isDone;\n      notifyListeners();\n    }\n  }\n\n  void remove(int index) {\n    _items.removeAt(index);\n    notifyListeners();\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a user name from a simulated API and display the loading, error, and data states in a widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserName() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Jane Doe';\n}\n\n// Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserName();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a horizontal dashed line across the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  final Color color;\n  final double dashWidth;\n  final double dashSpace;\n\n  DashedLinePainter({this.color = Colors.black, this.dashWidth = 5.0, this.dashSpace = 5.0});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    double startX = 0;\n    final paint = Paint()\n      ..color = color\n      ..strokeWidth = 2;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up an `EventChannel` to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('com.example.app/sensor');\n\n  Stream<double>? _sensorStream;\n\n  Stream<double> get sensorEvents {\n    _sensorStream ??= _channel.receiveBroadcastStream().map((dynamic event) => event as double);\n    return _sensorStream!;\n  }\n\n  void listenToSensor() {\n    sensorEvents.listen(\n      (double event) {\n        print('Sensor value: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n      cancelOnError: true,\n    );\n  }\n}"}
{"instruction": "Refactor a counter using Riverpod's `StateNotifier` and `StateNotifierProvider` to encapsulate business logic separately from the UI.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create the StateNotifier class\nclass CounterNotifier extends StateNotifier<int> {\n  CounterNotifier() : super(0);\n\n  void increment() => state++;\n  void decrement() => state--;\n  void reset() => state = 0;\n}\n\n// 2. Create the provider\nfinal counterNotifierProvider = StateNotifierProvider<CounterNotifier, int>((ref) {\n  return CounterNotifier();\n});\n\n// Usage in Widget (excerpt):\n// final count = ref.watch(counterNotifierProvider);\n// ref.read(counterNotifierProvider.notifier).increment();"}
{"instruction": "Using the `provider` package, use a `Selector` widget to optimize rebuilds. Only rebuild the Text widget if the user's `age` property changes, ignoring name changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Rebuilding Age Display');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a custom shape defined by a `Path` (e.g., a simple triangle) filled with a specific color.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at top center\n    path.moveTo(size.width / 2, 0);\n    // Line to bottom right\n    path.lineTo(size.width, size.height);\n    // Line to bottom left\n    path.lineTo(0, size.height);\n    // Close the path to form a triangle\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic counter application using the `provider` package. Define a `ChangeNotifier` class and a widget that consumes it to increment a counter.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: Scaffold(\n        appBar: AppBar(title: Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return FloatingActionButton(\n              onPressed: counter.increment,\n              child: Icon(Icons.add),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a simple counter using Riverpod 2.0 with a `NotifierProvider`. Show how to define the notifier and consume it in a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the Notifier\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\n// 2. Define the Provider\nfinal counterProvider = NotifierProvider<CounterNotifier, int>(CounterNotifier.new);\n\n// 3. Consume in UI\nclass RiverpodCounter extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod 2.0 Counter')),\n      body: Center(child: Text('Value: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).increment(),\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final paintFill = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final paintBorder = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, paintFill);\n    canvas.drawCircle(center, radius, paintBorder);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel to retrieve the battery level from native code. Include the Dart side implementation with error handling.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to handle an asynchronous data fetch (simulating a network request). Handle loading, error, and data states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulation of API call\nFuture<String> fetchUser() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) => fetchUser());\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsync.when(\n          data: (data) => Text('User: $data', style: TextStyle(fontSize: 24)),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic Bezier curve (an arch) from the bottom-left to the bottom-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass ArchPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Control point at top center, end point at bottom right\n    path.quadraticBezierTo(\n      size.width / 2, 0, // Control point (x, y)\n      size.width, size.height // End point (x, y)\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass ArchWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(300, 150),\n      painter: ArchPainter(),\n    );\n  }\n}"}
{"instruction": "Optimize a `provider` implementation using the `Selector` widget. Create a model with two properties (`name`, `age`) and a widget that only rebuilds when `age` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n  \n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, int>(\n      selector: (_, model) => model.age,\n      builder: (_, age, __) {\n        print('Rebuilding Age Widget'); // Debug print\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  @override\n  _SensorStreamWidgetState createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorListening();\n  }\n\n  void _enableSensorListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line across the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2.0;\n\n    final double dashWidth = 10.0;\n    final double dashSpace = 5.0;\n    double startX = 0.0;\n    final double y = size.height / 2;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, y),\n        Offset(startX + dashWidth, y),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific data.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Family provider accepting an int ID\nfinal itemProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Item Details for ID: $id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n\n  ItemDetailScreen({required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Pass the itemId to the provider\n    final itemAsync = ref.watch(itemProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Item $itemId')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => CircularProgressIndicator(),\n          error: (e, s) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple Counter application using the `provider` package. Include the `ChangeNotifier` class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Provider Counter\")),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a simple Todo List using `flutter_riverpod` with a `StateNotifier`. The state should be a List of Strings.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Riverpod Todos\")),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text(todos[index]),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete),\n              onPressed: () => ref.read(todoListProvider.notifier).remove(todos[index]),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add(\"Task ${todos.length + 1}\"),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a circular progress indicator with a background circle and a foreground arc based on a percentage.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass RadialProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  RadialProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey.withOpacity(0.2)\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n    \n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Foreground Arc\n    final fgPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    // -pi/2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      2 * pi * percentage,\n      false,\n      fgPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant RadialProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Implement the Flutter side of a `MethodChannel` to retrieve the battery level from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelScreen extends StatefulWidget {\n  const BatteryLevelScreen({super.key});\n\n  @override\n  State<BatteryLevelScreen> createState() => _BatteryLevelScreenState();\n}\n\nclass _BatteryLevelScreenState extends State<BatteryLevelScreen> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use `flutter_riverpod`'s `FutureProvider` to fetch and display a username asynchronously. Handle loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return \"John Doe\";\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUser();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<String> user = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: user.when(\n          data: (data) => Text(\"User: $data\", style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text(\"Error: $err\"),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a sine wave across the width of the canvas.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass SineWavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2.0;\n\n    final path = Path();\n    final double midY = size.height / 2;\n    path.moveTo(0, midY);\n\n    for (double x = 0; x <= size.width; x++) {\n      // Calculate y = A * sin(B * x)\n      double y = midY + 30 * sin((x / size.width) * 4 * pi);\n      path.lineTo(x, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Theme Switcher using `Provider`. The app should toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme() {\n    _themeMode = _themeMode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeProvider = Provider.of<ThemeProvider>(context);\n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeProvider.themeMode,\n      home: Scaffold(\n        appBar: AppBar(title: const Text(\"Theme Switcher\")),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => themeProvider.toggleTheme(),\n            child: const Text(\"Toggle Theme\"),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Flutter side code to invoke a native method `showToast` using `MethodChannel` that passes a message argument.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  static Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}\n\n// Usage inside a widget:\n// ElevatedButton(\n//   onPressed: () => NativeToastService.showToast(\"Hello Native World!\"),\n//   child: Text(\"Show Native Toast\"),\n// )"}
{"instruction": "Optimize rebuilds in `Provider` using a `Selector`. Create a widget that only rebuilds when the `cartItemCount` property of a `CartModel` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CartModel extends ChangeNotifier {\n  int _cartItemCount = 0;\n  String _lastAddedItem = \"\";\n\n  int get cartItemCount => _cartItemCount;\n  String get lastAddedItem => _lastAddedItem;\n\n  void addItem(String item) {\n    _cartItemCount++;\n    _lastAddedItem = item;\n    notifyListeners();\n  }\n}\n\nclass CartBadge extends StatelessWidget {\n  const CartBadge({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // This widget only rebuilds when 'cartItemCount' changes,\n    // even if other properties in CartModel change.\n    return Selector<CartModel, int>(\n      selector: (context, cart) => cart.cartItemCount,\n      builder: (context, count, child) {\n        print(\"Building Cart Badge\");\n        return CircleAvatar(\n          child: Text('$count'),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that fills a rectangle with a Linear Gradient using a Shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    \n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.blue, Colors.purple],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage:\n// CustomPaint(\n//   size: Size(200, 100),\n//   painter: GradientPainter(),\n// )"}
{"instruction": "Implement a basic Counter state using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<Counter>().increment(),\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Todo list manager using Riverpod's StateNotifierProvider.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoNotifier extends StateNotifier<List<String>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((element) => element != todo).toList();\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<String>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a red circle with a black border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.black\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Handle asynchronous data loading (Loading, Error, Data) using Riverpod's FutureProvider and the .when method.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Fetched Data';\n});\n\nclass DataWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Draw a simple triangle path using CustomPainter.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(size.width / 2, 0); // Top vertex\n    path.lineTo(0, size.height); // Bottom left\n    path.lineTo(size.width, size.height); // Bottom right\n    path.close(); // Connects back to top\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Setup a MultiProvider at the root of the application to inject two different ChangeNotifiers.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {}\nclass CartModel extends ChangeNotifier {}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProvider(create: (_) => CartModel()),\n      ],\n      child: MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Implement the Dart side of an EventChannel to listen to a stream of continuous sensor data.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorListener {\n  static const eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening() {\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        print('Sensor reading: $event');\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use the Riverpod family modifier to create a provider that accepts a user ID argument to fetch specific user details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final String id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Family provider accepting a String id\nfinal userProvider = FutureProvider.family<User, String>((ref, id) async {\n  // Simulate network request\n  await Future.delayed(Duration(seconds: 1));\n  return User(id, 'User $id');\n});\n\n// Usage: ref.watch(userProvider('123'))"}
{"instruction": "Render custom text onto a canvas using TextPainter within a CustomPainter.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final textSpan = TextSpan(\n      text: 'Hello Canvas',\n      style: TextStyle(color: Colors.black, fontSize: 24),\n    );\n    \n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n\n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n\n    final offset = Offset(\n      (size.width - textPainter.width) / 2,\n      (size.height - textPainter.height) / 2,\n    );\n\n    textPainter.paint(canvas, offset);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using the 'Provider' package for state management. Include the ChangeNotifier class and the UI implementation.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter to draw a simple circular progress indicator with a background circle and a foreground arc indicating 75% progress.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircularProgressPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final backgroundPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n\n    canvas.drawCircle(center, radius, backgroundPaint);\n\n    // Foreground Arc (75%)\n    final foregroundPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    // -pi/2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      2 * pi * 0.75,\n      false,\n      foregroundPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass ProgressWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(100, 100),\n      painter: CircularProgressPainter(),\n    );\n  }\n}"}
{"instruction": "Write a Flutter MethodChannel implementation to invoke a native platform method named 'getBatteryLevel'. Handle the PlatformException.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Using Riverpod, create a StateNotifier to manage a list of Todo strings. Include methods to add and remove todos.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((element) => element != todo).toList();\n  }\n}\n\n// Provider Definition\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\n// Usage Example (Snippet)\n// In a ConsumerWidget build method:\n// final todos = ref.watch(todoListProvider);\n// ref.read(todoListProvider.notifier).add('New Task');"}
{"instruction": "Create a CustomPainter that draws a curved header background using quadratic bezier curves.", "output": "import 'package:flutter/material.dart';\n\nclass CurvedHeaderPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.deepPurple\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.lineTo(0, size.height - 50);\n    \n    // Quadratic Bezier Curve\n    path.quadraticBezierTo(\n      size.width / 2, \n      size.height, \n      size.width, \n      size.height - 50\n    );\n    \n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's 'FutureProvider' to fetch asynchronous data and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement an EventChannel in Flutter to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  Stream<double>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    // Receiving broadcast stream from native side\n    _sensorStream = eventChannel.receiveBroadcastStream().map((event) => event as double);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder<double>(\n          stream: _sensorStream,\n          builder: (context, snapshot) {\n            if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n            if (!snapshot.hasData) return const Text('Waiting for sensor data...');\n            return Text('Sensor Value: ${snapshot.data}');\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a 'ThemeNotifier' using the Provider package to toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeNotifier.mode,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeNotifier.toggleTheme,\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'FutureProvider.family' in Riverpod to fetch details based on a specific item ID passed as a parameter.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// Mock fetch function\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item $id';\n}\n\n// Family Provider definition\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch provider with specific family argument\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Item Details')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, s) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a 5-pointed star shape.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass StarPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.amber\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width, size.height) / 2;\n    final innerRadius = radius / 2.5;\n\n    double step = pi / 5;\n\n    for (int i = 0; i < 10; i++) {\n      // Calculate radius: outer for even indices, inner for odd\n      double r = (i % 2 == 0) ? radius : innerRadius;\n      // -pi/2 rotates the star to point upwards\n      double angle = i * step - pi / 2;\n      \n      double x = center.dx + r * cos(angle);\n      double y = center.dy + r * sin(angle);\n\n      if (i == 0) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.close();\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application state using the Provider package. Define a `ChangeNotifier` class and wrap the main app with `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a blue circle in the center of the widget with a red border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 3 : size.height / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `StateNotifier` to manage a list of Todo strings. Create the provider and a method to add a todo.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement the Dart side of a `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel'. Handle potential `PlatformException`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod `FutureProvider` that fetches a user's name from a simulated API, and a widget that handles the loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate API\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return userAsync.when(\n      data: (name) => Text('Hello, $name'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a smooth arc) from the bottom-left to the top-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    path.moveTo(0, size.height); // Start at bottom-left\n    // Control point at top-left, end point at top-right\n    path.quadraticBezierTo(0, 0, size.width, 0);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the `Selector` widget from the Provider package to rebuild a widget ONLY when a specific property (`age`) of a `Person` model changes, ignoring other property changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Person extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void haveBirthday() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<Person, int>(\n      selector: (context, person) => person.age,\n      builder: (context, age, child) {\n        // This builder only runs when 'age' changes\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an `EventChannel` in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('com.example.app/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that fetches details for a specific item ID passed as an argument.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A simulated API call\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item $id';\n}\n\n// Family provider accepting an int ID\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\n// Usage inside a widget\n// final itemDetails = ref.watch(itemDetailProvider(42));"}
{"instruction": "Create a `CustomPainter` that renders a text string directly onto the canvas using `TextPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    const textStyle = TextStyle(\n      color: Colors.black,\n      fontSize: 30,\n    );\n    const textSpan = TextSpan(\n      text: 'Hello Canvas',\n      style: textStyle,\n    );\n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n\n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n\n    // Center the text\n    final xCenter = (size.width - textPainter.width) / 2;\n    final yCenter = (size.height - textPainter.height) / 2;\n    final offset = Offset(xCenter, yCenter);\n\n    textPainter.paint(canvas, offset);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter model using Flutter's Provider package (ChangeNotifier) and a widget that consumes it to display the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<CounterModel>(\n      builder: (context, counter, child) {\n        return Text('Count: ${counter.count}');\n      },\n    );\n  }\n}"}
{"instruction": "Define a StateNotifier and a StateNotifierProvider using Riverpod to manage a simple list of strings (Todo list).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write a CustomPainter class that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 4 : size.height / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Dart function to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod FutureProvider using the .family modifier to fetch user data based on a dynamic userId.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final String id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// Mock API call\nFuture<User> fetchUser(String id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return User(id, 'User $id');\n}\n\nfinal userProvider = FutureProvider.family<User, String>((ref, userId) async {\n  return await fetchUser(userId);\n});"}
{"instruction": "Create a CustomPainter that draws a red triangle using the Path class.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(size.width / 2, 0);\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Flutter EventChannel to listen to a stream of events (e.g., sensor data) from the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n\n  void listenToSensorEvents() {\n    _eventChannel.receiveBroadcastStream().listen((dynamic event) {\n      print('Received sensor event: $event');\n    }, onError: (dynamic error) {\n      print('Received error: ${error.message}');\n    });\n  }\n}"}
{"instruction": "Demonstrate how to use ProxyProvider in the Provider package to inject a value from an AuthModel into a DatabaseModel.", "output": "import 'package:provider/provider.dart';\n\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider<AuthModel>(\n      create: (_) => AuthModel(),\n    ),\n    ProxyProvider<AuthModel, DatabaseModel>(\n      update: (_, auth, previousDb) => DatabaseModel(auth.token),\n    ),\n  ],\n  child: MyApp(),\n);"}
{"instruction": "Write a Riverpod ConsumerWidget build method that handles data, loading, and error states of an AsyncValue.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final AsyncValue<User> userAsync = ref.watch(userProvider('123'));\n\n    return userAsync.when(\n      data: (user) => Text('Hello ${user.name}'),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that paints a TextSpan onto the canvas at a specific offset.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final textSpan = TextSpan(\n      text: 'Hello CustomPainter',\n      style: TextStyle(color: Colors.black, fontSize: 24),\n    );\n    \n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n    \n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n    \n    final offset = Offset(10, size.height / 2 - textPainter.height / 2);\n    textPainter.paint(canvas, offset);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a simple counter application using Flutter Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count', style: const TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.shortestSide / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use the `provider` package to implement a `ThemeController` that toggles between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeController extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeController(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeController = Provider.of<ThemeController>(context);\n    return MaterialApp(\n      theme: themeController.currentTheme,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeController.toggleTheme,\n            child: Text('Switch to ${themeController.isDark ? \"Light\" : \"Dark\"} Mode'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display a string from a simulated API call, handling loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Fetched Data Successfully';\n});\n\nclass DataScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Draw a quadratic bezier curve (a simple arch) using `CustomPainter` and the `Path` class.", "output": "import 'package:flutter/material.dart';\n\nclass ArchPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.purple\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Control point at top center, end point at bottom right\n    path.quadraticBezierTo(size.width / 2, 0, size.width, size.height);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Todo list manager using Riverpod's `StateNotifier` to add and remove items immutably.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// State Class\nclass Todo {\n  final String id;\n  final String description;\n  Todo({required this.id, required this.description});\n}\n\n// Notifier\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void remove(String id) {\n    state = state.where((todo) => todo.id != id).toList();\n  }\n}\n\n// Provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Set up an `EventChannel` in Flutter to listen to a stream of random numbers sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass NumberStreamWidget extends StatelessWidget {\n  static const eventChannel = EventChannel('com.example.app/random_numbers');\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder( \n      stream: eventChannel.receiveBroadcastStream(),\n      builder: (context, snapshot) {\n        if (snapshot.hasError) return Text('Error: ${snapshot.error}');\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return const Text('Waiting for numbers...');\n        }\n        return Text('Received Number: ${snapshot.data}');\n      },\n    );\n  }\n}"}
{"instruction": "Setup `MultiProvider` to inject two distinct ChangeNotifiers (`UserProvider` and `CartProvider`) into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserProvider extends ChangeNotifier {\n  String name = 'Guest';\n}\n\nclass CartProvider extends ChangeNotifier {\n  int itemCount = 0;\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => UserProvider()),\n        ChangeNotifierProvider(create: (_) => CartProvider()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) => const MaterialApp(home: Scaffold());\n}"}
{"instruction": "Create a `CustomPainter` that draws a rectangle filled with a linear gradient from purple to blue.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using the 'Provider' package for state management. Include the ChangeNotifier class and the UI to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. The State Class\nclass CounterProvider extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// 2. The App Entry Point\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\n// 3. The UI\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          // Consumer rebuilds only this widget when state changes\n          child: Consumer<CounterProvider>(\n            builder: (context, counter, child) {\n              return Text(\n                'Count: ${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterProvider>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter to draw a simple blue circle with a red border in the center of a widget.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainterWidget extends StatelessWidget {\n  const CirclePainterWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's 'FutureProvider' to fetch and display a string asynchronously. Handle loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the FutureProvider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network delay\n  return 'Fetched Data from API';\n});\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final asyncValue = ref.watch(dataProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod FutureProvider')),\n        body: Center(\n          child: asyncValue.when(\n            data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n            loading: () => const CircularProgressIndicator(),\n            error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel. Include error handling.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Implement a simple theme switcher (Light/Dark mode) using Riverpod's 'StateProvider'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. StateProvider for ThemeMode\nfinal themeModeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.light);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final themeMode = ref.watch(themeModeProvider);\n\n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeMode,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: SwitchListTile(\n            title: const Text('Dark Mode'),\n            value: themeMode == ThemeMode.dark,\n            onChanged: (isDark) {\n              // 2. Update state\n              ref.read(themeModeProvider.notifier).state = \n                  isDark ? ThemeMode.dark : ThemeMode.light;\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line horizontally across the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..style = PaintingStyle.stroke;\n\n    double dashWidth = 10;\n    double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass DashedLine extends StatelessWidget {\n  const DashedLine({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 20),\n      painter: DashedLinePainter(),\n    );\n  }\n}"}
{"instruction": "Use Provider's 'Selector' widget to optimize performance by rebuilding a widget only when a specific property of the provider changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserData extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplayWidget extends StatelessWidget {\n  const AgeDisplayWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Selector only listens to the 'age' integer, ignoring 'name' changes\n    return Selector<UserData, int>(\n      selector: (context, userData) => userData.age,\n      builder: (context, age, child) {\n        // 'child' is optional optimization for static sub-trees\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod 'StateNotifier' to manage a list of Todo items (add and toggle completion).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Model\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\n// Notifier\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\n// Provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a Bezier curve (a wave shape) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Line to top left (start of wave)\n    path.lineTo(0, size.height * 0.8);\n\n    // Quadratic Bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (dip)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close path\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's '.family' modifier on a Provider to pass an argument (userID) to fetch specific user details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// 1. Define Family Provider\n// Takes an int (userId) and returns a String (User Name)\nfinal userProvider = FutureProvider.family<String, int>((ref, userId) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'User $userId Name'; // Mock API response\n});\n\nclass UserProfile extends ConsumerWidget {\n  final int userId;\n  const UserProfile({super.key, required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Pass the argument to the provider\n    final userAsync = ref.watch(userProvider(userId));\n\n    return userAsync.when(\n      data: (name) => Text('Profile: $name'),\n      loading: () => const CircularProgressIndicator(),\n      error: (e, s) => const Text('Error loading user'),\n    );\n  }\n}"}
{"instruction": "Create a basic counter application state using the 'provider' package. Define a `ChangeNotifier` class and show how to consume it in a Widget using `Consumer`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching a user's profile from an API and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    // Draw fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), child: Container())"}
{"instruction": "Write a Dart function that uses `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handles potential `PlatformException`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod `StateNotifier` to manage a list of Todo strings, including methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement a `CustomPainter` that draws a quadratic Bezier curve (a simple arch) from the bottom-left to the bottom-right of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    var path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Control point at top center, end point at bottom right\n    path.quadraticBezierTo(\n        size.width / 2, 0, size.width, size.height);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the `Selector` widget from the `provider` package to optimize a widget so it only rebuilds when a specific property (`userName`) of the model changes, ignoring other changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String userName = 'Guest';\n  int age = 25;\n  // ... methods to update state\n}\n\nclass UserNameDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, String>(\n      selector: (context, userModel) => userModel.userName,\n      builder: (context, userName, child) {\n        print('Building UserNameDisplay'); // Only prints when userName changes\n        return Text('User: $userName');\n      },\n    );\n  }\n}"}
{"instruction": "Demonstrate how to pass an argument to a Riverpod provider using the `.family` modifier to fetch details for a specific item ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulating an API call\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Details for Item $id';\n}\n\n// Family provider accepting an int id\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItemDetails(id);\n});\n\n// Usage inside a Widget build method:\n// final asyncValue = ref.watch(itemDetailProvider(42));"}
{"instruction": "Create a `CustomPainter` that fills a rectangle with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\nimport 'dart:ui' as ui;\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..shader = ui.Gradient.linear(\n        rect.topLeft,\n        rect.bottomRight,\n        [Colors.blue, Colors.purple],\n      );\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Dart-side `EventChannel` to listen to a continuous stream of data (e.g., sensor readings) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorService {\n  static const EventChannel _channel = EventChannel('com.example.app/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      (event) {\n        onData(event);\n      },\n      onError: (error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod's `StateProvider` and a `ConsumerWidget` to display and increment the value.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a theme switcher using the `provider` package. Create a `ChangeNotifier` that toggles a boolean and a widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nclass ThemeSwitcherApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: Consumer<ThemeNotifier>(\n        builder: (context, themeNotifier, child) {\n          return MaterialApp(\n            theme: themeNotifier.isDark ? ThemeData.dark() : ThemeData.light(),\n            home: Scaffold(\n              body: Center(\n                child: Switch(\n                  value: themeNotifier.isDark,\n                  onChanged: (value) => themeNotifier.toggleTheme(),\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` class that draws a circular progress indicator based on a percentage value (0.0 to 1.0).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircleProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  CircleProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey.withOpacity(0.2)\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n    \n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Progress Arc\n    final progressPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    // -pi/2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      2 * pi * percentage,\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircleProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' on the channel 'samples.flutter.dev/battery'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Fetch data asynchronously using Riverpod's `FutureProvider` and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'User: John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return userAsync.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a sine wave (Bezier curve) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.8);\n    \n    // Draw quadratic bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.25, size.height * 0.6, // Control point 1\n      size.width * 0.5, size.height * 0.8,  // End point 1\n    );\n    path.quadraticBezierTo(\n      size.width * 0.75, size.height * 1.0, // Control point 2\n      size.width, size.height * 0.8,        // End point 2\n    );\n\n    // Close the path\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Shopping Cart logic using `ChangeNotifier` (Provider package) that allows adding and removing strings from a list.", "output": "import 'package:flutter/material.dart';\nimport 'dart:collection';\n\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n\n  UnmodifiableListView<String> get items => UnmodifiableListView(_items);\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(String item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n\n  void removeAll() {\n    _items.clear();\n    notifyListeners();\n  }\n}"}
{"instruction": "Implement a Dart function to call a native 'showToast' method passing a message string argument via `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToast {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Manage a list of Todo objects using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoNotifier extends StateNotifier<List<Todo>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {\n  return TodoNotifier();\n});"}
{"instruction": "Create a CustomPainter that fills a rectangle with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    \n    final paint = Paint()\n      ..shader = LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`. Include the `ProviderScope` setup and a `ConsumerWidget` that reads and updates the counter.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider for changes\n    final count = ref.watch(counterProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(\n          child: Text(\n            '$count',\n            style: Theme.of(context).textTheme.headlineMedium,\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // 4. Update the state\n            ref.read(counterProvider.notifier).state++;\n          },\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`. Include error handling for `PlatformException`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the native method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a User Profile manager using the `Provider` package with `ChangeNotifier`. The model should have a `name` property and a method to update it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the model\nclass UserProfile extends ChangeNotifier {\n  String _name = 'Guest';\n\n  String get name => _name;\n\n  void updateName(String newName) {\n    _name = newName;\n    notifyListeners(); // Notify widgets to rebuild\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Provide the model\n    ChangeNotifierProvider(\n      create: (context) => UserProfile(),\n      child: const MaterialApp(home: ProfileScreen()),\n    ),\n  );\n}\n\nclass ProfileScreen extends StatelessWidget {\n  const ProfileScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 3. Consume the model\n    final userProfile = Provider.of<UserProfile>(context);\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('User: ${userProfile.name}'),\n            ElevatedButton(\n              onPressed: () => userProfile.updateName('Alice'),\n              child: const Text('Login as Alice'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch and display a string from a simulated API. Handle 'loading', 'error', and 'data' states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchConfig() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'App Config Loaded';\n}\n\n// Define the FutureProvider\nfinal configProvider = FutureProvider<String>((ref) async {\n  return fetchConfig();\n});\n\nclass ConfigLoader extends ConsumerWidget {\n  const ConfigLoader({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    // Handle all states: data, loading, error\n    return configAsync.when(\n      data: (data) => Text('Success: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    \n    // Draw curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Todo List manager using Riverpod's `StateNotifier` and `StateNotifierProvider` to handle immutable state updates.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the State (Immutable Todo class)\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n  \n  Todo copyWith({bool? completed}) {\n    return Todo(id: id, description: description, completed: completed ?? this.completed);\n  }\n}\n\n// 2. Define the StateNotifier\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo\n    ];\n  }\n}\n\n// 3. Define the Provider\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a widget that listens to a native stream of events (e.g., sensor data) using Flutter's `EventChannel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  // Define the event channel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  Stream<dynamic>? _sensorStream;\n\n  @override\n  void initState() {\n    super.initState();\n    // Initialize the stream\n    _sensorStream = eventChannel.receiveBroadcastStream();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<dynamic>(\n      stream: _sensorStream,\n      builder: (context, snapshot) {\n        if (snapshot.hasError) {\n          return Text('Error: ${snapshot.error}');\n        }\n        if (snapshot.connectionState == ConnectionState.active) {\n          return Text('Sensor Data: ${snapshot.data}');\n        }\n        return const CircularProgressIndicator();\n      },\n    );\n  }\n}"}
{"instruction": "Use the `Provider` package's `ProxyProvider` to make a `CartModel` depend on an `AuthModel` (i.e., the cart updates when the user changes).", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? userId;\n  void login(String id) { userId = id; notifyListeners(); }\n}\n\nclass CartModel extends ChangeNotifier {\n  final AuthModel _auth;\n  final List<String> items = [];\n\n  CartModel(this._auth);\n\n  String get status => _auth.userId != null ? 'Cart for ${_auth.userId}' : 'Guest Cart';\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        // ProxyProvider updates CartModel when AuthModel changes\n        ChangeNotifierProxyProvider<AuthModel, CartModel>(\n          create: (context) => CartModel(Provider.of<AuthModel>(context, listen: false)),\n          update: (context, auth, previousCart) => CartModel(auth),\n        ),\n      ],\n      child: const MaterialApp(home: HomeScreen()),\n    ),\n  );\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n       body: Center(child: Text(Provider.of<CartModel>(context).status)),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a progress arc with a gradient sweep (SweepGradient).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 3 * pi / 2; // 75% progress\n    final useCenter = false;\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 10.0\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple, Colors.red],\n        startAngle: 0.0,\n        endAngle: pi * 2,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, startAngle, sweepAngle, useCenter, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter class using the Provider package (ChangeNotifier) and show how to provide it to the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// Usage in main:\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}"}
{"instruction": "Implement a CustomPainter that draws a blue circle with a red border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass TargetPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Riverpod StateNotifier to manage a list of String items (Todo list).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<int?> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return result;\n    } on PlatformException catch (e) {\n      print(\"Failed to get battery level: '${e.message}'.\");\n      return null;\n    }\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch user data asynchronously and handle the loading/error states in a ConsumerWidget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userFutureProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userFutureProvider);\n\n    return userAsync.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic Bezier curve (a simple arch).", "output": "import 'package:flutter/material.dart';\n\nclass ArchPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.green\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5;\n\n    final path = Path();\n    path.moveTo(0, size.height);\n    // Control point at top-center, end point at bottom-right\n    path.quadraticBezierTo(size.width / 2, 0, size.width, size.height);\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Setup an EventChannel in Dart to listen to a continuous stream of data (e.g., sensor readings) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void cancel() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Demonstrate how to use MultiProvider to inject multiple independent providers into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        Provider(create: (_) => ApiService()),\n        ProxyProvider<AuthModel, UserProfile>(\n          update: (_, auth, __) => UserProfile(auth.token),\n        ),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}"}
{"instruction": "Use Riverpod's .family modifier to create a provider that accepts an argument (e.g., fetching a specific item by ID).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchItem(int id) async => 'Item $id';\n\n// Provider with family modifier accepting an integer ID\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  return await fetchItem(id);\n});\n\n// Usage inside a widget:\n// ref.watch(itemFamilyProvider(42));"}
{"instruction": "Implement a CustomPainter that fills the canvas with a vertical linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n        colors: [Colors.orange, Colors.deepPurple],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using Riverpod 2.0 (Annotation syntax) to manage the state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nclass CounterApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(child: Text('Count: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a filled circle with a stroke border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' on Android/iOS.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(onPressed: _getBatteryLevel, child: Text('Get Level')),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Provider to create a Theme Switcher that toggles between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    return MaterialApp(\n      theme: themeNotifier.currentTheme,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: Switch(\n            value: themeNotifier.isDark,\n            onChanged: (val) => themeNotifier.toggleTheme(),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Fetch asynchronous data using Riverpod's FutureProvider and handle loading/error states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network\n  return ['Apple', 'Banana', 'Cherry'];\n});\n\nclass FruitList extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: asyncValue.when(\n        data: (fruits) => ListView.builder(\n          itemCount: fruits.length,\n          itemBuilder: (ctx, index) => ListTile(title: Text(fruits[index])),\n        ),\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (err, stack) => Center(child: Text('Error: $err')),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a Bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.25,\n      size.height * 0.7,\n      size.width * 0.5,\n      size.height * 0.8,\n    );\n    path.quadraticBezierTo(\n      size.width * 0.75,\n      size.height * 0.9,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a simple EventChannel in Dart to listen for a stream of events from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nclass EventListenerWidget extends StatefulWidget {\n  @override\n  _EventListenerWidgetState createState() => _EventListenerWidgetState();\n}\n\nclass _EventListenerWidgetState extends State<EventListenerWidget> {\n  static const eventChannel = EventChannel('com.example.app/events');\n  StreamSubscription? _subscription;\n  String _eventData = 'Waiting...';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() => _eventData = 'Received: $event');\n      },\n      onError: (dynamic error) {\n        setState(() => _eventData = 'Error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => Text(_eventData);\n}"}
{"instruction": "Create a Todo list manager using Riverpod's Notifier class (class-based provider).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoNotifier extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() => [];\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoProvider = NotifierProvider<TodoNotifier, List<Todo>>(TodoNotifier.new);"}
{"instruction": "Embed a native iOS UIKit view (e.g., a UILabel) into the Flutter widget tree using UiKitView.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/foundation.dart';\n\nclass NativeLabel extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // This is used only on iOS\n    if (defaultTargetPlatform == TargetPlatform.iOS) {\n      return const SizedBox(\n        height: 50,\n        width: 200,\n        child: UiKitView(\n          viewType: 'com.example.native_label',\n          creationParams: {'text': 'Hello from UIKit'},\n          creationParamsCodec: StandardMessageCodec(),\n        ),\n      );\n    }\n    return const Text('Not supported on this platform');\n  }\n}"}
{"instruction": "Setup a MultiProvider to inject multiple dependent providers into the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? _userId = 'User123';\n  String? get userId => _userId;\n}\n\nclass CartModel extends ChangeNotifier {\n  final AuthModel _auth;\n  CartModel(this._auth);\n  \n  String get status => 'Cart for user: ${_auth.userId}';\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProxyProvider<AuthModel, CartModel>(\n          create: (context) => CartModel(Provider.of<AuthModel>(context, listen: false)),\n          update: (context, auth, previousCart) => CartModel(auth),\n        ),\n      ],\n      child: const MaterialApp(home: Scaffold(body: Center(child: Text('App')))),\n    ),\n  );\n}"}
{"instruction": "Create a basic counter application using Flutter Riverpod's `StateProvider`. Include the provider definition and a `ConsumerWidget` that displays the count and increments it via a FloatingActionButton.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(ProviderScope(child: MaterialApp(home: CounterApp())));\n}\n\nclass CounterApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider for changes\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Read the provider and update state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass BlueCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    // Draw circle at the center of the available size\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 2 : size.height / 2;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // No dynamic changes, no repaint needed\n  }\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(100, 100),\n      painter: BlueCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a simple MethodChannel in Flutter to invoke a platform-specific method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher {\n  // Define the channel name\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the method on the native side\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use the `Provider` package to create a `ChangeNotifier` for a Theme model and wrap the app in a `ChangeNotifierProvider` to toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeModel extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeModel>(\n      builder: (context, theme, child) {\n        return MaterialApp(\n          theme: theme.isDark ? ThemeData.dark() : ThemeData.light(),\n          home: Scaffold(\n            body: Center(\n              child: ElevatedButton(\n                onPressed: () => theme.toggleTheme(),\n                child: const Text(\"Toggle Theme\"),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Create a Riverpod `FutureProvider` to simulate fetching user data from an API, and display the result using `.when` to handle loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomClipper` that clips a widget into a downward-pointing triangle.", "output": "import 'package:flutter/material.dart';\n\nclass TriangleClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    final path = Path();\n    // Top left\n    path.moveTo(0, 0);\n    // Top right\n    path.lineTo(size.width, 0);\n    // Bottom center\n    path.lineTo(size.width / 2, size.height);\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}\n\n// Usage\n// ClipPath(clipper: TriangleClipper(), child: Container(color: Colors.red, height: 100, width: 100));"}
{"instruction": "Use the `Selector` widget from the `Provider` package to optimize rebuilds. Create a widget that only rebuilds when the `age` property of a `Person` model changes, ignoring changes to `name`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Person extends ChangeNotifier {\n  String name = \"Alice\";\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n  \n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<Person, int>(\n      selector: (_, person) => person.age,\n      builder: (_, age, __) {\n        print(\"Rebuilding Age Display\");\n        return Text(\"Age: $age\");\n      },\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod `StateNotifier` to manage a Todo list (List<String>). Include methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Implement a `CustomPainter` that draws a diagonal line with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.red, Colors.blue],\n      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height))\n      ..strokeWidth = 8.0\n      ..strokeCap = StrokeCap.round;\n\n    canvas.drawLine(\n      const Offset(0, 0),\n      Offset(size.width, size.height),\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a Flutter `EventChannel` to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorListener {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n\n  void startListening(Function(dynamic) onData, Function(dynamic) onError) {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      onData,\n      onError: onError,\n    );\n  }\n\n  void stopListening() {\n    _streamSubscription?.cancel();\n  }\n}"}
{"instruction": "Create a basic counter implementation using the Provider package with a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<Counter>(\n          builder: (context, counter, child) => Text(\n            '${counter.count}',\n            style: Theme.of(context).textTheme.headlineMedium,\n          ),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<Counter>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a simple Todo list manager using Riverpod's StateNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoNotifier extends StateNotifier<List<String>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<String>>((ref) {\n  return TodoNotifier();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) => ListTile(\n          title: Text(todos[index]),\n          onTap: () => ref.read(todoProvider.notifier).removeTodo(todos[index]),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoProvider.notifier).addTodo('New Task ${todos.length + 1}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a red circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass MyCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 4 : size.height / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false;\n  }\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: MyCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a MethodChannel in Flutter to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelScreen extends StatefulWidget {\n  const BatteryLevelScreen({super.key});\n\n  @override\n  State<BatteryLevelScreen> createState() => _BatteryLevelScreenState();\n}\n\nclass _BatteryLevelScreenState extends State<BatteryLevelScreen> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to fetch data asynchronously and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network request\n  return 'Fetched Data Successfully';\n});\n\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Draw a quadratic bezier curve (wave pattern) using CustomPainter and Path.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 5.0;\n\n    final path = Path();\n    path.moveTo(0, size.height / 2);\n    \n    // Quadratic Bezier Curve\n    path.quadraticBezierTo(\n      size.width / 2, // Control point x\n      size.height * 0.2, // Control point y (peak of the wave)\n      size.width, // End point x\n      size.height / 2, // End point y\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize rebuilds using Selector from the Provider package to listen only to a specific property of a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void updateAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // This widget will only rebuild when 'age' changes, ignoring 'name' changes.\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building Age Display');\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a Riverpod provider that accepts an ID argument using the .family modifier to fetch specific item details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate a database fetch\nFuture<String> fetchItemById(int id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Item Details for ID: $id';\n}\n\n// Family provider accepting an int argument\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemById(id);\n});\n\n// Usage in a Widget\n/*\n   @override\n   Widget build(BuildContext context, WidgetRef ref) {\n     final itemAsync = ref.watch(itemFamilyProvider(42));\n     return itemAsync.when(\n       data: (data) => Text(data),\n       loading: () => CircularProgressIndicator(),\n       error: (e, s) => Text('Error'),\n     );\n   }\n*/"}
{"instruction": "Implement an EventChannel to listen to a stream of events from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass EventChannelDemo extends StatefulWidget {\n  const EventChannelDemo({super.key});\n\n  @override\n  State<EventChannelDemo> createState() => _EventChannelDemoState();\n}\n\nclass _EventChannelDemoState extends State<EventChannelDemo> {\n  static const EventChannel _eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _streamSubscription;\n  String _sensorValue = 'Waiting for events...';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorListening();\n  }\n\n  void _enableSensorListening() {\n    _streamSubscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorValue = 'Sensor value: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorValue = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorValue));\n  }\n}"}
{"instruction": "Create a CustomPainter that applies a linear gradient shader to a rectangle.", "output": "import 'package:flutter/material.dart';\n\nclass GradientRectPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    \n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.blue],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the Provider package for state management. The solution should include a `CounterModel` class extending `ChangeNotifier` and a `main` function wrapping the app in a `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter in Flutter that draws a circular progress indicator. The painter should accept a `percentage` (0.0 to 1.0) and a `color`.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass CircleProgressPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  CircleProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey.withOpacity(0.2)\n      ..strokeWidth = strokeWidth\n      ..style = PaintingStyle.stroke;\n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Progress Arc\n    final progressPaint = Paint()\n      ..color = color\n      ..strokeWidth = strokeWidth\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    final sweepAngle = 2 * pi * percentage;\n    // -pi/2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      sweepAngle,\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircleProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage || oldDelegate.color != color;\n  }\n}"}
{"instruction": "Create a Flutter widget that uses `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel'. Handle the result and potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod (flutter_riverpod) to manage a Todo list. Create a `StateNotifier` for the list of strings and a `ConsumerWidget` to display the list and add new items.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier to manage the list\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n}\n\n// Global provider definition\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\nclass TodoScreen extends ConsumerWidget {\n  final TextEditingController _controller = TextEditingController();\n\n  TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todo')),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _controller,\n              onSubmitted: (value) {\n                ref.read(todoListProvider.notifier).add(value);\n                _controller.clear();\n              },\n              decoration: const InputDecoration(labelText: 'Add Todo'),\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: todos.length,\n              itemBuilder: (context, index) => ListTile(title: Text(todos[index])),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a quadratic bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n    \n    // Draw curve to the right side\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point X (center)\n      size.height * 0.6, // Control point Y (higher up)\n      size.width,        // End point X\n      size.height * 0.8  // End point Y\n    );\n\n    // Close the path at bottom right\n    path.lineTo(size.width, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Theme Switcher using Provider. Define a `ThemeService` class that toggles between light and dark `ThemeData`, and wrap the `MaterialApp` to listen to changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeService extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  ThemeData get currentTheme => _isDark ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeService(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeService = context.watch<ThemeService>();\n    return MaterialApp(\n      theme: themeService.currentTheme,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Theme Switcher')),\n        body: Center(\n          child: Switch(\n            value: themeService.isDark,\n            onChanged: (_) => themeService.toggleTheme(),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to handle asynchronous data fetching (e.g., simulating an API call). Display loading, error, and data states using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nfinal apiProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  // throw Exception('Network Error'); // Uncomment to test error\n  return 'Fetched Data from API';\n});\n\nclass AsyncDataScreen extends ConsumerWidget {\n  const AsyncDataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(apiProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('FutureProvider Example')),\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 20)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement an `EventChannel` in Dart to listen to a stream of events sent from the native platform (e.g., sensor data).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    // Start listening to the stream\n    eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        _sensorData,\n        style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    double dashWidth = 5.0;\n    double dashSpace = 5.0;\n    double startX = 0.0;\n\n    // Draw dashes horizontally across the width\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an argument (id) and returns a specific value based on that ID.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that takes an int ID and returns a String\nfinal itemFamilyProvider = Provider.family<String, int>((ref, id) {\n  return 'Item #$id details';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider with the specific family argument\n    final itemDetails = ref.watch(itemFamilyProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Item $itemId')),\n      body: Center(\n        child: Text(itemDetails, style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`. Include the provider definition and a `ConsumerWidget` that reads and updates the state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\n// 2. Consume the provider\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the state to rebuild on changes\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        // Read the notifier to update state without rebuilding this specific button\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a simple blue triangle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Top point\n    path.moveTo(size.width / 2, 0);\n    // Bottom right\n    path.lineTo(size.width, size.height);\n    // Bottom left\n    path.lineTo(0, size.height);\n    // Close the path to form a triangle\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Dart method that uses `MethodChannel` to invoke a native platform method named 'getBatteryLevel' and handles the result.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  // Define the channel name matching the native side\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}';\n    }\n  }\n}"}
{"instruction": "Create a Theme Switcher using the `Provider` package. Define a `ChangeNotifier` for the theme mode and a widget that toggles it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nclass ThemeButton extends StatelessWidget {\n  const ThemeButton({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Use context.read to trigger the method without listening for changes here\n    return IconButton(\n      icon: const Icon(Icons.brightness_6),\n      onPressed: () => context.read<ThemeNotifier>().toggleTheme(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching a list of user names asynchronously and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nfinal userListProvider = FutureProvider<List<String>>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return ['Alice', 'Bob', 'Charlie'];\n});\n\nclass UserListScreen extends ConsumerWidget {\n  const UserListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncUsers = ref.watch(userListProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncUsers.when(\n          data: (users) => ListView.builder(\n            itemCount: users.length,\n            itemBuilder: (context, index) => ListTile(title: Text(users[index])),\n          ),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a wave) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.8);\n    \n    // Draw curve to bottom right using a control point\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point X (center)\n      size.height,      // Control point Y (bottom)\n      size.width,       // End point X (right)\n      size.height * 0.8 // End point Y\n    );\n\n    // Close the shape\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize widget rebuilding using the `Selector` widget from the `Provider` package to listen only to a specific property ('age') of a 'User' model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      // Only rebuild if 'age' changes, ignore 'name' changes\n      selector: (_, user) => user.age,\n      builder: (_, age, __) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an `EventChannel` in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\n\nclass SensorService {\n  // Channel name must match the native EventChannel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n\n  Stream<double> get sensorStream {\n    return eventChannel.receiveBroadcastStream().map((event) {\n      // Cast the dynamic event to the expected type\n      return event as double;\n    });\n  }\n}"}
{"instruction": "Create a Riverpod provider using the `.family` modifier to fetch details for a specific item ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that accepts an argument (itemId)\nfinal itemDetailsProvider = FutureProvider.family<String, int>((ref, itemId) async {\n  // Simulate network request based on itemId\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item #$itemId';\n});\n\n// Usage in ConsumerWidget:\n// final item = ref.watch(itemDetailsProvider(42));"}
{"instruction": "Implement a `CustomPainter` that fills a circle with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    \n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.orange, Colors.purple],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawCircle(\n      size.center(Offset.zero),\n      size.shortestSide / 2,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a basic counter state using the `provider` package. Create a `ChangeNotifier` class and wrap the app with a `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter with ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => Counter(),\n      child: const MaterialApp(home: HomePage()),\n    ),\n  );\n}"}
{"instruction": "Create a simple Todo list manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String desc;\n  final bool completed;\n  Todo(this.id, this.desc, this.completed);\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String desc) {\n    state = [...state, Todo(DateTime.now().toString(), desc, false)];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(todo.id, todo.desc, !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a `CustomPainter` that draws a filled blue circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the Dart side of a Platform Channel (MethodChannel) to invoke a native method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider.family` to fetch user details based on a dynamic user ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserById(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'User $id';\n}\n\n// Family provider allowing arguments\nfinal userProvider = FutureProvider.family<String, int>((ref, userId) async {\n  return await fetchUserById(userId);\n});\n\n// Usage in a ConsumerWidget: ref.watch(userProvider(123));"}
{"instruction": "Create a `CustomPainter` to draw a horizontal progress bar with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientProgressBarPainter extends CustomPainter {\n  final double progress; // Value between 0.0 and 1.0\n\n  GradientProgressBarPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.blue, Colors.purple],\n      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));\n\n    // Draw the progress rect\n    canvas.drawRect(\n      Rect.fromLTWH(0, 0, size.width * progress, size.height),\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientProgressBarPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Set up a Dart `EventChannel` to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorStreamHandler {\n  static const EventChannel _channel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use `ProxyProvider` from the `provider` package to inject an `AuthModel` into a `CartModel`, allowing the cart to update when authentication changes.", "output": "import 'package:provider/provider.dart';\n\nclass AuthModel {\n  String? userId;\n}\n\nclass CartModel {\n  final AuthModel _auth;\n  CartModel(this._auth);\n\n  void add() {\n    print(\"Adding item for user: ${_auth.userId}\");\n  }\n}\n\n// Widget Tree setup\n/*\nMultiProvider(\n  providers: [\n    Provider<AuthModel>(create: (_) => AuthModel()),\n    ProxyProvider<AuthModel, CartModel>(\n      update: (_, auth, __) => CartModel(auth),\n    ),\n  ],\n  child: MyApp(),\n)\n*/"}
{"instruction": "Draw a quadratic bezier curve (a wave shape) at the bottom of a container using `CustomPainter` and `Path`.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    // Start at top-left\n    path.moveTo(0, 0);\n    path.lineTo(0, size.height * 0.8);\n    // Draw curve\n    path.quadraticBezierTo(\n        size.width / 2, size.height, size.width, size.height * 0.8);\n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Riverpod provider using `.autoDispose` to automatically reset state (e.g., a search query) when the widget is unmounted.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// This state is destroyed when the widget listening to it is removed from the tree\nfinal searchQueryProvider = StateProvider.autoDispose<String>((ref) {\n  return '';\n});\n\n// Usage:\n// ref.watch(searchQueryProvider);\n// ref.read(searchQueryProvider.notifier).state = 'new query';"}
{"instruction": "Create a simple Counter application state using the 'provider' package. Include the ChangeNotifier class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier class\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\n// 2. Setup the Provider in the widget tree\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          // 3. Consume the state\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}', style: Theme.of(context).textTheme.headlineMedium);\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'CustomPainter' that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw the red fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw the blue border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // Static drawing, no repaint needed\n  }\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod 'StateNotifier' to manage a list of Todo items (String).", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. The StateNotifier class\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. The Provider definition\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});\n\n// Usage example (not full UI)\n// ref.read(todoListProvider.notifier).addTodo('Buy milk');"}
{"instruction": "Implement a Dart method using 'MethodChannel' to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelFetcher {\n  // Define the channel name\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the native method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod 'FutureProvider' to fetch user data asynchronously and a widget that handles loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\n// 1. Define FutureProvider\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\n// 2. Consume in Widget\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Write a CustomPainter that draws a simple sine wave across the width of the canvas.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 3.0;\n\n    final path = Path();\n    \n    // Start at middle-left\n    path.moveTo(0, size.height / 2);\n\n    for (double i = 0; i <= size.width; i++) {\n      // Calculate Y based on Sine function\n      double y = size.height / 2 + 20 * sin(i * 0.05);\n      path.lineTo(i, y);\n    }\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Theme Switcher using 'provider' to toggle between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  ThemeMode _mode = ThemeMode.light;\n  ThemeMode get mode => _mode;\n\n  void toggleTheme() {\n    _mode = _mode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyThemedApp(),\n    ),\n  );\n}\n\nclass MyThemedApp extends StatelessWidget {\n  const MyThemedApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeNotifier = Provider.of<ThemeNotifier>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeNotifier.mode,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => themeNotifier.toggleTheme(),\n            child: const Text('Toggle Theme'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that fills a rectangle with a linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    \n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.purple, Colors.orange],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that fetches details for a specific item ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item $id';\n}\n\n// Provider with family modifier to accept an argument (id)\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\n// Usage in Widget\n// final itemAsync = ref.watch(itemDetailProvider(42));"}
{"instruction": "Create a Dart MethodChannel implementation to send data (a Map) to the native platform to show a Toast message.", "output": "import 'package:flutter/services.dart';\n\nclass NativeToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message, bool isLong) async {\n    try {\n      await platform.invokeMethod('showToast', <String, dynamic>{\n        'message': message,\n        'duration': isLong ? 1 : 0, // 1 for Long, 0 for Short\n      });\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Create a simple Counter application using the Provider package for state management. Include the ChangeNotifier class and the UI implementation.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Provider Counter')),\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text(\n                '${counter.count}',\n                style: Theme.of(context).textTheme.headlineMedium,\n              );\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a simple circular progress indicator with a background circle and a foreground arc indicating 75% progress.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircleProgress extends StatelessWidget {\n  const CircleProgress({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: ProgressPainter(),\n    );\n  }\n}\n\nclass ProgressPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final backgroundPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n    \n    canvas.drawCircle(center, radius - strokeWidth / 2, backgroundPaint);\n\n    // Foreground Arc (75%)\n    final foregroundPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius - strokeWidth / 2),\n      -pi / 2, // Start at top\n      2 * pi * 0.75, // Sweep 75%\n      false,\n      foregroundPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a basic Riverpod StateNotifierProvider to manage a list of Todo strings (add and remove functionality).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// StateNotifier\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// Provider\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});\n\n// UI\nclass TodoApp extends ConsumerWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todos = ref.watch(todoListProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Todos')),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text(todos[index]),\n            onTap: () => ref.read(todoListProvider.notifier).remove(todos[index]),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(todoListProvider.notifier).add('New Item ${todos.length}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Dart class that uses MethodChannel to invoke a platform-specific method named 'getBatteryLevel'. Handle the PlatformException.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Demonstrate how to use Riverpod's FutureProvider to fetch data asynchronously and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchUserData() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return fetchUserData();\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('User: $data'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a CustomPainter that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at bottom left\n    path.moveTo(0, size.height * 0.8);\n    \n    // Draw quadratic bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height,      // Control point y (peak of wave at bottom)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path to fill the bottom area\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Dart class that listens to a platform EventChannel named 'com.example.app/sensors' to receive a stream of accelerometer data (doubles).", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamHandler {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensors');\n\n  Stream<double>? _sensorStream;\n\n  Stream<double> get sensorStream {\n    _sensorStream ??= _eventChannel\n        .receiveBroadcastStream()\n        .map((dynamic event) => event as double);\n    return _sensorStream!;\n  }\n}"}
{"instruction": "Implement a Riverpod 'family' provider. Create a provider that accepts an integer ID and returns a string 'Item {ID}'.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Family provider accepting an int id\nfinal itemProvider = Provider.family<String, int>((ref, id) {\n  return 'Item $id';\n});\n\nclass ItemWidget extends ConsumerWidget {\n  final int id;\n  const ItemWidget({required this.id, super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watching the provider with a specific argument\n    final itemTitle = ref.watch(itemProvider(id));\n    \n    return Text(itemTitle);\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a pattern of dots (grid) across the entire canvas.", "output": "import 'package:flutter/material.dart';\n\nclass GridDotsPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 4.0;\n\n    const double spacing = 20.0;\n\n    for (double x = 0; x < size.width; x += spacing) {\n      for (double y = 0; y < size.height; y += spacing) {\n        canvas.drawPoints(PointMode.points, [Offset(x, y)], paint);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the Provider package to create a ThemeChanger class that toggles between light and dark mode, and wrap the MaterialApp with it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeChanger with ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme() {\n    _themeMode = _themeMode == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeChanger(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeChanger = Provider.of<ThemeChanger>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeChanger.themeMode,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: themeChanger.toggleTheme,\n            child: const Text('Toggle Dark Mode'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod 2.0 with a StateProvider and a ConsumerWidget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterScreen());\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter to draw a circular progress indicator that accepts a percentage value (0.0 to 1.0) and a color.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircularProgressPainter extends CustomPainter {\n  final double percentage;\n  final Color color;\n\n  CircularProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey.withOpacity(0.2)\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n    \n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Progress Arc\n    final progressPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = strokeWidth;\n\n    // -pi/2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      2 * pi * percentage,\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircularProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage || oldDelegate.color != color;\n  }\n}"}
{"instruction": "Create a Flutter MethodChannel implementation to invoke a native platform method named 'getBatteryLevel'. Handle the PlatformException.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use the Provider package to create a Theme Switcher (Light/Dark mode). Create a ChangeNotifier class and a simple UI to toggle it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. Create the ChangeNotifier\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  ThemeMode get themeMode => _themeMode;\n\n  void toggleTheme(bool isDark) {\n    _themeMode = isDark ? ThemeMode.dark : ThemeMode.light;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 2. Consume the provider for MaterialApp theme\n    final themeProvider = Provider.of<ThemeProvider>(context);\n    \n    return MaterialApp(\n      theme: ThemeData.light(),\n      darkTheme: ThemeData.dark(),\n      themeMode: themeProvider.themeMode,\n      home: const SettingsScreen(),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final themeProvider = Provider.of<ThemeProvider>(context);\n    final isDark = themeProvider.themeMode == ThemeMode.dark;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Theme Switcher')),\n      body: Center(\n        child: SwitchListTile(\n          title: const Text('Dark Mode'),\n          value: isDark,\n          onChanged: (val) => themeProvider.toggleTheme(val),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Fetch data asynchronously using Riverpod's FutureProvider and handle loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define async provider\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2)); // Simulate network\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the AsyncValue\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Async User Fetch')),\n      body: Center(\n        // 3. Handle states using .when\n        child: userAsync.when(\n          data: (data) => Text('User: $data', style: const TextStyle(fontSize: 24)),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a Bezier curve wave at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    \n    // Start at bottom left\n    path.moveTo(0, size.height);\n    // Move up slightly\n    path.lineTo(0, size.height * 0.8);\n\n    // Create a quadratic bezier curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height * 0.6, // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n\n    // Close the path\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a 'Shopping Cart' logic using the Provider package with `ChangeNotifier` to add and remove items from a list.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(String item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n}\n\nclass CartScreen extends StatelessWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Cart')),\n      body: Consumer<CartModel>(\n        builder: (context, cart, child) {\n          return ListView.builder(\n            itemCount: cart.items.length,\n            itemBuilder: (context, index) => ListTile(\n              title: Text(cart.items[index]),\n              trailing: IconButton(\n                icon: const Icon(Icons.delete),\n                onPressed: () => cart.remove(cart.items[index]),\n              ),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CartModel>().add('Item ${DateTime.now().second}'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a continuous stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  // 1. Define EventChannel\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _startListening();\n  }\n\n  void _startListening() {\n    // 2. Listen to the broadcast stream\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    // 3. Cancel subscription\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an argument (e.g., an ID) to fetch specific item details.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define Family Provider (accepts int id)\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return 'Details for Item #$id';\n});\n\nclass ItemDetailScreen extends ConsumerWidget {\n  final int itemId;\n  const ItemDetailScreen({super.key, required this.itemId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Pass the argument to the provider\n    final itemAsync = ref.watch(itemDetailProvider(itemId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Item Details')),\n      body: Center(\n        child: itemAsync.when(\n          data: (data) => Text(data),\n          loading: () => const CircularProgressIndicator(),\n          error: (e, s) => Text('Error: $e'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const double dashWidth = 5.0;\n    const double dashSpace = 5.0;\n    double startX = 0;\n    \n    // Draw dashes horizontally across the width\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using the 'Provider' package. Include the ChangeNotifier class and the UI widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: Consumer<CounterModel>(\n          builder: (context, counter, child) => FloatingActionButton(\n            onPressed: counter.increment,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a 'CustomPainter' that draws a red circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass RedCirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: Size(200, 200),\n      painter: RedCirclePainter(),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod 'StateNotifier' to manage a list of Todo strings, including adding and removing items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write a Flutter method that uses 'MethodChannel' to invoke a native platform method named 'getBatteryLevel'. Handle potential PlatformExceptions.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Create a Riverpod 'FutureProvider' that simulates fetching user data from an API and a widget that handles the loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a progress arc with a sweep gradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: -pi / 2,\n        endAngle: 3 * pi / 2,\n      ).createShader(rect);\n\n    canvas.drawArc(\n      rect,\n      -pi / 2,\n      2 * pi * progress,\n      false,\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Optimize a Provider implementation using 'Selector' to ensure a widget only rebuilds when a specific property ('name') of the model changes, ignoring other property changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Guest';\n  int age = 25;\n\n  void updateName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass NameDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Selector<UserModel, String>(\n      selector: (context, model) => model.name,\n      builder: (context, name, child) {\n        // This only rebuilds if 'name' changes, not 'age'\n        return Text('Name: $name');\n      },\n    );\n  }\n}"}
{"instruction": "Use Riverpod's '.family' modifier to create a provider that accepts an integer ID and returns a formatted string based on that ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal itemProvider = Provider.family<String, int>((ref, id) {\n  return 'Item ID: $id';\n});\n\n// Usage in a ConsumerWidget:\n// final title = ref.watch(itemProvider(42));"}
{"instruction": "Create a Dart class that invokes a native Android Toast message using MethodChannel.", "output": "import 'package:flutter/services.dart';\n\nclass ToastService {\n  static const platform = MethodChannel('com.example.app/toast');\n\n  Future<void> showToast(String message) async {\n    try {\n      await platform.invokeMethod('showToast', {'message': message});\n    } on PlatformException catch (e) {\n      print(\"Failed to show toast: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    double dashWidth = 5, dashSpace = 5;\n    double startX = 0;\n    final double endX = size.width;\n\n    while (startX < endX) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application using the `provider` package. The solution should include a `CounterModel` extending `ChangeNotifier` and a widget that consumes this provider to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) {\n            return Text(\n              '${counter.count}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter `CustomPainter` that draws a circular progress indicator with a background circle and a foreground arc representing the percentage complete.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass CircularProgressPainter extends CustomPainter {\n  final double percentage; // 0.0 to 1.0\n  final Color color;\n\n  CircularProgressPainter({required this.percentage, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n    final strokeWidth = 10.0;\n\n    // Background Circle\n    final bgPaint = Paint()\n      ..color = Colors.grey[300]!\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth;\n\n    canvas.drawCircle(center, radius, bgPaint);\n\n    // Foreground Arc\n    final fgPaint = Paint()\n      ..color = color\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = strokeWidth\n      ..strokeCap = StrokeCap.round;\n\n    final sweepAngle = 2 * pi * percentage;\n    // -pi / 2 to start from top\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2,\n      sweepAngle,\n      false,\n      fgPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant CircularProgressPainter oldDelegate) {\n    return oldDelegate.percentage != percentage;\n  }\n}"}
{"instruction": "Demonstrate how to use Riverpod's `FutureProvider` to fetch a string of data asynchronously and handle the loading, error, and data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create the FutureProvider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: DataScreen())));\n}\n\nclass DataScreen extends ConsumerWidget {\n  const DataScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the provider\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod FutureProvider')),\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 24)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err', style: const TextStyle(color: Colors.red)),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write a Dart method that uses `MethodChannel` to invoke a platform-specific method named 'getBatteryLevel'. Include error handling for `PlatformException`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}\n\n// Usage Example inside a Widget:\n// String _level = await BatteryService().getBatteryLevel();"}
{"instruction": "Create a Riverpod `StateNotifier` and `StateNotifierProvider` to manage a simple Todo list (List of Strings). Include methods to add and remove todos.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. The StateNotifier class\nclass TodoListNotifier extends StateNotifier<List<String>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. The Provider definition\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<String>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Implement a `CustomPainter` that draws a dashed line between two points.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n    final double endX = size.width;\n\n    while (startX < endX) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the `provider` package's `Selector` widget to optimize rebuilds. Create a `User` model with `name` and `age`, and a widget that only rebuilds when the `age` changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass User extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void birthday() {\n    age++;\n    notifyListeners();\n  }\n\n  void changeName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass AgeWidget extends StatelessWidget {\n  const AgeWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<User, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        print('Building AgeWidget'); // Only prints when age changes\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Demonstrate how to set up an `EventChannel` in Flutter to listen to a stream of events from the native platform (e.g., sensor data).", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  String _sensorData = 'No Data';\n\n  @override\n  void initState() {\n    super.initState();\n    _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(dynamic event) {\n    setState(() {\n      _sensorData = 'Sensor: $event';\n    });\n  }\n\n  void _onError(dynamic error) {\n    setState(() {\n      _sensorData = 'Error: $error';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(_sensorData);\n  }\n}"}
{"instruction": "Create a Riverpod provider using the `.family` modifier to fetch details for a specific item ID asynchronously.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Mock API call\nFuture<String> fetchItemDetails(int id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item #$id';\n}\n\n// Family provider accepting an int (id) argument\nfinal itemDetailProvider = FutureProvider.family<String, int>((ref, id) async {\n  return fetchItemDetails(id);\n});\n\n// Usage in Widget:\n// Widget build(BuildContext context, WidgetRef ref) {\n//   final itemAsync = ref.watch(itemDetailProvider(42));\n//   return itemAsync.when(...);\n// }"}
{"instruction": "Implement a `CustomPainter` that draws a polygon (e.g., a triangle) filled with a LinearGradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientTrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final path = Path();\n    // Define a triangle path\n    path.moveTo(size.width / 2, 0);\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.blue, Colors.purple],\n        begin: Alignment.topCenter,\n        end: Alignment.bottomCenter,\n      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple Counter application state using the Provider package. Include the ChangeNotifier class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Counter extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => Counter(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<Counter>(\n            builder: (context, counter, child) {\n              return Text('${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<Counter>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Riverpod StateNotifier to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Create a CustomPainter that draws a simple red filled circle in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width < size.height ? size.width / 4 : size.height / 4;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), child: Container())"}
{"instruction": "Write a Dart method using MethodChannel to invoke a platform-specific method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use Riverpod's FutureProvider to handle an asynchronous data fetch (e.g., fetching a username) and display loading, error, or data states in a Widget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserWidget extends ConsumerWidget {\n  const UserWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height,      // Control point y\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement the 'Selector' widget from the Provider package to optimize rebuilds by listening only to a specific property of a ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'Guest';\n  int age = 25;\n\n  void updateName(String newName) {\n    name = newName;\n    notifyListeners();\n  }\n}\n\nclass NameDisplay extends StatelessWidget {\n  const NameDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds if 'name' changes, ignores 'age' changes\n    return Selector<UserModel, String>(\n      selector: (_, model) => model.name,\n      builder: (_, name, __) {\n        return Text('User Name: $name');\n      },\n    );\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a continuous stream of events from the native platform (e.g., sensor data).", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _channel.receiveBroadcastStream().listen(\n      onData,\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Create a Riverpod provider using the 'family' modifier to pass an argument (userID) to the provider logic.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that accepts an integer ID and returns a string\nfinal userByIdProvider = FutureProvider.family<String, int>((ref, id) async {\n  // Simulate network request\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'User ID: $id';\n});\n\n// Usage in ConsumerWidget:\n// final userAsync = ref.watch(userByIdProvider(42));"}
{"instruction": "Use TextPainter within a CustomPainter to draw text directly onto the canvas at a specific coordinate.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    const textStyle = TextStyle(color: Colors.black, fontSize: 30);\n    const textSpan = TextSpan(text: 'Hello World', style: textStyle);\n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n\n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n\n    // Draw text at x: 10, y: 10\n    textPainter.paint(canvas, const Offset(10, 10));\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a basic counter state management system using the `provider` package. Create a `ChangeNotifier` class and a widget that consumes it.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) => Text('${counter.count}'),\n          ),\n        ),\n        floatingActionButton: Builder(\n          builder: (context) => FloatingActionButton(\n            onPressed: () => Provider.of<CounterModel>(context, listen: false).increment(),\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a filled blue circle with a red border stroke.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch configuration data asynchronously and display a loading spinner, error, or data based on the state.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'App Config Loaded';\n});\n\nclass ConfigView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final configAsync = ref.watch(configProvider);\n\n    return configAsync.when(\n      data: (data) => Text(data),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a native platform method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}';\n    }\n  }\n}"}
{"instruction": "Create a Riverpod `StateNotifier` to manage a list of Todo items (strings). Include methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement a `CustomPainter` to draw a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5, size.height * 1.0,\n      size.width, size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a `MultiProvider` at the root of a Flutter application to inject two separate change notifiers: `AuthService` and `ThemeService`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => ThemeService()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}\n\n// Mock Classes\nclass AuthService extends ChangeNotifier {}\nclass ThemeService extends ChangeNotifier {}"}
{"instruction": "Implement the Dart side of an `EventChannel` to listen to a stream of accelerometer data events from native code.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\n\nclass SensorStream {\n  static const EventChannel _channel = EventChannel('com.example.app/accelerometer');\n\n  Stream<List<double>> get accelerometerStream {\n    return _channel.receiveBroadcastStream().map((event) {\n      return (event as List).cast<double>();\n    });\n  }\n}"}
{"instruction": "Create a Riverpod provider using the `.family` modifier to fetch specific user details based on a User ID passed as an argument.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass User {\n  final int id;\n  final String name;\n  User(this.id, this.name);\n}\n\n// A provider that accepts an 'id' argument\nfinal userProvider = FutureProvider.family<User, int>((ref, id) async {\n  // Simulate network request\n  await Future.delayed(Duration(milliseconds: 500));\n  return User(id, 'User $id');\n});"}
{"instruction": "Create a `CustomPainter` that draws a circular progress arc with a linear gradient shader.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final gradient = LinearGradient(\n      colors: [Colors.blue, Colors.purple],\n    ).createShader(rect);\n\n    final paint = Paint()\n      ..shader = gradient\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round;\n\n    // Draw 75% of a circle\n    canvas.drawArc(rect, -pi / 2, 3 * pi / 2, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a basic counter application using the 'provider' package. Define a ChangeNotifier class for the counter and wrap the app with a ChangeNotifierProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Consumer<CounterModel>(\n            builder: (context, counter, child) {\n              return Text('Count: ${counter.count}');\n            },\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => context.read<CounterModel>().increment(),\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a CustomPainter that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use 'flutter_riverpod' to fetch user data asynchronously. Create a FutureProvider that returns a string and a ConsumerWidget to handle loading, error, and data states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a Flutter MethodChannel implementation in Dart to invoke a native platform method named 'getBatteryLevel'.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}"}
{"instruction": "Implement a CustomClipper<Path> to create a widget with a wave-like bottom edge.", "output": "import 'package:flutter/material.dart';\n\nclass WaveClipper extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    var path = Path();\n    path.lineTo(0, size.height - 50);\n    \n    var firstControlPoint = Offset(size.width / 4, size.height);\n    var firstEndPoint = Offset(size.width / 2, size.height - 50);\n    path.quadraticBezierTo(firstControlPoint.dx, firstControlPoint.dy,\n        firstEndPoint.dx, firstEndPoint.dy);\n\n    var secondControlPoint = Offset(size.width * 3 / 4, size.height - 100);\n    var secondEndPoint = Offset(size.width, size.height - 50);\n    path.quadraticBezierTo(secondControlPoint.dx, secondControlPoint.dy,\n        secondEndPoint.dx, secondEndPoint.dy);\n\n    path.lineTo(size.width, 0);\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}"}
{"instruction": "Using Riverpod, create a StateNotifier to manage a list of Todo items and a method to toggle their completion status.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [...state, Todo(id: DateTime.now().toString(), description: description)];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          todo.copyWith(completed: !todo.completed)\n        else\n          todo\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Create a CustomPainter that draws a progress bar with a linear gradient.", "output": "import 'package:flutter/material.dart';\n\nclass GradientProgressBarPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientProgressBarPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..style = PaintingStyle.fill;\n\n    // Draw background\n    paint.color = Colors.grey[300]!;\n    canvas.drawRect(Offset.zero & size, paint);\n\n    // Draw progress with gradient\n    final shader = const LinearGradient(\n      colors: [Colors.blue, Colors.purple],\n    ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));\n\n    paint.shader = shader;\n    canvas.drawRect(\n      Rect.fromLTWH(0, 0, size.width * progress, size.height),\n      paint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientProgressBarPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Set up an EventChannel in Dart to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      (event) {\n        onData(event);\n      },\n      onError: (error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use Provider's ProxyProvider to inject an 'AuthModel' dependency into a 'CartModel', allowing the cart to access the user's ID.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? userId = 'user_123';\n}\n\nclass CartModel extends ChangeNotifier {\n  final AuthModel _auth;\n  CartModel(this._auth);\n\n  void checkout() {\n    print('Checking out for user: ${_auth.userId}');\n  }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ChangeNotifierProxyProvider<AuthModel, CartModel>(\n          create: (context) => CartModel(context.read<AuthModel>()),\n          update: (context, auth, previousCart) => CartModel(auth),\n        ),\n      ],\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Create an animated widget using a CustomPainter. The widget should accept an AnimationController and draw a pulsing circle that grows and fades based on the animation value.", "output": "import 'package:flutter/material.dart';\n\nclass PulsingCircle extends AnimatedWidget {\n  const PulsingCircle({super.key, required Animation<double> animation})\n      : super(listenable: animation);\n\n  @override\n  Widget build(BuildContext context) {\n    final animation = listenable as Animation<double>;\n    return CustomPaint(\n      painter: _PulsingPainter(animation.value),\n      size: const Size(100, 100),\n    );\n  }\n}\n\nclass _PulsingPainter extends CustomPainter {\n  final double value;\n  _PulsingPainter(this.value);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue.withOpacity(1.0 - value)\n      ..style = PaintingStyle.fill;\n    \n    final radius = (size.width / 2) * value;\n    canvas.drawCircle(size.center(Offset.zero), radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(_PulsingPainter oldDelegate) => true;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod with a `StateProvider` and a `ConsumerWidget`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app in ProviderScope\n    const ProviderScope(\n      child: MaterialApp(home: CounterPage()),\n    ),\n  );\n}\n\n// 3. Create a ConsumerWidget\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text('$count', style: const TextStyle(fontSize: 24)),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 5. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class named `CirclePainter` that draws a blue circle filled with color and a red border stroke.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw the fill\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw the border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // Return true if the painting depends on external state that changed\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' on the channel 'samples.flutter.dev/battery' inside a StatefulWidget.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryPage extends StatefulWidget {\n  const BatteryPage({super.key});\n\n  @override\n  State<BatteryPage> createState() => _BatteryPageState();\n}\n\nclass _BatteryPageState extends State<BatteryPage> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(_batteryLevel),\n          ElevatedButton(\n            onPressed: _getBatteryLevel,\n            child: const Text('Get Battery Level'),\n          ),\n        ],\n      ),\n    );\n  }\n}"}
{"instruction": "Demonstrate how to use the `Provider` package to manage a shopping cart using `ChangeNotifier` and `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 1. The Model\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 2. Inject the Provider\n    ChangeNotifierProvider(\n      create: (context) => CartModel(),\n      child: const MaterialApp(home: CartScreen()),\n    ),\n  );\n}\n\nclass CartScreen extends StatelessWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Cart Provider Example')),\n      body: Consumer<CartModel>(\n        builder: (context, cart, child) {\n          return ListView.builder(\n            itemCount: cart.items.length,\n            itemBuilder: (context, index) => ListTile(title: Text(cart.items[index])),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 3. Access provider to change state\n          Provider.of<CartModel>(context, listen: false).add('Item ${DateTime.now().second}');\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch data asynchronously and handle Loading, Error, and Data states in the UI.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define async provider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data from API';\n});\n\nclass AsyncPage extends ConsumerWidget {\n  const AsyncPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 2. Watch the async value\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 20)),\n          error: (err, stack) => Text('Error: $err'),\n          loading: () => const CircularProgressIndicator(),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..style = PaintingStyle.stroke;\n\n    const dashWidth = 5.0;\n    const dashSpace = 5.0;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, 0),\n        Offset(startX + dashWidth, 0),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use the `.family` modifier in Riverpod to create a provider that accepts an argument (e.g., an ID) to fetch specific item details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// A provider that takes an integer ID and returns a string\nfinal itemFamilyProvider = FutureProvider.family<String, int>((ref, id) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return 'Details for Item ID: $id';\n});\n\n// Usage in Widget:\n// ref.watch(itemFamilyProvider(42)).when(...);"}
{"instruction": "Implement the Dart side of an `EventChannel` to listen to a stream of events from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamPage extends StatefulWidget {\n  const SensorStreamPage({super.key});\n\n  @override\n  State<SensorStreamPage> createState() => _SensorStreamPageState();\n}\n\nclass _SensorStreamPageState extends State<SensorStreamPage> {\n  static const EventChannel _eventChannel = EventChannel('events/sensor');\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    // Listen to the stream\n    _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(Object? event) {\n    setState(() {\n      _sensorData = \"Sensor: $event\";\n    });\n  }\n\n  void _onError(Object error) {\n    setState(() {\n      _sensorData = \"Error: $error\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Implement a Todo list using Riverpod's `StateNotifier` and `StateNotifierProvider` to manage an immutable list of strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. StateNotifier class\nclass TodoNotifier extends StateNotifier<List<String>> {\n  TodoNotifier() : super([]);\n\n  void addTodo(String todo) {\n    state = [...state, todo];\n  }\n\n  void removeTodo(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\n// 2. StateNotifierProvider\nfinal todoProvider = StateNotifierProvider<TodoNotifier, List<String>>((ref) {\n  return TodoNotifier();\n});\n\n// Usage in UI:\n// final todos = ref.watch(todoProvider);\n// ref.read(todoProvider.notifier).addTodo('New Task');"}
{"instruction": "Create a `CustomPainter` that fills the canvas with a linear gradient from the top-left to the bottom-right corner.", "output": "import 'package:flutter/material.dart';\n\nclass GradientPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n        colors: [\n          Colors.purple,\n          Colors.blue,\n        ],\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Riverpod. Define a global `StateProvider` for the counter and a `ConsumerWidget` that displays the count and increments it via a FloatingActionButton.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Define the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap app in ProviderScope\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: CounterPage());\n  }\n}\n\n// 3. Create a ConsumerWidget\nclass CounterPage extends ConsumerWidget {\n  const CounterPage({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 4. Watch the provider\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineMedium,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 5. Update the state\n          ref.read(counterProvider.notifier).state++;\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class named `CirclePainter` that draws a filled blue circle with a red stroke border in the center of the available space.", "output": "import 'package:flutter/material.dart';\n\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw filled blue circle\n    final fillPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n    \n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw red border\n    final borderPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return false; // Static shape, no repaint needed\n  }\n}"}
{"instruction": "Write a Dart function that uses `MethodChannel` to invoke a native platform method named 'getBatteryLevel'. Include error handling for `PlatformException`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  // Define the channel name matching the native side\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Use the `provider` package to manage a Todo list. Create a `TodoNotifier` extending `ChangeNotifier` with methods to add and remove items, and show how to provide it to the app.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoNotifier extends ChangeNotifier {\n  final List<String> _todos = [];\n\n  List<String> get todos => List.unmodifiable(_todos);\n\n  void addTodo(String task) {\n    _todos.add(task);\n    notifyListeners();\n  }\n\n  void removeTodo(int index) {\n    _todos.removeAt(index);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => TodoNotifier(),\n      child: const MaterialApp(home: TodoListScreen()),\n    ),\n  );\n}\n\nclass TodoListScreen extends StatelessWidget {\n  const TodoListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Consumer<TodoNotifier>(\n        builder: (context, notifier, child) {\n          return ListView.builder(\n            itemCount: notifier.todos.length,\n            itemBuilder: (context, index) => ListTile(\n              title: Text(notifier.todos[index]),\n              onLongPress: () => notifier.removeTodo(index),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<TodoNotifier>().addTodo('New Task'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a Riverpod `FutureProvider` that simulates a network request returning a String. Then, build a widget that uses `.when` to handle data, loading, and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Define the FutureProvider\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Fetched Data Successfully';\n});\n\nclass DataView extends ConsumerWidget {\n  const DataView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return Scaffold(\n      body: Center(\n        child: asyncValue.when(\n          data: (data) => Text(data, style: const TextStyle(fontSize: 20)),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic Bezier curve (a wave) at the bottom of a container.", "output": "import 'package:flutter/material.dart';\n\nclass WaveHeader extends StatelessWidget {\n  const WaveHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(double.infinity, 200),\n      painter: WavePainter(),\n    );\n  }\n}\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at top-left\n    path.moveTo(0, 0);\n    // Line to bottom-left (minus some height for the wave)\n    path.lineTo(0, size.height - 40);\n    \n    // Create a curve: control point, end point\n    path.quadraticBezierTo(\n      size.width / 2, // Control point X (middle)\n      size.height,    // Control point Y (bottom)\n      size.width,     // End point X (right)\n      size.height - 40 // End point Y\n    );\n\n    // Line to top-right\n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Riverpod `StateNotifier` and `StateNotifierProvider` to manage an immutable list of `CartItem` objects.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass CartItem {\n  final String id;\n  final String name;\n  CartItem(this.id, this.name);\n}\n\nclass CartNotifier extends StateNotifier<List<CartItem>> {\n  CartNotifier() : super([]);\n\n  void addItem(CartItem item) {\n    // State is immutable, return a new list\n    state = [...state, item];\n  }\n\n  void removeItem(String id) {\n    state = [    for (final item in state)\n      if (item.id != id) item,\n    ];\n  }\n}\n\nfinal cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) {\n  return CartNotifier();\n});"}
{"instruction": "Set up a Flutter `EventChannel` to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorService {\n  static const EventChannel _eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _subscription;\n\n  void startListening(Function(dynamic) onData) {\n    _subscription = _eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        // Handle incoming event from native side\n        onData(event);\n      },\n      onError: (dynamic error) {\n        print('Received error: ${error.message}');\n      },\n    );\n  }\n\n  void stopListening() {\n    _subscription?.cancel();\n  }\n}"}
{"instruction": "Use `ProxyProvider` from the `provider` package to inject an `AuthModel` into a `DatabaseService`, ensuring the database updates when the user changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel extends ChangeNotifier {\n  String? userId;\n  // ... auth logic\n}\n\nclass DatabaseService {\n  final String? userId;\n  DatabaseService(this.userId);\n  \n  void getData() { \n    print('Getting data for $userId'); \n  }\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, DatabaseService>(\n          update: (context, auth, previousDb) => \n            DatabaseService(auth.userId),\n        ),\n      ],\n      child: const MaterialApp(home: MyApp()),\n    ),\n  );\n}"}
{"instruction": "Implement an animated `CustomPainter` that expands a circle's radius based on an `AnimationController` value. Pass the animation to the painter's super constructor to trigger repaints.", "output": "import 'package:flutter/material.dart';\n\nclass PulseAnimation extends StatefulWidget {\n  const PulseAnimation({super.key});\n\n  @override\n  State<PulseAnimation> createState() => _PulseAnimationState();\n}\n\nclass _PulseAnimationState extends State<PulseAnimation>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 2),\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: PulsePainter(animation: _controller),\n      size: const Size(200, 200),\n    );\n  }\n}\n\nclass PulsePainter extends CustomPainter {\n  final Animation<double> animation;\n\n  PulsePainter({required this.animation}) : super(repaint: animation);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    // Animate radius from 0 to width/2\n    final radius = (size.width / 2) * animation.value;\n\n    final paint = Paint()\n      ..color = Colors.orange.withOpacity(0.5)\n      ..style = PaintingStyle.fill;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant PulsePainter oldDelegate) => true;\n}"}
{"instruction": "Create a basic counter application using Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass CounterApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      appBar: AppBar(title: Text('Riverpod Counter')),\n      body: Center(child: Text('$count', style: TextStyle(fontSize: 24))),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write a Flutter method to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future<String> getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      return 'Failed to get battery level: ${e.message}.';\n    }\n  }\n}"}
{"instruction": "Create a `ChangeNotifier` class using the Provider package to manage a boolean theme state (Dark/Light mode).", "output": "import 'package:flutter/material.dart';\n\nclass ThemeProvider extends ChangeNotifier {\n  bool _isDarkMode = false;\n\n  bool get isDarkMode => _isDarkMode;\n\n  ThemeData get currentTheme => _isDarkMode ? ThemeData.dark() : ThemeData.light();\n\n  void toggleTheme() {\n    _isDarkMode = !_isDarkMode;\n    notifyListeners();\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to simulate fetching a user name asynchronously and display it using `.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n    return userAsync.when(\n      data: (name) => Text('User: $name'),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` to draw a dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Paint paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const double dashWidth = 5;\n    const double dashSpace = 5;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(Offset(startX, 0), Offset(startX + dashWidth, 0), paint);\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a `StateNotifier` and `StateNotifierProvider` in Riverpod to manage a list of Todo strings.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String todo) {\n    state = [...state, todo];\n  }\n\n  void remove(String todo) {\n    state = state.where((item) => item != todo).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write a `CustomPainter` that draws a gradient arc (like a progress bar).", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, -pi / 2, 2 * pi * progress, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) => oldDelegate.progress != progress;\n}"}
{"instruction": "Setup the Android-side Kotlin code to handle a Flutter MethodChannel call named 'showToast'.", "output": "import android.widget.Toast\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity: FlutterActivity() {\n    private val CHANNEL = \"com.example.app/toast\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            if (call.method == \"showToast\") {\n                val message = call.argument<String>(\"message\")\n                Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\n                result.success(null)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n}"}
{"instruction": "Use the Provider package's `Selector` to rebuild a widget only when a specific property of a model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel with ChangeNotifier {\n  String name = 'Guest';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'age' changes, ignores 'name' changes\n    return Selector<UserModel, int>(\n      selector: (_, model) => model.age,\n      builder: (_, age, __) => Text('Age: $age'),\n    );\n  }\n}"}
{"instruction": "Create a simple counter application using Riverpod's `StateProvider`. Include the necessary `ProviderScope` and a `ConsumerWidget` to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Scaffold(\n      body: Center(child: Text('Count: $count')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class that draws a red circle with a blue border (stroke) in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw Fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw Border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`. Handle potential `PlatformException`s.", "output": "import 'package:flutter/services.dart';\n\nclass BatteryService {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n\n  Future<String> getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n    return batteryLevel;\n  }\n}"}
{"instruction": "Implement a `ChangeNotifier` class for a Shopping Cart and wrap the app with `ChangeNotifierProvider` using the `provider` package.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CartModel extends ChangeNotifier {\n  final List<String> _items = [];\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CartModel(),\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to fetch a configuration string from a simulated API and display the result using `AsyncValue.when`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal configProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Host: localhost, Port: 8080';\n});\n\nclass ConfigView extends ConsumerWidget {\n  const ConfigView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final config = ref.watch(configProvider);\n\n    return config.when(\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n      data: (data) => Text('Config: $data'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a simple wave) across the bottom of the container.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height,      // Control point y\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a Todo list manager using Riverpod's `StateNotifier` and `StateNotifierProvider`. Ensure state immutability.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(id: todo.id, description: todo.description, completed: !todo.completed)\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Implement a Flutter widget that listens to a continuous stream of events (e.g., sensor data) from native code using `EventChannel`.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorListener extends StatefulWidget {\n  const SensorListener({super.key});\n  @override\n  State<SensorListener> createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  static const eventChannel = EventChannel('samples.flutter.dev/sensors');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen((event) {\n      setState(() => _sensorData = event.toString());\n    });\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => Text(_sensorData);\n}"}
{"instruction": "Create a `CustomPainter` that fills a rectangle with a Linear Gradient shader.", "output": "import 'package:flutter/material.dart';\n\nclass GradientBoxPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    final paint = Paint()\n      ..shader = const LinearGradient(\n        colors: [Colors.orange, Colors.purple],\n        begin: Alignment.topLeft,\n        end: Alignment.bottomRight,\n      ).createShader(rect);\n\n    canvas.drawRect(rect, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate how to use `ProxyProvider` from the `provider` package to inject a value from an `AuthProvider` into a `DatabaseProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthModel { final String userId = '123'; }\n\nclass DatabaseModel {\n  final String userId;\n  DatabaseModel(this.userId);\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        Provider<AuthModel>(create: (_) => AuthModel()),\n        ProxyProvider<AuthModel, DatabaseModel>(\n          update: (_, auth, __) => DatabaseModel(auth.userId),\n        ),\n      ],\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod with a StateProvider.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('$count', style: const TextStyle(fontSize: 24))),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a CustomPainter that draws a yellow circle with a blue border.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    final fillPaint = Paint()\n      ..color = Colors.yellow\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage: CustomPaint(painter: CirclePainter(), size: Size(200, 200))"}
{"instruction": "Implement a MethodChannel in a Flutter widget to retrieve the platform version from native code.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass PlatformChannelWidget extends StatefulWidget {\n  const PlatformChannelWidget({super.key});\n\n  @override\n  State<PlatformChannelWidget> createState() => _PlatformChannelWidgetState();\n}\n\nclass _PlatformChannelWidgetState extends State<PlatformChannelWidget> {\n  static const platform = MethodChannel('com.example/platform_info');\n  String _platformVersion = 'Unknown';\n\n  Future<void> _getPlatformVersion() async {\n    String version;\n    try {\n      version = await platform.invokeMethod('getPlatformVersion');\n    } on PlatformException catch (e) {\n      version = \"Failed to get version: '${e.message}'.\";\n    }\n    setState(() {\n      _platformVersion = version;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_platformVersion),\n        ElevatedButton(onPressed: _getPlatformVersion, child: const Text('Get Version')),\n      ],\n    );\n  }\n}"}
{"instruction": "Implement a Theme Switcher using the Provider package and ChangeNotifier.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeNotifier extends ChangeNotifier {\n  bool _isDark = false;\n  bool get isDark => _isDark;\n\n  void toggleTheme() {\n    _isDark = !_isDark;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeNotifier(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeNotifier>(\n      builder: (context, themeNotifier, child) {\n        return MaterialApp(\n          theme: themeNotifier.isDark ? ThemeData.dark() : ThemeData.light(),\n          home: Scaffold(\n            body: Center(\n              child: Switch(\n                value: themeNotifier.isDark,\n                onChanged: (val) => themeNotifier.toggleTheme(),\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}"}
{"instruction": "Fetch and display a user's name asynchronously using Riverpod's FutureProvider and handle loading/error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulate API call\nFuture<String> fetchUser() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n}\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  return await fetchUser();\n});\n\nclass UserWidget extends ConsumerWidget {\n  const UserWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return userAsyncValue.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Write a CustomPainter to draw a horizontal dashed line.", "output": "import 'package:flutter/material.dart';\n\nclass DashedLinePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.black\n      ..strokeWidth = 2\n      ..strokeCap = StrokeCap.round;\n\n    const dashWidth = 5.0;\n    const dashSpace = 5.0;\n    double startX = 0;\n\n    while (startX < size.width) {\n      canvas.drawLine(\n        Offset(startX, size.height / 2),\n        Offset(startX + dashWidth, size.height / 2),\n        paint,\n      );\n      startX += dashWidth + dashSpace;\n    }\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Use Riverpod's .family modifier to pass an ID to a provider to fetch specific item details.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Provider that accepts an integer ID and returns a String\nfinal itemFamilyProvider = Provider.family<String, int>((ref, id) {\n  return 'Item $id Details';\n});\n\n// Usage in Widget:\n// final itemDetails = ref.watch(itemFamilyProvider(42));"}
{"instruction": "Set up an EventChannel to listen to a stream of events (e.g., sensor data) from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('com.example/sensors');\n  StreamSubscription? _subscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() => _sensorData = 'Sensor: $event');\n      },\n      onError: (dynamic error) {\n        setState(() => _sensorData = 'Error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => Text(_sensorData);\n}"}
{"instruction": "Draw a quadratic bezier curve (wave shape) using CustomPainter.", "output": "import 'package:flutter/material.dart';\n\nclass CurvePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.blueAccent\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 3;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.5);\n    \n    // Control point (x,y) and End point (x,y)\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point X\n      size.height * 0.2, // Control point Y (pulls curve up)\n      size.width,       // End point X\n      size.height * 0.5 // End point Y\n    );\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Optimize rebuilds using the Selector widget from the Provider package to listen to only a specific property of a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel extends ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'age' changes, ignores changes to 'name'\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Create a simple Counter app using Riverpod's `StateProvider` and a `ConsumerWidget` to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// 1. Create the provider\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(\n    // 2. Wrap the app in ProviderScope\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 3. Watch the provider state\n    final int count = ref.watch(counterProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(\n          child: Text('Count: $count', style: const TextStyle(fontSize: 24)),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () {\n            // 4. Update the state\n            ref.read(counterProvider.notifier).state++;\n          },\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 3;\n\n    // Draw the fill\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n    canvas.drawCircle(center, radius, fillPaint);\n\n    // Draw the border\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage widget\nclass MyCircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Set up a user profile state management class using the `Provider` package with `ChangeNotifier`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserProfile extends ChangeNotifier {\n  String _username = 'Guest';\n  int _age = 0;\n\n  String get username => _username;\n  int get age => _age;\n\n  void updateUser(String name, int age) {\n    _username = name;\n    _age = age;\n    notifyListeners();\n  }\n}\n\n// Usage in main\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => UserProfile(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Consumer<UserProfile>(\n          builder: (context, user, child) {\n            return Text('User: ${user.username}, Age: ${user.age}');\n          },\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform-specific method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelFetcher extends StatefulWidget {\n  @override\n  _BatteryLevelFetcherState createState() => _BatteryLevelFetcherState();\n}\n\nclass _BatteryLevelFetcherState extends State<BatteryLevelFetcher> {\n  // 1. Define the channel name\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      // 2. Invoke the method\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `FutureProvider` to handle asynchronous data fetching with loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Simulated API call\nFuture<String> fetchConfig() async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Dark Mode Enabled';\n}\n\n// Define FutureProvider\nfinal configProvider = FutureProvider<String>((ref) async {\n  return fetchConfig();\n});\n\nclass ConfigView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the AsyncValue\n    final AsyncValue<String> config = ref.watch(configProvider);\n\n    return config.when(\n      data: (data) => Text('Config: $data'),\n      error: (err, stack) => Text('Error: $err'),\n      loading: () => const CircularProgressIndicator(),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a wave shape at the bottom of a container using `Path` and `quadraticBezierTo`.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    // Start at top-left\n    path.moveTo(0, 0);\n    // Line to bottom-left (start of wave)\n    path.lineTo(0, size.height * 0.8);\n    \n    // Create a curve\n    path.quadraticBezierTo(\n      size.width * 0.5, // Control point x\n      size.height,      // Control point y (peak of wave)\n      size.width,       // End point x\n      size.height * 0.8 // End point y\n    );\n    \n    // Line to top-right\n    path.lineTo(size.width, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement a Todo List manager using Riverpod's `StateNotifier` and `StateNotifierProvider`.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoListNotifier extends StateNotifier<List<Todo>> {\n  TodoListNotifier() : super([]);\n\n  void addTodo(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {\n  return TodoListNotifier();\n});"}
{"instruction": "Configure `MultiProvider` from the Provider package to inject an Auth service and a Theme notifier at the root of the app.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass AuthService with ChangeNotifier { /* ... */ }\nclass ThemeNotifier with ChangeNotifier { /* ... */ }\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthService()),\n        ChangeNotifierProvider(create: (_) => ThemeNotifier()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: Center(child: Text('MultiProvider Setup'))),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a circular progress indicator with a sweep gradient.", "output": "import 'package:flutter/material.dart';\nimport 'dart:math';\n\nclass GradientArcPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  GradientArcPainter({required this.progress});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final startAngle = -pi / 2;\n    final sweepAngle = 2 * pi * progress;\n\n    final paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..shader = const SweepGradient(\n        colors: [Colors.blue, Colors.purple],\n        startAngle: 0.0,\n        endAngle: 2 * pi,\n      ).createShader(rect);\n\n    canvas.drawArc(rect, startAngle, sweepAngle, false, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant GradientArcPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Set up an `EventChannel` in Dart to listen to a continuous stream of events (e.g., sensor data) from native code.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'dart:async';\n\nclass SensorListener extends StatefulWidget {\n  @override\n  _SensorListenerState createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  static const eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableSensorListening();\n  }\n\n  void _enableSensorListening() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() {\n          _sensorData = 'Sensor: $event';\n        });\n      },\n      onError: (dynamic error) {\n        setState(() {\n          _sensorData = 'Error: ${error.message}';\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Implement a simple counter application using Flutter Riverpod's `StateProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('$count', style: const TextStyle(fontSize: 24))),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Create a custom widget that draws a filled blue circle in the center of the screen using `CustomPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    canvas.drawCircle(size.center(Offset.zero), 50.0, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\nclass CircleWidget extends StatelessWidget {\n  const CircleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: CirclePainter(),\n      child: const SizedBox(width: 200, height: 200),\n    );\n  }\n}"}
{"instruction": "Use the `provider` package to create a `ThemeChanger` class that toggles between light and dark modes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeChanger with ChangeNotifier {\n  ThemeData _themeData;\n\n  ThemeChanger(this._themeData);\n\n  get getTheme => _themeData;\n\n  void setTheme(ThemeData theme) {\n    _themeData = theme;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeChanger(ThemeData.light()),\n      child: const MaterialAppWithTheme(),\n    ),\n  );\n}\n\nclass MaterialAppWithTheme extends StatelessWidget {\n  const MaterialAppWithTheme({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = Provider.of<ThemeChanger>(context);\n    return MaterialApp(\n      theme: theme.getTheme,\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => theme.setTheme(ThemeData.dark()),\n            child: const Text('Switch to Dark'),\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Write the Dart code to invoke a platform channel method named 'getBatteryLevel' using `MethodChannel`.", "output": "import 'package:flutter/services.dart';\nimport 'package:flutter/material.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Fetch and display a string asynchronously using Riverpod's `FutureProvider` handling loading and error states.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal dataProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'Data Loaded';\n});\n\nclass AsyncWidget extends ConsumerWidget {\n  const AsyncWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(dataProvider);\n\n    return asyncValue.when(\n      data: (data) => Text(data),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Draw a red triangle using `CustomPainter` and the `Path` class.", "output": "import 'package:flutter/material.dart';\n\nclass TrianglePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(size.width / 2, 0);\n    path.lineTo(size.width, size.height);\n    path.lineTo(0, size.height);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Manage a To-Do list state using `StateNotifier` and `StateNotifierProvider` in Riverpod.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass Todo {\n  final String id;\n  final String description;\n  final bool completed;\n  Todo({required this.id, required this.description, this.completed = false});\n}\n\nclass TodoList extends StateNotifier<List<Todo>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [\n      ...state,\n      Todo(id: DateTime.now().toString(), description: description),\n    ];\n  }\n\n  void toggle(String id) {\n    state = [\n      for (final todo in state)\n        if (todo.id == id)\n          Todo(\n            id: todo.id,\n            description: todo.description,\n            completed: !todo.completed,\n          )\n        else\n          todo,\n    ];\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<Todo>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Optimize rebuilds in a Provider setup using `Selector` to listen only to a specific property of a model.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass UserModel with ChangeNotifier {\n  String name = 'John';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeWidget extends StatelessWidget {\n  const AgeWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only rebuilds when 'age' changes, ignores 'name' changes\n    return Selector<UserModel, int>(\n      selector: (context, user) => user.age,\n      builder: (context, age, child) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Send a map of arguments to native code using a MethodChannel to open a specific URL.", "output": "import 'package:flutter/services.dart';\n\nclass UrlLauncher {\n  static const platform = MethodChannel('com.example.app/browser');\n\n  Future<void> openUrl(String url) async {\n    try {\n      await platform.invokeMethod('openUrl', <String, dynamic>{\n        'url': url,\n        'forceWebView': true,\n      });\n    } on PlatformException catch (e) {\n      print(\"Failed to open URL: '${e.message}'.\");\n    }\n  }\n}"}
{"instruction": "Render custom text directly onto the canvas using `TextPainter` within a `CustomPainter`.", "output": "import 'package:flutter/material.dart';\n\nclass TextCustomPainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    const textStyle = TextStyle(\n      color: Colors.black,\n      fontSize: 30,\n    );\n    const textSpan = TextSpan(\n      text: 'Hello Canvas',\n      style: textStyle,\n    );\n    final textPainter = TextPainter(\n      text: textSpan,\n      textDirection: TextDirection.ltr,\n    );\n    \n    textPainter.layout(\n      minWidth: 0,\n      maxWidth: size.width,\n    );\n    \n    // Center the text\n    final xCenter = (size.width - textPainter.width) / 2;\n    final yCenter = (size.height - textPainter.height) / 2;\n    final offset = Offset(xCenter, yCenter);\n    \n    textPainter.paint(canvas, offset);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Create a simple counter application using Flutter Riverpod's `StateProvider`. Include the `ProviderScope` and a `ConsumerWidget` to display and increment the count.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Riverpod Counter')),\n        body: Center(child: Text('Count: $count')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a `CustomPainter` class named `CirclePainter` that draws a filled blue circle with a radius of 50 in the center of the available canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.fill;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    canvas.drawCircle(center, 50, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Set up a `MethodChannel` on the Flutter side to invoke a native platform method named 'getBatteryLevel'. Handle the result and potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  const BatteryLevelWidget({super.key});\n\n  @override\n  State<BatteryLevelWidget> createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('samples.flutter.dev/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: _getBatteryLevel, child: const Text('Get Battery Level')),\n        Text(_batteryLevel),\n      ],\n    );\n  }\n}"}
{"instruction": "Using the `provider` package, create a `ChangeNotifier` class called `TodoList` that manages a list of strings, and wrap the app in a `ChangeNotifierProvider`.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass TodoList extends ChangeNotifier {\n  final List<String> _items = [];\n\n  List<String> get items => _items;\n\n  void add(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void remove(String item) {\n    _items.remove(item);\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => TodoList(),\n      child: const MaterialApp(home: Scaffold()),\n    ),\n  );\n}"}
{"instruction": "Implement a Riverpod `FutureProvider` to simulate fetching user data, and use a `ConsumerWidget` to handle the `AsyncValue` states (data, loading, error).", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'John Doe';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return userAsync.when(\n      data: (data) => Text('User: $data'),\n      loading: () => const CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}"}
{"instruction": "Create a `CustomPainter` that draws a quadratic bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    var path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(size.width / 2, size.height, size.width, size.height * 0.8);\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Implement an `EventChannel` on the Flutter side to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorStreamWidget extends StatefulWidget {\n  const SensorStreamWidget({super.key});\n\n  @override\n  State<SensorStreamWidget> createState() => _SensorStreamWidgetState();\n}\n\nclass _SensorStreamWidgetState extends State<SensorStreamWidget> {\n  static const eventChannel = EventChannel('samples.flutter.dev/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\n  }\n\n  void _onEvent(Object? event) {\n    setState(() {\n      _sensorData = \"Sensor: $event\";\n    });\n  }\n\n  void _onError(Object error) {\n    setState(() {\n      _sensorData = \"Error: $error\";\n    });\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => Text(_sensorData);\n}"}
{"instruction": "Use the `Selector` widget from the `provider` package to rebuild a widget only when a specific property (`age`) of a `Person` model changes.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass Person extends ChangeNotifier {\n  String name = 'Alice';\n  int age = 25;\n\n  void incrementAge() {\n    age++;\n    notifyListeners();\n  }\n}\n\nclass AgeDisplay extends StatelessWidget {\n  const AgeDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Selector<Person, int>(\n      selector: (context, person) => person.age,\n      builder: (context, age, child) {\n        return Text('Age: $age');\n      },\n    );\n  }\n}"}
{"instruction": "Use Riverpod's `.family` modifier to create a provider that accepts an integer ID and returns a string message based on that ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal messageFamilyProvider = Provider.family<String, int>((ref, id) {\n  return 'Message for ID: $id';\n});\n\n// Usage in a ConsumerWidget:\n// final message = ref.watch(messageFamilyProvider(42));"}
{"instruction": "Create a `CustomPainter` to draw a circular progress bar with a stroke width, using `drawArc`.", "output": "import 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass ProgressPainter extends CustomPainter {\n  final double progress; // 0.0 to 1.0\n\n  ProgressPainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.grey[300]!\n      ..strokeWidth = 10\n      ..style = PaintingStyle.stroke;\n\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = min(size.width / 2, size.height / 2);\n\n    // Draw background circle\n    canvas.drawCircle(center, radius, paint);\n\n    // Draw progress arc\n    final progressPaint = Paint()\n      ..color = Colors.blue\n      ..strokeWidth = 10\n      ..strokeCap = StrokeCap.round\n      ..style = PaintingStyle.stroke;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius),\n      -pi / 2, // Start at top\n      2 * pi * progress,\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant ProgressPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}"}
{"instruction": "Create a simple Counter application using the Provider package for state management. Include the ChangeNotifier class and the widget tree setup.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass CounterModel extends ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (context) => CounterModel(),\n      child: const MaterialApp(home: CounterScreen()),\n    ),\n  );\n}\n\nclass CounterScreen extends StatelessWidget {\n  const CounterScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Counter')),\n      body: Center(\n        child: Consumer<CounterModel>(\n          builder: (context, counter, child) => Text(\n            'Count: ${counter.count}',\n            style: Theme.of(context).textTheme.headlineMedium,\n          ),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterModel>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter CustomPainter that draws a red circle with a blue border in the center of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass CirclePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 4;\n\n    final fillPaint = Paint()\n      ..color = Colors.red\n      ..style = PaintingStyle.fill;\n\n    final borderPaint = Paint()\n      ..color = Colors.blue\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 4.0;\n\n    canvas.drawCircle(center, radius, fillPaint);\n    canvas.drawCircle(center, radius, borderPaint);\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;\n}\n\n// Usage Widget\nclass CircleWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      size: const Size(200, 200),\n      painter: CirclePainter(),\n    );\n  }\n}"}
{"instruction": "Use Riverpod (flutter_riverpod) to create a 'FutureProvider' that simulates fetching a username asynchronously and displays the result using '.when' in a ConsumerWidget.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal userProvider = FutureProvider<String>((ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return 'FlutterDev';\n});\n\nclass UserProfile extends ConsumerWidget {\n  const UserProfile({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsyncValue = ref.watch(userProvider);\n\n    return Scaffold(\n      body: Center(\n        child: userAsyncValue.when(\n          data: (data) => Text('Hello, $data!'),\n          loading: () => const CircularProgressIndicator(),\n          error: (err, stack) => Text('Error: $err'),\n        ),\n      ),\n    );\n  }\n}"}
{"instruction": "Implement a Flutter MethodChannel to invoke a native platform method named 'getBatteryLevel' and handle potential PlatformExceptions.", "output": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass BatteryLevelWidget extends StatefulWidget {\n  @override\n  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();\n}\n\nclass _BatteryLevelWidgetState extends State<BatteryLevelWidget> {\n  static const platform = MethodChannel('com.example.app/battery');\n  String _batteryLevel = 'Unknown battery level.';\n\n  Future<void> _getBatteryLevel() async {\n    String batteryLevel;\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      batteryLevel = 'Battery level at $result % .';\n    } on PlatformException catch (e) {\n      batteryLevel = \"Failed to get battery level: '${e.message}'.\";\n    }\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(_batteryLevel),\n        ElevatedButton(\n          onPressed: _getBatteryLevel,\n          child: const Text('Get Battery Level'),\n        ),\n      ],\n    );\n  }\n}"}
{"instruction": "Create a Riverpod StateNotifier to manage a List of Strings (a simple Todo list) with methods to add and remove items.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoList extends StateNotifier<List<String>> {\n  TodoList() : super([]);\n\n  void add(String description) {\n    state = [...state, description];\n  }\n\n  void remove(String description) {\n    state = state.where((item) => item != description).toList();\n  }\n}\n\nfinal todoListProvider = StateNotifierProvider<TodoList, List<String>>((ref) {\n  return TodoList();\n});"}
{"instruction": "Write a CustomPainter that draws a quadratic Bezier curve (a wave shape) at the bottom of the canvas.", "output": "import 'package:flutter/material.dart';\n\nclass WavePainter extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.teal\n      ..style = PaintingStyle.fill;\n\n    final path = Path();\n    path.moveTo(0, size.height * 0.8);\n    path.quadraticBezierTo(\n      size.width * 0.5,\n      size.height * 1.0,\n      size.width,\n      size.height * 0.8,\n    );\n    path.lineTo(size.width, 0);\n    path.lineTo(0, 0);\n    path.close();\n\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}"}
{"instruction": "Demonstrate how to use 'MultiProvider' to provide two different ChangeNotifiers (ThemeModel and AuthModel) to the widget tree.", "output": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass ThemeModel extends ChangeNotifier { /* ... */ }\nclass AuthModel extends ChangeNotifier { /* ... */ }\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n        ChangeNotifierProvider(create: (_) => AuthModel()),\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: Scaffold());\n  }\n}"}
{"instruction": "Create a Flutter EventChannel to listen to a stream of events (e.g., sensor data) sent from the native platform.", "output": "import 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nclass SensorListener extends StatefulWidget {\n  @override\n  _SensorListenerState createState() => _SensorListenerState();\n}\n\nclass _SensorListenerState extends State<SensorListener> {\n  static const EventChannel eventChannel = EventChannel('com.example.app/sensor');\n  StreamSubscription? _streamSubscription;\n  String _sensorData = 'No data';\n\n  @override\n  void initState() {\n    super.initState();\n    _enableListening();\n  }\n\n  void _enableListening() {\n    _streamSubscription = eventChannel.receiveBroadcastStream().listen(\n      (dynamic event) {\n        setState(() => _sensorData = event.toString());\n      },\n      onError: (dynamic error) {\n        setState(() => _sensorData = 'Error: ${error.message}');\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    _streamSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(_sensorData));\n  }\n}"}
{"instruction": "Implement a Riverpod 'family' provider that accepts an integer ID and returns a string dynamically based on that ID.", "output": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// A provider that takes an argument (id)\nfinal itemProvider = Provider.family<String, int>((ref, id) {\n  return 'Item $id';\n});\n\nclass ItemDetail extends ConsumerWidget {\n  final int itemId;\n  const ItemDetail({required this.itemId, Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final itemTitle = ref.watch(itemProvider(itemId));\n    return Text(itemTitle);\n  }\n}"}
{"instruction": "Create a CustomPainter that integrates with an AnimationController to draw a growing circle.", "output": "import 'package:flutter/material.dart';\n\nclass AnimatedCirclePainter extends CustomPainter {\n  final double progress;\n\n  AnimatedCirclePainter(this.progress);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()..color = Colors.purple;\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = (size.width / 2) * progress;\n\n    canvas.drawCircle(center, radius, paint);\n  }\n\n  @override\n  bool shouldRepaint(covariant AnimatedCirclePainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}\n\nclass GrowingCircle extends StatefulWidget {\n  @override\n  _GrowingCircleState createState() => _GrowingCircleState();\n}\n\nclass _GrowingCircleState extends State<GrowingCircle>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(seconds: 2),\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      builder: (context, child) {\n        return CustomPaint(\n          size: const Size(200, 200),\n          painter: AnimatedCirclePainter(_controller.value),\n        );\n      },\n    );\n  }\n}"}
