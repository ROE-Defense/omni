{"instruction": "Create a SwiftUI View that utilizes the `LocalAuthentication` framework to authenticate a user via FaceID or TouchID before revealing sensitive content.", "output": "import SwiftUI\nimport LocalAuthentication\n\nstruct BiometricView: View {\n    @State private var isUnlocked = false\n\n    var body: some View {\n        VStack {\n            if isUnlocked {\n                Text(\"Sensitive Data Revealed\")\n                    .font(.title)\n                    .foregroundColor(.green)\n            } else {\n                Text(\"Locked\")\n                Button(\"Authenticate\") {\n                    authenticate()\n                }\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n            }\n        }\n    }\n\n    func authenticate() {\n        let context = LAContext()\n        var error: NSError?\n\n        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n            let reason = \"Please authenticate to unlock data.\"\n\n            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n                DispatchQueue.main.async {\n                    if success {\n                        self.isUnlocked = true\n                    } else {\n                        // Handle authentication failure\n                        print(\"Authentication failed\")\n                    }\n                }\n            }\n        } else {\n            // Biometrics not available\n            print(\"Biometrics not available\")\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI `UIViewControllerRepresentable` to wrap a native `AVCaptureVideoPreviewLayer` for a custom camera view.", "output": "import SwiftUI\nimport AVFoundation\nimport UIKit\n\nstruct CameraPreview: UIViewControllerRepresentable {\n    \n    class CameraViewController: UIViewController {\n        var captureSession: AVCaptureSession?\n        var previewLayer: AVCaptureVideoPreviewLayer?\n\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            setupCamera()\n        }\n\n        func setupCamera() {\n            let session = AVCaptureSession()\n            guard let device = AVCaptureDevice.default(for: .video),\n                  let input = try? AVCaptureDeviceInput(device: device) else { return }\n            \n            if session.canAddInput(input) {\n                session.addInput(input)\n            }\n            \n            previewLayer = AVCaptureVideoPreviewLayer(session: session)\n            previewLayer?.videoGravity = .resizeAspectFill\n            previewLayer?.frame = view.layer.bounds\n            \n            if let layer = previewLayer {\n                view.layer.addSublayer(layer)\n            }\n            \n            DispatchQueue.global(qos: .background).async {\n                session.startRunning()\n            }\n            self.captureSession = session\n        }\n        \n        override func viewDidLayoutSubviews() {\n            super.viewDidLayoutSubviews()\n            previewLayer?.frame = view.bounds\n        }\n    }\n\n    func makeUIViewController(context: Context) -> CameraViewController {\n        return CameraViewController()\n    }\n\n    func updateUIViewController(_ uiViewController: CameraViewController, context: Context) {}\n}"}
{"instruction": "Write a Swift function to trigger a heavy impact haptic feedback using `UIImpactFeedbackGenerator`.", "output": "import UIKit\n\nfunc triggerHeavyHaptic() {\n    let generator = UIImpactFeedbackGenerator(style: .heavy)\n    generator.prepare()\n    generator.impactOccurred()\n}"}
{"instruction": "Use CoreMotion in Swift to query the pedometer for the number of steps taken in the last 24 hours.", "output": "import CoreMotion\n\nclass PedometerManager {\n    private let pedometer = CMPedometer()\n\n    func getStepsForLast24Hours(completion: @escaping (Int?, Error?) -> Void) {\n        guard CMPedometer.isStepCountingAvailable() else {\n            completion(nil, NSError(domain: \"Pedometer\", code: 1, userInfo: [NSLocalizedDescriptionKey: \"Step counting unavailable\"]))\n            return\n        }\n\n        let now = Date()\n        let yesterday = Calendar.current.date(byAdding: .hour, value: -24, to: now)!\n\n        pedometer.queryPedometerData(from: yesterday, to: now) { data, error in\n            if let error = error {\n                completion(nil, error)\n            } else if let data = data {\n                completion(data.numberOfSteps.intValue, nil)\n            }\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that displays the current magnetic heading (compass) using CoreLocation.", "output": "import SwiftUI\nimport CoreLocation\nimport Combine\n\nclass CompassManager: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    @Published var heading: Double = 0\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingHeading()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {\n        self.heading = newHeading.magneticHeading\n    }\n}\n\nstruct CompassView: View {\n    @StateObject private var compass = CompassManager()\n\n    var body: some View {\n        VStack {\n            Text(\"Heading\")\n                .font(.headline)\n            Text(\"\\(Int(compass.heading))\u00b0\")\n                .font(.largeTitle)\n                .fontWeight(.bold)\n            \n            Image(systemName: \"arrow.up\")\n                .resizable()\n                .scaledToFit()\n                .frame(width: 100, height: 100)\n                .rotationEffect(Angle(degrees: -compass.heading))\n                .animation(.easeInOut, value: compass.heading)\n        }\n    }\n}"}
{"instruction": "Write a SwiftUI function to authenticate a user using FaceID or TouchID (LocalAuthentication).", "output": "import LocalAuthentication\nimport SwiftUI\n\nfunc authenticateUser(completion: @escaping (Bool) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if biometric authentication is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true)\n                } else {\n                    // Failed to authenticate\n                    completion(false)\n                }\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false)\n    }\n}"}
{"instruction": "Create a SwiftUI wrapper for a native UIKit Camera View Controller using UIViewControllerRepresentable.", "output": "import SwiftUI\nimport UIKit\n\nstruct CameraView: UIViewControllerRepresentable {\n    @Binding var image: UIImage?\n    @Environment(\\.presentationMode) var presentationMode\n\n    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {\n        let parent: CameraView\n\n        init(parent: CameraView) {\n            self.parent = parent\n        }\n\n        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {\n            if let uiImage = info[.originalImage] as? UIImage {\n                parent.image = uiImage\n            }\n            parent.presentationMode.wrappedValue.dismiss()\n        }\n    }\n\n    func makeCoordinator() -> Coordinator {\n        Coordinator(parent: self)\n    }\n\n    func makeUIViewController(context: Context) -> UIImagePickerController {\n        let picker = UIImagePickerController()\n        picker.delegate = context.coordinator\n        picker.sourceType = .camera\n        return picker\n    }\n\n    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}\n}"}
{"instruction": "Implement a SwiftUI view that triggers haptic feedback using UIImpactFeedbackGenerator.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            // Trigger Haptic Feedback\n            let generator = UIImpactFeedbackGenerator(style: .medium)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Tap for Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI ObservableObject that monitors the device's accelerometer using CoreMotion to detect tilt.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager: CMMotionManager\n    @Published var x: Double = 0.0\n    @Published var y: Double = 0.0\n    @Published var z: Double = 0.0\n\n    init() {\n        self.motionManager = CMMotionManager()\n        self.motionManager.accelerometerUpdateInterval = 0.1\n        startAccelerometers()\n    }\n\n    private func startAccelerometers() {\n        if self.motionManager.isAccelerometerAvailable {\n            self.motionManager.startAccelerometerUpdates(to: .main) { (data, error) in\n                guard let data = data else { return }\n                self.x = data.acceleration.x\n                self.y = data.acceleration.y\n                self.z = data.acceleration.z\n            }\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI `UIViewRepresentable` to display a native UIKit `WKWebView`.", "output": "import SwiftUI\nimport WebKit\n\nstruct WebView: UIViewRepresentable {\n    let url: URL\n\n    func makeUIView(context: Context) -> WKWebView {\n        return WKWebView()\n    }\n\n    func updateUIView(_ uiView: WKWebView, context: Context) {\n        let request = URLRequest(url: url)\n        uiView.load(request)\n    }\n}\n\n// Usage Example:\n// WebView(url: URL(string: \"https://www.apple.com\")!)"}
{"instruction": "Create a SwiftUI view that triggers Haptic Feedback (Impact) when a button is pressed.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let impactMed = UIImpactFeedbackGenerator(style: .medium)\n            impactMed.impactOccurred()\n        }) {\n            Text(\"Press for Haptics\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI View that displays the current value of the Proximity Sensor (detecting if the phone is held near the ear).", "output": "import SwiftUI\n\nstruct ProximityView: View {\n    @State private var isClose = false\n\n    var body: some View {\n        Text(isClose ? \"Near Ear\" : \"Far Away\")\n            .font(.largeTitle)\n            .onAppear {\n                UIDevice.current.isProximityMonitoringEnabled = true\n                NotificationCenter.default.addObserver(\n                    forName: UIDevice.proximityStateDidChangeNotification,\n                    object: nil,\n                    queue: .main\n                ) { _ in\n                    self.isClose = UIDevice.current.proximityState\n                }\n            }\n            .onDisappear {\n                UIDevice.current.isProximityMonitoringEnabled = false\n            }\n    }\n}"}
{"instruction": "Create a SwiftUI view that displays live accelerometer data (X, Y, Z) using CoreMotion.", "output": "import SwiftUI\nimport CoreMotion\n\nstruct AccelerometerView: View {\n    @State private var x = 0.0\n    @State private var y = 0.0\n    @State private var z = 0.0\n    let motionManager = CMMotionManager()\n\n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Accelerometer Data\")\n                .font(.headline)\n            Text(\"X: \\(x, specifier: \"%.2f\")\")\n            Text(\"Y: \\(y, specifier: \"%.2f\")\")\n            Text(\"Z: \\(z, specifier: \"%.2f\")\")\n        }\n        .onAppear {\n            startAccelerometers()\n        }\n        .onDisappear {\n            motionManager.stopAccelerometerUpdates()\n        }\n    }\n\n    func startAccelerometers() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { data, error in\n                guard let data = data else { return }\n                self.x = data.acceleration.x\n                self.y = data.acceleration.y\n                self.z = data.acceleration.z\n            }\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI function to play a complex haptic pattern (sharp tap followed by a rumble) using CoreHaptics.", "output": "import CoreHaptics\nimport SwiftUI\n\nclass HapticManager {\n    var engine: CHHapticEngine?\n\n    init() {\n        prepareHaptics()\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playComplexPattern() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n\n        var events = [CHHapticEvent]()\n\n        // Sharp tap\n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let tap = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n        events.append(tap)\n\n        // Rumble 0.1 seconds later\n        let rumbleIntensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.8)\n        let rumbleSharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.2)\n        let rumble = CHHapticEvent(eventType: .hapticContinuous, parameters: [rumbleIntensity, rumbleSharpness], relativeTime: 0.1, duration: 0.5)\n        events.append(rumble)\n\n        do {\n            let pattern = try CHHapticPattern(events: events, parameters: [])\n            let player = try engine?.makePlayer(with: pattern)\n            try player?.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "Build a SwiftUI view using ARKit (via UIViewRepresentable) that places a simple blue box 0.5 meters in front of the camera.", "output": "import SwiftUI\nimport RealityKit\n\nstruct ARBoxView: UIViewRepresentable {\n    func makeUIView(context: Context) -> ARView {\n        let arView = ARView(frame: .zero)\n\n        // Create a cube model\n        let mesh = MeshResource.generateBox(size: 0.1)\n        let material = SimpleMaterial(color: .blue, isMetallic: true)\n        let modelEntity = ModelEntity(mesh: mesh, materials: [material])\n\n        // Create an anchor 0.5 meters in front of the camera\n        let anchor = AnchorEntity(.camera)\n        modelEntity.transform.translation = [0, 0, -0.5]\n        \n        anchor.addChild(modelEntity)\n        arView.scene.addAnchor(anchor)\n\n        return arView\n    }\n\n    func updateUIView(_ uiView: ARView, context: Context) {}\n}"}
{"instruction": "Create a SwiftUI view that acts as a digital compass, rotating an arrow image based on magnetic heading.", "output": "import SwiftUI\nimport CoreLocation\n\nstruct CompassView: View {\n    @StateObject private var compass = CompassModel()\n\n    var body: some View {\n        VStack {\n            Text(\"\\(Int(compass.heading))\u00b0\")\n                .font(.largeTitle)\n                .bold()\n            \n            Image(systemName: \"arrow.up.circle.fill\")\n                .resizable()\n                .frame(width: 200, height: 200)\n                .rotationEffect(Angle(degrees: -compass.heading))\n                .animation(.easeInOut, value: compass.heading)\n        }\n    }\n}\n\nclass CompassModel: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    @Published var heading: Double = 0\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingHeading()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {\n        self.heading = newHeading.magneticHeading\n    }\n}"}
{"instruction": "Create a SwiftUI ObservableObject that uses CoreMotion to read Accelerometer data and publish X, Y, and Z coordinates.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    init() {\n        startAccelerometer()\n    }\n\n    func startAccelerometer() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] data, error in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n    \n    func stopAccelerometer() {\n        motionManager.stopAccelerometerUpdates()\n    }\n}"}
{"instruction": "Write a SwiftUI Button that triggers a heavy haptic impact feedback when tapped.", "output": "import SwiftUI\n\nstruct HapticButton: View {\n    var body: some View {\n        Button(action: {\n            let impactHeavy = UIImpactFeedbackGenerator(style: .heavy)\n            impactHeavy.impactOccurred()\n            print(\"Button Tapped\")\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI UIViewRepresentable to wrap a native UIKit MKMapView.", "output": "import SwiftUI\nimport MapKit\n\nstruct MapViewWrapper: UIViewRepresentable {\n    func makeUIView(context: Context) -> MKMapView {\n        let mapView = MKMapView()\n        mapView.showsUserLocation = true\n        mapView.userTrackingMode = .follow\n        return mapView\n    }\n\n    func updateUIView(_ uiView: MKMapView, context: Context) {\n        // Update map view configuration here if needed\n    }\n}"}
{"instruction": "Create a SwiftUI view that displays altitude changes using CMAltimeter (Barometer).", "output": "import SwiftUI\nimport CoreMotion\n\nstruct AltimeterView: View {\n    @State private var relativeAltitude: String = \"0.0 m\"\n    private let altimeter = CMAltimeter()\n\n    var body: some View {\n        Text(\"Relative Altitude: \\(relativeAltitude)\")\n            .onAppear {\n                if CMAltimeter.isRelativeAltitudeAvailable() {\n                    altimeter.startRelativeAltitudeUpdates(to: .main) { data, error in\n                        if let data = data {\n                            self.relativeAltitude = String(format: \"%.2f m\", data.relativeAltitude.doubleValue)\n                        }\n                    }\n                } else {\n                    relativeAltitude = \"Not Available\"\n                }\n            }\n            .onDisappear {\n                altimeter.stopRelativeAltitudeUpdates()\n            }\n    }\n}"}
{"instruction": "Create a SwiftUI View with a button that triggers a 'heavy' haptic feedback impact when tapped using UIKit integration.", "output": "import SwiftUI\nimport UIKit\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Heavy Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Build a `UIViewRepresentable` in SwiftUI to display a live camera feed using `AVFoundation`.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    class VideoPreviewView: UIView {\n        override class var layerClass: AnyClass {\n            AVCaptureVideoPreviewLayer.self\n        }\n        \n        var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n            return layer as! AVCaptureVideoPreviewLayer\n        }\n    }\n\n    func makeUIView(context: Context) -> VideoPreviewView {\n        let view = VideoPreviewView()\n        view.backgroundColor = .black\n        \n        let session = AVCaptureSession()\n        if let device = AVCaptureDevice.default(for: .video),\n           let input = try? AVCaptureDeviceInput(device: device) {\n            if session.canAddInput(input) {\n                session.addInput(input)\n            }\n        }\n        \n        view.videoPreviewLayer.session = session\n        view.videoPreviewLayer.videoGravity = .resizeAspectFill\n        \n        DispatchQueue.global(qos: .userInitiated).async {\n            session.startRunning()\n        }\n        \n        return view\n    }\n\n    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}\n}"}
{"instruction": "Use Swift and `CoreMotion` to create a `MotionManager` class that publishes the device's pitch, roll, and yaw.", "output": "import CoreMotion\nimport Combine\n\nclass MotionManager: ObservableObject {\n    private let motionManager = CMMotionManager()\n    @Published var pitch: Double = 0.0\n    @Published var roll: Double = 0.0\n    @Published var yaw: Double = 0.0\n\n    func startUpdates() {\n        if motionManager.isDeviceMotionAvailable {\n            motionManager.deviceMotionUpdateInterval = 0.1\n            motionManager.startDeviceMotionUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data, error == nil else { return }\n                \n                self?.pitch = data.attitude.pitch\n                self?.roll = data.attitude.roll\n                self?.yaw = data.attitude.yaw\n            }\n        }\n    }\n\n    func stopUpdates() {\n        motionManager.stopDeviceMotionUpdates()\n    }\n}"}
{"instruction": "Apply a custom color inversion effect to an Image in SwiftUI using a Metal shader (iOS 17+).", "output": "import SwiftUI\n\n@available(iOS 17.0, *)\nstruct ShaderView: View {\n    var body: some View {\n        Image(\"exampleImage\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .colorEffect(ShaderLibrary.invertColor())\n    }\n}\n\n// Assumes a .metal file exists with:\n// [[ stitchable ]]\n// half4 invertColor(float2 position, half4 color) {\n//    return half4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, color.a);\n// }"}
{"instruction": "Create a SwiftUI ObservableObject that monitors the device's accelerometer using CoreMotion and publishes X, Y, and Z coordinates.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager: CMMotionManager\n    @Published var x: Double = 0.0\n    @Published var y: Double = 0.0\n    @Published var z: Double = 0.0\n\n    init() {\n        self.motionManager = CMMotionManager()\n        self.motionManager.accelerometerUpdateInterval = 0.1\n        startAccelerometers()\n    }\n\n    private func startAccelerometers() {\n        if self.motionManager.isAccelerometerAvailable {\n            self.motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n}"}
{"instruction": "Implement a custom SwiftUI `Shape` that draws a simple Triangle.", "output": "import SwiftUI\n\nstruct Triangle: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n\n        // Start at the top center\n        path.move(to: CGPoint(x: rect.midX, y: rect.minY))\n        \n        // Draw line to bottom right\n        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))\n        \n        // Draw line to bottom left\n        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))\n        \n        // Close path back to top center\n        path.closeSubpath()\n\n        return path\n    }\n}"}
{"instruction": "Write a Swift function using `UIImpactFeedbackGenerator` to trigger a 'rigid' haptic feedback event.", "output": "import UIKit\n\nfunc triggerRigidHaptic() {\n    let generator = UIImpactFeedbackGenerator(style: .rigid)\n    generator.prepare()\n    generator.impactOccurred()\n}"}
{"instruction": "Create a UIView subclass in Swift that sets up a basic AVFoundation camera preview layer.", "output": "import UIKit\nimport AVFoundation\n\nclass CameraPreviewView: UIView {\n    override class var layerClass: AnyClass {\n        return AVCaptureVideoPreviewLayer.self\n    }\n    \n    var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n        return layer as! AVCaptureVideoPreviewLayer\n    }\n    \n    func setupSession(session: AVCaptureSession) {\n        videoPreviewLayer.session = session\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n    }\n}"}
{"instruction": "Create a SwiftUI `UIViewRepresentable` to display a native `WKWebView` that loads a specific URL.", "output": "import SwiftUI\nimport WebKit\n\nstruct WebView: UIViewRepresentable {\n    let url: URL\n\n    func makeUIView(context: Context) -> WKWebView {\n        return WKWebView()\n    }\n\n    func updateUIView(_ webView: WKWebView, context: Context) {\n        let request = URLRequest(url: url)\n        webView.load(request)\n    }\n}\n\n// Usage:\n// WebView(url: URL(string: \"https://www.example.com\")!)"}
{"instruction": "Create a SwiftUI View that utilizes the CoreMotion framework to display real-time accelerometer data (X, Y, Z).", "output": "import SwiftUI\nimport CoreMotion\n\nstruct AccelerometerView: View {\n    @State private var x = 0.0\n    @State private var y = 0.0\n    @State private var z = 0.0\n    let motionManager = CMMotionManager()\n\n    var body: some View {\n        VStack {\n            Text(\"X: \\(x, specifier: \"%.2f\")\")\n            Text(\"Y: \\(y, specifier: \"%.2f\")\")\n            Text(\"Z: \\(z, specifier: \"%.2f\")\")\n        }\n        .onAppear {\n            if motionManager.isAccelerometerAvailable {\n                motionManager.accelerometerUpdateInterval = 0.1\n                motionManager.startAccelerometerUpdates(to: .main) { data, error in\n                    guard let data = data else { return }\n                    self.x = data.acceleration.x\n                    self.y = data.acceleration.y\n                    self.z = data.acceleration.z\n                }\n            }\n        }\n        .onDisappear {\n            motionManager.stopAccelerometerUpdates()\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI function that triggers the native haptic feedback engine for a 'success' notification.", "output": "import SwiftUI\n\nfunc triggerSuccessHaptic() {\n    let generator = UINotificationFeedbackGenerator()\n    generator.prepare()\n    generator.notificationOccurred(.success)\n}\n\n// Usage inside a View:\n// Button(\"Save\") {\n//     triggerSuccessHaptic()\n// }"}
{"instruction": "Create a SwiftUI View that uses `AVCaptureVideoPreviewLayer` to show a live camera feed.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreviewView: UIViewRepresentable {\n    func makeUIView(context: Context) -> UIView {\n        let view = UIView(frame: UIScreen.main.bounds)\n        \n        let captureSession = AVCaptureSession()\n        captureSession.sessionPreset = .high\n        \n        guard let videoDevice = AVCaptureDevice.default(for: .video),\n              let videoInput = try? AVCaptureDeviceInput(device: videoDevice) else {\n            return view\n        }\n        \n        if captureSession.canAddInput(videoInput) {\n            captureSession.addInput(videoInput)\n        }\n        \n        let previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)\n        previewLayer.frame = view.frame\n        previewLayer.videoGravity = .resizeAspectFill\n        view.layer.addSublayer(previewLayer)\n        \n        DispatchQueue.global(qos: .background).async {\n            captureSession.startRunning()\n        }\n        \n        return view\n    }\n\n    func updateUIView(_ uiView: UIView, context: Context) {}\n}"}
{"instruction": "Create a SwiftUI ObservableObject that monitors the device's accelerometer using CoreMotion and publishes the X, Y, and Z values.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager: CMMotionManager\n    @Published var x: Double = 0.0\n    @Published var y: Double = 0.0\n    @Published var z: Double = 0.0\n\n    init() {\n        self.motionManager = CMMotionManager()\n        self.startAccelerometer()\n    }\n\n    func startAccelerometer() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n    \n    func stopAccelerometer() {\n        motionManager.stopAccelerometerUpdates()\n    }\n}"}
{"instruction": "Implement a SwiftUI `UIViewRepresentable` to display a live camera preview using `AVCaptureVideoPreviewLayer`.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    let session: AVCaptureSession\n\n    func makeUIView(context: Context) -> VideoPreviewView {\n        let view = VideoPreviewView()\n        view.videoPreviewLayer.session = session\n        view.videoPreviewLayer.videoGravity = .resizeAspectFill\n        return view\n    }\n\n    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}\n\n    class VideoPreviewView: UIView {\n        override class var layerClass: AnyClass {\n            AVCaptureVideoPreviewLayer.self\n        }\n\n        var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n            return layer as! AVCaptureVideoPreviewLayer\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI View that triggers a heavy haptic impact feedback when a button is pressed.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n        }\n    }\n}"}
{"instruction": "Implement a Location Manager in Swift that requests 'When In Use' authorization and updates user coordinates.", "output": "import Foundation\nimport CoreLocation\n\nclass LocationService: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    @Published var location: CLLocation?\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        self.location = location\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Create a SwiftUI Button that triggers a medium native haptic feedback impact when tapped.", "output": "import SwiftUI\n\nstruct HapticButton: View {\n    var body: some View {\n        Button(action: {\n            let impactMed = UIImpactFeedbackGenerator(style: .medium)\n            impactMed.impactOccurred()\n        }) {\n            Text(\"Tap for Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n        }\n    }\n}"}
{"instruction": "Wrap a native UIKit PencilKit canvas (PKCanvasView) inside a SwiftUI UIViewRepresentable to allow drawing.", "output": "import SwiftUI\nimport PencilKit\n\nstruct CanvasView: UIViewRepresentable {\n    @Binding var canvasView: PKCanvasView\n\n    func makeUIView(context: Context) -> PKCanvasView {\n        canvasView.drawingPolicy = .anyInput\n        canvasView.tool = PKInkingTool(.pen, color: .black, width: 15)\n        return canvasView\n    }\n\n    func updateUIView(_ uiView: PKCanvasView, context: Context) {\n        // Update logic if needed\n    }\n}\n\n// Usage in View\nstruct DrawingPad: View {\n    @State private var canvas = PKCanvasView()\n    \n    var body: some View {\n        CanvasView(canvasView: $canvas)\n            .frame(maxHeight: .infinity)\n    }\n}"}
{"instruction": "Write a Swift class that uses CoreLocation to request 'When In Use' authorization and start updating location.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestLocation() {\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Lon: \\(location.coordinate.longitude)\")\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Implement a SwiftUI struct that displays a live Camera preview using AVFoundation and UIViewRepresentable.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    class VideoPreviewView: UIView {\n        override class var layerClass: AnyClass {\n             AVCaptureVideoPreviewLayer.self\n        }\n        var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n            return layer as! AVCaptureVideoPreviewLayer\n        }\n    }\n\n    let session: AVCaptureSession\n\n    func makeUIView(context: Context) -> VideoPreviewView {\n        let view = VideoPreviewView()\n        view.videoPreviewLayer.session = session\n        view.videoPreviewLayer.videoGravity = .resizeAspectFill\n        return view\n    }\n\n    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}\n}"}
{"instruction": "Create a SwiftUI view that acts as a digital compass. It should display the current heading and trigger a haptic feedback vibration when the device points North (between 355 and 5 degrees).", "output": "import SwiftUI\nimport CoreLocation\nimport UIKit\n\nclass CompassViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private var locationManager = CLLocationManager()\n    @Published var heading: Double = 0\n    private var hasHapticked = false\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.startUpdatingHeading()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {\n        self.heading = newHeading.magneticHeading\n        \n        // Haptic feedback logic for North\n        if (heading > 355 || heading < 5) {\n            if !hasHapticked {\n                let generator = UIImpactFeedbackGenerator(style: .medium)\n                generator.impactOccurred()\n                hasHapticked = true\n            }\n        } else {\n            hasHapticked = false\n        }\n    }\n}\n\nstruct CompassView: View {\n    @StateObject var viewModel = CompassViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Heading: \\(Int(viewModel.heading))\u00b0\")\n                .font(.largeTitle)\n                .padding()\n            \n            Image(systemName: \"location.north.fill\")\n                .resizable()\n                .frame(width: 100, height: 100)\n                .rotationEffect(Angle(degrees: -viewModel.heading))\n                .foregroundColor((viewModel.heading > 355 || viewModel.heading < 5) ? .red : .primary)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view using AVFoundation that displays a live camera preview suitable for scanning QR codes.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreviewView: UIViewRepresentable {\n    func makeUIView(context: Context) -> UIView {\n        let view = UIView(frame: UIScreen.main.bounds)\n        \n        let captureSession = AVCaptureSession()\n        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else { return view }\n        let videoInput: AVCaptureDeviceInput\n\n        do {\n            videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)\n        } else { return view }\n\n        if (captureSession.canAddInput(videoInput)) {\n            captureSession.addInput(videoInput)\n        } else { return view }\n\n        let videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)\n        videoPreviewLayer.frame = view.layer.bounds\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        view.layer.addSublayer(videoPreviewLayer)\n\n        // Run on background thread to avoid UI blocking\n        DispatchQueue.global(qos: .userInitiated).async {\n            captureSession.startRunning()\n        }\n\n        return view\n    }\n\n    func updateUIView(_ uiView: UIView, context: Context) {}\n}"}
{"instruction": "Create a SwiftUI view that uses CoreMotion to move a circle around the screen based on the device's accelerometer tilt.", "output": "import SwiftUI\nimport CoreMotion\n\nstruct TiltBallView: View {\n    @State private var position = CGPoint(x: 200, y: 400)\n    let motionManager = CMMotionManager()\n    let timer = Timer.publish(every: 0.02, on: .main, in: .common).autoconnect()\n\n    var body: some View {\n        GeometryReader { geo in\n            Circle()\n                .fill(Color.blue)\n                .frame(width: 50, height: 50)\n                .position(position)\n                .onReceive(timer) { _ in\n                    if motionManager.isAccelerometerAvailable {\n                        motionManager.startAccelerometerUpdates()\n                        if let data = motionManager.accelerometerData {\n                            // Amplify tilt for movement\n                            let dx = CGFloat(data.acceleration.x * 20.0)\n                            let dy = CGFloat(data.acceleration.y * -20.0) // Invert Y\n                            \n                            var newX = position.x + dx\n                            var newY = position.y + dy\n                            \n                            // Boundary checks\n                            newX = max(25, min(geo.size.width - 25, newX))\n                            newY = max(25, min(geo.size.height - 25, newY))\n                            \n                            self.position = CGPoint(x: newX, y: newY)\n                        }\n                    }\n                }\n        }\n    }\n}"}
{"instruction": "Develop a SwiftUI View that visualizes microphone audio levels using a series of animated bars (Bar Chart style visualization).", "output": "import SwiftUI\nimport AVFoundation\n\nstruct AudioVisualizerView: View {\n    // Mocking the data for brevity, normally driven by AVAudioRecorder.averagePower\n    @State private var audioLevels: [CGFloat] = Array(repeating: 10.0, count: 10)\n    let timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()\n\n    var body: some View {\n        HStack(spacing: 4) {\n            ForEach(0..<10, id: \\.self) { index in\n                RoundedRectangle(cornerRadius: 2)\n                    .fill(Color.green)\n                    .frame(width: 20, height: audioLevels[index])\n                    .animation(.spring(), value: audioLevels[index])\n            }\n        }\n        .onReceive(timer) { _ in\n            // Simulate audio updates\n            updateLevels()\n        }\n    }\n\n    func updateLevels() {\n        // In a real app, read from AVAudioRecorder\n        for i in 0..<audioLevels.count {\n            audioLevels[i] = CGFloat.random(in: 10...100)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that utilizes `CoreMotion` to display real-time accelerometer data (X, Y, Z) on screen.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    init() {\n        startAccelerometer()\n    }\n\n    func startAccelerometer() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] data, error in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n}\n\nstruct AccelerometerView: View {\n    @StateObject var motion = MotionManager()\n\n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Accelerometer Data\").font(.headline)\n            Text(\"X: \\(motion.x, specifier: \"%.2f\")\")\n            Text(\"Y: \\(motion.y, specifier: \"%.2f\")\")\n            Text(\"Z: \\(motion.z, specifier: \"%.2f\")\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI `UIViewRepresentable` to display a native `WKWebView` that loads a specific URL.", "output": "import SwiftUI\nimport WebKit\n\nstruct WebView: UIViewRepresentable {\n    let url: URL\n\n    func makeUIView(context: Context) -> WKWebView {\n        return WKWebView()\n    }\n\n    func updateUIView(_ uiView: WKWebView, context: Context) {\n        let request = URLRequest(url: url)\n        uiView.load(request)\n    }\n}\n\n// Usage Example\nstruct BrowserView: View {\n    var body: some View {\n        WebView(url: URL(string: \"https://www.apple.com\")!)\n            .edgesIgnoringSafeArea(.all)\n    }\n}"}
{"instruction": "Create a Swift function using `CoreHaptics` to play a transient haptic event (like a sharp tap) on supported iOS devices.", "output": "import CoreHaptics\nimport UIKit\n\nclass HapticManager {\n    private var engine: CHHapticEngine?\n\n    init() {\n        prepareHaptics()\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playTap() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        \n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n\n        do {\n            let pattern = try CHHapticPattern(events: [event], parameters: [])\n            let player = try engine?.makePlayer(with: pattern)\n            try player?.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI view that authenticates a user using FaceID or TouchID via the `LocalAuthentication` framework.", "output": "import SwiftUI\nimport LocalAuthentication\n\nstruct BiometricAuthView: View {\n    @State private var isUnlocked = false\n    \n    var body: some View {\n        VStack {\n            if isUnlocked {\n                Text(\"Welcome, User!\").font(.largeTitle)\n            } else {\n                Text(\"Locked\").font(.title)\n                Button(\"Authenticate\") {\n                    authenticate()\n                }\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n            }\n        }\n    }\n\n    func authenticate() {\n        let context = LAContext()\n        var error: NSError?\n\n        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n            let reason = \"Identify yourself to unlock the app.\"\n\n            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n                DispatchQueue.main.async {\n                    if success {\n                        self.isUnlocked = true\n                    } else {\n                        // Handle authentication failure\n                        print(\"Authentication failed\")\n                    }\n                }\n            }\n        } else {\n            // No biometrics available\n            print(\"Biometrics not available\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI View that triggers a heavy impact haptic feedback when a button is pressed.", "output": "import SwiftUI\nimport UIKit\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI ObservableObject that reads the device Accelerometer data using CoreMotion.", "output": "import CoreMotion\nimport SwiftUI\n\nclass MotionManager: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    init() {\n        startAccelerometer()\n    }\n\n    func startAccelerometer() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom native SwiftUI Shape that draws a sine wave.", "output": "import SwiftUI\n\nstruct SineWaveShape: Shape {\n    var frequency: Double = 1.0\n    var amplitude: CGFloat = 50\n\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let width = rect.width\n        let height = rect.height\n        let midHeight = height / 2\n\n        path.move(to: CGPoint(x: 0, y: midHeight))\n\n        for x in stride(from: 0, to: width, by: 1) {\n            let relativeX = x / width\n            let sine = sin(relativeX * frequency * 2 * .pi)\n            let y = midHeight + (CGFloat(sine) * amplitude)\n            path.addLine(to: CGPoint(x: x, y: y))\n        }\n\n        return path\n    }\n}"}
{"instruction": "Implement a simple Swift class conforming to CLLocationManagerDelegate to request location permissions and print coordinates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    let manager = CLLocationManager()\n\n    override init() {\n        super.init()\n        manager.delegate = self\n        manager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestPermission() {\n        manager.requestWhenInUseAuthorization()\n    }\n\n    func start() {\n        manager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        if let location = locations.last {\n            print(\"Lat: \\(location.coordinate.latitude), Lon: \\(location.coordinate.longitude)\")\n        }\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location Error: \\(error)\")\n    }\n}"}
{"instruction": "Create a SwiftUI View that triggers a heavy impact haptic feedback when a button is pressed.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI ObservableObject that uses CoreMotion to read the device's accelerometer data.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    init() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI wrapper for `UIImagePickerController` to access the native camera.", "output": "import SwiftUI\nimport UIKit\n\nstruct CameraView: UIViewControllerRepresentable {\n    @Binding var image: UIImage?\n    @Environment(\\.presentationMode) var presentationMode\n\n    func makeUIViewController(context: Context) -> UIImagePickerController {\n        let picker = UIImagePickerController()\n        picker.delegate = context.coordinator\n        picker.sourceType = .camera\n        return picker\n    }\n\n    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}\n\n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n\n    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {\n        let parent: CameraView\n\n        init(_ parent: CameraView) {\n            self.parent = parent\n        }\n\n        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {\n            if let uiImage = info[.originalImage] as? UIImage {\n                parent.image = uiImage\n            }\n            parent.presentationMode.wrappedValue.dismiss()\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that displays the device's battery level using `UIDevice`.", "output": "import SwiftUI\n\nstruct BatteryLevelView: View {\n    @State private var batteryLevel: Float = UIDevice.current.batteryLevel\n\n    var body: some View {\n        VStack {\n            Text(\"Battery Level\")\n                .font(.headline)\n            Text(\"\\(Int(batteryLevel * 100))%\")\n                .font(.largeTitle)\n                .foregroundColor(batteryLevel > 0.2 ? .green : .red)\n        }\n        .onAppear {\n            UIDevice.current.isBatteryMonitoringEnabled = true\n            self.batteryLevel = UIDevice.current.batteryLevel\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that utilizes CoreHaptics to trigger a complex haptic pattern when a user long-presses a circle.", "output": "import SwiftUI\nimport CoreHaptics\n\nstruct HapticCircleView: View {\n    @State private var engine: CHHapticEngine?\n\n    var body: some View {\n        Circle()\n            .fill(Color.blue)\n            .frame(width: 100, height: 100)\n            .onAppear(perform: prepareHaptics)\n            .onLongPressGesture(perform: playComplexHaptic)\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playComplexHaptic() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        \n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n\n        do {\n            let pattern = try CHHapticPattern(events: [event], parameters: [])\n            let player = try engine?.makePlayer(with: pattern)\n            try player?.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view utilizing `CMAltimeter` to display relative altitude changes.", "output": "import SwiftUI\nimport CoreMotion\n\nstruct AltimeterView: View {\n    @State private var relativeAltitude: String = \"0.0 m\"\n    private let altimeter = CMAltimeter()\n\n    var body: some View {\n        VStack {\n            Text(\"Relative Altitude Change\")\n                .font(.headline)\n            Text(relativeAltitude)\n                .font(.largeTitle)\n                .padding()\n        }\n        .onAppear(perform: startAltimeter)\n        .onDisappear(perform: stopAltimeter)\n    }\n\n    func startAltimeter() {\n        if CMAltimeter.isRelativeAltitudeAvailable() {\n            altimeter.startRelativeAltitudeUpdates(to: .main) { data, error in\n                if let data = data {\n                    let altitude = String(format: \"%.2f m\", data.relativeAltitude.doubleValue)\n                    self.relativeAltitude = altitude\n                }\n            }\n        } else {\n            self.relativeAltitude = \"Not Available\"\n        }\n    }\n\n    func stopAltimeter() {\n        altimeter.stopRelativeAltitudeUpdates()\n    }\n}"}
{"instruction": "Create a SwiftUI implementation of a `UIViewControllerRepresentable` to wrap a native `UIImagePickerController` for selecting an image.", "output": "import SwiftUI\nimport UIKit\n\nstruct ImagePicker: UIViewControllerRepresentable {\n    @Binding var selectedImage: UIImage?\n    @Environment(\\.presentationMode) var presentationMode\n\n    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {\n        let parent: ImagePicker\n\n        init(_ parent: ImagePicker) {\n            self.parent = parent\n        }\n\n        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {\n            if let image = info[.originalImage] as? UIImage {\n                parent.selectedImage = image\n            }\n            parent.presentationMode.wrappedValue.dismiss()\n        }\n    }\n\n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n\n    func makeUIViewController(context: Context) -> UIImagePickerController {\n        let picker = UIImagePickerController()\n        picker.delegate = context.coordinator\n        return picker\n    }\n\n    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}\n}"}
{"instruction": "Write a SwiftUI View that uses `MapKit` to display a map centered on the user's location with a tracking mode button.", "output": "import SwiftUI\nimport MapKit\n\nstruct UserLocationMapView: View {\n    @State private var region = MKCoordinateRegion(\n        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)\n    )\n    @State private var trackingMode: MapUserTrackingMode = .follow\n\n    var body: some View {\n        Map(coordinateRegion: $region,\n            showsUserLocation: true,\n            userTrackingMode: $trackingMode)\n            .edgesIgnoringSafeArea(.all)\n            .overlay(\n                Button(action: {\n                    trackingMode = .follow\n                }) {\n                    Image(systemName: \"location.fill\")\n                        .padding()\n                        .background(Color.white)\n                        .clipShape(Circle())\n                        .shadow(radius: 4)\n                }\n                .padding(),\n                alignment: .bottomTrailing\n            )\n    }\n}"}
{"instruction": "SwiftUI: Create a native camera preview view using `AVFoundation` wrapped in `UIViewRepresentable`.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    class VideoPreviewView: UIView {\n        override class var layerClass: AnyClass {\n             AVCaptureVideoPreviewLayer.self\n        }\n        \n        var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n            return layer as! AVCaptureVideoPreviewLayer\n        }\n    }\n    \n    let session: AVCaptureSession\n    \n    func makeUIView(context: Context) -> VideoPreviewView {\n        let view = VideoPreviewView()\n        view.backgroundColor = .black\n        view.videoPreviewLayer.session = session\n        view.videoPreviewLayer.videoGravity = .resizeAspectFill\n        return view\n    }\n    \n    func updateUIView(_ uiView: VideoPreviewView, context: Context) {}\n}\n\n// Usage inside a View\n// CameraPreview(session: session)"}
{"instruction": "SwiftUI: Implement a CoreHaptics engine to play a transient haptic pattern when a button is pressed.", "output": "import SwiftUI\nimport CoreHaptics\n\nstruct HapticButtonView: View {\n    @State private var engine: CHHapticEngine?\n\n    var body: some View {\n        Button(\"Feel Impact\") {\n            playHaptic()\n        }\n        .onAppear(perform: prepareHaptics)\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playHaptic() {\n        guard let engine = engine else { return }\n        \n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n\n        do {\n            let pattern = try CHHapticPattern(events: [event], parameters: [])\n            let player = try engine.makePlayer(with: pattern)\n            try player.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "iOS (Swift): Set up a Geofence monitor using `CLLocationManager` that prints to console when entering a region.", "output": "import CoreLocation\n\nclass GeofenceManager: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.requestAlwaysAuthorization()\n    }\n\n    func startMonitoring(lat: Double, lon: Double, identifier: String) {\n        let center = CLLocationCoordinate2D(latitude: lat, longitude: lon)\n        let region = CLCircularRegion(center: center, radius: 100.0, identifier: identifier)\n        region.notifyOnEntry = true\n        region.notifyOnExit = false\n        \n        locationManager.startMonitoring(for: region)\n    }\n\n    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n        if let region = region as? CLCircularRegion {\n            print(\"Entered region: \\(region.identifier)\")\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error)\")\n    }\n}"}
{"instruction": "SwiftUI: Read step count data using `CMPedometer` and display it in a View.", "output": "import SwiftUI\nimport CoreMotion\n\nclass PedometerViewModel: ObservableObject {\n    private let pedometer = CMPedometer()\n    @Published var steps: Int = 0\n    @Published var isAvailable: Bool = false\n\n    init() {\n        self.isAvailable = CMPedometer.isStepCountingAvailable()\n    }\n\n    func startUpdates() {\n        guard isAvailable else { return }\n        pedometer.startUpdates(from: Date()) { data, error in\n            guard let data = data, error == nil else { return }\n            DispatchQueue.main.async {\n                self.steps = data.numberOfSteps.intValue\n            }\n        }\n    }\n}\n\nstruct PedometerView: View {\n    @StateObject var viewModel = PedometerViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Steps: \\(viewModel.steps)\")\n                .font(.largeTitle)\n            if !viewModel.isAvailable {\n                Text(\"Pedometer not available\")\n                    .foregroundColor(.red)\n            }\n        }\n        .onAppear { viewModel.startUpdates() }\n    }\n}"}
{"instruction": "Create a SwiftUI view that triggers a 'Heavy' impact haptic feedback when a button is pressed.", "output": "import SwiftUI\nimport UIKit\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Heavy Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI ViewModel that uses CoreMotion to read the device's Pitch, Roll, and Yaw.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionViewModel: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var pitch: Double = 0.0\n    @Published var roll: Double = 0.0\n    @Published var yaw: Double = 0.0\n\n    func startMotionUpdates() {\n        if motionManager.isDeviceMotionAvailable {\n            motionManager.deviceMotionUpdateInterval = 0.1\n            motionManager.startDeviceMotionUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data, error == nil else { return }\n                self?.pitch = data.attitude.pitch\n                self?.roll = data.attitude.roll\n                self?.yaw = data.attitude.yaw\n            }\n        }\n    }\n\n    func stopMotionUpdates() {\n        motionManager.stopDeviceMotionUpdates()\n    }\n}"}
{"instruction": "Create a minimal Swift `UIViewControllerRepresentable` to display a native `UIImagePickerController` (Camera) in SwiftUI.", "output": "import SwiftUI\nimport UIKit\n\nstruct CameraView: UIViewControllerRepresentable {\n    @Binding var image: UIImage?\n    @Environment(\\.presentationMode) var presentationMode\n\n    func makeUIViewController(context: Context) -> UIImagePickerController {\n        let picker = UIImagePickerController()\n        picker.sourceType = .camera\n        picker.delegate = context.coordinator\n        return picker\n    }\n\n    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}\n\n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n\n    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {\n        let parent: CameraView\n\n        init(_ parent: CameraView) {\n            self.parent = parent\n        }\n\n        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {\n            if let uiImage = info[.originalImage] as? UIImage {\n                parent.image = uiImage\n            }\n            parent.presentationMode.wrappedValue.dismiss()\n        }\n    }\n}"}
{"instruction": "Write a Swift snippet using `CMAltimeter` to check for relative altitude changes (Barometer).", "output": "import CoreMotion\n\nlet altimeter = CMAltimeter()\n\nfunc startAltimeter() {\n    if CMAltimeter.isRelativeAltitudeAvailable() {\n        altimeter.startRelativeAltitudeUpdates(to: OperationQueue.main) { (data, error) in\n            guard let data = data, error == nil else { return }\n            print(\"Relative Altitude: \\(data.relativeAltitude) meters\")\n            print(\"Pressure: \\(data.pressure) kPa\")\n        }\n    } else {\n        print(\"Barometer not available\")\n    }\n}"}
{"instruction": "Create a SwiftUI ViewModel that uses CoreMotion to read the device's Pitch, Roll, and Yaw in real-time.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager: CMMotionManager\n    @Published var pitch: Double = 0.0\n    @Published var roll: Double = 0.0\n    @Published var yaw: Double = 0.0\n\n    init() {\n        self.motionManager = CMMotionManager()\n        self.motionManager.deviceMotionUpdateInterval = 1.0 / 60.0\n        self.startDeviceMotion()\n    }\n\n    func startDeviceMotion() {\n        if motionManager.isDeviceMotionAvailable {\n            motionManager.startDeviceMotionUpdates(to: .main) { (data, error) in\n                guard let data = data else { return }\n                self.pitch = data.attitude.pitch\n                self.roll = data.attitude.roll\n                self.yaw = data.attitude.yaw\n            }\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI `UIViewRepresentable` to display a live camera preview using AVFoundation.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    func makeUIView(context: Context) -> UIView {\n        let view = UIView(frame: UIScreen.main.bounds)\n        let captureSession = AVCaptureSession()\n        captureSession.sessionPreset = .medium\n\n        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video),\n              let videoInput = try? AVCaptureDeviceInput(device: videoCaptureDevice),\n              captureSession.canAddInput(videoInput) else { return view }\n\n        captureSession.addInput(videoInput)\n\n        let previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)\n        previewLayer.frame = view.frame\n        previewLayer.videoGravity = .resizeAspectFill\n        view.layer.addSublayer(previewLayer)\n\n        DispatchQueue.global(qos: .background).async {\n            captureSession.startRunning()\n        }\n\n        return view\n    }\n\n    func updateUIView(_ uiView: UIView, context: Context) {}\n}"}
{"instruction": "Create a simple SwiftUI view that triggers the device's haptic feedback engine (heavy impact) when a button is pressed.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(10)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that displays the user's current location on a Map using MapKit.", "output": "import SwiftUI\nimport MapKit\n\nstruct LocationMapView: View {\n    // State to hold region, centered on coordinates with a span\n    @State private var region = MKCoordinateRegion(\n        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)\n    )\n\n    var body: some View {\n        Map(coordinateRegion: $region, \n            showsUserLocation: true, \n            userTrackingMode: .constant(.follow))\n            .edgesIgnoringSafeArea(.all)\n            .onAppear {\n                // Ensure CLLocationManager requests authorization elsewhere in the app\n            }\n    }\n}"}
{"instruction": "Create a SwiftUI ObservableObject that streams Accelerometer data using CoreMotion.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private let motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    func startUpdates() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in\n                guard let data = data else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n\n    func stopUpdates() {\n        motionManager.stopAccelerometerUpdates()\n    }\n}"}
{"instruction": "Wrap a standard UIKit MKMapView into a SwiftUI view using UIViewRepresentable.", "output": "import SwiftUI\nimport MapKit\n\nstruct MapView: UIViewRepresentable {\n    func makeUIView(context: Context) -> MKMapView {\n        let mapView = MKMapView()\n        mapView.showsUserLocation = true\n        return mapView\n    }\n\n    func updateUIView(_ uiView: MKMapView, context: Context) {\n        // Update the view if needed\n    }\n}"}
{"instruction": "Create a function in SwiftUI to play a transient haptic pattern using CoreHaptics.", "output": "import CoreHaptics\n\nclass HapticManager {\n    private var engine: CHHapticEngine?\n\n    init() {\n        prepareHaptics()\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playComplexHaptic() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        \n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n\n        do {\n            let pattern = try CHHapticPattern(events: [event], parameters: [])\n            let player = try engine?.makePlayer(with: pattern)\n            try player?.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "Create a Swift class to handle 'When In Use' location authorization and updates using CoreLocation.", "output": "import CoreLocation\n\nclass LocationService: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    @Published var location: CLLocation?\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func startLocationUpdates() {\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let latestLocation = locations.last else { return }\n        self.location = latestLocation\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Implement a Swift function to authenticate a user using FaceID or TouchID via LocalAuthentication.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure features\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a SwiftUI struct that wraps a native UIKit camera preview layer using `UIViewRepresentable`. This enables the display of a live camera feed within a SwiftUI view hierarchy.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewRepresentable {\n    class VideoPreviewView: UIView {\n        override class var layerClass: AnyClass {\n            AVCaptureVideoPreviewLayer.self\n        }\n        \n        var videoPreviewLayer: AVCaptureVideoPreviewLayer {\n            return layer as! AVCaptureVideoPreviewLayer\n        }\n    }\n\n    let session: AVCaptureSession\n\n    func makeUIView(context: Context) -> VideoPreviewView {\n        let view = VideoPreviewView()\n        view.backgroundColor = .black\n        view.videoPreviewLayer.session = session\n        view.videoPreviewLayer.videoGravity = .resizeAspectFill\n        view.videoPreviewLayer.connection?.videoOrientation = .portrait\n        return view\n    }\n\n    func updateUIView(_ uiView: VideoPreviewView, context: Context) {\n        // View updates handled by the session\n    }\n}"}
{"instruction": "Create a Swift class utilizing `CoreLocation` to request 'When In Use' authorization and start updating the user's location. Include the delegate method to handle location updates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    var didUpdateLocation: ((CLLocation) -> Void)?\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func start() {\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        didUpdateLocation?(location)\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error)\")\n    }\n}"}
{"instruction": "Implement a SwiftUI function to trigger native Haptic Feedback using `UIImpactFeedbackGenerator`. This allows the app to provide physical feedback to the user.", "output": "import UIKit\n\nfunc triggerHapticFeedback(style: UIImpactFeedbackGenerator.FeedbackStyle) {\n    let generator = UIImpactFeedbackGenerator(style: style)\n    generator.prepare()\n    generator.impactOccurred()\n}\n\n// Usage example inside a SwiftUI Button:\n// Button(action: {\n//     triggerHapticFeedback(style: .medium)\n// }) {\n//     Text(\"Tap Me\")\n// }"}
{"instruction": "Write a Swift function using `LocalAuthentication` to implement Biometric Authentication (FaceID/TouchID). It should handle the success and failure cases via a completion handler.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, String?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure features\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError?.localizedDescription)\n                }\n            }\n        }\n    } else {\n        completion(false, \"Biometry not available\")\n    }\n}"}
{"instruction": "Create a SwiftUI ObservableObject that monitors the device's accelerometer using CoreMotion to detect X, Y, and Z axis changes.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private let motionManager = CMMotionManager()\n    @Published var x = 0.0\n    @Published var y = 0.0\n    @Published var z = 0.0\n\n    init() {\n        startAccelerometers()\n    }\n\n    func startAccelerometers() {\n        if motionManager.isAccelerometerAvailable {\n            motionManager.accelerometerUpdateInterval = 0.1\n            motionManager.startAccelerometerUpdates(to: .main) { [weak self] data, error in\n                guard let data = data, error == nil else { return }\n                self?.x = data.acceleration.x\n                self?.y = data.acceleration.y\n                self?.z = data.acceleration.z\n            }\n        }\n    }\n    \n    func stopUpdates() {\n        motionManager.stopAccelerometerUpdates()\n    }\n}"}
{"instruction": "Create a SwiftUI View that triggers a complex haptic feedback pattern using CoreHaptics when a button is pressed.", "output": "import SwiftUI\nimport CoreHaptics\n\nstruct HapticView: View {\n    @State private var engine: CHHapticEngine?\n\n    var body: some View {\n        Button(\"Feel Texture\") {\n            playHaptics()\n        }\n        .onAppear(perform: prepareHaptics)\n    }\n\n    func prepareHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        do {\n            engine = try CHHapticEngine()\n            try engine?.start()\n        } catch {\n            print(\"Haptic engine error: \\(error.localizedDescription)\")\n        }\n    }\n\n    func playHaptics() {\n        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }\n        \n        var events = [CHHapticEvent]()\n        // Create a sharp tap\n        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)\n        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)\n        let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)\n        events.append(event)\n\n        do {\n            let pattern = try CHHapticPattern(events: events, parameters: [])\n            let player = try engine?.makePlayer(with: pattern)\n            try player?.start(atTime: 0)\n        } catch {\n            print(\"Failed to play pattern: \\(error.localizedDescription)\")\n        }\n    }\n}"}
{"instruction": "Using Swift and AVFoundation, create a function that toggles the device flashlight (torch) on and off.", "output": "import AVFoundation\n\nfunc toggleFlashlight(on: Bool) {\n    guard let device = AVCaptureDevice.default(for: .video) else { return }\n\n    if device.hasTorch {\n        do {\n            try device.lockForConfiguration()\n            if on {\n                try device.setTorchModeOn(level: 1.0)\n            } else {\n                device.torchMode = .off\n            }\n            device.unlockForConfiguration()\n        } catch {\n            print(\"Torch could not be used\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI View that wraps a map view to show the user's current location using MapKit.", "output": "import SwiftUI\nimport MapKit\n\nstruct LocationMapView: View {\n    @StateObject private var viewModel = MapViewModel()\n\n    var body: some View {\n        Map(coordinateRegion: $viewModel.region, showsUserLocation: true)\n            .onAppear {\n                viewModel.checkLocationAuthorization()\n            }\n    }\n}\n\nclass MapViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {\n    @Published var region = MKCoordinateRegion(\n        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)\n    )\n    var locationManager: CLLocationManager?\n\n    func checkLocationAuthorization() {\n        locationManager = CLLocationManager()\n        locationManager?.delegate = self\n        locationManager?.requestWhenInUseAuthorization()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        DispatchQueue.main.async {\n            self.region = MKCoordinateRegion(\n                center: location.coordinate,\n                span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)\n            )\n        }\n    }\n}"}
{"instruction": "Create a custom circular progress view in SwiftUI that animates based on a binding double value between 0.0 and 1.0.", "output": "import SwiftUI\n\nstruct CircularProgressView: View {\n    @Binding var progress: Double\n\n    var body: some View {\n        ZStack {\n            Circle()\n                .stroke(lineWidth: 20.0)\n                .opacity(0.3)\n                .foregroundColor(Color.gray)\n\n            Circle()\n                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))\n                .stroke(style: StrokeStyle(lineWidth: 20.0, lineCap: .round, lineJoin: .round))\n                .foregroundColor(Color.blue)\n                .rotationEffect(Angle(degrees: 270.0))\n                .animation(.linear, value: progress)\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI View that triggers haptic feedback (medium impact) when a button is pressed.", "output": "import SwiftUI\n\nstruct HapticButtonView: View {\n    var body: some View {\n        Button(action: {\n            let impactMed = UIImpactFeedbackGenerator(style: .medium)\n            impactMed.impactOccurred()\n        }) {\n            Text(\"Press for Haptics\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n        }\n    }\n}"}
{"instruction": "Create a Swift ObservableObject that uses CoreLocation to request permission and publish the user's current location coordinates.", "output": "import Foundation\nimport CoreLocation\nimport Combine\n\nclass LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    @Published var location: CLLocation?\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        self.location = location\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Wrap a UIKit MKMapView in a SwiftUI UIViewRepresentable to display a map.", "output": "import SwiftUI\nimport MapKit\n\nstruct MapView: UIViewRepresentable {\n    func makeUIView(context: Context) -> MKMapView {\n        let mapView = MKMapView()\n        mapView.showsUserLocation = true\n        return mapView\n    }\n\n    func updateUIView(_ uiView: MKMapView, context: Context) {\n        // Update map view configuration here if needed\n    }\n}"}
{"instruction": "Create a SwiftUI button that triggers a heavy impact haptic feedback when tapped using UIKit integration.", "output": "import SwiftUI\nimport UIKit\n\nstruct HapticButton: View {\n    var body: some View {\n        Button(action: {\n            let generator = UIImpactFeedbackGenerator(style: .heavy)\n            generator.prepare()\n            generator.impactOccurred()\n        }) {\n            Text(\"Trigger Haptic\")\n                .padding()\n                .background(Color.blue)\n                .foregroundColor(.white)\n                .cornerRadius(8)\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI `UIViewControllerRepresentable` to display a basic camera preview using `AVCaptureSession`.", "output": "import SwiftUI\nimport AVFoundation\n\nstruct CameraPreview: UIViewControllerRepresentable {\n    func makeUIViewController(context: Context) -> UIViewController {\n        let controller = UIViewController()\n        let session = AVCaptureSession()\n        \n        guard let device = AVCaptureDevice.default(for: .video),\n              let input = try? AVCaptureDeviceInput(device: device) else { return controller }\n        \n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        let previewLayer = AVCaptureVideoPreviewLayer(session: session)\n        previewLayer.videoGravity = .resizeAspectFill\n        previewLayer.frame = controller.view.bounds\n        controller.view.layer.addSublayer(previewLayer)\n        \n        DispatchQueue.global(qos: .background).async {\n            session.startRunning()\n        }\n        \n        return controller\n    }\n\n    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {}\n}"}
{"instruction": "Create a SwiftUI view that uses `CMMotionManager` to display the device's pitch and roll in real-time.", "output": "import SwiftUI\nimport CoreMotion\n\nclass MotionManager: ObservableObject {\n    private var motionManager = CMMotionManager()\n    @Published var pitch: Double = 0.0\n    @Published var roll: Double = 0.0\n\n    init() {\n        motionManager.deviceMotionUpdateInterval = 0.1\n        motionManager.startDeviceMotionUpdates(to: .main) { [weak self] (data, error) in\n            guard let data = data else { return }\n            self?.pitch = data.attitude.pitch\n            self?.roll = data.attitude.roll\n        }\n    }\n}\n\nstruct MotionView: View {\n    @StateObject var motion = MotionManager()\n\n    var body: some View {\n        VStack {\n            Text(\"Pitch: \\(motion.pitch, specifier: \"%.2f\")\")\n            Text(\"Roll: \\(motion.roll, specifier: \"%.2f\")\")\n        }\n    }\n}"}
{"instruction": "Create a function in Swift to authenticate a user using FaceID or TouchID via the `LocalAuthentication` framework.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle in the following Swift closure usage within a View Controller.", "output": "class MyViewController: UIViewController {\n    var completionHandler: (() -> Void)?\n    var status = \"Loading\"\n\n    func setupHandler() {\n        // Fix: Add [weak self] to capture list to avoid retain cycle\n        completionHandler = { [weak self] in\n            guard let self = self else { return }\n            self.status = \"Complete\"\n            print(self.status)\n        }\n    }\n}"}
{"instruction": "Create a simple Core Data stack singleton in Swift using NSPersistentContainer.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n    \n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            try? context.save()\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that fetches JSON data from a URL, decodes it into a 'User' struct, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "In Objective-C, declare a delegate property ensuring it does not cause a memory leak (retain cycle).", "output": "@protocol MyDelegate <NSObject>\n- (void)didFinishTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' to prevent strong reference cycles with delegates\n@property (nonatomic, weak) id<MyDelegate> delegate;\n\n@end"}
{"instruction": "Create a programmatic UIKit view setup where a UILabel is centered in the view using NSLayoutConstraint. Ensure `translatesAutoresizingMaskIntoConstraints` is handled.", "output": "import UIKit\n\nclass MessageView: UIView {\n    let label = UILabel()\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    private func setupView() {\n        label.text = \"Hello World\"\n        label.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(label)\n\n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write a SwiftUI view that uses @StateObject to observe a model and displays a list of items.", "output": "import SwiftUI\n\nclass ItemModel: ObservableObject {\n    @Published var items: [String] = [\"Apple\", \"Banana\", \"Cherry\"]\n}\n\nstruct ItemListView: View {\n    @StateObject private var viewModel = ItemModel()\n\n    var body: some View {\n        List(viewModel.items, id: \\.self) { item in\n            Text(item)\n        }\n    }\n}"}
{"instruction": "Perform a Core Data fetch request in Swift to retrieve all 'Person' entities where the 'age' attribute is greater than 21.", "output": "import CoreData\n\nfunc fetchAdults(context: NSManagedObjectContext) -> [Person] {\n    let fetchRequest: NSFetchRequest<Person> = Person.fetchRequest()\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Implement a Combine pipeline that subscribes to a text publisher (like a search bar), debounces for 500ms, and removes duplicate inputs.", "output": "import Combine\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Demonstrate the use of `unowned` in Swift to break a reference cycle between two classes, Customer and CreditCard, where a CreditCard must always have a Customer.", "output": "class Customer {\n    let name: String\n    var card: CreditCard?\n    \n    init(name: String) {\n        self.name = name\n    }\n    \n    deinit { print(\"Customer deinitialized\") }\n}\n\nclass CreditCard {\n    let number: String\n    // 'unowned' is used because a CreditCard cannot exist without a Customer\n    // and the Customer outlives the CreditCard.\n    unowned let customer: Customer\n    \n    init(number: String, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    \n    deinit { print(\"CreditCard deinitialized\") }\n}"}
{"instruction": "Using the LocalAuthentication framework, write a function to check if FaceID/TouchID is available and request biometric authentication.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself!\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication successful\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometrics not available\")\n    }\n}"}
{"instruction": "Write a Swift code snippet that demonstrates how to prevent a strong reference cycle (retain cycle) when a closure captures `self` inside a class named `DataFetcher`. The closure should be stored in a property and executed later.", "output": "class DataFetcher {\n    var completionHandler: (() -> Void)?\n    var data: String = \"\"\n\n    func setupHandler() {\n        // Use [weak self] to prevent a strong reference cycle\n        completionHandler = { [weak self] in\n            guard let self = self else { return }\n            self.processData()\n        }\n    }\n\n    func processData() {\n        self.data = \"Processed\"\n        print(\"Data processed\")\n    }\n\n    deinit {\n        print(\"DataFetcher is being deallocated\")\n    }\n}"}
{"instruction": "Using Core Data in Swift, write a function that performs a background task to insert a new `LogEntry` entity. Ensure the context is saved and the operation does not block the main thread.", "output": "func createLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let log = LogEntry(context: context)\n        log.message = message\n        log.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Log saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save log: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that fetches JSON data from a URL, decodes it into a `User` struct, handles errors by returning a placeholder user, and assigns the result to a `@Published` property named `user`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nclass UserViewModel: ObservableObject {\n    @Published var user: User = User(id: 0, name: \"Guest\")\n    private var cancellables = Set<AnyCancellable>()\n\n    func fetchUser(url: URL) {\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: User.self, decoder: JSONDecoder())\n            .replaceError(with: User(id: 0, name: \"Guest\"))\n            .receive(on: DispatchQueue.main)\n            .assign(to: \\.user, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "In Objective-C, demonstrate how to use an `@autoreleasepool` block to manage memory usage within a tight loop that allocates many temporary `NSString` objects.", "output": "void processLargeDataSet(int iterationCount) {\n    for (int i = 0; i < iterationCount; i++) {\n        @autoreleasepool {\n            // Temporary objects created here are released at the end of this block\n            // preventing memory spikes during the loop execution.\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d with heavy overhead...\", i];\n            NSArray *tempArray = [tempString componentsSeparatedByString:@\" \"];\n            NSLog(@\"First word: %@\", tempArray.firstObject);\n        }\n    }\n}"}
{"instruction": "Write a Swift function using the Vision framework to detect text (rectangles) in a given `CGImage`.", "output": "import Vision\n\nfunc detectText(in image: CGImage) {\n    let request = VNDetectTextRectanglesRequest { (request, error) in\n        guard let observations = request.results as? [VNTextObservation] else { return }\n        \n        for observation in observations {\n            print(\"Text detected with confidence: \\(observation.confidence) at bounding box: \\(observation.boundingBox)\")\n        }\n    }\n\n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform detection: \\(error)\")\n    }\n}"}
{"instruction": "Using Combine, implement a search bar logic snippet that debounces the user input for 500 milliseconds and removes duplicate consecutive strings before printing the search query.", "output": "import Combine\nimport Foundation\n\nclass SearchManager {\n    let searchText = PassthroughSubject<String, Never>()\n    var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Performing search for: \\(query)\")\n            }\n            .store(in: &subscriptions)\n    }\n\n    func type(_ text: String) {\n        searchText.send(text)\n    }\n}"}
{"instruction": "Implement a SwiftUI View that uses `@FetchRequest` to display a list of `Item` entities from Core Data, sorted by their `createdAt` date in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.createdAt, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.name ?? \"Unknown\")\n                }\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n}"}
{"instruction": "Write an Objective-C class implementation that adds a Key-Value Observer (KVO) to a property `status` of another object `NetworkManager` and handles the change notification.", "output": "@interface StatusObserver : NSObject\n@property (nonatomic, strong) NetworkManager *manager;\n@end\n\n@implementation StatusObserver\n\n- (instancetype)initWithManager:(NetworkManager *)manager {\n    self = [super init];\n    if (self) {\n        _manager = manager;\n        [_manager addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];\n    }\n    return self;\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed from %@ to %@\", change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);\n    }\n}\n\n- (void)dealloc {\n    [_manager removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Create a thread-safe `Counter` using a Swift Actor to prevent data races when incrementing a value from multiple threads.", "output": "actor Counter {\n    private var value = 0\n\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage Example\nlet counter = Counter()\nTask {\n    let newValue = await counter.increment()\n    print(\"Counter is now: \\(newValue)\")\n}"}
{"instruction": "Write a Swift function that uses `NSPredicate` to filter a Core Data fetch request, returning only `Order` entities where `isCompleted` is false and the `total` is greater than 50.0.", "output": "func fetchPendingHighValueOrders(context: NSManagedObjectContext) -> [Order] {\n    let fetchRequest: NSFetchRequest<Order> = Order.fetchRequest()\n    \n    // Predicate: isCompleted == false AND total > 50.0\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == NO AND total > %f\", 50.0)\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Write a Swift function inside a class `DataLoader` that simulates a network call. Use a closure to handle the result, but ensure you prevent a strong reference cycle (retain cycle) when accessing the property `cache` inside the closure.", "output": "class DataLoader {\n    var cache: [String] = []\n\n    func fetchData() {\n        let url = URL(string: \"https://api.example.com/data\")!\n        \n        let task = URLSession.shared.dataTask(with: url) { [weak self] data, response, error in\n            // Capture list [weak self] prevents strong reference cycle\n            guard let self = self else { return }\n            \n            if let data = data {\n                // Simulate parsing and caching\n                self.cache.append(\"New Data\")\n                print(\"Data cached. Total items: \\(self.cache.count)\")\n            }\n        }\n        task.resume()\n    }\n}"}
{"instruction": "Create a Swift function using Core Data that performs a background save. The function should create a private queue context from a persistent container, create a new `LogEntry` entity, set its `timestamp`, and save the context safely.", "output": "import CoreData\n\nfunc createLogEntryInBackground(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Context is created on a private queue automatically here\n        let log = NSEntityDescription.insertNewObject(forEntityName: \"LogEntry\", into: context)\n        log.setValue(Date(), forKey: \"timestamp\")\n        \n        do {\n            try context.save()\n            print(\"Background save successful.\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that listens to a `searchText` publisher (String). The pipeline should debounce for 500ms, remove duplicates, and map the text to an API URL string. Return the resulting publisher type `AnyPublisher<String, Never>`.", "output": "import Combine\nimport Foundation\n\nfunc createSearchPipeline(textPublisher: AnyPublisher<String, Never>) -> AnyPublisher<String, Never> {\n    return textPublisher\n        .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n        .removeDuplicates()\n        .map { query in\n            return \"https://api.example.com/search?q=\\(query)\"\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "In Objective-C, write a code snippet that iterates through a large array of 10,000 image paths and processes them. Wrap the processing logic in an `@autoreleasepool` to ensure temporary autoreleased objects are freed immediately after each iteration to keep memory footprint low.", "output": "NSArray *imagePaths = @[/* ... 10,000 strings ... */];\n\nfor (NSString *path in imagePaths) {\n    @autoreleasepool {\n        // Load image (simulated)\n        UIImage *image = [UIImage imageWithContentsOfFile:path];\n        \n        // Process image (e.g., resize or filter)\n        NSData *processedData = UIImageJPEGRepresentation(image, 0.5);\n        \n        NSLog(@\"Processed image at path: %@\", path);\n        // processedData and image are released here\n    }\n}"}
{"instruction": "Create a SwiftUI `ObservableObject` named `AuthenticationManager`. It should have a `@Published` boolean property `isAuthenticated`. Include a method `login` that sets this property to true after a 2-second delay using `DispatchQueue`.", "output": "import SwiftUI\n\nclass AuthenticationManager: ObservableObject {\n    @Published var isAuthenticated: Bool = false\n\n    func login() {\n        // Simulate network delay\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {\n            self.isAuthenticated = true\n        }\n    }\n}"}
{"instruction": "Write a Swift code snippet inside a `UIViewController` that uses Combine to bind a `UITextField`'s text changes to a `UILabel`. The label should only update if the text length is greater than 3 characters.", "output": "import UIKit\nimport Combine\n\nclass ViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var label: UILabel!\n    var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .filter { $0.count > 3 }\n            .assign(to: \\.text, on: label)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a Swift function using `NSFetchRequest` to fetch `User` entities from Core Data. The fetch request should filter for users where `isActive` is true and sort the results by `lastName` in ascending order.", "output": "import CoreData\n\nfunc fetchActiveUsers(context: NSManagedObjectContext) -> [NSManagedObject]? {\n    let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: \"User\")\n    \n    // Filter: isActive == true\n    fetchRequest.predicate = NSPredicate(format: \"isActive == %@\", NSNumber(value: true))\n    \n    // Sort: lastName ascending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Using `DispatchGroup` in Swift, write a function `syncData` that performs two asynchronous tasks (fetching profile and fetching settings) and prints 'All Finished' only when both tasks are complete.", "output": "import Foundation\n\nfunc syncData() {\n    let group = DispatchGroup()\n\n    // Task 1\n    group.enter()\n    fetchProfile { \n        print(\"Profile fetched\")\n        group.leave()\n    }\n\n    // Task 2\n    group.enter()\n    fetchSettings { \n        print(\"Settings fetched\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All Finished\")\n    }\n}\n\n// Dummy async functions for context\nfunc fetchProfile(completion: @escaping () -> Void) { DispatchQueue.global().async { completion() } }\nfunc fetchSettings(completion: @escaping () -> Void) { DispatchQueue.global().async { completion() } }"}
{"instruction": "In Objective-C, define a property for a block that takes an `NSString` and returns `void`. Demonstrate how to assign a block to this property using the `copy` attribute to ensure it is moved from the stack to the heap.", "output": "@interface MessageHandler : NSObject\n@property (nonatomic, copy) void (^onMessageReceived)(NSString *);\n@end\n\n@implementation MessageHandler\n\n- (void)setupHandler {\n    // Assigning the block. The 'copy' property attribute ensures \n    // the block is copied to the heap.\n    self.onMessageReceived = ^(NSString *message) {\n        NSLog(@\"Received: %@\", message);\n    };\n}\n@end"}
{"instruction": "Write a Swift function using the native `FileManager` to save a JSON string to the app's Documents directory. The function should take a filename and the string content as arguments.", "output": "import Foundation\n\nfunc saveJsonToDocuments(filename: String, jsonString: String) {\n    guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }\n    \n    let fileURL = documentsDirectory.appendingPathComponent(filename)\n    \n    do {\n        try jsonString.write(to: fileURL, atomically: true, encoding: .utf8)\n        print(\"Saved to \\(fileURL)\")\n    } catch {\n        print(\"Error saving file: \\(error)\")\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var dataLoader: DataLoader?\n    var statusLabel: UILabel = UILabel()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Fix: Add [weak self] to the capture list to prevent a retain cycle\n        dataLoader?.onDataLoaded = { [weak self] result in\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                self.statusLabel.text = \"Data loaded: \\(result)\"\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to perform a background import of a large array of dictionaries to ensure the main UI thread is not blocked.", "output": "func importUsers(userDictionaries: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for dict in userDictionaries {\n            guard let id = dict[\"id\"] as? String else { continue }\n            \n            // Assuming 'User' is a valid NSManagedObject subclass\n            let user = User(context: context)\n            user.id = id\n            user.name = dict[\"name\"] as? String\n            user.email = dict[\"email\"] as? String\n        }\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a search query string from a UITextField publisher, debounces it, removes duplicates, and fetches results from an API.", "output": "import Combine\nimport UIKit\n\nclass SearchViewModel {\n    @Published var searchQuery: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n    \n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &subscriptions)\n    }\n    \n    func performSearch(query: String) {\n        // API call logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton in Objective-C.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    \n    return sharedInstance;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        // Initialization code\n    }\n    return self;\n}\n\n@end"}
{"instruction": "Create a custom UIView subclass programmatically in Swift that centers a UILabel using Auto Layout anchors.", "output": "import UIKit\n\nclass CenteredLabelView: UIView {\n    private let label = UILabel()\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n\n    private func setupView() {\n        addSubview(label)\n        label.translatesAutoresizingMaskIntoConstraints = false\n        label.text = \"Centered Text\"\n        \n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write a SwiftUI view that observes a ViewModel conforming to ObservableObject and displays a list of items.", "output": "import SwiftUI\n\nclass ItemViewModel: ObservableObject {\n    @Published var items: [String] = [\"Apple\", \"Banana\", \"Cherry\"]\n}\n\nstruct ItemListView: View {\n    @StateObject private var viewModel = ItemViewModel()\n\n    var body: some View {\n        NavigationView {\n            List(viewModel.items, id: \\.self) { item in\n                Text(item)\n            }\n            .navigationTitle(\"Fruits\")\n        }\n    }\n}"}
{"instruction": "Set up a basic AVCaptureSession in Swift to capture video input from the back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n    \n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else { return nil }\n    \n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n            return session\n        }\n    } catch {\n        print(\"Error setting up camera input: \\(error)\")\n    }\n    return nil\n}"}
{"instruction": "Implement a `CLLocationManagerDelegate` in Swift to request 'When In Use' authorization and handle the status change.", "output": "import CoreLocation\n\nclass LocationHandler: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n\n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Access granted\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Access denied\")\n        case .notDetermined:\n            print(\"Waiting for user selection\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Convert the following closure-based function to a modern Swift Async/Await function using `withCheckedThrowingContinuation`.", "output": "// Original: func fetchImage(url: URL, completion: @escaping (Result<UIImage, Error>) -> Void)\n\nfunc fetchImage(url: URL) async throws -> UIImage {\n    return try await withCheckedThrowingContinuation { continuation in\n        fetchImage(url: url) { result in\n            switch result {\n            case .success(let image):\n                continuation.resume(returning: image)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}"}
{"instruction": "Using Objective-C, define a protocol and a class with a delegate property that uses the correct memory management attribute to avoid retain cycles.", "output": "@protocol DataDelegate <NSObject>\n- (void)didFinishLoadingData;\n@end\n\n@interface DataFetcher : NSObject\n\n// Use 'weak' to prevent retain cycles (delegate holds strong ref to Fetcher, Fetcher holds weak ref to delegate)\n@property (nonatomic, weak) id<DataDelegate> delegate;\n\n- (void)startFetching;\n\n@end"}
{"instruction": "Write a Swift function that safely loads a high-resolution image from a URL without blocking the main thread, using Swift Concurrency (async/await), and downsamples it using ImageIO to reduce memory footprint before displaying it.", "output": "import UIKit\nimport ImageIO\n\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage? {\n    let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n    guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions) else { return nil }\n    \n    let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale\n    let downsampleOptions = [\n        kCGImageSourceCreateThumbnailFromImageAlways: true,\n        kCGImageSourceShouldCacheImmediately: true,\n        kCGImageSourceCreateThumbnailWithTransform: true,\n        kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n    ] as CFDictionary\n    \n    guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else { return nil }\n    return UIImage(cgImage: downsampledImage)\n}\n\nfunc fetchAndDisplayImage(url: URL, targetSize: CGSize) async throws -> UIImage? {\n    let (localURL, _) = try await URLSession.shared.download(from: url)\n    // Move to background thread for CPU intensive image processing\n    return await Task.detached(priority: .userInitiated) {\n        return downsample(imageAt: localURL, to: targetSize, scale: UIScreen.main.scale)\n    }.value\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a user's search text input, debounces it for 500ms, removes duplicate consecutive entries, and triggers an API call, handling potential errors gracefully using `catch`.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .flatMap { [weak self] query -> AnyPublisher<[String], Never> in\n                guard let self = self else { return Empty().eraseToAnyPublisher() }\n                return self.performSearch(query: query)\n                    .catch { error -> Just<[String]> in\n                        print(\"Search error: \\(error)\")\n                        return Just([])\n                    }\n                    .eraseToAnyPublisher()\n            }\n            .sink { results in\n                print(\"Received results: \\(results)\")\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) -> AnyPublisher<[String], Error> {\n        // Mock API call\n        let results = [\"Result for \\(query)\"]\n        return Just(results)\n            .setFailureType(to: Error.self)\n            .delay(for: 0.5, scheduler: RunLoop.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Demonstrate how to prevent a strong reference cycle (retain cycle) in Objective-C when defining a Delegate protocol and a property for that delegate.", "output": "// MyClass.h\n#import <Foundation/Foundation.h>\n\n@class MyClass;\n\n// 1. Define the protocol\n@protocol MyClassDelegate <NSObject>\n- (void)didCompleteTaskInObject:(MyClass *)object;\n@end\n\n@interface MyClass : NSObject\n\n// 2. Use 'weak' attribute to prevent retain cycle\n@property (nonatomic, weak) id<MyClassDelegate> delegate;\n\n- (void)startTask;\n\n@end\n\n// MyClass.m\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)startTask {\n    // Perform task...\n    if ([self.delegate respondsToSelector:@selector(didCompleteTaskInObject:)]) {\n        [self.delegate didCompleteTaskInObject:self];\n    }\n}\n@end"}
{"instruction": "Implement a Core Data background task in Swift using `NSPersistentContainer` to batch insert 1000 records without blocking the main UI thread.", "output": "import CoreData\n\nfunc importBatchData(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // The context is created automatically on a background queue\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for i in 0..<1000 {\n            let entity = NSEntityDescription.insertNewObject(forEntityName: \"Item\", into: context)\n            entity.setValue(\"Item \\(i)\", forKey: \"name\")\n            entity.setValue(Date(), forKey: \"timestamp\")\n        }\n        \n        do {\n            try context.save()\n            print(\"Batch save completed successfully on background thread.\")\n        } catch {\n            print(\"Failed to save batch: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a thread-safe counter in Swift using the `actor` keyword to manage shared mutable state in a concurrent environment.", "output": "actor SafeCounter {\n    private var value = 0\n    \n    func increment() {\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage\nlet counter = SafeCounter()\n\nTask {\n    await counter.increment()\n    let currentValue = await counter.getValue()\n    print(\"Current count: \\(currentValue)\")\n}"}
{"instruction": "Write a SwiftUI view that uses `@FetchRequest` to display a list of 'Task' entities from Core Data, sorted by creation date, and includes a swipe-to-delete action.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: true)],\n        animation: .default)\n    private var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    Text(task.title ?? \"Untitled\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { tasks[$0] }.forEach(viewContext.delete)\n\n            do {\n                try viewContext.save()\n            } catch {\n                let nsError = error as NSError\n                fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a wrapper function in Swift that converts a legacy completion-handler based API into a Combine `Future`.", "output": "import Combine\nimport Foundation\n\n// Legacy API\nfunc legacyFetchData(completion: @escaping (Result<String, Error>) -> Void) {\n    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n        completion(.success(\"Legacy Data\"))\n    }\n}\n\n// Combine Wrapper\nfunc fetchDataFuture() -> Future<String, Error> {\n    return Future { promise in\n        legacyFetchData { result in\n            switch result {\n            case .success(let data):\n                promise(.success(data))\n            case .failure(let error):\n                promise(.failure(error))\n            }\n        }\n    }\n}\n\n// Usage\nlet cancellable = fetchDataFuture()\n    .sink(receiveCompletion: { _ in }, receiveValue: { print($0) })"}
{"instruction": "Use the `LocalAuthentication` framework in Swift to authenticate a user via FaceID or TouchID before revealing sensitive information.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if hardware is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a custom `UIView` in UIKit that uses a `CABasicAnimation` (Core Animation) to rotate its layer 360 degrees indefinitely.", "output": "import UIKit\n\nclass RotatingView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        self.backgroundColor = .systemBlue\n        startRotation()\n    }\n    \n    private func startRotation() {\n        let rotation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n        rotation.toValue = NSNumber(value: Double.pi * 2)\n        rotation.duration = 2.0\n        rotation.isCumulative = true\n        rotation.repeatCount = Float.greatestFiniteMagnitude\n        self.layer.add(rotation, forKey: \"rotationAnimation\")\n    }\n}"}
{"instruction": "Demonstrate how to access raw bytes of a Swift String safely to interact with a C API that requires a `const char *`.", "output": "import Foundation\n\n// Mock C function\nfunc c_api_function(_ string: UnsafePointer<CChar>) {\n    print(\"Received C string: \\(String(cString: string))\")\n}\n\nfunc passStringToCAPI() {\n    let swiftString = \"Hello, Low Level World\"\n    \n    // Method 1: withCString (Preferred for temporary access)\n    swiftString.withCString { ptr in\n        // ptr is valid only inside this closure\n        c_api_function(ptr)\n    }\n    \n    // Method 2: Array of CChar (if you need a mutable buffer)\n    var cStringArray = swiftString.cString(using: .utf8)!\n    cStringArray.withUnsafeBufferPointer { buffer in\n        if let baseAddress = buffer.baseAddress {\n            c_api_function(baseAddress)\n        }\n    }\n}"}
{"instruction": "Create a Swift function that uses Combine to fetch JSON data from a URL, decode it into a custom `User` model, and return it as an `AnyPublisher`. Ensure the result is delivered on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a ViewController class. The closure is stored in a property and accesses `self`.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n    var status: String = \"Ready\"\n\n    func setupClosure() {\n        // Use [weak self] to capture self weakly\n        onCompletion = { [weak self] in\n            // Safely unwrap self\n            guard let self = self else { return }\n            self.status = \"Completed\"\n            print(self.status)\n        }\n    }\n    \n    deinit {\n        print(\"MyViewController deallocated\")\n    }\n}"}
{"instruction": "Write a SwiftUI view that uses `@StateObject` to manage the lifecycle of a ViewModel conforming to `ObservableObject`. The view should display a counter and a button to increment it.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    \n    func increment() {\n        count += 1\n    }\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the VM is only initialized once per view lifecycle\n    @StateObject private var viewModel = CounterViewModel()\n    \n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Implement a Core Data fetch request in Swift to retrieve all `Employee` entities where the `department` attribute is \"Engineering\", sorted by `hireDate` in descending order.", "output": "import CoreData\n\nfunc fetchEngineeringEmployees(context: NSManagedObjectContext) -> [Employee]? {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    \n    // Set Predicate\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    // Set Sort Descriptor\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"hireDate\", ascending: false)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Failed to fetch employees: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Create an Objective-C class interface for a custom view that defines a delegate protocol. Ensure the delegate property uses the correct memory management attribute to avoid retain cycles.", "output": "@protocol CustomViewDelegate <NSObject>\n- (void)didTapButton;\n@end\n\n@interface CustomView : UIView\n\n// Use 'weak' to prevent retain cycles (delegate holds view, view shouldn't hold delegate strongly)\n@property (nonatomic, weak) id<CustomViewDelegate> delegate;\n\n@end"}
{"instruction": "Using UIKit programmatically (no Storyboards), create a `UIView` subclass that centers a `UILabel` with the text \"Hello World\" using Auto Layout anchors.", "output": "import UIKit\n\nclass CenteredLabelView: UIView {\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    private func setupView() {\n        let label = UILabel()\n        label.text = \"Hello World\"\n        label.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(label)\n        \n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write a Swift `actor` to create a thread-safe image cache. It should have methods to store and retrieve `UIImage` objects by a string key.", "output": "import UIKit\n\nactor ImageCache {\n    private var cache: [String: UIImage] = [:]\n    \n    func setImage(_ image: UIImage, forKey key: String) {\n        cache[key] = image\n    }\n    \n    func getImage(forKey key: String) -> UIImage? {\n        return cache[key]\n    }\n    \n    func clearCache() {\n        cache.removeAll()\n    }\n}"}
{"instruction": "Implement a Combine pipeline that observes a text input publisher (e.g., a search bar), debounces the input for 500 milliseconds, removes duplicates, and filters out empty strings.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Set up a basic Core Data stack in Swift using `NSPersistentContainer`. Include a computed property to access the `viewContext`.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n    \n    private init() {}\n    \n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n    \n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n    \n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Core Location framework, write a Swift class that requests \"When In Use\" authorization and implements the delegate method to receive location updates.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func startTracking() {\n        locationManager.startUpdatingLocation()\n    }\n    \n    // Delegate Method\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Long: \\(location.coordinate.longitude)\")\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            startTracking()\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet using a capture list.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func start() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onComplete = { [weak self] in\n            guard let self = self else { return }\n            self.process(data: self.data)\n        }\n    }\n\n    func process(data: String) {\n        print(\"Processing: \\(data)\")\n    }\n}"}
{"instruction": "Create a Singleton Core Data Stack class in Swift that initializes an NSPersistentContainer.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n\n    let container: NSPersistentContainer\n\n    private init() {\n        container = NSPersistentContainer(name: \"AppModel\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n\n    var context: NSManagedObjectContext {\n        return container.viewContext\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that performs a network request, decodes a JSON response into a struct, and receives the value on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Codable {\n    let id: Int\n    let name: String\n}\n\nvar cancellables = Set<AnyCancellable>()\n\nfunc fetchUser() {\n    guard let url = URL(string: \"https://api.example.com/user\") else { return }\n\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .sink(receiveCompletion: { completion in\n            if case .failure(let error) = completion {\n                print(\"Error: \\(error)\")\n            }\n        }, receiveValue: { user in\n            print(\"Fetched user: \\(user.name)\")\n        })\n        .store(in: &cancellables)\n}"}
{"instruction": "Write a SwiftUI view that uses @FetchRequest to retrieve 'Event' entities from Core Data, sorted by 'creationDate'.", "output": "import SwiftUI\nimport CoreData\n\nstruct EventListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Event.creationDate, ascending: true)],\n        animation: .default)\n    private var events: FetchedResults<Event>\n\n    var body: some View {\n        List {\n            ForEach(events) { event in\n                Text(event.creationDate?.description ?? \"Unknown Date\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a programmatic UI in UIKit (Swift) that centers a 100x100 blue UIView in the center of the ViewController using Auto Layout anchors.", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.backgroundColor = .white\n\n        let boxView = UIView()\n        boxView.backgroundColor = .blue\n        boxView.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(boxView)\n\n        NSLayoutConstraint.activate([\n            boxView.widthAnchor.constraint(equalToConstant: 100),\n            boxView.heightAnchor.constraint(equalToConstant: 100),\n            boxView.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            boxView.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write an Objective-C code snippet that defines a block property and demonstrates the 'Weak-Strong Dance' to avoid a retain cycle when accessing 'self'.", "output": "@interface MyClass : NSObject\n@property (nonatomic, copy) void (^completionBlock)(void);\n@end\n\n@implementation MyClass\n\n- (void)configureBlock {\n    __weak typeof(self) weakSelf = self;\n    self.completionBlock = ^{\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        if (strongSelf) {\n            [strongSelf doSomething];\n        }\n    };\n}\n\n- (void)doSomething {\n    NSLog(@\"Action performed\");\n}\n@end"}
{"instruction": "Using Combine, create a search mechanism that observes a text string, debounces the input for 500ms, and removes duplicates before printing.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Performing search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Create a Swift function that executes a heavy task on a background queue using GCD and updates a UILabel on the main queue upon completion.", "output": "import UIKit\n\nfunc performHeavyTask(label: UILabel) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        // Simulate heavy work\n        let result = \"Calculation Complete\"\n        Thread.sleep(forTimeInterval: 2)\n\n        DispatchQueue.main.async {\n            label.text = result\n        }\n    }\n}"}
{"instruction": "Write a Core Data fetch request in Swift to retrieve 'Task' entities where 'isCompleted' is false, utilizing an NSPredicate.", "output": "import CoreData\n\nfunc fetchIncompleteTasks(context: NSManagedObjectContext) -> [Task] {\n    let fetchRequest: NSFetchRequest<Task> = Task.fetchRequest()\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false))\n    \n    do {\n        let tasks = try context.fetch(fetchRequest)\n        return tasks\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Demonstrate data flow in SwiftUI by creating a Parent View with a State variable and a Child View that modifies it using a Binding.", "output": "import SwiftUI\n\nstruct ParentView: View {\n    @State private var isOn: Bool = false\n\n    var body: some View {\n        VStack {\n            Text(isOn ? \"Switch is ON\" : \"Switch is OFF\")\n            ChildSwitch(toggleState: $isOn)\n        }\n    }\n}\n\nstruct ChildSwitch: View {\n    @Binding var toggleState: Bool\n\n    var body: some View {\n        Toggle(\"Control Parent\", isOn: $toggleState)\n            .padding()\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet where a closure captures 'self'.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func start() {\n        // FIXED: Added [weak self] to the capture list to prevent a strong reference cycle\n        onComplete = { [weak self] in\n            guard let self = self else { return }\n            print(\"Data fetched: \\(self.data)\")\n        }\n    }\n\n    deinit {\n        print(\"DataFetcher deallocated\")\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to perform a background save operation using `NSPersistentContainer`. Ensure the context is saved only if it has changes.", "output": "func saveInBackground(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Create or modify entities here\n        let entity = MyEntity(context: context)\n        entity.timestamp = Date()\n\n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"Background save successful.\")\n            } catch {\n                print(\"Background save failed: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a search query string, debounces it for 500 milliseconds, removes duplicates, and prints the result. Assume the input is a `PassthroughSubject`.", "output": "import Combine\nimport Foundation\n\nvar cancellables = Set<AnyCancellable>()\nlet searchQuerySubject = PassthroughSubject<String, Never>()\n\nsearchQuerySubject\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .sink { query in\n        print(\"Performing search for: \\(query)\")\n    }\n    .store(in: &cancellables)\n\n// Usage example\nsearchQuerySubject.send(\"App\")\nsearchQuerySubject.send(\"Apple\")"}
{"instruction": "Write a SwiftUI View that uses `@FetchRequest` to retrieve a list of `Item` entities from Core Data, sorted by a `createdAt` attribute in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.createdAt, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.name ?? \"Unknown\")\n                }\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n}"}
{"instruction": "Using UIKit (Swift), programmatically center a red `UIView` of size 100x100 within a parent view controller using Auto Layout anchors.", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let boxView = UIView()\n        boxView.backgroundColor = .red\n        boxView.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(boxView)\n        \n        NSLayoutConstraint.activate([\n            boxView.widthAnchor.constraint(equalToConstant: 100),\n            boxView.heightAnchor.constraint(equalToConstant: 100),\n            boxView.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            boxView.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' in Objective-C to avoid a retain cycle inside a block implementation.", "output": "__weak typeof(self) weakSelf = self;\nself.completionBlock = ^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf doSomethingWithData];\n        NSLog(@\"Operation completed for object: %@\", strongSelf);\n    }\n};"}
{"instruction": "Create a Swift function using the Vision framework to perform text recognition (OCR) on a `CGImage`.", "output": "import Vision\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Detected text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform request: \\(error)\")\n    }\n}"}
{"instruction": "Implement a network fetch using Combine's `URLSession.dataTaskPublisher`. Decode a JSON array of `User` structs and handle errors.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUsers() -> AnyPublisher<[User], Error> {\n    let url = URL(string: \"https://api.example.com/users\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map(\\.data)\n        .decode(type: [User].self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write a Swift class conforming to `CLLocationManagerDelegate` that requests 'When In Use' authorization and prints the user's coordinates when updated.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Long: \\(location.coordinate.longitude)\")\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Create a SwiftUI `ObservableObject` View Model that includes a `@Published` property. Update this property using a Combine timer every second.", "output": "import SwiftUI\nimport Combine\n\nclass TimerViewModel: ObservableObject {\n    @Published var counter: Int = 0\n    private var cancellable: AnyCancellable?\n\n    init() {\n        startTimer()\n    }\n\n    func startTimer() {\n        cancellable = Timer.publish(every: 1.0, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak self] _ in\n                self?.counter += 1\n            }\n    }\n    \n    deinit {\n        cancellable?.cancel()\n    }\n}"}
{"instruction": "Create a thread-safe array in Swift using Grand Central Dispatch (GCD) with a concurrent queue and barrier flag to handle concurrent reads and writes.", "output": "class ThreadSafeArray<T> {\n    private var array = [T]()\n    private let queue = DispatchQueue(label: \"com.example.threadSafeArray\", attributes: .concurrent)\n\n    func append(_ element: T) {\n        queue.async(flags: .barrier) {\n            self.array.append(element)\n        }\n    }\n\n    var allElements: [T] {\n        return queue.sync {\n            return array\n        }\n    }\n\n    func remove(at index: Int) {\n        queue.async(flags: .barrier) {\n            guard index < self.array.count else { return }\n            self.array.remove(at: index)\n        }\n    }\n}"}
{"instruction": "Implement a Combine pipeline in Swift that observes a UITextField's text changes, debounces the input for 500ms, removes duplicates, and prints the result.", "output": "import UIKit\nimport Combine\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { text in\n                print(\"Search query: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C method to perform Method Swizzling on `viewWillAppear:` of a UIViewController to log a message every time a view appears.", "output": "#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(log_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        BOOL didAddMethod = class_addMethod(class,\n                                            originalSelector,\n                                            method_getImplementation(swizzledMethod),\n                                            method_getTypeEncoding(swizzledMethod));\n\n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)log_viewWillAppear:(BOOL)animated {\n    [self log_viewWillAppear:animated];\n    NSLog(@\"View Controller Appeared: %@\", self);\n}\n\n@end"}
{"instruction": "Demonstrate how to fix a retain cycle in a Swift closure where a View Controller holds a reference to a ViewModel, and the ViewModel's closure references the View Controller.", "output": "class ViewModel {\n    var onDataUpdated: (() -> Void)?\n    \n    func fetchData() {\n        // Simulate network call\n        onDataUpdated?()\n    }\n}\n\nclass MyViewController: UIViewController {\n    let viewModel = ViewModel()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Fix: Use [weak self] to break the strong reference cycle\n        viewModel.onDataUpdated = { [weak self] in\n            guard let self = self else { return }\n            self.updateUI()\n        }\n        \n        viewModel.fetchData()\n    }\n    \n    func updateUI() {\n        print(\"UI Updated\")\n    }\n}"}
{"instruction": "Create a Core Data stack setup in Swift using `NSPersistentContainer` and provide a function to save the context.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using SwiftUI, create a view that asynchronously loads an image from a URL using `AsyncImage` and handles the placeholder and error states.", "output": "import SwiftUI\n\nstruct RemoteImageView: View {\n    let url: URL?\n\n    var body: some View {\n        AsyncImage(url: url) { phase in\n            switch phase {\n            case .empty:\n                ProgressView()\n            case .success(let image):\n                image\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n            case .failure:\n                Image(systemName: \"photo\")\n                    .foregroundColor(.gray)\n            @unknown default:\n                EmptyView()\n            }\n        }\n        .frame(width: 200, height: 200)\n    }\n}"}
{"instruction": "Write a Swift function using `URLSession` and `async/await` to download JSON data from a URL and decode it into a generic Codable type.", "output": "import Foundation\n\nfunc fetch<T: Decodable>(url: URL) async throws -> T {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    let decoder = JSONDecoder()\n    return try decoder.decode(T.self, from: data)\n}"}
{"instruction": "Perform a background batch insert in Core Data using `NSBatchInsertRequest` to efficiently import a large array of dictionaries into an entity named 'User'.", "output": "import CoreData\n\nfunc batchInsertUsers(dictionaries: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let batchInsert = NSBatchInsertRequest(entityName: \"User\", objects: dictionaries)\n        \n        do {\n            let result = try context.execute(batchInsert) as? NSBatchInsertResult\n            if let success = result?.result as? Bool, success {\n                print(\"Batch insert successful\")\n            }\n        } catch {\n            print(\"Batch insert failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Use Core Animation (CALayer) in Swift to create a repeating pulse animation on a UIView's layer.", "output": "import UIKit\n\nextension UIView {\n    func addPulseAnimation() {\n        let pulseAnimation = CABasicAnimation(keyPath: \"transform.scale\")\n        pulseAnimation.duration = 1.0\n        pulseAnimation.fromValue = 1.0\n        pulseAnimation.toValue = 1.2\n        pulseAnimation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)\n        pulseAnimation.autoreverses = true\n        pulseAnimation.repeatCount = .infinity\n        \n        self.layer.add(pulseAnimation, forKey: \"pulse\")\n    }\n}"}
{"instruction": "Implement a SwiftUI View that uses `@StateObject` to observe a ViewModel conforming to `ObservableObject`, which fetches data and updates a `@Published` property.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n\n    func increment() {\n        count += 1\n    }\n}\n\nstruct CounterView: View {\n    // Owns the lifecycle of the ViewModel\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n                .font(.largeTitle)\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Prevent a strong reference cycle (memory leak) in a Swift closure within a class.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"Raw Data\"\n\n    func startFetching() {\n        // Use [weak self] to capture self weakly, preventing a retain cycle\n        // since the closure is owned by self, and self would be owned by the closure.\n        onComplete = { [weak self] in\n            guard let self = self else { return }\n            print(\"Data processed: \\(self.data)\")\n        }\n    }\n\n    deinit {\n        print(\"DataFetcher is being deallocated\")\n    }\n}"}
{"instruction": "Implement a background save operation using Core Data's `performBackgroundTask` to avoid blocking the UI.", "output": "func saveUser(name: String, email: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = UserEntity(context: context)\n        user.name = name\n        user.email = email\n        user.id = UUID()\n\n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"User saved successfully on background thread.\")\n            } catch {\n                print(\"Failed to save user: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline for a search bar that debounces input and removes duplicates before making a network call.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[NetworkManager alloc] init];\n        // Additional initialization here\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Use SwiftUI's `@FetchRequest` with an `NSPredicate` and `NSSortDescriptor` to display Core Data entities.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    // FetchRequest automatically updates the view when data changes\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: true)],\n        predicate: NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false)),\n        animation: .default)\n    private var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        List(tasks) { task in\n            Text(task.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Implement a generic network fetcher using Combine that decodes JSON into a Decodable type.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Use LocalAuthentication (FaceID/TouchID) to verify a user's identity in Swift.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Use an `autoreleasepool` to manage memory usage inside a loop creating many temporary objects (Objective-C or Swift).", "output": "// Swift Implementation\nfunc processHeavyData() {\n    for i in 0..<10000 {\n        // Using autoreleasepool ensures temporary objects created inside the loop\n        // are released immediately after each iteration, preventing memory spikes.\n        autoreleasepool {\n            let image = UIImage(named: \"heavy_image_\\(i)\")\n            let processed = image?.jpegData(compressionQuality: 0.5)\n            print(\"Processed image \\(i): \\(String(describing: processed?.count))\")\n        }\n    }\n}"}
{"instruction": "Create a custom `UIView` in UIKit that uses a `CAGradientLayer` for its background.", "output": "import UIKit\n\nclass GradientView: UIView {\n    override class var layerClass: AnyClass {\n        return CAGradientLayer.self\n    }\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupGradient()\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupGradient()\n    }\n\n    private func setupGradient() {\n        guard let gradientLayer = self.layer as? CAGradientLayer else { return }\n        gradientLayer.colors = [UIColor.blue.cgColor, UIColor.purple.cgColor]\n        gradientLayer.startPoint = CGPoint(x: 0, y: 0)\n        gradientLayer.endPoint = CGPoint(x: 1, y: 1)\n    }\n}"}
{"instruction": "Implement a Core Data Batch Delete Request to remove all records of a specific entity efficiently.", "output": "import CoreData\n\nfunc deleteAllLogs(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let fetchRequest: NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName: \"LogEntity\")\n        \n        // Create Batch Delete Request\n        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n        \n        do {\n            // Use execute instead of save for batch operations\n            try context.execute(deleteRequest)\n            // Merge changes if necessary, though batch deletes operate directly on the store\n            try context.save()\n        } catch {\n            print(\"Batch delete failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Swift class named `ImageLoader` with a closure property `onImageLoaded`. Implement a method `downloadImage` that simulates a network delay and calls the closure. In the usage example, assign a closure that references `self` (assuming `ImageLoader` is owned by a ViewController) and use a capture list to prevent a strong reference cycle (memory leak).", "output": "class ImageLoader {\n    var onImageLoaded: ((UIImage?) -> Void)?\n\n    func downloadImage() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {\n            let image = UIImage(systemName: \"photo\")\n            DispatchQueue.main.async {\n                self.onImageLoaded?(image)\n            }\n        }\n    }\n}\n\nclass ViewController: UIViewController {\n    let loader = ImageLoader()\n    var loadedImage: UIImage?\n\n    func startDownload() {\n        // [weak self] prevents the retain cycle here\n        loader.onImageLoaded = { [weak self] image in\n            guard let self = self else { return }\n            self.loadedImage = image\n            print(\"Image loaded: \\(String(describing: image))\")\n        }\n        loader.downloadImage()\n    }\n}"}
{"instruction": "Using Core Data in Swift, write a function that performs a background task to batch insert 1,000 `LogEntry` entities (assuming attributes `timestamp` and `message`) into the persistent container to avoid blocking the main UI thread.", "output": "func saveLogsInBackground(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        for i in 0..<1000 {\n            let log = LogEntry(context: context)\n            log.timestamp = Date()\n            log.message = \"Log entry #\\(i)\"\n        }\n\n        do {\n            try context.save()\n            print(\"Successfully saved logs in background context.\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a Combine pipeline in Swift using `URLSession` to fetch data from a URL. The pipeline should map the data to a custom `User` struct (Decodable), handle errors by replacing them with a default value, and receive the result on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(url: URL) -> AnyPublisher<User, Never> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .replaceError(with: User(id: 0, name: \"Unknown\")) // Error handling\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C code snippet that centers a `UIView` (redView) inside its superview using programmatic Auto Layout (NSLayoutConstraint). Ensure `translatesAutoresizingMaskIntoConstraints` is set correctly.", "output": "UIView *redView = [[UIView alloc] init];\nredView.backgroundColor = [UIColor redColor];\n[self.view addSubview:redView];\n\n// Disable autoresizing mask\nredView.translatesAutoresizingMaskIntoConstraints = NO;\n\n[NSLayoutConstraint activateConstraints:@[\n    [redView.widthAnchor constraintEqualToConstant:100],\n    [redView.heightAnchor constraintEqualToConstant:100],\n    [redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],\n    [redView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor]\n]];"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to retrieve `TaskEntity` objects from Core Data, sorted by `createdAt` in descending order. Display the title of each task in a List.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: false)],\n        animation: .default)\n    private var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    Text(task.title ?? \"Untitled\")\n                }\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' in Objective-C to avoid a retain cycle when accessing `self` inside a block property of the same class.", "output": "self.completionBlock = ^{\n    // Weak reference to break the cycle\n    __weak typeof(self) weakSelf = self;\n    \n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        // Strong reference to ensure self stays alive during execution\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        \n        if (strongSelf) {\n            [strongSelf processData];\n            NSLog(@\"Processed data in: %@\", strongSelf);\n        }\n    });\n};"}
{"instruction": "Using the Vision framework in Swift, create a function `recognizeText` that takes a `CGImage` and performs text recognition. Print the recognized strings to the console.", "output": "import Vision\n\nfunc recognizeText(from image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed: \\(String(describing: error))\")\n            return\n        }\n        \n        for observation in observations {\n            // Get top candidate\n            if let candidate = observation.topCandidates(1).first {\n                print(\"Recognized text: \\(candidate.string)\")\n            }\n        }\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform request: \\(error)\")\n    }\n}"}
{"instruction": "Create a Swift `ViewModel` that conforms to `ObservableObject`. It should have a `@Published` property `searchQuery` and a `searchResults` property. Use Combine to debounce the search query input by 500ms and remove duplicates before triggering a mock search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchQuery: String = \"\"\n    @Published var searchResults: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        // Mock search logic\n        print(\"Searching for: \\(query)\")\n        self.searchResults = [\"Result for \\(query)\"]\n    }\n}"}
{"instruction": "Write a Swift function using `CoreLocation` that requests 'When In Use' authorization and sets up the `CLLocationManager` delegate to receive location updates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestLocationAccess() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func startTracking() {\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Current location: \\(location.coordinate.latitude), \\(location.coordinate.longitude)\")\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Implement a Combine publisher chain in Swift that attempts a network request. If the request fails, it should retry up to 3 times before finally catching the error and returning a placeholder value.", "output": "import Combine\nimport Foundation\n\nfunc fetchDataWithRetry(url: URL) -> AnyPublisher<Data, Never> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .retry(3) // Retry logic\n        .catch { error -> Just<Data> in\n            print(\"Request failed after retries: \\(error)\")\n            return Just(Data()) // Return empty data on failure\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: ((String) -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in \n            // Fix: Use [weak self] to break the retain cycle\n            guard let self = self else { return }\n            let result = \"Fetched Data\"\n            self.data = result\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?(result)\n            }\n        }\n    }\n}"}
{"instruction": "Create a function in Swift using Core Data to save a new 'User' entity with a 'name' attribute on a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc saveUser(name: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = NSEntityDescription.insertNewObject(forEntityName: \"User\", into: context)\n        user.setValue(name, forKey: \"name\")\n        \n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that takes a URL, fetches data, decodes it into a generic 'Decodable' type, and returns an 'AnyPublisher'.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C code snippet that demonstrates how to manage memory efficiently when creating a large number of temporary objects inside a loop.", "output": "NSArray *largeDataArray = [self getLargeDataSet];\n\nfor (id dataObject in largeDataArray) {\n    @autoreleasepool {\n        // By using @autoreleasepool inside the loop, temporary objects\n        // created here are released at the end of each iteration,\n        // preventing memory spikes.\n        NSString *processedString = [[NSString alloc] initWithFormat:@\"Processed: %@\", dataObject];\n        [self handleString:processedString];\n    }\n}"}
{"instruction": "Implement a SwiftUI View Model using Combine that debounces a search text input to prevent excessive API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // API call logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using UIKit and the Native FileManager, write a Swift function to save a UIImage to the user's Documents directory.", "output": "import UIKit\n\nfunc saveImageToDocuments(_ image: UIImage, fileName: String) -> URL? {\n    guard let data = image.jpegData(compressionQuality: 0.8) else { return nil }\n    \n    let fileManager = FileManager.default\n    guard let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return nil }\n    \n    let fileURL = documentsURL.appendingPathComponent(fileName)\n    \n    do {\n        try data.write(to: fileURL)\n        return fileURL\n    } catch {\n        print(\"Error saving file: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Create a Swift class structure demonstrating the use of 'unowned' to prevent strong reference cycles between a 'Customer' and a 'CreditCard', where a card cannot exist without a customer.", "output": "class Customer {\n    let name: String\n    var card: CreditCard?\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass CreditCard {\n    let number: String\n    // unowned is used here because a CreditCard is always assumed to have a Customer\n    // and the Customer outlives the CreditCard.\n    unowned let customer: Customer\n    \n    init(number: String, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n}"}
{"instruction": "Using the native MetricKit framework, implement a basic subscriber to listen for daily power and performance metrics.", "output": "import MetricKit\n\nclass AppMetricManager: NSObject, MXMetricManagerSubscriber {\n    \n    static let shared = AppMetricManager()\n    \n    private override init() {\n        super.init()\n        MXMetricManager.shared.add(self)\n    }\n    \n    func didReceive(_ payloads: [MXMetricPayload]) {\n        for payload in payloads {\n            // Process daily metrics (e.g., send to server)\n            if let memoryMetrics = payload.memoryMetrics {\n                print(\"Peak Memory Usage: \\(memoryMetrics.peakMemoryUsage)\")\n            }\n        }\n    }\n    \n    deinit {\n        MXMetricManager.shared.remove(self)\n    }\n}"}
{"instruction": "Write a Swift function using Core Image to apply a Sepia Tone filter to a given UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Using UIKit and Core Graphics, create a UIView subclass that draws a red circle in the center of the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Identify and fix the memory leak (retain cycle) in the following Swift closure where a ViewModel updates a property after a network call.", "output": "class DataViewModel {\n    var data: String = \"\"\n    let service = NetworkService()\n\n    func fetchData() {\n        // Fix: Added [weak self] to capture list to prevent strong reference cycle\n        service.requestData { [weak self] result in\n            guard let self = self else { return }\n            self.data = result\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to fetch all 'Employee' entities where the 'department' attribute equals 'Engineering', sorted by 'hireDate' in descending order.", "output": "import CoreData\n\nfunc fetchEngineeringEmployees(context: NSManagedObjectContext) -> [Employee]? {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    \n    // Predicate to filter by department\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    // Sort descriptor for hireDate descending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"hireDate\", ascending: false)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that takes a publisher of Strings (e.g., from a search text field), waits for 500ms of inactivity (debounce), removes duplicate consecutive values, and prints the result.", "output": "import Combine\nimport Foundation\n\nvar cancellables = Set<AnyCancellable>()\nlet searchTextPublisher = PassthroughSubject<String, Never>()\n\nsearchTextPublisher\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .sink { searchText in\n        print(\"Searching for: \\(searchText)\")\n    }\n    .store(in: &cancellables)"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "// NetworkManager.h\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n// NetworkManager.m\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a SwiftUI view that uses `GeometryReader` to draw a Rectangle that is exactly one-third the width of the screen and centered.", "output": "import SwiftUI\n\nstruct ThirdWidthView: View {\n    var body: some View {\n        GeometryReader { geometry in\n            Rectangle()\n                .fill(Color.blue)\n                .frame(width: geometry.size.width / 3)\n                .position(x: geometry.size.width / 2, y: geometry.size.height / 2)\n        }\n        .edgesIgnoringSafeArea(.all)\n    }\n}"}
{"instruction": "Write a function using the `LocalAuthentication` framework to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access your account\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication successful\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometrics not available\")\n    }\n}"}
{"instruction": "Use `DispatchGroup` to perform two independent asynchronous network simulations and print 'Finished' only when both are complete.", "output": "import Foundation\n\nlet group = DispatchGroup()\n\n// Task 1\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n    print(\"Task 1 complete\")\n    group.leave()\n}\n\n// Task 2\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n    print(\"Task 2 complete\")\n    group.leave()\n}\n\n// Notify when both are done\ngroup.notify(queue: .main) {\n    print(\"Finished: Both tasks complete\")\n}"}
{"instruction": "Create a Swift `Actor` to manage a bank account balance safely in a concurrent environment.", "output": "actor BankAccount {\n    private var balance: Double = 0.0\n\n    func deposit(amount: Double) {\n        balance += amount\n    }\n\n    func withdraw(amount: Double) -> Double? {\n        if balance >= amount {\n            balance -= amount\n            return balance\n        } else {\n            return nil\n        }\n    }\n\n    func currentBalance() -> Double {\n        return balance\n    }\n}"}
{"instruction": "Implement a `UIView` subclass that uses Core Graphics (`draw(_:)`) to draw a red circle centered in the view.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let diameter = min(rect.width, rect.height) * 0.8\n        let x = (rect.width - diameter) / 2\n        let y = (rect.height - diameter) / 2\n        let circleRect = CGRect(x: x, y: y, width: diameter, height: diameter)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Write a function to securely save a password to the iOS Keychain using the Security framework.", "output": "import Security\nimport Foundation\n\nfunc savePassword(service: String, account: String, data: Data) -> OSStatus {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrService as String: service,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: data\n    ]\n    \n    // Delete any existing item to ensure update\n    SecItemDelete(query as CFDictionary)\n    \n    // Add the new item\n    return SecItemAdd(query as CFDictionary, nil)\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift class where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var completionHandler: (() -> Void)?\n    var data: Data?\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async {\n            let result = Data()\n            DispatchQueue.main.async {\n                // FIX: Use [weak self] to prevent strong reference cycle\n                self.completionHandler = { [weak self] in\n                    guard let self = self else { return }\n                    self.data = result\n                    self.processData()\n                }\n                self.completionHandler?()\n            }\n        }\n    }\n\n    func processData() {\n        print(\"Data processed\")\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses @FetchRequest to retrieve 'Task' entities from Core Data, sorted by a 'createdAt' date attribute in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    // Initialize the fetch request with a sort descriptor\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Task.createdAt, ascending: false)],\n        animation: .default)\n    private var tasks: FetchedResults<Task>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    Text(task.title ?? \"Untitled\")\n                }\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that takes a text input publisher (e.g., from a search bar), debounces it for 500 milliseconds, removes duplicate consecutive values, and filters out empty strings.", "output": "import Combine\nimport Foundation\n\nfunc setupSearchSubscription(publisher: AnyPublisher<String, Never>) -> AnyCancellable {\n    return publisher\n        .debounce(for: .milliseconds(500), scheduler: RunLoop.main) // Wait 500ms for pause\n        .removeDuplicates() // Ignore if same as previous value\n        .filter { !$0.isEmpty } // Ignore empty strings\n        .sink { searchText in\n            print(\"Perform search for: \\(searchText)\")\n        }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedManager = nil;\n    static dispatch_once_t onceToken;\n    \n    // dispatch_once ensures the block is run only once for the lifetime of the app\n    dispatch_once(&onceToken, ^{\n        sharedManager = [[self alloc] init];\n    });\n    \n    return sharedManager;\n}\n\n@end"}
{"instruction": "Create a custom UIView subclass in Swift that draws a red circle centered in the view using Core Graphics within the draw(_:) method.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        // Calculate center and radius\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10 // 10pt padding\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Create the circle path\n        let circlePath = UIBezierPath(arcCenter: center,\n                                      radius: radius,\n                                      startAngle: 0,\n                                      endAngle: CGFloat.pi * 2,\n                                      clockwise: true)\n        \n        // Fill the path\n        circlePath.fill()\n    }\n}"}
{"instruction": "Write a function using Swift Concurrency (async/await) to fetch data from a URL, decoding it into a generic Codable type.", "output": "import Foundation\n\nfunc fetchData<T: Decodable>(from url: URL) async throws -> T {\n    // Use async URLSession API\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    // Decode the data\n    let decodedData = try JSONDecoder().decode(T.self, from: data)\n    return decodedData\n}"}
{"instruction": "Set up a Core Data stack in Swift by initializing an NSPersistentContainer and loading the persistent stores.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n    \n    lazy var persistentContainer: NSPersistentContainer = {\n        // Initialize container with the name of the Data Model file\n        let container = NSPersistentContainer(name: \"MyDataModel\")\n        \n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                // Handle error appropriately in production (logging, alert, etc.)\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        \n        // Merge policies for conflict resolution\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        return container\n    }()\n    \n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n}"}
{"instruction": "Create a function using Core Image to apply a Sepia Tone filter to a UIImage.", "output": "import UIKit\nimport CoreImage\nimport CoreImage.CIFilterBuiltins\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let inputImage = CIImage(image: image) else { return nil }\n    \n    let context = CIContext()\n    let filter = CIFilter.sepiaTone()\n    \n    filter.inputImage = inputImage\n    filter.intensity = 1.0 // Full sepia effect\n    \n    guard let outputImage = filter.outputImage,\n          let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else {\n        return nil\n    }\n    \n    return UIImage(cgImage: cgImage)\n}"}
{"instruction": "Implement a LocationManager class using Core Location that requests 'When In Use' authorization and handles location updates.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n    \n    func requestLocationAccess() {\n        // Check authorization status before requesting\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func startTracking() {\n        locationManager.startUpdatingLocation()\n    }\n    \n    // Delegate method: Handle location updates\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Long: \\(location.coordinate.longitude)\")\n    }\n    \n    // Delegate method: Handle errors\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Bind a UITextField's text property to a ViewModel's @Published property using Combine in a UIKit ViewController.", "output": "import UIKit\nimport Combine\n\nclass ViewModel {\n    @Published var searchQuery: String = \"\"\n}\n\nclass SearchViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    var viewModel = ViewModel()\n    var cancellables = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Bind UITextField text changes to ViewModel\n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .assign(to: \\.searchQuery, on: viewModel)\n            .store(in: &cancellables)\n            \n        // Verify binding (Optional: print changes from VM)\n        viewModel.$searchQuery\n            .sink { print(\"ViewModel updated: \\($0)\") }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Demonstrate how to prevent a strong reference cycle (memory leak) in Swift when using a closure within a View Controller to handle a network response.", "output": "class UserProfileViewController: UIViewController {\n    let networkService = NetworkService()\n    var userData: User?\n\n    func fetchProfile() {\n        // Use [weak self] to break the strong reference cycle\n        networkService.fetchData { [weak self] result in\n            // Guard against self being nil (view controller deallocated)\n            guard let self = self else { return }\n            \n            switch result {\n            case .success(let user):\n                // Dispatch UI updates to the main thread\n                DispatchQueue.main.async {\n                    self.userData = user\n                    self.updateUI()\n                }\n            case .failure(let error):\n                print(error.localizedDescription)\n            }\n        }\n    }\n\n    func updateUI() {\n        // UI update logic\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to perform a batch insert of objects on a background context to avoid blocking the main UI thread.", "output": "func saveLogs(messages: [String], container: NSPersistentContainer) {\n    // Use performBackgroundTask to automatically create and manage a background context\n    container.performBackgroundTask { context in\n        for message in messages {\n            let log = LogEntity(context: context)\n            log.message = message\n            log.timestamp = Date()\n        }\n        \n        do {\n            try context.save()\n            print(\"Background save successful.\")\n        } catch {\n            print(\"Failed to save logs: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a simple Combine pipeline in Swift that fetches JSON data from a URL, decodes it into a struct, and handles errors.", "output": "import Combine\nimport Foundation\n\nstruct Todo: Decodable {\n    let id: Int\n    let title: String\n}\n\nclass DataFetcher {\n    var cancellables = Set<AnyCancellable>()\n\n    func fetchTodo() {\n        let url = URL(string: \"https://jsonplaceholder.typicode.com/todos/1\")!\n\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data } // Extract data\n            .decode(type: Todo.self, decoder: JSONDecoder()) // Decode JSON\n            .receive(on: DispatchQueue.main) // Switch to main thread for UI work\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .finished:\n                    print(\"Finished\")\n                case .failure(let error):\n                    print(\"Error: \\(error)\")\n                }\n            }, receiveValue: { todo in\n                print(\"Received Todo: \\(todo.title)\")\n            })\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton in Objective-C using `dispatch_once`.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n        // Additional initialization if needed\n    });\n    \n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Using SwiftUI, create a view that observes a `ViewModel` conforming to `ObservableObject` and displays a text field that updates a published property.", "output": "import SwiftUI\n\nclass UserSettings: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct SettingsView: View {\n    // StateObject owns the ObservableObject\n    @StateObject private var settings = UserSettings()\n\n    var body: some View {\n        VStack {\n            Text(\"Current User: \\(settings.username)\")\n            \n            // Binding to the published property\n            TextField(\"Enter username\", text: $settings.username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n        }\n    }\n}"}
{"instruction": "Write a UIKit function using Auto Layout anchors programmatically to center a red square view (100x100) inside a parent view.", "output": "import UIKit\n\nfunc addCenteredView(to parentView: UIView) {\n    let redView = UIView()\n    redView.backgroundColor = .red\n    redView.translatesAutoresizingMaskIntoConstraints = false // Vital for programmatic Auto Layout\n    \n    parentView.addSubview(redView)\n    \n    NSLayoutConstraint.activate([\n        redView.widthAnchor.constraint(equalToConstant: 100),\n        redView.heightAnchor.constraint(equalToConstant: 100),\n        redView.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n        redView.centerYAnchor.constraint(equalTo: parentView.centerYAnchor)\n    ])\n}"}
{"instruction": "Using Swift's concurrency model (Actors), create a thread-safe `Counter` actor to prevent data races when incrementing a value from multiple threads.", "output": "actor Counter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage Example\nlet counter = Counter()\n\nTask {\n    await counter.increment()\n    let currentValue = await counter.getValue()\n    print(\"Count is \\(currentValue)\")\n}"}
{"instruction": "Implement a Combine pipeline to debounce user input from a search bar, ensuring an API call is only made after the user stops typing for 500 milliseconds.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main) // Wait for pause\n            .removeDuplicates() // Ignore if query hasn't changed\n            .filter { !$0.isEmpty } // Ignore empty strings\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Use the Core Image framework in Swift to apply a Sepia Tone filter to a `UIImage`.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext()\n    // Create CGImage from CIImage\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Use the Core Motion framework to start receiving accelerometer updates on a specific operation queue.", "output": "import CoreMotion\n\nlet motionManager = CMMotionManager()\n\nfunc startAccelerometer() {\n    if motionManager.isAccelerometerAvailable {\n        motionManager.accelerometerUpdateInterval = 0.1\n        \n        motionManager.startAccelerometerUpdates(to: OperationQueue.main) { (data, error) in\n            guard let data = data, error == nil else { return }\n            \n            let x = data.acceleration.x\n            let y = data.acceleration.y\n            let z = data.acceleration.z\n            \n            print(\"X: \\(x), Y: \\(y), Z: \\(z)\")\n        }\n    }\n}"}
{"instruction": "Create a Swift function using Combine to fetch a JSON array of 'User' objects from a URL. The function should decode the data, handle errors by returning an empty array, and receive the result on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nclass UserService {\n    var cancellables = Set<AnyCancellable>()\n\n    func fetchUsers() -> AnyPublisher<[User], Never> {\n        let url = URL(string: \"https://api.example.com/users\")!\n        \n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: [User].self, decoder: JSONDecoder())\n            .replaceError(with: []) // Handle errors by returning empty array\n            .receive(on: DispatchQueue.main) // Switch to main thread\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Demonstrate how to prevent a Retain Cycle in an Objective-C block by creating a weak reference to 'self'.", "output": "#import \"MyViewController.h\"\n\n@interface MyViewController ()\n@property (nonatomic, strong) void (^completionHandler)(void);\n@end\n\n@implementation MyViewController\n\n- (void)setupBlock {\n    __weak typeof(self) weakSelf = self;\n    \n    self.completionHandler = ^{\n        // Use the strong reference inside the block to ensure self exists during execution\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        if (strongSelf) {\n            [strongSelf doSomething];\n        }\n    };\n}\n\n- (void)doSomething {\n    NSLog(@\"Action performed without retain cycle.\");\n}\n\n@end"}
{"instruction": "Implement a SwiftUI View that uses `@FetchRequest` to retrieve 'Item' entities from Core Data, sorted by 'timestamp' in descending order, and displays them in a List.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.timestamp?.description ?? \"Unknown Date\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Write a Swift class that performs a background Core Data save operation using `performBackgroundTask` to avoid blocking the main thread.", "output": "import CoreData\n\nclass CoreDataManager {\n    let persistentContainer: NSPersistentContainer\n\n    init(container: NSPersistentContainer) {\n        self.persistentContainer = container\n    }\n\n    func saveNewDataInBackground(name: String) {\n        persistentContainer.performBackgroundTask { context in\n            let entity = MyEntity(context: context)\n            entity.name = name\n            entity.createdAt = Date()\n\n            do {\n                try context.save()\n                print(\"Saved successfully on background context.\")\n            } catch {\n                print(\"Failed to save: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Swift ViewModel using Combine that debounces a search text input to prevent excessive API calls. The search should only trigger 500ms after the user stops typing.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        print(\"API Call for: \\(query)\")\n        // Mock result\n        self.results = [\"Result for \\(query)\"]\n    }\n}"}
{"instruction": "Define a Swift protocol for a delegate and implement a class that holds a `weak` reference to that delegate to prevent strong reference cycles.", "output": "import Foundation\n\n// 1. Restrict protocol to classes so it can be weak\nprotocol DataProviderDelegate: AnyObject {\n    func didReceiveData(_ data: String)\n}\n\nclass DataProvider {\n    // 2. Use weak to break potential retain cycle\n    weak var delegate: DataProviderDelegate?\n\n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            let data = \"Fetched Data\"\n            DispatchQueue.main.async {\n                // 3. safely unwrap or optional chain\n                self.delegate?.didReceiveData(data)\n            }\n        }\n    }\n}"}
{"instruction": "Use UIKit's `UITableViewDiffableDataSource` to update a table view with a list of strings in a typesafe manner.", "output": "import UIKit\n\nclass ListViewController: UITableViewController {\n    enum Section { case main }\n    var dataSource: UITableViewDiffableDataSource<Section, String>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\")\n        configureDataSource()\n        updateSnapshot(with: [\"Apple\", \"Banana\", \"Cherry\"])\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n            return cell\n        }\n    }\n\n    func updateSnapshot(with items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Implement a Swift class using `CLLocationManager` to request 'When In Use' authorization and print the user's current coordinates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestLocation() {\n        // Check authorization status (iOS 14+)\n        if locationManager.authorizationStatus == .notDetermined {\n            locationManager.requestWhenInUseAuthorization()\n        } else {\n            locationManager.requestLocation()\n        }\n    }\n\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        if manager.authorizationStatus == .authorizedWhenInUse || manager.authorizationStatus == .authorizedAlways {\n            manager.requestLocation()\n        }\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        if let location = locations.first {\n            print(\"Lat: \\(location.coordinate.latitude), Lon: \\(location.coordinate.longitude)\")\n        }\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Demonstrate the proper usage of `[weak self]` in a Swift closure to safely update a UIViewController's label after a delay, avoiding a memory leak.", "output": "import UIKit\n\nclass DetailViewController: UIViewController {\n    @IBOutlet weak var statusLabel: UILabel!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        performHeavyTask()\n    }\n\n    func performHeavyTask() {\n        // Simulate async operation\n        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Capture self weakly to allow deallocation if the VC is popped before this runs\n            guard let self = self else { return }\n            \n            let result = \"Task Complete\"\n            \n            DispatchQueue.main.async {\n                // Update UI on main thread\n                self.statusLabel.text = result\n            }\n        }\n    }\n}"}
{"instruction": "Create a Core Data stack setup in Swift that enables `viewContext.automaticallyMergesChangesFromParent` to ensure UI updates when background contexts save data.", "output": "import CoreData\n\nclass PersistenceController {\n    static let shared = PersistenceController()\n\n    let container: NSPersistentContainer\n\n    init() {\n        container = NSPersistentContainer(name: \"MyAppModel\")\n        \n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        \n        // Critical for updating SwiftUI views or NSFetchedResultsController \n        // when changes happen on a background thread\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        \n        // Optional: Resolve conflicts in favor of the in-memory version\n        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onDataLoaded: (() -> Void)?\n    var dataProvider = DataProvider()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Fix: Use [weak self] to break the retain cycle\n        dataProvider.fetchData { [weak self] in\n            guard let self = self else { return }\n            self.handleData()\n        }\n    }\n\n    func handleData() {\n        print(\"Data handled\")\n    }\n}"}
{"instruction": "Create a function using Core Data in Swift to save an array of user names to a background context to avoid blocking the main thread.", "output": "func saveUserNames(_ names: [String], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        for name in names {\n            let userEntity = User(context: context)\n            userEntity.name = name\n        }\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that fetches JSON from a URL, decodes it into a struct 'User', and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' in Objective-C to prevent a retain cycle inside a block.", "output": "__weak typeof(self) weakSelf = self;\n[self.dataManager fetchDataWithCompletion:^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf updateUI];\n    }\n}];"}
{"instruction": "Create a SwiftUI ViewModel using Combine that listens to a search text publisher, debounces the input by 0.5 seconds, and updates a results array.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // Mock search logic\n        self.results = [\"Result for \\(query)\"]\n    }\n}"}
{"instruction": "Implement a custom UIView in Swift that uses Core Graphics (draw method) to draw a red circle centered in the view.", "output": "class RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let radius = min(rect.width, rect.height) / 2\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Create a Swift class exposing a delegate protocol that can be used by Objective-C code.", "output": "@objc protocol DataDelegate: AnyObject {\n    func didReceiveData(_ data: String)\n}\n\nclass DataManager: NSObject {\n    @objc weak var delegate: DataDelegate?\n    \n    @objc func process() {\n        // Logic...\n        delegate?.didReceiveData(\"Success\")\n    }\n}"}
{"instruction": "Using Swift Concurrency (Async/Await), write a function to download an image from a URL and return a UIImage.", "output": "import UIKit\n\nfunc downloadImage(from url: URL) async throws -> UIImage? {\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return UIImage(data: data)\n}"}
{"instruction": "Write a function using FileManager in Swift to save a text string to a file named 'log.txt' in the user's Documents directory.", "output": "func saveLog(_ text: String) {\n    guard let documentDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }\n    let fileURL = documentDirectory.appendingPathComponent(\"log.txt\")\n    \n    do {\n        try text.write(to: fileURL, atomically: true, encoding: .utf8)\n        print(\"Saved to \\(fileURL.path)\")\n    } catch {\n        print(\"Error saving file: \\(error)\")\n    }\n}"}
{"instruction": "Setup a CLLocationManager in Swift to request 'When In Use' authorization and handle the delegate method for authorization changes.", "output": "import CoreLocation\n\nclass LocationHandler: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Permission granted\")\n        case .denied, .restricted:\n            print(\"Permission denied\")\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (retain cycle) in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        onDataFetched = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            print(self.data)\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that saves a new 'LogEntry' entity with a 'message' attribute using a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc saveLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let entry = NSEntityDescription.insertNewObject(forEntityName: \"LogEntry\", into: context)\n        entry.setValue(message, forKey: \"message\")\n        entry.setValue(Date(), forKey: \"timestamp\")\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a function using the Combine framework that performs a network request, decodes the JSON into a generic 'Codable' type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "In Objective-C, implement a 'Person' class with a property 'name'. Override the 'dealloc' method to log a message when the object is released from memory, verifying proper ARC behavior.", "output": "@interface Person : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n\n@implementation Person\n\n- (void)dealloc {\n    NSLog(@\"%@ is being deallocated\", _name);\n    // Note: [super dealloc] is called automatically by ARC\n}\n\n@end"}
{"instruction": "Define a Swift protocol named 'NetworkDelegate' restricted to classes, and implement a 'NetworkManager' class that holds a delegate property weakly to prevent memory leaks.", "output": "protocol NetworkDelegate: AnyObject {\n    func didReceiveData(_ data: Data)\n}\n\nclass NetworkManager {\n    // weak keyword is crucial here to prevent retain cycles\n    weak var delegate: NetworkDelegate?\n    \n    func completeRequest(with data: Data) {\n        delegate?.didReceiveData(data)\n    }\n}"}
{"instruction": "Construct a Core Data 'NSFetchRequest' in Swift for an entity named 'Task'. The request should filter for tasks where 'isCompleted' is false and sort them by 'dueDate' in ascending order.", "output": "import CoreData\n\nfunc makeIncompleteTasksFetchRequest() -> NSFetchRequest<NSManagedObject> {\n    let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: \"Task\")\n    \n    // Predicate: isCompleted == false\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false))\n    \n    // Sort Descriptor: Ascending by dueDate\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"dueDate\", ascending: true)]\n    \n    return fetchRequest\n}"}
{"instruction": "Use SwiftUI and Combine to create a view model that holds a 'searchQuery' string. Debounce the input by 0.5 seconds before triggering a search action to optimize API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchQuery: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchQuery\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using Native Core Graphics in a UIView subclass, override the 'draw(_:)' method to draw a blue circle centered in the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.blue.cgColor)\n        \n        // Calculate center and radius\n        let radius = min(rect.width, rect.height) / 2\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        \n        // Add Arc\n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Use Apple's native CryptoKit framework to write a Swift function that accepts a string, computes its SHA256 hash, and returns the hexadecimal string representation.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashStringSHA256(input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    \n    // Convert digest to hex string\n    return digest.map { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Implement a SwiftUI View that uses '@FetchRequest' to retrieve 'Item' entities from Core Data, displaying them in a List.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n            }\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Write a Swift class that demonstrates how to prevent a strong reference cycle (retain cycle) when a closure captures `self`. The closure should update a property on `self` after a delay.", "output": "class DataFetcher {\n    var data: String = \"\"\n    \n    func fetchData() {\n        // Use [weak self] to prevent a strong reference cycle\n        let workItem = DispatchWorkItem { [weak self] in\n            // Safely unwrap self to ensure it still exists\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            print(\"Data updated: \\(self.data)\")\n        }\n        \n        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0, execute: workItem)\n    }\n    \n    deinit {\n        print(\"DataFetcher is being deinitialized\")\n    }\n}"}
{"instruction": "Using Core Data in Swift, write a function that performs a background save of a new 'LogEntry' entity using `NSPersistentContainer`'s `performBackgroundTask` method.", "output": "func createLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let log = LogEntry(context: context)\n        log.message = message\n        log.timestamp = Date()\n        \n        do {\n            try context.save()\n            print(\"Log saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save log: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a user's search text input, debounces it for 500ms, removes duplicate consecutive entries, and performs a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C using `dispatch_once`.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedInstance;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[NetworkManager alloc] init];\n        // Additional initialization if needed\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Write a SwiftUI View that utilizes `@FetchRequest` to display a list of 'Item' entities from Core Data, sorted by their 'createdAt' date in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.createdAt, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.name ?? \"Unknown\")\n                }\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n}"}
{"instruction": "Convert a legacy callback-based Swift function `fetchImage(url: URL, completion: @escaping (Result<UIImage, Error>) -> Void)` into an `async/await` function using `withCheckedThrowingContinuation`.", "output": "func fetchImage(url: URL) async throws -> UIImage {\n    return try await withCheckedThrowingContinuation { continuation in\n        fetchImage(url: url) { result in\n            switch result {\n            case .success(let image):\n                continuation.resume(returning: image)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}"}
{"instruction": "Using UIKit (Swift), implement a `UICollectionViewDiffableDataSource` setup for a collection view displaying a list of unique strings.", "output": "import UIKit\n\nenum Section { case main }\n\nclass ListViewController: UIViewController {\n    var collectionView: UICollectionView!\n    var dataSource: UICollectionViewDiffableDataSource<Section, String>!\n\n    func configureDataSource() {\n        let cellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, String> { cell, indexPath, item in\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n        }\n\n        dataSource = UICollectionViewDiffableDataSource<Section, String>(collectionView: collectionView) { (collectionView, indexPath, itemIdentifier) -> UICollectionViewCell? in\n            return collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: itemIdentifier)\n        }\n    }\n\n    func applySnapshot(items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Use the Combine framework to fetch JSON data from a URL, decode it into a `User` struct, and return it as an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUserPublisher(url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate the usage of `autoreleasepool` in Objective-C to manage memory when creating a large number of temporary objects inside a loop.", "output": "void processLargeData() {\n    for (int i = 0; i < 100000; i++) {\n        @autoreleasepool {\n            // Objects created here are released at the end of this block\n            // preventing memory spikes during the loop execution\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSData *data = [tempString dataUsingEncoding:NSUTF8StringEncoding];\n            NSLog(@\"Processed: %lu bytes\", (unsigned long)data.length);\n        }\n    }\n}"}
{"instruction": "Using Core Graphics in a Swift `UIView` subclass, override `draw(_:)` to draw a red circle centered in the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let radius = min(rect.width, rect.height) / 2 - 10\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Create the circle path\n        let circlePath = UIBezierPath(arcCenter: center,\n                                      radius: radius,\n                                      startAngle: 0,\n                                      endAngle: .pi * 2,\n                                      clockwise: true)\n        \n        // Fill the path\n        context.addPath(circlePath.cgPath)\n        context.fillPath()\n    }\n}"}
{"instruction": "Swift: Fix the retain cycle in the following class where a closure captures 'self' strongly. The closure is stored in a property and called after a delay.", "output": "class DataFetcher {\n    var onDataFetched: ((String) -> Void)?\n    var data: String = \"Loading...\"\n\n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Capture self weakly to avoid retain cycle\n            guard let self = self else { return }\n            \n            self.data = \"Fetched Data\"\n            DispatchQueue.main.async {\n                self.onDataFetched?(self.data)\n            }\n        }\n    }\n}"}
{"instruction": "SwiftUI & Core Data: Create a SwiftUI view that fetches 'Item' entities sorted by 'timestamp' descending using the @FetchRequest property wrapper.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.timestamp?.description ?? \"Unknown Date\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Combine: Create a pipeline that takes a search query string publisher, debounces it for 500ms, removes duplicates, and triggers an API call (simulated).", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .flatMap { query in\n                // Simulated API call returning a Future\n                return Future<String, Never> { promise in\n                    print(\"Searching for: \\(query)\")\n                    promise(.success(\"Result for \\(query)\"))\n                }\n            }\n            .sink(receiveValue: { result in\n                print(\"Received: \\(result)\")\n            })\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "Objective-C: Implement the 'Weak-Strong Dance' pattern to safely access 'self' inside a block to prevent a retain cycle and ensure 'self' stays alive during execution.", "output": "__weak typeof(self) weakSelf = self;\n[self.networkService fetchDetailsWithCompletion:^(NSDictionary *result) {\n    // Upgrade weakSelf to strongSelf to ensure the object isn't deallocated mid-execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf updateUIWithResult:result];\n        strongSelf.isFinished = YES;\n    } else {\n        NSLog(@\"Self was deallocated before block execution.\");\n    }\n}];"}
{"instruction": "Core Data: Write a Swift function that performs a background task to import a large array of JSON objects into Core Data to avoid blocking the main thread.", "output": "import CoreData\n\nfunc importDataInBackground(jsonArray: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // 'context' is a private queue context independent of the main thread\n        \n        for json in jsonArray {\n            let entity = MyEntity(context: context)\n            entity.id = json[\"id\"] as? UUID\n            entity.name = json[\"name\"] as? String\n        }\n        \n        do {\n            // Save changes to the persistent store\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "UIKit: Create a custom UIView subclass that draws a red circle in the center of the view using Core Graphics (drawRect).", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Vision Framework: Write a Swift function using the Vision framework to recognize text (OCR) from a CGImage.", "output": "import Vision\n\nfunc recognizeText(from image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed: \\(String(describing: error))\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform request: \\(error)\")\n    }\n}"}
{"instruction": "Swift Concurrency: Convert a legacy callback-based function to an async/await function using 'withCheckedContinuation'.", "output": "// Legacy function\nfunc fetchImage(url: URL, completion: @escaping (UIImage?) -> Void) { /* ... */ }\n\n// Async/Await wrapper\nfunc fetchImageAsync(url: URL) async -> UIImage? {\n    await withCheckedContinuation { continuation in\n        fetchImage(url: url) { image in\n            continuation.resume(returning: image)\n        }\n    }\n}"}
{"instruction": "Objective-C Runtime: Use Method Swizzling to swap 'viewWillAppear:' with a custom implementation 'swizzled_viewWillAppear:' to log analytics for every View Controller.", "output": "#import <objc/runtime.h>\n\n@implementation UIViewController (Analytics)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(swizzled_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n}\n\n- (void)swizzled_viewWillAppear:(BOOL)animated {\n    [self swizzled_viewWillAppear:animated]; // Call original implementation\n    NSLog(@\"Analytics: View Appearing: %@\", NSStringFromClass([self class]));\n}\n\n@end"}
{"instruction": "Combine: Implement a network request publisher that retries 3 times on failure before returning an error.", "output": "import Combine\nimport Foundation\n\nfunc fetchData(from url: URL) -> AnyPublisher<Data, URLError> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map(\\.data)\n        .retry(3) // Retry the upstream publisher up to 3 times on failure\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a Swift function that fetches JSON data from a URL, decodes it into a generic Codable type, and returns a Combine AnyPublisher. Handle the error mapping specifically for URLError.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .mapError { error -> Error in\n            if let urlError = error as? URLError {\n                return urlError\n            }\n            return error\n        }\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a method in Swift using Core Data's `NSPersistentContainer` to perform a background task. Create a new `User` entity, set its name, and save the context, handling potential errors.", "output": "import CoreData\n\nfunc createBackgroundUser(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.createdAt = Date()\n        \n        do {\n            try context.save()\n            print(\"User saved successfully on background context.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Write a Swift closure implementation within a ViewController that accesses `self` safely to avoid a strong reference cycle (memory leak). The closure simulates a network completion handler.", "output": "class MyViewController: UIViewController {\n    var dataLoader: DataLoader?\n    var statusLabel = UILabel()\n\n    func startDownload() {\n        dataLoader?.downloadData { [weak self] result in\n            // Guard ensures self still exists and promotes weak to strong reference for the scope\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                switch result {\n                case .success(let data):\n                    self.statusLabel.text = \"Data received: \\(data.count) bytes\"\n                case .failure(let error):\n                    self.statusLabel.text = \"Error: \\(error.localizedDescription)\"\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to display a list of `Item` entities from Core Data, sorted by `timestamp` in descending order. Include the ability to delete items from the list.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .toolbar {\n                EditButton()\n            }\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Implement a thread-safe Singleton in Objective-C using `dispatch_once`.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n        // Additional initialization if needed\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Using Combine in Swift, create a ViewModel that observes a text input property, debounces the input for 500 milliseconds, removes duplicates, and performs a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] term in\n                self?.performSearch(query: term)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        guard !query.isEmpty else {\n            results = []\n            return\n        }\n        print(\"Searching for: \\(query)\")\n        // Simulate search result\n        self.results = [\"Result for \\(query)\"]\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to implement a function that authenticates the user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Demonstrate how to apply a Core Image filter (Sepia Tone) to a UIImage in Swift.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Create an Objective-C property for a block that avoids retain cycles, and demonstrate how to call it safely.", "output": "// Header\n@interface TaskHandler : NSObject\n@property (nonatomic, copy) void (^completionBlock)(BOOL success);\n- (void)doWork;\n@end\n\n// Implementation\n@implementation TaskHandler\n\n- (void)doWork {\n    // Simulate async work\n    __weak typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        // Do heavy lifting...\n        \n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        if (strongSelf && strongSelf.completionBlock) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                strongSelf.completionBlock(YES);\n            });\n        }\n    });\n}\n@end"}
{"instruction": "Use `DispatchGroup` in Swift to wait for two simultaneous asynchronous network operations to complete before updating the UI.", "output": "import Foundation\n\nfunc syncMultipleDownloads() {\n    let dispatchGroup = DispatchGroup()\n    \n    // Task 1\n    dispatchGroup.enter()\n    NetworkService.fetchProfile { _ in\n        print(\"Profile fetched\")\n        dispatchGroup.leave()\n    }\n    \n    // Task 2\n    dispatchGroup.enter()\n    NetworkService.fetchAvatar { _ in\n        print(\"Avatar fetched\")\n        dispatchGroup.leave()\n    }\n    \n    dispatchGroup.notify(queue: .main) {\n        print(\"All downloads complete. Update UI now.\")\n    }\n}"}
{"instruction": "Prevent a strong reference cycle (memory leak) in a Swift closure where a View Controller captures 'self' to update the UI after an asynchronous operation.", "output": "class MyViewController: UIViewController {\n    var dataLoader = DataLoader()\n\n    func fetchData() {\n        // usage of [weak self] prevents the retain cycle\n        dataLoader.performAsyncLoad { [weak self] result in\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                switch result {\n                case .success(let data):\n                    self.updateUI(with: data)\n                case .failure(let error):\n                    self.showError(error)\n                }\n            }\n        }\n    }\n\n    func updateUI(with data: Data) { /* ... */ }\n    func showError(_ error: Error) { /* ... */ }\n}"}
{"instruction": "Create a basic Core Data stack setup in Swift using NSPersistentContainer.", "output": "import CoreData\n\nclass PersistenceController {\n    static let shared = PersistenceController()\n\n    let container: NSPersistentContainer\n\n    init(inMemory: Bool = false) {\n        container = NSPersistentContainer(name: \"MyModelName\")\n        if inMemory {\n            container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: \"/dev/null\")\n        }\n        container.loadPersistentStores(completionHandler: { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        })\n        // Merge policy for constraints\n        container.viewContext.automaticallyMergesChangesFromParent = true\n    }\n}"}
{"instruction": "Use the Combine framework to fetch JSON data from a URL, decode it into a struct, and return it as an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(userId: Int) -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/users/\\(userId)\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Programmatically create a UILabel in UIKit, add it to a parent view, and center it using NSLayoutConstraint (Auto Layout).", "output": "import UIKit\n\nfunc setupLabel(in parentView: UIView) {\n    let label = UILabel()\n    label.text = \"Hello, UIKit\"\n    label.translatesAutoresizingMaskIntoConstraints = false\n    parentView.addSubview(label)\n    \n    NSLayoutConstraint.activate([\n        label.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n        label.centerYAnchor.constraint(equalTo: parentView.centerYAnchor)\n    ])\n}"}
{"instruction": "Define an Objective-C protocol for a delegate and a property that holds it, ensuring no retain cycles occur (ARC).", "output": "@protocol NetworkManagerDelegate <NSObject>\n- (void)didFinishLoadingData:(NSData *)data;\n@end\n\n@interface NetworkManager : NSObject\n\n// Using 'weak' prevents the manager from retaining the delegate\n@property (nonatomic, weak) id<NetworkManagerDelegate> delegate;\n\n- (void)startRequest;\n\n@end"}
{"instruction": "Implement a SwiftUI View that observes a ViewModel using @StateObject and @Published to toggle a loading state.", "output": "import SwiftUI\n\nclass LoginViewModel: ObservableObject {\n    @Published var isLoading = false\n    \n    func login() {\n        isLoading = true\n        // Simulate network delay\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n            self.isLoading = false\n        }\n    }\n}\n\nstruct LoginView: View {\n    @StateObject private var viewModel = LoginViewModel()\n    \n    var body: some View {\n        VStack {\n            if viewModel.isLoading {\n                ProgressView()\n            } else {\n                Button(\"Login\") {\n                    viewModel.login()\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a Swift Actor to manage a thread-safe integer counter to demonstrate modern concurrency.", "output": "actor SafeCounter {\n    private var value = 0\n    \n    func increment() {\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage example:\n// Task {\n//     let counter = SafeCounter()\n//     await counter.increment()\n//     print(await counter.getValue())\n// }"}
{"instruction": "Use Combine to debounce user input from a text field publisher before performing a search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Perform a Batch Delete Request in Core Data to delete all logs older than 7 days.", "output": "import CoreData\n\nfunc deleteOldLogs(context: NSManagedObjectContext) throws {\n    let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"LogEntry\")\n    \n    let dateThreshold = Calendar.current.date(byAdding: .day, value: -7, to: Date())!\n    fetchRequest.predicate = NSPredicate(format: \"timestamp < %@\", dateThreshold as NSDate)\n    \n    let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n    batchDeleteRequest.resultType = .resultTypeObjectIDs\n    \n    let result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult\n    \n    // Merge changes back into context to keep UI consistent\n    if let objectIDs = result?.result as? [NSManagedObjectID] {\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: [NSDeletedObjectsKey: objectIDs], into: [context])\n    }\n}"}
{"instruction": "Use the Vision framework in Swift to detect text (OCR) in a given UIImage.", "output": "import Vision\nimport UIKit\n\nfunc detectText(in image: UIImage, completion: @escaping ([String]) -> Void) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation] else { \n            completion([])\n            return \n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        completion(recognizedStrings)\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures `self` strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onDataFetched = { [weak self] in\n            // Guard to safely unwrap self\n            guard let self = self else { return }\n            self.data = \"Fetched\"\n            print(self.data)\n        }\n    }\n}"}
{"instruction": "Create a generic networking function using Combine in Swift that takes a URL and returns an `AnyPublisher` of a Decodable type.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating the 'Weak-Strong Dance' inside a block to avoid retain cycles while ensuring `self` remains valid during execution.", "output": "__weak typeof(self) weakSelf = self;\n[self.networkManager fetchItemsWithCompletion:^(NSArray *items) {\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (!strongSelf) {\n        return;\n    }\n    [strongSelf updateUIWithItems:items];\n}];"}
{"instruction": "Implement a function in Swift using Core Data to perform a Batch Delete Request for all entities named 'LogEntry' older than 7 days.", "output": "import CoreData\n\nfunc deleteOldLogs(context: NSManagedObjectContext) {\n    let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"LogEntry\")\n    let dateThreshold = Calendar.current.date(byAdding: .day, value: -7, to: Date())!\n    fetchRequest.predicate = NSPredicate(format: \"timestamp < %@\", dateThreshold as NSDate)\n\n    let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n    \n    do {\n        try context.execute(deleteRequest)\n        try context.save()\n    } catch {\n        print(\"Batch delete failed: \\(error)\")\n    }\n}"}
{"instruction": "Create a SwiftUI View that uses a `PassthroughSubject` to handle UI events and subscribes to it using `.onReceive`.", "output": "import SwiftUI\nimport Combine\n\nstruct EventView: View {\n    let eventSubject = PassthroughSubject<String, Never>()\n    @State private var message = \"Waiting...\"\n\n    var body: some View {\n        VStack {\n            Text(message)\n            Button(\"Trigger Event\") {\n                eventSubject.send(\"Event Fired at \\(Date())\")\n            }\n        }\n        .onReceive(eventSubject) { payload in\n            self.message = payload\n        }\n    }\n}"}
{"instruction": "Demonstrate how to use `DispatchGroup` in Swift to wait for two asynchronous network calls to complete before updating the UI.", "output": "func syncNetworkCalls() {\n    let group = DispatchGroup()\n    \n    group.enter()\n    fetchUserProfile { \n        print(\"Profile fetched\")\n        group.leave()\n    }\n    \n    group.enter()\n    fetchUserFriends { \n        print(\"Friends fetched\")\n        group.leave()\n    }\n    \n    group.notify(queue: .main) {\n        print(\"All data loaded. Update UI.\")\n    }\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift using Core Graphics to draw a red circle centered in the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Calculate center and radius\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10 // Padding\n        \n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift for a Search Bar ViewModel that debounces text input for 500ms and removes duplicates before performing a search.", "output": "import Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        // API Call logic here\n    }\n}"}
{"instruction": "Implement a `NSCache` wrapper in Swift to store images safely, ensuring the cache has a limit on the number of objects.", "output": "import UIKit\n\nclass ImageCache {\n    static let shared = ImageCache()\n    private let cache = NSCache<NSString, UIImage>()\n\n    private init() {\n        cache.countLimit = 100 // Maximum 100 images\n    }\n\n    func getImage(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n\n    func save(image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n}"}
{"instruction": "Create an Objective-C method that sets up a Key-Value Observer (KVO) for the 'status' property of a 'Task' object.", "output": "- (void)observeTask:(Task *)task {\n    [task addObserver:self \n           forKeyPath:@\"status\" \n              options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) \n              context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath \n                      ofObject:(id)object \n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change \n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed from %@ to %@\", change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);\n    }\n}\n\n- (void)dealloc {\n    // Ideally remove observer here or in viewDidDisappear depending on lifecycle\n    // [self.task removeObserver:self forKeyPath:@\"status\"];\n}"}
{"instruction": "Create a Swift function using Combine to fetch data from a URL, decode it into a generic Codable type, and handle errors, returning an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to fix a strong reference cycle (retain cycle) in a Swift closure within a ViewController class.", "output": "class MyViewController: UIViewController {\n    var dataLoader: DataLoader?\n    var status: String = \"Ready\"\n\n    func setupLoader() {\n        dataLoader = DataLoader()\n        // Fix: Use [weak self] to prevent the closure from strongly holding the ViewController\n        dataLoader?.onCompletion = { [weak self] result in\n            guard let self = self else { return }\n            self.status = result\n            print(self.status)\n        }\n    }\n}"}
{"instruction": "Write a SwiftUI View that retrieves 'Item' entities from Core Data using @FetchRequest, sorted by 'creationDate'.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.creationDate, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.name ?? \"Unknown\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a batch delete request in Core Data to remove all records of an entity named 'LogEntry' older than a specific date without loading them into memory.", "output": "func deleteOldLogs(olderThan date: Date, context: NSManagedObjectContext) throws {\n    let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"LogEntry\")\n    fetchRequest.predicate = NSPredicate(format: \"timestamp < %@\", date as NSDate)\n    \n    let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n    batchDeleteRequest.resultType = .resultTypeObjectIDs\n    \n    let result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult\n    \n    // Merge changes back to context to keep UI in sync\n    if let objectIDs = result?.result as? [NSManagedObjectID] {\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: [NSDeletedObjectsKey: objectIDs], into: [context])\n    }\n}"}
{"instruction": "Create an Objective-C property declaration for a delegate to ensure memory safety (avoiding retain cycles).", "output": "@protocol MyDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n// Use 'weak' to prevent strong reference cycles with the delegate\n@property (nonatomic, weak) id<MyDelegate> delegate;\n@end"}
{"instruction": "Use the Vision framework in Swift to recognize text in a UIImage.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage, completion: @escaping ([String]) -> Void) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            completion([])\n            return\n        }\n        let recognizedStrings = observations.compactMap { $0.topCandidates(1).first?.string }\n        completion(recognizedStrings)\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Implement a Combine pipeline that debounces search text input from a UITextField and removes duplicates before firing a search.", "output": "import UIKit\nimport Combine\n\nclass SearchViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    private var subscriptions = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .map { ($0.object as! UITextField).text ?? \"\" }\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] searchText in\n                self?.performSearch(query: searchText)\n            }\n            .store(in: &subscriptions)\n    }\n    \n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Use CryptoKit to generate a SHA256 hash of a String in Swift.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashString(_ input: String) -> String {\n    guard let data = input.data(using: .utf8) else { return \"\" }\n    let digest = SHA256.hash(data: data)\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Set up a Core Data stack (NSPersistentContainer) in a singleton class.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n    \n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n    \n    func saveContext() {\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a custom UIView in UIKit that draws a red circle using Core Graphics within the draw(_:) method.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        // Inset to ensure the stroke isn't clipped, though we are just filling here\n        let circleRect = rect.insetBy(dx: 5, dy: 5)\n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a view controller.", "output": "class NetworkManager {\n    var onCompletion: (() -> Void)?\n    \n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            self.onCompletion?()\n        }\n    }\n}\n\nclass MyViewController: UIViewController {\n    let networkManager = NetworkManager()\n    var status = \"Loading\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // FIX: Add [weak self] to the capture list to prevent a retain cycle.\n        // networkManager owns onCompletion, onCompletion captures self, self owns networkManager.\n        networkManager.onCompletion = { [weak self] in\n            guard let self = self else { return }\n            self.status = \"Finished\"\n            print(self.status)\n        }\n        \n        networkManager.fetchData()\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses @FetchRequest to retrieve 'TodoItem' entities from Core Data, filtered by a boolean attribute 'isCompleted' set to false.", "output": "import SwiftUI\nimport CoreData\n\nstruct TodoListView: View {\n    // The fetch request is initialized with a predicate to filter incomplete items\n    @FetchRequest(\n        entity: TodoItem.entity(),\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TodoItem.timestamp, ascending: true)],\n        predicate: NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false))\n    ) var pendingItems: FetchedResults<TodoItem>\n\n    var body: some View {\n        List(pendingItems, id: \\.self) { item in\n            Text(item.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that fetches JSON from a URL, decodes it into a 'User' model, retries the request twice on failure, and handles errors by returning a nil User.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nclass UserService {\n    var cancellables = Set<AnyCancellable>()\n    @Published var user: User? = nil\n    \n    func fetchUser() {\n        let url = URL(string: \"https://api.example.com/user/1\")!\n        \n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: User.self, decoder: JSONDecoder())\n            .retry(2) // Retry twice before failing\n            .replaceError(with: User(id: -1, name: \"Unknown\")) // Fallback on error\n            .receive(on: DispatchQueue.main)\n            .assign(to: \\.user, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface DatabaseManager : NSObject\n+ (instancetype)sharedInstance;\n@end\n\n@implementation DatabaseManager\n\n+ (instancetype)sharedInstance {\n    static DatabaseManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    // dispatch_once ensures the block is executed only once for the lifetime of the application\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    \n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a custom UIView subclass in UIKit that creates a label, adds it to the view hierarchy, and centers it using Auto Layout anchors programmatically.", "output": "import UIKit\n\nclass CenteredLabelView: UIView {\n    \n    private let label: UILabel = {\n        let lbl = UILabel()\n        lbl.text = \"Hello World\"\n        lbl.translatesAutoresizingMaskIntoConstraints = false\n        return lbl\n    }()\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        addSubview(label)\n        \n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to create a function that authenticates a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if biometric authentication is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Perform a large data insertion into Core Data using a background context to avoid blocking the main UI thread.", "output": "import CoreData\n\nfunc importLargeDataSet(container: NSPersistentContainer, rawData: [String]) {\n    // performBackgroundTask automatically creates a new context on a background queue\n    container.performBackgroundTask { context in\n        for title in rawData {\n            let entity = NSEntityDescription.insertNewObject(forEntityName: \"Item\", into: context)\n            entity.setValue(title, forKey: \"title\")\n        }\n        \n        do {\n            try context.save()\n            print(\"Background save successful\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Use Combine to observe text changes in a UITextField, debounce the input by 500ms, and print the text only if it has changed.", "output": "import UIKit\nimport Combine\n\nclass SearchViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    var subscriptions = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .map { ($0.object as? UITextField)?.text ?? \"\" }\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] searchText in\n                print(\"User stopped typing, searching for: \\(searchText)\")\n                self?.performSearch(query: searchText)\n            }\n            .store(in: &subscriptions)\n    }\n    \n    func performSearch(query: String) {\n        // Search logic here\n    }\n}"}
{"instruction": "Convert a legacy Swift function using a completion handler to the new async/await pattern using 'withCheckedContinuation'.", "output": "import Foundation\n\n// Legacy function\nfunc fetchImageLegacy(url: URL, completion: @escaping (Data?, Error?) -> Void) {\n    // Simulate async work\n    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n        completion(Data(), nil)\n    }\n}\n\n// Modern Async wrapper\nfunc fetchImage(url: URL) async throws -> Data {\n    return try await withCheckedThrowingContinuation { continuation in\n        fetchImageLegacy(url: url) { data, error in\n            if let error = error {\n                continuation.resume(throwing: error)\n            } else if let data = data {\n                continuation.resume(returning: data)\n            } else {\n                continuation.resume(throwing: URLError(.unknown))\n            }\n        }\n    }\n}"}
{"instruction": "Create a function using Core Image to apply a Sepia Tone filter to a UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    \n    return nil\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift class where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataReceived: ((Data) -> Void)?\n    var data: Data = Data()\n\n    func startFetching() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onDataReceived = { [weak self] receivedData in\n            guard let self = self else { return }\n            self.data = receivedData\n            self.processData()\n        }\n    }\n\n    func processData() {\n        print(\"Processing data...\")\n    }\n}"}
{"instruction": "Create a Core Data stack manager class in Swift using `NSPersistentContainer` that loads the persistent stores.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    \n    let container: NSPersistentContainer\n\n    private init() {\n        container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        // Merge policy helps avoid conflicts (e.g., duplicates)\n        container.viewContext.automaticallyMergesChangesFromParent = true\n        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift to fetch JSON data from a URL, decode it into a `User` model, and handle errors on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a text recognition request using the Vision framework in Swift to extract text from a `CGImage`.", "output": "import Vision\n\nfunc recognizeText(from image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed: \\(String(describing: error))\")\n            return\n        }\n        \n        let text = observations.compactMap { $0.topCandidates(1).first?.string }.joined(separator: \"\\n\")\n        print(\"Recognized Text: \\(text)\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating the 'weak-strong dance' to prevent a retain cycle inside a block.", "output": "@interface MyController : UIViewController\n@property (nonatomic, copy) void (^completionHandler)(void);\n@end\n\n@implementation MyController\n\n- (void)setupHandler {\n    __weak typeof(self) weakSelf = self;\n    \n    self.completionHandler = ^{\n        // Convert weak reference to strong to ensure self stays alive during execution\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        \n        if (strongSelf) {\n            [strongSelf doSomething];\n        }\n    };\n}\n\n- (void)doSomething {\n    NSLog(@\"Action performed\");\n}\n\n@end"}
{"instruction": "Create a SwiftUI View that uses `StateObject` to own a ViewModel and `ObservedObject` to pass it to a child view, ensuring correct memory lifecycle management.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n}\n\nstruct ParentView: View {\n    // StateObject ensures the ViewModel is created once and survives re-renders\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Parent: \\(viewModel.count)\")\n            ChildView(viewModel: viewModel)\n        }\n    }\n}\n\nstruct ChildView: View {\n    // ObservedObject watches the object but does not own it\n    @ObservedObject var viewModel: CounterViewModel\n\n    var body: some View {\n        Button(\"Increment\") {\n            viewModel.count += 1\n        }\n    }\n}"}
{"instruction": "Implement a Combine search bar debounce mechanism in a ViewModel to prevent API calls on every keystroke.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Perform a background save in Core Data using `performBackgroundTask` to avoid blocking the UI thread.", "output": "func saveInBackground() {\n    let container = CoreDataManager.shared.container\n    \n    container.performBackgroundTask { context in\n        // Create a new object in the background context\n        let entity = MyEntity(context: context)\n        entity.attribute = \"Background Data\"\n        entity.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Saved successfully in background\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Apply a Diffable Data Source snapshot to a UICollectionView in UIKit to animate data changes.", "output": "import UIKit\n\nenum Section { case main }\nstruct Item: Hashable { let id = UUID(); let title: String }\n\nclass ListViewController: UIViewController {\n    var dataSource: UICollectionViewDiffableDataSource<Section, Item>!\n    var collectionView: UICollectionView!\n\n    func applySnapshot(items: [Item]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, Item>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        \n        // Apply snapshot with animation\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Use the `CryptoKit` framework in Swift to generate a SHA256 hash of a String.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashString(_ input: String) -> String {\n    guard let data = input.data(using: .utf8) else { return \"\" }\n    let hashed = SHA256.hash(data: data)\n    \n    // Convert the digest to a hex string\n    return hashed.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in // Fix: Capture self weakly\n            guard let self = self else { return }\n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Swift function using Core Data that creates and saves a new 'User' entity with a 'name' attribute on a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc createUser(name: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        \n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that takes a 'searchText' publisher, debounces it for 500 milliseconds, removes duplicate inputs, and prints the result.", "output": "import Combine\nimport Foundation\n\nvar cancellables = Set<AnyCancellable>()\nlet searchTextPublisher = PassthroughSubject<String, Never>()\n\nsearchTextPublisher\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .sink { text in\n        print(\"Searching for: \\(text)\")\n    }\n    .store(in: &cancellables)\n\n// Usage\nsearchTextPublisher.send(\"Swif\")\nsearchTextPublisher.send(\"Swift\")"}
{"instruction": "Implement a custom UIView subclass in Swift that draws a red circle filling the view's bounds using Core Graphics within the 'draw(_:)' method.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.fillEllipse(in: rect)\n    }\n}"}
{"instruction": "Write an Objective-C property declaration for a delegate to prevent strong reference cycles (Retain Cycles).", "output": "@protocol NetworkManagerDelegate <NSObject>\n- (void)didFinishLoading;\n@end\n\n@interface NetworkManager : NSObject\n\n// Use 'weak' to prevent retain cycles\n@property (nonatomic, weak) id<NetworkManagerDelegate> delegate;\n\n@end"}
{"instruction": "Create a SwiftUI View that safely instantiates a ViewModel using @StateObject so that the ViewModel's lifecycle is tied to the View's identity and not recreated on every render.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    func increment() { count += 1 }\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the VM is initialized only once per view identity\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Using Swift's DispatchGroup, write a function that executes two asynchronous tasks in parallel and prints \"Finished\" only when both are complete.", "output": "import Foundation\n\nfunc performParallelTasks() {\n    let group = DispatchGroup()\n\n    // Task 1\n    group.enter()\n    DispatchQueue.global().async {\n        sleep(1) // Simulate work\n        print(\"Task 1 Complete\")\n        group.leave()\n    }\n\n    // Task 2\n    group.enter()\n    DispatchQueue.global().async {\n        sleep(2) // Simulate work\n        print(\"Task 2 Complete\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"Finished: Both tasks are done.\")\n    }\n}"}
{"instruction": "Implement a Combine function that fetches JSON data from a URL, decodes it into a generic Codable type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write the Objective-C code to manually implement Key-Value Observing (KVO) for a property named 'status' on a 'Task' object.", "output": "// Registering Observer\n[self.task addObserver:self\n            forKeyPath:@\"status\"\n               options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n               context:nil];\n\n// Handling Changes\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed from %@ to %@\", change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n// Cleanup\n- (void)dealloc {\n    [self.task removeObserver:self forKeyPath:@\"status\"];\n}"}
{"instruction": "Setup a CLLocationManager in Swift to request 'When In Use' authorization and handle the delegate method for location updates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func startTracking() {\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Latitude: \\(location.coordinate.latitude), Longitude: \\(location.coordinate.longitude)\")\n    }\n}"}
{"instruction": "Create a Swift class method that demonstrates how to prevent a Strong Reference Cycle (Retain Cycle) when using a closure to handle the completion of a network simulation.", "output": "class DataFetcher {\n    var onDataFetched: ((String) -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) { [weak self] in\n            // Capture self weakly to avoid retain cycle\n            guard let self = self else { return }\n            \n            self.data = \"Fetched Data\"\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?(self.data)\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift code snippet using Core Data to perform a batch insert of User entities on a background context to ensure the main UI thread remains responsive.", "output": "func saveUsersInBackground(userNames: [String], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        for name in userNames {\n            let user = User(context: context)\n            user.name = name\n            user.createdAt = Date()\n        }\n\n        do {\n            try context.save()\n            print(\"Saved users on background thread.\")\n        } catch {\n            print(\"Failed to save users: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a Combine pipeline in Swift that observes a text search publisher, debounces the input for 500 milliseconds, removes duplicates, and performs a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Provide an Objective-C code snippet demonstrating the 'Weak-Strong Dance' pattern within a block to safely access 'self' without causing a retain cycle or crashing if 'self' is deallocated.", "output": "__weak typeof(self) weakSelf = self;\n[self.networkService fetchDataWithCompletion:^(id result) {\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf updateUIWithResult:result];\n    } else {\n        NSLog(@\"Self was deallocated before block execution.\");\n    }\n}];"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to retrieve a list of 'Task' entities from Core Data, sorted by their creation date.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Task.createdAt, ascending: true)],\n        animation: .default)\n    private var tasks: FetchedResults<Task>\n\n    var body: some View {\n        List {\n            ForEach(tasks) { task in\n                Text(task.title ?? \"Untitled\")\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function that wraps a legacy completion-handler based API into a Combine `Future` publisher.", "output": "import Combine\n\nfunc fetchUserDataFuture() -> Future<String, Error> {\n    return Future { promise in\n        legacyFetchUserData { result, error in\n            if let error = error {\n                promise(.failure(error))\n            } else if let result = result {\n                promise(.success(result))\n            }\n        }\n    }\n}\n\n// Mock legacy function for context\nfunc legacyFetchUserData(completion: @escaping (String?, Error?) -> Void) {\n    completion(\"User Data\", nil)\n}"}
{"instruction": "Demonstrate how to use `Unmanaged` in Swift to manually manage memory when passing a class instance to a C-style API expecting a raw pointer (`void *`).", "output": "class MyContext {\n    var id: Int = 10\n}\n\nfunc passToCApi() {\n    let context = MyContext()\n    \n    // Retain the object and convert to a raw pointer\n    let rawPointer = Unmanaged.passRetained(context).toOpaque()\n    \n    // Assume cApiFunction takes (void *)\n    // cApiFunction(rawPointer)\n    \n    // Later, to convert back and release ownership:\n    let restoredContext = Unmanaged<MyContext>.fromOpaque(rawPointer).takeRetainedValue()\n    print(restoredContext.id)\n}"}
{"instruction": "Using UIKit and Swift, create a custom `UIView` subclass that draws a red circle in the center of the view using Core Graphics (`draw(_:)`).", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Calculate center circle\n        let diameter = min(rect.width, rect.height) * 0.8\n        let x = (rect.width - diameter) / 2\n        let y = (rect.height - diameter) / 2\n        let circleRect = CGRect(x: x, y: y, width: diameter, height: diameter)\n        \n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Implement a Swift function using `NSCache` to store and retrieve images, demonstrating basic memory management for caching expensive objects.", "output": "class ImageCache {\n    static let shared = ImageCache()\n    private let cache = NSCache<NSString, UIImage>()\n\n    private init() {\n        // Configure limits to prevent excessive memory usage\n        cache.countLimit = 100\n    }\n\n    func getImage(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n\n    func setImage(_ image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that attempts a network request, retries up to 3 times on failure, and replaces the error with a default value if all retries fail.", "output": "import Combine\nimport Foundation\n\nfunc fetchReliableData() -> AnyPublisher<String, Never> {\n    let url = URL(string: \"https://api.example.com/data\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { String(data: $0.data, encoding: .utf8) ?? \"\" }\n        .retry(3) // Retry 3 times on failure\n        .catch { _ in \n            Just(\"Default Value\") // Fallback on persistent failure\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Identify and fix the strong reference cycle in the following Swift code snippet where a closure captures 'self'.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in // Fix: Use [weak self] to break the retain cycle\n            guard let self = self else { return }\n            // Simulate data processing\n            self.data = \"New Data\"\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Core Data stack singleton in Swift using `NSPersistentContainer`.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n    \n    private init() {}\n    \n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"AppModel\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n    \n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n    \n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that fetches JSON data from a URL, decodes it into a `User` struct, and returns an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Programmatically create a red UIView (100x100) and center it in a UIViewController using Auto Layout anchors in Swift.", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let redView = UIView()\n        redView.backgroundColor = .red\n        redView.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(redView)\n        \n        NSLayoutConstraint.activate([\n            redView.widthAnchor.constraint(equalToConstant: 100),\n            redView.heightAnchor.constraint(equalToConstant: 100),\n            redView.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            redView.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Implement a 'debounce' mechanism on a text search string using Combine and SwiftUI. The search should only trigger 500ms after the user stops typing.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // Perform API call here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating how to safely access `self` inside a block to avoid a retain cycle.", "output": "// Assuming this is inside a method of 'MyClass'\n__weak typeof(self) weakSelf = self;\n\n[self.someAsyncOperation executeWithCompletion:^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf handleCompletion];\n    }\n}];"}
{"instruction": "Perform a batch update in Core Data to set the 'isRead' attribute to true for all entities named 'Message' without loading them into memory.", "output": "func markAllMessagesAsRead(context: NSManagedObjectContext) {\n    let batchUpdateRequest = NSBatchUpdateRequest(entityName: \"Message\")\n    batchUpdateRequest.propertiesToUpdate = [\"isRead\": true]\n    batchUpdateRequest.resultType = .updatedObjectIDsResultType\n    \n    do {\n        let result = try context.execute(batchUpdateRequest) as? NSBatchUpdateResult\n        if let objectIDs = result?.result as? [NSManagedObjectID] {\n            let changes = [NSUpdatedObjectsKey: objectIDs]\n            NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [context])\n        }\n    } catch {\n        print(\"Batch update failed: \\(error)\")\n    }\n}"}
{"instruction": "Use the Vision framework in Swift to perform text recognition on a `CGImage`.", "output": "import Vision\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { (request, error) in\n        guard let observations = request.results as? [VNRecognizedTextObservation] else { return }\n        \n        for observation in observations {\n            let topCandidate = observation.topCandidates(1).first\n            if let text = topCandidate?.string {\n                print(\"Recognized text: \\(text)\")\n            }\n        }\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Create a SwiftUI View that uses `@Binding` to toggle a boolean state passed from a parent view.", "output": "import SwiftUI\n\nstruct ParentView: View {\n    @State private var isWifiOn: Bool = false\n    \n    var body: some View {\n        VStack {\n            Text(isWifiOn ? \"WiFi is ON\" : \"WiFi is OFF\")\n            ToggleSwitch(isOn: $isWifiOn)\n        }\n    }\n}\n\nstruct ToggleSwitch: View {\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        Toggle(\"Enable WiFi\", isOn: $isOn)\n            .padding()\n    }\n}"}
{"instruction": "Implement a function using `DispatchQueue` to perform a heavy calculation on a background thread and update a label on the main thread.", "output": "func performHeavyCalculation(label: UILabel) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        // Simulate heavy work\n        var result = 0\n        for i in 0..<1_000_000 {\n            result += i\n        }\n        \n        let resultString = \"Result: \\(result)\"\n        \n        DispatchQueue.main.async {\n            // Update UI on main thread\n            label.text = resultString\n        }\n    }\n}"}
{"instruction": "Swift: Create a function that fetches 'User' entities from Core Data where the 'age' attribute is greater than 18, sorted by 'name'.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 18)\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"name\", ascending: true)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Swift (Combine): Implement a ViewModel property that takes a search text publisher, debounces it for 500ms, removes duplicates, and performs a search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var searchResults: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        // Perform search logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Objective-C: Implement a thread-safe Singleton using 'dispatch_once'.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Swift: Fix the retain cycle in the following closure where 'self' is captured strongly by a timer block.", "output": "class TimerWrapper {\n    var timer: Timer?\n    var counter = 0\n    \n    func startTimer() {\n        // Solution: Use [weak self] to break the strong reference cycle\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            guard let self = self else { return }\n            self.counter += 1\n            print(\"Counter: \\(self.counter)\")\n        }\n    }\n    \n    func stopTimer() {\n        timer?.invalidate()\n        timer = nil\n    }\n}"}
{"instruction": "SwiftUI: Create a View that displays a list of items fetched from a Core Data entity named 'TaskItem' using @FetchRequest.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n    \n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskItem.createdAt, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<TaskItem>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.title ?? \"Untitled\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Swift (Combine + Networking): specific function using URLSession's dataTaskPublisher to fetch and decode a generic Codable model.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Objective-C: Create a huge number of temporary objects inside a loop and use an @autoreleasepool to manage memory pressure.", "output": "void processLargeData() {\n    for (int i = 0; i < 100000; i++) {\n        @autoreleasepool {\n            // Objects created here are released at the end of each iteration\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSArray *tempArray = @[tempString, tempString, tempString];\n            NSLog(@\"%@\", tempArray[0]);\n        }\n    }\n}"}
{"instruction": "Swift (LocalAuthentication): Implement a function to authenticate the user using Face ID or Touch ID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself!\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Swift (UIKit): Create a custom UIView subclass that draws a red circle in the center using Core Graphics (draw func).", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Calculate center and radius\n        let radius = min(rect.width, rect.height) / 2 - 10\n        let center = CGPoint(x: rect.width / 2, y: rect.height / 2)\n        \n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Swift (Core Location): Setup a CLLocationManagerDelegate to request 'When In Use' authorization and start updating location.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            locationManager.startUpdatingLocation()\n        default:\n            break\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Lon: \\(location.coordinate.longitude)\")\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle in a Swift closure where a view controller updates its UI after an asynchronous delay.", "output": "class MyViewController: UIViewController {\n    var label: UILabel = UILabel()\n\n    func updateData() {\n        // Fix: Use [weak self] to break the retain cycle\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Guard ensures self still exists\n            guard let self = self else { return }\n            self.label.text = \"Updated\"\n        }\n    }\n}"}
{"instruction": "Write a Swift function using `NSPersistentContainer` to perform a background task that creates a new 'LogEntry' entity and saves the context.", "output": "func createLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let log = LogEntry(context: context)\n        log.timestamp = Date()\n        log.message = message\n\n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that fetches data from a URL, decodes it into a `Post` struct, handles errors by replacing them with a default value, and assigns the result to a published property.", "output": "import Combine\nimport Foundation\n\nstruct Post: Decodable { let id: Int; let title: String }\n\nclass DataLoader: ObservableObject {\n    @Published var post: Post = Post(id: 0, title: \"Loading\")\n    var cancellables = Set<AnyCancellable>()\n\n    func fetchPost(url: URL) {\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: Post.self, decoder: JSONDecoder())\n            .replaceError(with: Post(id: -1, title: \"Error\"))\n            .receive(on: DispatchQueue.main)\n            .assign(to: \\.post, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C code snippet to swizzle the `viewWillAppear:` method of `UIViewController` using the runtime library.", "output": "#import <objc/runtime.h>\n\n@implementation UIViewController (Swizzling)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n}\n\n- (void)xxx_viewWillAppear:(BOOL)animated {\n    [self xxx_viewWillAppear:animated];\n    NSLog(@\"View Will Appear: %@\", self);\n}\n\n@end"}
{"instruction": "Create a SwiftUI view that observes a `Timer` publisher and updates a counter text every second.", "output": "import SwiftUI\nimport Combine\n\nstruct TimerView: View {\n    @State private var counter = 0\n    // Auto-connect timer publisher\n    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()\n\n    var body: some View {\n        Text(\"Counter: \\(counter)\")\n            .font(.largeTitle)\n            .onReceive(timer) { _ in\n                counter += 1\n            }\n    }\n}"}
{"instruction": "Implement a function in Swift to configure an `AVCaptureSession` with the back camera as the input device.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.beginConfiguration()\n\n    guard let backCamera = AVCaptureDevice.default(for: .video),\n          let input = try? AVCaptureDeviceInput(device: backCamera) else {\n        return nil\n    }\n\n    if session.canAddInput(input) {\n        session.addInput(input)\n    }\n\n    session.commitConfiguration()\n    return session\n}"}
{"instruction": "Write a Swift class that manages a `CLLocationManager` to request 'When In Use' authorization and handles location updates via the delegate.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n\n    override init() {\n        super.init()\n        manager.delegate = self\n        manager.requestWhenInUseAuthorization()\n    }\n\n    func startTracking() {\n        manager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Lon: \\(location.coordinate.longitude)\")\n    }\n}"}
{"instruction": "Use `DispatchGroup` to execute two asynchronous tasks in parallel and print a message once both are complete.", "output": "let group = DispatchGroup()\n\n// Task 1\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n    print(\"Task 1 done\")\n    group.leave()\n}\n\n// Task 2\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n    print(\"Task 2 done\")\n    group.leave()\n}\n\n// Completion\ngroup.notify(queue: .main) {\n    print(\"All tasks finished\")\n}"}
{"instruction": "Create a function using Core Animation (Swift) to animate a CALayer's position along the x-axis.", "output": "import UIKit\n\nfunc animateLayerPosition(layer: CALayer) {\n    let animation = CABasicAnimation(keyPath: \"position.x\")\n    animation.fromValue = layer.position.x\n    animation.toValue = layer.position.x + 100\n    animation.duration = 1.0\n    animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)\n    \n    // Update model layer to match end state\n    layer.position.x += 100\n    \n    layer.add(animation, forKey: \"positionAnimation\")\n}"}
{"instruction": "Write a Swift function to save a `Codable` struct to the app's Documents directory using `FileManager`.", "output": "struct UserSettings: Codable {\n    let username: String\n    let isDarkMode: Bool\n}\n\nfunc saveSettings(_ settings: UserSettings) throws {\n    let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(\"settings.json\")\n    let data = try JSONEncoder().encode(settings)\n    try data.write(to: url)\n}"}
{"instruction": "Create a Swift class named `ImageDownloader` that uses the Combine framework to download an image from a URL. It should handle errors, retry the request once on failure, and ensure the result is delivered on the main thread.", "output": "import UIKit\nimport Combine\n\nclass ImageDownloader {\n    func downloadImage(from url: URL) -> AnyPublisher<UIImage?, Never> {\n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map { UIImage(data: $0.data) }\n            .retry(1)\n            .replaceError(with: nil)\n            .receive(on: DispatchQueue.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that performs a background save operation. The function should accept a `NSPersistentContainer` and a closure to modify the context.", "output": "import CoreData\n\nfunc performBackgroundSave(container: NSPersistentContainer, block: @escaping (NSManagedObjectContext) -> Void) {\n    container.performBackgroundTask { context in\n        block(context)\n        \n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                print(\"Background save error: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton in Objective-C using `dispatch_once`.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a SwiftUI view that observes a `SearchViewModel`. The view should contain a TextField. Use Combine in the ViewModel to debounce the search text input by 500ms before printing the query to the console.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                if !query.isEmpty {\n                    print(\"Searching for: \\(query)\")\n                }\n            }\n            .store(in: &cancellables)\n    }\n}\n\nstruct SearchView: View {\n    @StateObject private var viewModel = SearchViewModel()\n    \n    var body: some View {\n        TextField(\"Search...\", text: $viewModel.searchText)\n            .padding()\n            .textFieldStyle(RoundedBorderTextFieldStyle())\n    }\n}"}
{"instruction": "Demonstrate how to fix a retain cycle in a Swift closure where a class instance (`self`) captures a closure that refers back to `self`. Provide a class `TimerWrapper` that updates a counter.", "output": "import Foundation\n\nclass TimerWrapper {\n    var timer: Timer?\n    var counter = 0\n    \n    func startTimer() {\n        // Use [weak self] to break the retain cycle\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            guard let self = self else { return }\n            self.counter += 1\n            print(\"Counter: \\(self.counter)\")\n        }\n    }\n    \n    func stopTimer() {\n        timer?.invalidate()\n        timer = nil\n    }\n    \n    deinit {\n        print(\"TimerWrapper deallocated\")\n        stopTimer()\n    }\n}"}
{"instruction": "Write a generic function in Swift to fetch records from Core Data. The function should accept a generic type `T` conforming to `NSManagedObject`, a context, and an optional predicate.", "output": "import CoreData\n\nfunc fetchRecords<T: NSManagedObject>(type: T.Type, context: NSManagedObjectContext, predicate: NSPredicate? = nil) -> [T] {\n    let request = T.fetchRequest()\n    request.predicate = predicate\n    \n    do {\n        if let results = try context.fetch(request) as? [T] {\n            return results\n        }\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n    }\n    return []\n}"}
{"instruction": "Create a programmatic UIKit `UIView` subclass named `CircleView` that ensures it remains a circle using `layoutSubviews` and sets a red background color.", "output": "import UIKit\n\nclass CircleView: UIView {\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        backgroundColor = .red\n        clipsToBounds = true\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        // Update corner radius dynamically based on the current bounds\n        layer.cornerRadius = min(bounds.width, bounds.height) / 2\n    }\n}"}
{"instruction": "Write an Objective-C method that performs a block operation. Ensure `self` is referenced weakly inside the block to avoid memory leaks, then upgraded to a strong reference to ensure it stays alive during execution.", "output": "@interface DataProcessor : NSObject\n- (void)processData;\n- (void)handleCompletion;\n@end\n\n@implementation DataProcessor\n\n- (void)processData {\n    __weak typeof(self) weakSelf = self;\n    \n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        // Simulate work\n        [NSThread sleepForTimeInterval:2.0];\n        \n        __strong typeof(self) strongSelf = weakSelf;\n        if (strongSelf) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [strongSelf handleCompletion];\n            });\n        }\n    });\n}\n\n- (void)handleCompletion {\n    NSLog(@\"Processing complete.\");\n}\n\n@end"}
{"instruction": "Using Swift 5.5+ concurrency, write a function that downloads data from a URL using `async/await` and returns a decoded JSON object.", "output": "import Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) async throws -> User {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse, \n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    let user = try JSONDecoder().decode(User.self, from: data)\n    return user\n}"}
{"instruction": "Create a Combine pipeline that merges two integer publishers, filters for even numbers only, and collects the results into an array.", "output": "import Combine\n\nfunc mergeAndFilter() {\n    let publisher1 = [1, 2, 3, 4].publisher\n    let publisher2 = [5, 6, 7, 8].publisher\n    \n    _ = publisher1\n        .merge(with: publisher2)\n        .filter { $0 % 2 == 0 }\n        .collect()\n        .sink(receiveValue: { numbers in\n            print(\"Even numbers: \\(numbers)\") // Output: [2, 4, 6, 8] (order may vary)\n        })\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a `ViewController` holds a reference to a `ViewModel`, and the `ViewModel`'s closure updates the `ViewController`'s UI.", "output": "class ViewController: UIViewController {\n    var viewModel: ViewModel?\n    var statusLabel = UILabel()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        viewModel = ViewModel()\n        \n        // Fix: Use [weak self] to break the retain cycle\n        viewModel?.onDataUpdated = { [weak self] data in\n            // Guard ensures self still exists before accessing properties\n            guard let self = self else { return }\n            self.statusLabel.text = data\n        }\n        \n        viewModel?.fetchData()\n    }\n}\n\nclass ViewModel {\n    var onDataUpdated: ((String) -> Void)?\n    \n    func fetchData() {\n        // Simulating network call\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            DispatchQueue.main.async {\n                self.onDataUpdated?(\"Data Loaded\")\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that performs a background import of JSON data. Ensure the context is saved properly and changes are propagated to the main context.", "output": "import CoreData\n\nfunc importDataInBackground(jsonArray: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Optimization: Set merge policy\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for dict in jsonArray {\n            // Assuming 'User' is a Core Data entity\n            let user = User(context: context)\n            user.id = dict[\"id\"] as? Int64 ?? 0\n            user.name = dict[\"name\"] as? String\n            user.updatedAt = Date()\n        }\n        \n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"Background context saved successfully.\")\n            } catch {\n                print(\"Failed to save background context: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that fetches data from a URL, decodes it into a struct, handles errors by returning a placeholder, and assigns the result to a published property on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let name: String\n}\n\nclass UserViewModel: ObservableObject {\n    @Published var user: User = User(name: \"Loading...\")\n    var cancellables = Set<AnyCancellable>()\n    \n    func fetchUser() {\n        let url = URL(string: \"https://api.example.com/user\")!\n        \n        URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: User.self, decoder: JSONDecoder())\n            .replaceError(with: User(name: \"Guest\")) // Error handling\n            .receive(on: DispatchQueue.main) // Ensure UI updates on main thread\n            .assign(to: \\.user, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating how to use `@autoreleasepool` to manage memory usage inside a tight loop creating many temporary objects.", "output": "#import <Foundation/Foundation.h>\n\nvoid processLargeDataSet() {\n    for (int i = 0; i < 1000000; i++) {\n        // Without this pool, memory usage would spike until the loop finishes\n        @autoreleasepool {\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSArray *tempArray = [tempString componentsSeparatedByString:@\" \"];\n            // ... perform operations with temp objects ...\n            NSLog(@\"Processed: %@\", tempArray.lastObject);\n        }\n    }\n}"}
{"instruction": "Using SwiftUI and Combine, create a search view that debounces the user's input by 500ms before triggering a search action to avoid excessive API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var query: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $query\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] searchText in\n                self?.performSearch(query: searchText)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // Simulate API call\n        print(\"Searching for: \\(query)\")\n        self.results = [\"Result for \\(query)\"]\n    }\n}\n\nstruct SearchView: View {\n    @StateObject var viewModel = SearchViewModel()\n    \n    var body: some View {\n        VStack {\n            TextField(\"Search...\", text: $viewModel.query)\n                .padding()\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            List(viewModel.results, id: \\.self) { result in\n                Text(result)\n            }\n        }\n    }\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift using Core Graphics to draw a red circle with a dashed black border.", "output": "import UIKit\n\nclass DashedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let padding: CGFloat = 10\n        let circleRect = rect.insetBy(dx: padding, dy: padding)\n        \n        // Draw Fill\n        context.setFillColor(UIColor.red.cgColor)\n        context.fillEllipse(in: circleRect)\n        \n        // Draw Dashed Stroke\n        let path = UIBezierPath(ovalIn: circleRect)\n        path.lineWidth = 4\n        let dashPattern: [CGFloat] = [10, 5]\n        path.setLineDash(dashPattern, count: dashPattern.count, phase: 0)\n        \n        UIColor.black.setStroke()\n        path.stroke()\n    }\n}"}
{"instruction": "Write an XCTest unit test in Swift to verify that a specific class does not create a memory leak (retain cycle) upon deinitialization.", "output": "import XCTest\n@testable import MyApp\n\nclass MemoryLeakTests: XCTestCase {\n    \n    func testViewControllerDeallocation() {\n        // 1. Create the object\n        var vc: MyViewController? = MyViewController()\n        \n        // 2. Create a weak reference to track it\n        weak var weakVC = vc\n        \n        // 3. Configure object (simulate load causing potential cycles)\n        vc?.loadViewIfNeeded()\n        \n        // 4. Destroy the strong reference\n        vc = nil\n        \n        // 5. Assert that the weak reference is now nil\n        XCTAssertNil(weakVC, \"MyViewController leaked! It was not deallocated after setting to nil.\")\n    }\n}"}
{"instruction": "Use AVFoundation in Swift to set up a basic video capture session and add the preview layer to a UIView.", "output": "import UIKit\nimport AVFoundation\n\nclass CameraViewController: UIViewController {\n    var captureSession: AVCaptureSession!\n    var previewLayer: AVCaptureVideoPreviewLayer!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupCamera()\n    }\n\n    func setupCamera() {\n        captureSession = AVCaptureSession()\n        captureSession.sessionPreset = .medium\n\n        guard let backCamera = AVCaptureDevice.default(for: .video) else { return }\n\n        do {\n            let input = try AVCaptureDeviceInput(device: backCamera)\n            if captureSession.canAddInput(input) {\n                captureSession.addInput(input)\n            }\n            \n            previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)\n            previewLayer.videoGravity = .resizeAspectFill\n            previewLayer.frame = view.layer.bounds\n            view.layer.addSublayer(previewLayer)\n            \n            DispatchQueue.global(qos: .userInitiated).async {\n                self.captureSession.startRunning()\n            }\n        } catch {\n            print(\"Error setting up camera: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement Method Swizzling in Objective-C to intercept `viewWillAppear:` for all ViewControllers to log an analytics event.", "output": "#import <UIKit/UIKit.h>\n#import <objc/runtime.h>\n\n@implementation UIViewController (Analytics)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(analytics_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n}\n\n- (void)analytics_viewWillAppear:(BOOL)animated {\n    // Call the original method (which is now swizzled)\n    [self analytics_viewWillAppear:animated];\n    \n    // Custom Logging Logic\n    NSLog(@\"Analytics: View Will Appear for %@\", NSStringFromClass([self class]));\n}\n\n@end"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to retrieve Core Data entities sorted by a timestamp, and display them in a list.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    // Automatically fetches data and listens for changes in the context\n    @FetchRequest(\n        entity: TaskEntity.entity(),\n        sortDescriptors: [\n            NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: false)\n        ],\n        predicate: NSPredicate(format: \"isCompleted == NO\")\n    ) var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        NavigationView {\n            List(tasks, id: \\.self) { task in\n                HStack {\n                    Text(task.title ?? \"Untitled\")\n                    Spacer()\n                    Text(task.createdAt ?? Date(), style: .date)\n                        .font(.caption)\n                        .foregroundColor(.gray)\n                }\n            }\n            .navigationTitle(\"Pending Tasks\")\n        }\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift closure. The class `DataFetcher` holds a closure `onComplete`, and inside the closure, it calls a method on `self`.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        onComplete = { [weak self] in\n            guard let self = self else { return }\n            self.process(data: self.data)\n        }\n    }\n\n    func process(data: String) {\n        print(\"Processing: \\(data)\")\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that creates and saves a new `LogEntry` entity with a `message` and `timestamp` on a background context to avoid blocking the main UI thread.", "output": "func createLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let log = LogEntry(context: context)\n        log.message = message\n        log.timestamp = Date()\n\n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save log on background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a function that fetches JSON data from a URL, decodes it into a `User` struct, and assigns it to a published property `currentUser`. Ensure the assignment happens on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable { let id: Int; let name: String }\n\nclass UserViewModel: ObservableObject {\n    @Published var currentUser: User?\n    var cancellables = Set<AnyCancellable>()\n\n    func fetchUser(url: URL) {\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: User.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                if case .failure(let error) = completion {\n                    print(\"Error: \\(error)\")\n                }\n            }, receiveValue: { [weak self] user in\n                self?.currentUser = user\n            })\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "In Objective-C, declare a property for a delegate named `NetworkDelegate` to handle callback events. Ensure the property attributes are set correctly to prevent a retain cycle.", "output": "@protocol NetworkDelegate <NSObject>\n- (void)didFinishLoadingData:(NSData *)data;\n@end\n\n@interface NetworkManager : NSObject\n\n// output: Use 'weak' to prevent strong reference cycles with delegates\n@property (nonatomic, weak) id<NetworkDelegate> delegate;\n\n@end"}
{"instruction": "Create a SwiftUI view that fetches `TodoItem` entities from Core Data using `@FetchRequest`. The list should be sorted by the `createdAt` date in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TodoListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TodoItem.createdAt, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<TodoItem>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.title ?? \"Untitled\")\n            }\n        }\n    }\n}"}
{"instruction": "Implement a text search feature using Combine in Swift. Observe a `@Published` property `searchText`, debounce the input for 500 milliseconds to reduce API calls, remove duplicate inputs, and trigger a search function.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                guard !text.isEmpty else { return }\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Write a Swift function using `DispatchGroup` to perform two asynchronous network requests concurrently and print \"All finished\" only when both requests have completed.", "output": "func syncNetworkCalls() {\n    let group = DispatchGroup()\n    \n    group.enter()\n    simulateNetworkCall(duration: 2) { \n        print(\"Call 1 finished\")\n        group.leave()\n    }\n    \n    group.enter()\n    simulateNetworkCall(duration: 1) { \n        print(\"Call 2 finished\")\n        group.leave()\n    }\n    \n    group.notify(queue: .main) {\n        print(\"All finished\")\n    }\n}\n\nfunc simulateNetworkCall(duration: TimeInterval, completion: @escaping () -> Void) {\n    DispatchQueue.global().asyncAfter(deadline: .now() + duration) {\n        completion()\n    }\n}"}
{"instruction": "Use the Core Image framework in Swift to apply a Sepia Tone filter to a given `UIImage` and return the result.", "output": "import CoreImage\nimport UIKit\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let context = CIContext()\n    guard let filter = CIFilter(name: \"CISepiaTone\") else { return nil }\n    \n    filter.setValue(ciImage, forKey: kCIInputImageKey)\n    filter.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    if let outputImage = filter.outputImage,\n       let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Demonstrate how to use `LocalAuthentication` in Swift to check if Biometric authentication (Face ID or Touch ID) is available and then attempt to authenticate the user.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access the app.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication successful\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometrics not available\")\n    }\n}"}
{"instruction": "Using Swift's memory management rules, explain and implement a `lazy` property closure that captures `self` as `unowned`. This implies `self` will outlive the closure execution.", "output": "class HTMLElement {\n    let name: String\n    let text: String?\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    // Using unowned self because the closure depends on the instance \n    // and cannot exist after the instance is deallocated.\n    lazy var asHTML: () -> String = { [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: ((Data) -> Void)?\n    var data: Data = Data()\n\n    func fetchData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in\n            // Use guard to safely unwrap self\n            guard let self = self else { return }\n            \n            let fetched = Data()\n            self.data = fetched\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?(fetched)\n            }\n        }\n    }\n}"}
{"instruction": "Create a function in Swift using Core Data that performs a background save to avoid blocking the main UI thread.", "output": "import CoreData\n\nfunc saveInBackground(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let entity = UserEntity(context: context)\n        entity.name = name\n        entity.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that fetches JSON from a URL, decodes it into a struct, and handles errors.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Using Objective-C and UIKit, programmatically create a red UIView and center it within the parent view using NSLayoutConstraint.", "output": "- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIView *redView = [[UIView alloc] init];\n    redView.backgroundColor = [UIColor redColor];\n    redView.translatesAutoresizingMaskIntoConstraints = NO;\n    [self.view addSubview:redView];\n    \n    [NSLayoutConstraint activateConstraints:@[\n        [redView.widthAnchor constraintEqualToConstant:100],\n        [redView.heightAnchor constraintEqualToConstant:100],\n        [redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],\n        [redView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor]\n    ]];\n}"}
{"instruction": "Implement a SwiftUI View that correctly instantiates a ViewModel using @StateObject to ensure the object's lifecycle is tied to the view.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    func increment() { count += 1 }\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the ViewModel persists during View updates/redraws\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Using Core Graphics within a UIView subclass in Swift, draw a blue circle with a 2-point stroke width in the center of the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 5\n        let circlePath = UIBezierPath(arcCenter: center,\n                                      radius: radius,\n                                      startAngle: 0,\n                                      endAngle: .pi * 2,\n                                      clockwise: true)\n        \n        UIColor.blue.setStroke()\n        circlePath.lineWidth = 2.0\n        circlePath.stroke()\n    }\n}"}
{"instruction": "Use DispatchGroup in Swift to synchronize two asynchronous network tasks and print a message when both are complete.", "output": "let group = DispatchGroup()\n\n// Task 1\ngroup.enter()\nsimulateNetworkCall(duration: 2) {\n    print(\"Task 1 finished\")\n    group.leave()\n}\n\n// Task 2\ngroup.enter()\nsimulateNetworkCall(duration: 1) {\n    print(\"Task 2 finished\")\n    group.leave()\n}\n\ngroup.notify(queue: .main) {\n    print(\"All tasks completed.\")\n}\n\nfunc simulateNetworkCall(duration: TimeInterval, completion: @escaping () -> Void) {\n    DispatchQueue.global().asyncAfter(deadline: .now() + duration) {\n        completion()\n    }\n}"}
{"instruction": "Setup a basic AVCaptureSession in Swift to capture video input from the default back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n    \n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else { return nil }\n    \n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n            return session\n        }\n    } catch {\n        print(\"Error setting up camera input: \\(error)\")\n    }\n    return nil\n}"}
{"instruction": "Implement a Combine search pipeline that debounces text input for 500ms and removes duplicate strings before performing a search.", "output": "import Combine\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Optimize a tight loop in Objective-C that creates many temporary objects by using an @autoreleasepool to reduce peak memory footprint.", "output": "- (void)processLargeDataSet {\n    for (int i = 0; i < 100000; i++) {\n        @autoreleasepool {\n            // Creates temporary objects that would otherwise pile up in memory\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSData *tempData = [tempString dataUsingEncoding:NSUTF8StringEncoding];\n            \n            [self handleData:tempData];\n            // Objects are released here at the end of every iteration\n        }\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewModel.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n}\n\nclass ViewModel {\n    let fetcher = DataFetcher()\n    var data: String = \"\"\n\n    init() {\n        // Solution: Use [weak self] to break the strong reference cycle\n        fetcher.onDataFetched = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Updated\"\n            self.processData()\n        }\n    }\n\n    func processData() {\n        print(\"Data processed: \\(data)\")\n    }\n}"}
{"instruction": "Write a Swift function using `NSPersistentContainer` to create and save 'User' entities (with a 'name' attribute) on a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc saveUsers(names: [String], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        for name in names {\n            let user = NSEntityDescription.insertNewObject(forEntityName: \"User\", into: context)\n            user.setValue(name, forKey: \"name\")\n        }\n\n        do {\n            try context.save()\n            print(\"Saved users on background thread\")\n        } catch {\n            print(\"Failed to save users: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Swift ViewModel using Combine that observes a `searchText` property, debounces the input for 0.5 seconds, removes duplicates, and triggers a search function.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Implement a custom UIView subclass in Objective-C that adds a UILabel as a subview and centers it using programmatic Auto Layout anchors.", "output": "#import \"CustomView.h\"\n\n@implementation CustomView\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    self = [super initWithFrame:frame];\n    if (self) {\n        UILabel *label = [[UILabel alloc] init];\n        label.text = @\"Centered\";\n        label.translatesAutoresizingMaskIntoConstraints = NO;\n        [self addSubview:label];\n\n        [NSLayoutConstraint activateConstraints:@[\n            [label.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],\n            [label.centerYAnchor constraintEqualToAnchor:self.centerYAnchor]\n        ]];\n    }\n    return self;\n}\n\n@end"}
{"instruction": "Write a Swift function using Core Image to apply a Sepia Tone filter to a given UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n\n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext()\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Implement a generic network fetch function in Swift using the modern async/await concurrency model extending URLSession.", "output": "import Foundation\n\nextension URLSession {\n    func fetch<T: Decodable>(_ url: URL) async throws -> T {\n        let (data, response) = try await self.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            throw URLError(.badServerResponse)\n        }\n        \n        let decodedData = try JSONDecoder().decode(T.self, from: data)\n        return decodedData\n    }\n}"}
{"instruction": "Create a thread-safe Singleton class named `NetworkManager` in Objective-C using `dispatch_once`.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n- (instancetype)init {\n    if (self = [super init]) {\n        // Initialization code here\n    }\n    return self;\n}\n\n@end"}
{"instruction": "Bind a UITextField's text property to a UILabel in a UIKit ViewController using Combine, ensuring the label updates whenever the text changes.", "output": "import UIKit\nimport Combine\n\nclass ViewController: UIViewController {\n    let textField = UITextField()\n    let label = UILabel()\n    var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .assign(to: \\.text, on: label)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Set up a class in Swift that conforms to `CLLocationManagerDelegate` to request 'When In Use' authorization and print coordinates when the location updates.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n\n    func requestLocation() {\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.startUpdatingLocation()\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        print(\"Lat: \\(location.coordinate.latitude), Long: \\(location.coordinate.longitude)\")\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \\(error)\")\n    }\n}"}
{"instruction": "Demonstrate the correct way to instantiate a ViewModel in a SwiftUI View using `@StateObject` to ensure the ViewModel is not recreated when the View redraws.", "output": "import SwiftUI\n\nclass UserViewModel: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct UserView: View {\n    // Solution: Use @StateObject for the owner of the ObservableObject lifecycle.\n    // If this were @ObservedObject, the model might reset if the parent view redraws.\n    @StateObject private var viewModel = UserViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Hello, \\(viewModel.username)\")\n            Button(\"Login\") {\n                viewModel.username = \"Alice\"\n            }\n        }\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet involving a closure.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async {\n            self.data = \"Fetched Data\"\n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}\n\nclass ViewModel {\n    let fetcher = DataFetcher()\n    var status = \"Loading\"\n\n    init() {\n        // FIX: Add [weak self] to the capture list to break the retain cycle\n        fetcher.onDataFetched = { [weak self] in\n            guard let self = self else { return }\n            self.status = \"Data: \\(self.fetcher.data)\"\n            print(self.status)\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to fetch all 'User' entities where the 'age' attribute is greater than 21, sorted by 'lastName' in ascending order.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Predicate: age > 21\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    // Sort Descriptor: lastName ascending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Create a generic network manager function using Combine that fetches a Decodable object from a URL.", "output": "import Combine\nimport Foundation\n\nstruct NetworkManager {\n    func fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Using UIKit programmatically (no Storyboards), create a `UIView` subclass that centers a red square (50x50) within itself using Auto Layout anchors.", "output": "import UIKit\n\nclass CenteredRedView: UIView {\n    private let redSquare = UIView()\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    private func setupView() {\n        backgroundColor = .white\n        redSquare.backgroundColor = .red\n        redSquare.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(redSquare)\n\n        NSLayoutConstraint.activate([\n            redSquare.widthAnchor.constraint(equalToConstant: 50),\n            redSquare.heightAnchor.constraint(equalToConstant: 50),\n            redSquare.centerXAnchor.constraint(equalTo: centerXAnchor),\n            redSquare.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Implement a SwiftUI view that uses `@StateObject` to observe a ViewModel. The ViewModel should have a `@Published` counter property that increments every second using a Timer.", "output": "import SwiftUI\nimport Combine\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    private var timer: AnyCancellable?\n\n    init() {\n        timer = Timer.publish(every: 1.0, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak self] _ in\n                self?.count += 1\n            }\n    }\n}\n\nstruct CounterView: View {\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n                .font(.largeTitle)\n        }\n    }\n}"}
{"instruction": "In Objective-C, declare a property for a delegate that conforms to a custom protocol `MyDelegate`, ensuring it does not cause a retain cycle.", "output": "@protocol MyDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' to prevent retain cycles (or 'assign' for non-ARC legacy code, though weak is preferred in modern Obj-C)\n@property (nonatomic, weak) id<MyDelegate> delegate;\n\n@end"}
{"instruction": "Write a Swift function that saves a Codable struct to the app's Documents directory as a JSON file using `FileManager`.", "output": "import Foundation\n\nstruct UserSettings: Codable {\n    let theme: String\n    let notificationsEnabled: Bool\n}\n\nfunc saveSettings(_ settings: UserSettings) throws {\n    let fileManager = FileManager.default\n    let urls = fileManager.urls(for: .documentDirectory, in: .userDomainMask)\n    \n    guard let documentsURL = urls.first else { return }\n    let fileURL = documentsURL.appendingPathComponent(\"settings.json\")\n    \n    let data = try JSONEncoder().encode(settings)\n    try data.write(to: fileURL)\n    print(\"Saved to: \\(fileURL.path)\")\n}"}
{"instruction": "Using Combine, create a pipeline that listens to a text publisher (e.g., from a search bar), debounces the input for 500ms, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write a Swift code snippet using `DispatchQueue` to resize an image on a background thread and then update a UIImageView on the main thread.", "output": "import UIKit\n\nfunc processImage(_ image: UIImage, for imageView: UIImageView) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        // Simulate expensive image processing/resizing\n        let resizedImage = image // Assume resize logic happens here\n        \n        DispatchQueue.main.async {\n            imageView.image = resizedImage\n        }\n    }\n}"}
{"instruction": "Create a `CoreImage` filter in Swift that applies a Sepia Tone to a `UIImage`.", "output": "import UIKit\nimport CoreImage\nimport CoreImage.CIFilterBuiltins\n\nfunc applySepiaFilter(to inputImage: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: inputImage) else { return nil }\n    \n    let context = CIContext()\n    let filter = CIFilter.sepiaTone()\n    filter.inputImage = ciImage\n    filter.intensity = 1.0\n    \n    guard let outputImage = filter.outputImage,\n          let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else {\n        return nil\n    }\n    \n    return UIImage(cgImage: cgImage)\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift class where a closure captures 'self' strongly. Provide the corrected code using capture lists.", "output": "class DataFetcher {\n    var onDataFetched: ((Data) -> Void)?\n    var data: Data = Data()\n\n    func fetchData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in\n            // Capture list [weak self] prevents strong reference cycle\n            guard let self = self else { return }\n            \n            let fetchedData = Data()\n            self.data = fetchedData\n            \n            // Execute closure on main thread\n            DispatchQueue.main.async {\n                self.onDataFetched?(fetchedData)\n            }\n        }\n    }\n    \n    deinit {\n        print(\"DataFetcher deallocated\")\n    }\n}"}
{"instruction": "Create a Swift function using Core Data that performs a large data import on a background context to avoid blocking the main UI thread. Assume 'container' is an NSPersistentContainer.", "output": "func importItems(data: [String], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // This closure runs on a background queue\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for name in data {\n            let item = Item(context: context)\n            item.name = name\n            item.timestamp = Date()\n        }\n        \n        do {\n            try context.save()\n            print(\"Background import successful\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a network layer function in Swift using the Combine framework. It should fetch a URL, decode a generic Codable type, and return an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C implementation of a thread-safe Singleton using 'dispatch_once' to ensure the instance is created only once in memory.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a SwiftUI View that uses Combine to debounce text input. The view should listen to a TextField and only trigger a search action after the user stops typing for 0.5 seconds.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var query: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $query\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] searchText in\n                self?.performSearch(searchText)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(_ text: String) {\n        print(\"Searching for: \\(text)\")\n    }\n}\n\nstruct SearchView: View {\n    @StateObject private var viewModel = SearchViewModel()\n    \n    var body: some View {\n        TextField(\"Search...\", text: $viewModel.query)\n            .padding()\n            .textFieldStyle(RoundedBorderTextFieldStyle())\n    }\n}"}
{"instruction": "Write a Swift function using the Vision framework (native Apple framework) to detect text in a UIImage (OCR).", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage, completion: @escaping ([String]) -> Void) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            completion([])\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        completion(recognizedStrings)\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' pattern in Objective-C to safely access properties inside a block without causing a retain cycle or crashing if self is deallocated.", "output": "__weak typeof(self) weakSelf = self;\n[self.someAsyncOperation executeWithCompletion:^{\n    // Convert weak reference to strong to ensure self stays alive during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf updateUI];\n        strongSelf.status = @\"Finished\";\n    } else {\n        // object was deallocated\n    }\n}];"}
{"instruction": "Use Apple's CryptoKit framework in Swift to generate a SHA256 hash of a String.", "output": "import CryptoKit\nimport Foundation\n\nfunc generateSHA256(from input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    \n    // Convert digest to hex string\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Create a SwiftUI view that dynamically filters a Core Data fetch request based on a search string passed into the initializer.", "output": "import SwiftUI\nimport CoreData\n\nstruct FilteredListView: View {\n    @FetchRequest var fetchRequest: FetchedResults<Item>\n\n    init(filter: String) {\n        // Dynamic predicate construction\n        let predicate = filter.isEmpty ? nil : NSPredicate(format: \"name CONTAINS[cd] %@\", filter)\n        \n        _fetchRequest = FetchRequest<Item>(\n            sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n            predicate: predicate,\n            animation: .default\n        )\n    }\n\n    var body: some View {\n        List(fetchRequest) { item in\n            Text(item.name ?? \"Unknown\")\n        }\n    }\n}"}
{"instruction": "Using Combine, demonstrate how to zip two network publishers together to wait for both to finish before processing the results.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable { let id: Int }\nstruct Profile: Decodable { let bio: String }\n\nfunc fetchUserAndProfile(userId: Int) -> AnyPublisher<(User, Profile), Error> {\n    let userURL = URL(string: \"https://api.example.com/users/\\(userId)\")!\n    let profileURL = URL(string: \"https://api.example.com/users/\\(userId)/profile\")!\n    \n    let userPub = URLSession.shared.dataTaskPublisher(for: userURL)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n        \n    let profilePub = URLSession.shared.dataTaskPublisher(for: profileURL)\n        .map(\\.data)\n        .decode(type: Profile.self, decoder: JSONDecoder())\n        \n    // Zip waits for both to emit\n    return Publishers.Zip(userPub, profilePub)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Identify and fix the strong reference cycle in the following Swift code snippet where a class instance captures itself strongly within a closure.", "output": "class DataFetcher {\n    var onDataFetched: ((String) -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in // Fix: Use [weak self] capture list\n            guard let self = self else { return }\n            let result = \"Fetched Data\"\n            self.data = result\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?(result)\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Core Data stack in Swift using `NSPersistentContainer` that loads a persistent store named 'AppModel'.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"AppModel\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Write a function using the Combine framework to fetch JSON data from a URL, decode it into a generic `Decodable` type, and return an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to configure a `UITableViewDiffableDataSource` in UIKit to manage a list of strings.", "output": "import UIKit\n\nenum Section { case main }\n\nclass ListViewController: UIViewController {\n    var tableView: UITableView!\n    var dataSource: UITableViewDiffableDataSource<Section, String>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n        applySnapshot(items: [\"Apple\", \"Banana\", \"Cherry\"])\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource<Section, String>(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n            return cell\n        }\n    }\n\n    func applySnapshot(items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses `@FetchRequest` to display a list of `Item` entities (with a `timestamp` attribute) sorted by date.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .toolbar {\n                EditButton()\n            }\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Define an Objective-C class interface with properties demonstrating correct memory management attributes for a delegate, a string, and a mutable array.", "output": "@protocol NetworkDelegate <NSObject>\n- (void)didFinishLoading;\n@end\n\n@interface NetworkManager : NSObject\n\n// Weak reference to avoid retain cycles (Delegate pattern)\n@property (nonatomic, weak) id<NetworkDelegate> delegate;\n\n// Copy to ensure immutability of the string value assigned\n@property (nonatomic, copy) NSString *baseURL;\n\n// Strong to own the array object\n@property (nonatomic, strong) NSMutableArray *cachedRequests;\n\n@end"}
{"instruction": "Use Combine to validate a form where a 'Submit' button is enabled only if the username is at least 3 characters and the password is at least 8 characters.", "output": "import Combine\nimport UIKit\n\nclass LoginViewModel {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    \n    var isSubmitEnabled: AnyPublisher<Bool, Never> {\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                return username.count >= 3 && password.count >= 8\n            }\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Write a Swift function using `AVFoundation` to request camera access permission and setup a basic `AVCaptureSession`.", "output": "import AVFoundation\n\nfunc setupCameraSession(completion: @escaping (AVCaptureSession?) -> Void) {\n    switch AVCaptureDevice.authorizationStatus(for: .video) {\n    case .authorized:\n        configureSession(completion: completion)\n    case .notDetermined:\n        AVCaptureDevice.requestAccess(for: .video) { granted in\n            if granted {\n                configureSession(completion: completion)\n            } else {\n                completion(nil)\n            }\n        }\n    default:\n        completion(nil)\n    }\n}\n\nprivate func configureSession(completion: @escaping (AVCaptureSession?) -> Void) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        let session = AVCaptureSession()\n        session.beginConfiguration()\n        \n        guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),\n              let videoDeviceInput = try? AVCaptureDeviceInput(device: videoDevice),\n              session.canAddInput(videoDeviceInput) else {\n            completion(nil)\n            return\n        }\n        \n        session.addInput(videoDeviceInput)\n        session.commitConfiguration()\n        completion(session)\n    }\n}"}
{"instruction": "Demonstrate the usage of `autoreleasepool` in a loop to manage memory usage when creating many temporary objects (e.g., image processing) in Swift.", "output": "import UIKit\n\nfunc processImages(names: [String]) {\n    for name in names {\n        // autoreleasepool ensures temporary objects (like UIImage data) are released \n        // at the end of each iteration rather than waiting for the loop to finish.\n        autoreleasepool {\n            if let image = UIImage(named: name) {\n                let processedData = image.jpegData(compressionQuality: 0.5)\n                // Save or upload processedData\n                print(\"Processed \\(name)\")\n            }\n        }\n    }\n}"}
{"instruction": "Use `CryptoKit` (Native Framework) to generate a SHA256 hash of a string.", "output": "import CryptoKit\nimport Foundation\n\nfunc generateSHA256(from input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    \n    // Convert the digest to a hex string\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Create a Swift function that uses `LAContext` from the LocalAuthentication framework to authenticate a user using Face ID or Touch ID. Handle success and error cases appropriately.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if biometric authentication is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Log in to your account\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Write a Swift code snippet using Combine to create a search pipeline. It should take a publisher of strings (search text), debounce the input for 500ms, remove duplicates, and perform a network request (mocked as a future) based on the text, switching to the main thread for the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .flatMap { [weak self] query -> AnyPublisher<[String], Never> in\n                return self?.performSearch(query: query) ?? Just([]).eraseToAnyPublisher()\n            }\n            .receive(on: RunLoop.main)\n            .assign(to: \\.results, on: self)\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) -> AnyPublisher<[String], Never> {\n        // Mock network request\n        let mockResult = [\"Result for \\(query)\", \"Another result\"]\n        return Just(mockResult)\n            .delay(for: .milliseconds(200), scheduler: RunLoop.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Demonstrate how to prevent a retain cycle in a Swift closure within a ViewController class. The closure is a completion handler for a network service that updates a UI label.", "output": "class MyViewController: UIViewController {\n    @IBOutlet weak var statusLabel: UILabel!\n    let networkService = NetworkService()\n\n    func fetchData() {\n        // usage of [weak self] prevents the closure from strongly holding the ViewController\n        networkService.getData { [weak self] result in\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                switch result {\n                case .success(let data):\n                    self.statusLabel.text = data.description\n                case .failure(let error):\n                    self.statusLabel.text = error.localizedDescription\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet that uses `@autoreleasepool` inside a loop to manage memory efficiently when creating a large number of temporary objects.", "output": "- (void)processLargeDataSet {\n    for (int i = 0; i < 1000000; i++) {\n        @autoreleasepool {\n            // Objects created here are released at the end of each iteration\n            // preventing memory spikes during the loop execution.\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSArray *tempArray = [tempString componentsSeparatedByString:@\" \"];\n            NSLog(@\"%@\", [tempArray lastObject]);\n        }\n    }\n}"}
{"instruction": "Create a Core Data background task in Swift using `performBackgroundTask`. The task should create a new `User` entity, set its properties, and save the context handling potential errors.", "output": "import CoreData\n\nfunc createNewUserInBackground(persistentContainer: NSPersistentContainer, name: String, age: Int16) {\n    persistentContainer.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.age = age\n        user.creationDate = Date()\n\n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"User saved successfully in background context.\")\n            } catch {\n                let nserror = error as NSError\n                print(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Provide a SwiftUI view that uses `@FetchRequest` to retrieve a list of `Item` entities from Core Data, sorted by a `timestamp` attribute in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Items\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Implement a class in Objective-C that observes a property `status` on another object `Task` using Key-Value Observing (KVO). Include the observer registration and the observation method.", "output": "@interface TaskObserver : NSObject\n@property (nonatomic, strong) Task *taskToObserve;\n@end\n\n@implementation TaskObserver\n\n- (instancetype)initWithTask:(Task *)task {\n    self = [super init];\n    if (self) {\n        _taskToObserve = task;\n        [_taskToObserve addObserver:self\n                         forKeyPath:@\"status\"\n                            options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                            context:nil];\n    }\n    return self;\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSString *newStatus = change[NSKeyValueChangeNewKey];\n        NSLog(@\"Status changed to: %@\", newStatus);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    [_taskToObserve removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Write a Swift function using `CLLocationManager` to request one-time location usage authorization and fetch the current location. Include the delegate method implementation to handle the location update.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n\n    func requestLocation() {\n        // Request permission\n        locationManager.requestWhenInUseAuthorization()\n        // Request a one-time location update\n        locationManager.requestLocation()\n    }\n\n    // MARK: - CLLocationManagerDelegate\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        if let location = locations.first {\n            print(\"Found user's location: \\(location.coordinate.latitude), \\(location.coordinate.longitude)\")\n        }\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Failed to find user's location: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Create a Combine publisher pipeline in Swift that fetches data from a URL using `URLSession`, retries the request 3 times on failure, handles errors by returning a default value, and decodes the JSON into a `User` struct.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(url: URL) -> AnyPublisher<User, Never> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .retry(3) // Retry 3 times on failure\n        .catch { error -> Just<User> in\n            print(\"Request failed: \\(error)\")\n            // Return a placeholder user in case of ultimate failure\n            return Just(User(id: -1, name: \"Unknown\"))\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate the correct usage of `@StateObject` vs `@ObservedObject` in SwiftUI to ensure a ViewModel persists correctly during view updates. Create a parent view that holds the state object and passes it to a child view.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    func increment() { count += 1 }\n}\n\nstruct ParentView: View {\n    // @StateObject owns the lifecycle of the ViewModel. \n    // It is initialized once and persists even if ParentView redraws.\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Parent Count: \\(viewModel.count)\")\n            Button(\"Increment\") { viewModel.increment() }\n            \n            // Pass the existing instance to the child.\n            ChildView(viewModel: viewModel)\n        }\n    }\n}\n\nstruct ChildView: View {\n    // @ObservedObject watches an external object but does not own it.\n    // If this was @StateObject, it would reset every time ParentView re-inits ChildView.\n    @ObservedObject var viewModel: CounterViewModel\n\n    var body: some View {\n        Text(\"Child observing count: \\(viewModel.count)\")\n    }\n}"}
{"instruction": "Fix the strong reference cycle (retain cycle) in the following Swift closure where `self` is captured strongly inside a completion handler.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Solution: Use [weak self] to capture self weakly\n        let task = { [weak self] in\n            // Safely unwrap self to prevent a crash if the object is deallocated\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            self.onDataFetched?()\n        }\n        task()\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that performs a background save operation to avoid blocking the main thread. Assume a `NSPersistentContainer` named `persistentContainer` exists.", "output": "func saveEntityInBackground(name: String) {\n    persistentContainer.performBackgroundTask { context in\n        let entity = MyEntity(context: context)\n        entity.name = name\n        entity.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Saved successfully on background thread\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI ViewModel using Combine that listens to a `@Published` search query string. The pipeline should debounce input for 0.5 seconds, remove duplicates, and ensure updates are received on the main thread.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var query: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $query\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] searchText in\n                self?.performSearch(with: searchText)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(with text: String) {\n        // Mock search logic\n        self.results = [\"Result for \\(text)\"]\n    }\n}"}
{"instruction": "Implement a standard Delegate pattern in Objective-C using ARC (Automatic Reference Counting). Specifically, define the property attributes required to prevent a retain cycle between the delegator and the delegate.", "output": "// MyClass.h\n@protocol MyClassDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Solution: Use 'weak' to prevent strong reference cycles\n@property (nonatomic, weak) id<MyClassDelegate> delegate;\n\n- (void)startTask;\n\n@end\n\n// MyClass.m\n@implementation MyClass\n- (void)startTask {\n    // Task logic...\n    if ([self.delegate respondsToSelector:@selector(didCompleteTask)]) {\n        [self.delegate didCompleteTask];\n    }\n}\n@end"}
{"instruction": "Write a generic function in Swift using Combine and URLSession to fetch data from a URL and decode it into a Decodable type. The function should return an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate the correct usage of `NSCache` in Swift to store images. Include the `NSDiscardableContent` logic (implicitly handled by NSCache) and set a count limit.", "output": "import UIKit\n\nclass ImageCache {\n    static let shared = ImageCache()\n    private let cache = NSCache<NSString, UIImage>()\n\n    private init() {\n        // Set limits to manage memory footprint\n        cache.countLimit = 100\n        cache.totalCostLimit = 1024 * 1024 * 50 // 50 MB\n    }\n\n    func getImage(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n\n    func save(image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n}"}
{"instruction": "Using the Vision framework in Swift, create a function that accepts a `CGImage` and performs text recognition request (`VNRecognizeTextRequest`).", "output": "import Vision\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        print(\"Recognized text: \\(recognizedStrings)\")\n    }\n\n    request.recognitionLevel = .accurate\n\n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Write a SwiftUI View that correctly instantiates a `StateObject` for the View's lifecycle, ensuring the model is not recreated when the View is redrawn by its parent.", "output": "import SwiftUI\n\nclass ProfileModel: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct ProfileView: View {\n    // Solution: Use @StateObject for the source of truth created in this view.\n    // If this model was passed in, we would use @ObservedObject.\n    @StateObject private var model = ProfileModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Hello, \\(model.username)\")\n            Button(\"Login\") {\n                model.username = \"User123\"\n            }\n        }\n    }\n}"}
{"instruction": "Implement a `NSFetchedResultsController` delegate method in Swift to update a UITableView when Core Data content changes.", "output": "extension MyViewController: NSFetchedResultsControllerDelegate {\n    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChangeContentWith snapshot: NSDiffableDataSourceSnapshotReference) {\n        // Modern approach using Diffable Data Source\n        // Assuming 'dataSource' is a UITableViewDiffableDataSource\n        // snapshot needs to be cast or converted depending on iOS version specifics, \n        // but broadly acting on the snapshot:\n        \n        // For legacy UITableViewDataSource style:\n        self.tableView.reloadData()\n    }\n    \n    // Legacy granular update method example:\n    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {\n        switch type {\n        case .insert:\n            tableView.insertRows(at: [newIndexPath!], with: .automatic)\n        case .delete:\n            tableView.deleteRows(at: [indexPath!], with: .automatic)\n        case .update:\n            tableView.reloadRows(at: [indexPath!], with: .automatic)\n        case .move:\n            tableView.moveRow(at: indexPath!, to: newIndexPath!)\n        @unknown default:\n            fatalError()\n        }\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication successful\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometry unavailable\")\n    }\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure when a class instance holds a reference to a closure that captures 'self'.", "output": "class DataFetcher {\n    var completionHandler: (() -> Void)?\n    var data: String = \"Raw Data\"\n\n    func fetchData() {\n        // Using [weak self] breaks the retain cycle.\n        // If we used strong self (default), 'self' holds 'completionHandler' \n        // and 'completionHandler' holds 'self', causing a memory leak.\n        completionHandler = { [weak self] in\n            guard let self = self else { return }\n            print(\"Data processed: \\(self.data)\")\n        }\n    }\n\n    deinit {\n        print(\"DataFetcher is being deallocated\")\n    }\n}"}
{"instruction": "Create a function using Combine to fetch JSON data from a URL, decode it into a generic Codable type, and return it as an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write a Swift function to perform a background batch insert using Core Data to ensure the main thread is not blocked.", "output": "import CoreData\n\nfunc performBackgroundBatchInsert(container: NSPersistentContainer, items: [String]) {\n    container.performBackgroundTask { context in\n        // 'context' is created on a private queue automatically\n        for item in items {\n            let entity = MyEntity(context: context)\n            entity.name = item\n        }\n\n        do {\n            try context.save()\n            print(\"Background save successful\")\n        } catch {\n            print(\"Background save failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement Method Swizzling in Objective-C to intercept the 'viewWillAppear:' method of UIViewController.", "output": "#import <objc/runtime.h>\n#import <UIKit/UIKit.h>\n\n@implementation UIViewController (Swizzling)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(proj_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        BOOL didAddMethod = class_addMethod(class,\n                                            originalSelector,\n                                            method_getImplementation(swizzledMethod),\n                                            method_getTypeEncoding(swizzledMethod));\n\n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)proj_viewWillAppear:(BOOL)animated {\n    [self proj_viewWillAppear:animated]; // Calls original implementation\n    NSLog(@\"View Will Appear Swizzled: %@\", self);\n}\n\n@end"}
{"instruction": "Use the Vision framework in Swift to detect text within a CGImage.", "output": "import Vision\nimport CoreGraphics\n\nfunc detectText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            // Return the top candidate\n            return observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Detected text: \\(recognizedStrings)\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Demonstrate how to safely convert an Unmanaged<CFString> to a Swift String, transferring memory ownership to ARC.", "output": "import Foundation\n\nfunc convertUnmanagedString() {\n    // Simulate a CoreFoundation function returning an Unmanaged<CFString>\n    // +1 retain count (Create/Copy rule)\n    let unmanagedCFString: Unmanaged<CFString> = CFStringCreateWithCString(nil, \"Hello World\", CFStringBuiltInEncodings.UTF8.rawValue)\n    \n    // takeRetainedValue() consumes the +1 retain count and hands ownership to Swift's ARC.\n    // If we used takeUnretainedValue(), we would have a memory leak because the original CFString wouldn't be released.\n    let swiftString: String = unmanagedCFString.takeRetainedValue() as String\n    \n    print(swiftString)\n}"}
{"instruction": "Implement a Combine pipeline that handles search bar input by debouncing, removing duplicates, and filtering empty strings.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main) // Wait for typing to stop\n            .removeDuplicates() // Ignore if the text hasn't changed\n            .filter { !$0.isEmpty } // Ignore empty strings\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &subscriptions)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Programmatically center a UIView within a parent view using UIKit Auto Layout anchors.", "output": "import UIKit\n\nfunc setupCenteredView(parentView: UIView) {\n    let redBox = UIView()\n    redBox.backgroundColor = .red\n    redBox.translatesAutoresizingMaskIntoConstraints = false // Critical for Auto Layout\n    parentView.addSubview(redBox)\n\n    NSLayoutConstraint.activate([\n        redBox.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n        redBox.centerYAnchor.constraint(equalTo: parentView.centerYAnchor),\n        redBox.widthAnchor.constraint(equalToConstant: 100),\n        redBox.heightAnchor.constraint(equalToConstant: 100)\n    ])\n}"}
{"instruction": "Explain and implement the Singleton pattern for a Core Data Manager in Swift to ensure a single persistent container instance.", "output": "import CoreData\n\nclass CoreDataManager {\n    // Singleton instance\n    static let shared = CoreDataManager()\n\n    // Private init to prevent external instantiation\n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            try? context.save()\n        }\n    }\n}"}
{"instruction": "Demonstrate the difference between @StateObject and @ObservedObject in SwiftUI regarding memory management and view lifecycle.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n}\n\nstruct ParentView: View {\n    @State private var refreshToggle = false\n\n    var body: some View {\n        VStack {\n            Button(\"Refresh Parent\") { refreshToggle.toggle() }\n            \n            // Correct: ViewModel persists when ParentView redraws\n            ChildViewStateObject()\n            \n            // Incorrect: ViewModel is destroyed and recreated every time ParentView redraws\n            ChildViewObservedObject(viewModel: CounterViewModel())\n        }\n    }\n}\n\nstruct ChildViewStateObject: View {\n    // @StateObject owns the object. Created once.\n    @StateObject var viewModel = CounterViewModel()\n    var body: some View { Text(\"Count: \\(viewModel.count)\") }\n}\n\nstruct ChildViewObservedObject: View {\n    // @ObservedObject does not own the object. It depends on external injection.\n    // If injected via init() in the parent's body, it may reset unexpectedly.\n    @ObservedObject var viewModel: CounterViewModel\n    var body: some View { Text(\"Count: \\(viewModel.count)\") }\n}"}
{"instruction": "Create a Swift function that demonstrates how to prevent a Strong Reference Cycle (Retain Cycle) inside a closure when accessing a class property. The class 'DataFetcher' has a property 'onComplete' and a method 'fetchData'.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulating async operation\n        DispatchQueue.global().async { [weak self] in\n            // Capture self weakly to avoid retain cycle\n            guard let self = self else { return }\n            \n            self.data = \"Fetched Data\"\n            \n            DispatchQueue.main.async {\n                self.onComplete?()\n            }\n        }\n    }\n}"}
{"instruction": "Using Core Data in Swift, write a function that performs a background task to update a 'User' entity's 'lastLogin' date to the current date. Assume 'persistentContainer' is available globally.", "output": "func updateLastLogin(for userID: UUID) {\n    let backgroundContext = persistentContainer.newBackgroundContext()\n    \n    backgroundContext.perform {\n        let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n        fetchRequest.predicate = NSPredicate(format: \"id == %@\", userID as CVarArg)\n        \n        do {\n            let results = try backgroundContext.fetch(fetchRequest)\n            if let user = results.first {\n                user.lastLogin = Date()\n                try backgroundContext.save()\n            }\n        } catch {\n            print(\"Failed to update user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a Combine pipeline in Swift that takes a 'searchText' publisher, debounces it for 0.5 seconds, removes duplicates, and ensures the output is delivered on the main thread.", "output": "import Combine\nimport Foundation\n\nfunc setupSearchSubscription(searchTextPublisher: AnyPublisher<String, Never>) -> AnyCancellable {\n    return searchTextPublisher\n        .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n        .removeDuplicates()\n        .sink { text in\n            print(\"Searching for: \\(text)\")\n            // Trigger API call here\n        }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating how to use an @autoreleasepool block to manage memory usage inside a loop that processes a large number of temporary objects (e.g., UIImages).", "output": "NSArray *imagePaths = @[/* ... 1000 file paths ... */];\n\nfor (NSString *path in imagePaths) {\n    @autoreleasepool {\n        // The image object is released at the end of this block\n        // preventing memory spikes during the loop iteration\n        UIImage *image = [UIImage imageWithContentsOfFile:path];\n        [self processImage:image];\n    }\n}"}
{"instruction": "Create a simple SwiftUI View that observes a 'TimerManager' class conforming to ObservableObject. The view should display a counter that increments every second.", "output": "import SwiftUI\nimport Combine\n\nclass TimerManager: ObservableObject {\n    @Published var count = 0\n    private var timer: AnyCancellable?\n\n    init() {\n        timer = Timer.publish(every: 1, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak self] _ in self?.count += 1 }\n    }\n}\n\nstruct TimerView: View {\n    @StateObject private var timerManager = TimerManager()\n\n    var body: some View {\n        Text(\"Count: \\(timerManager.count)\")\n            .font(.largeTitle)\n            .padding()\n    }\n}"}
{"instruction": "Using native Swift concurrency (Actors), create a thread-safe 'BankAccount' actor that allows depositing and withdrawing funds without race conditions.", "output": "actor BankAccount {\n    private(set) var balance: Double = 0.0\n\n    func deposit(amount: Double) {\n        balance += amount\n    }\n\n    func withdraw(amount: Double) -> Bool {\n        if balance >= amount {\n            balance -= amount\n            return true\n        }\n        return false\n    }\n}\n\n// Usage:\n// Task {\n//     let account = BankAccount()\n//     await account.deposit(amount: 100)\n// }"}
{"instruction": "Write a Swift function using Core Image to apply a Sepia Tone filter to a UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Implement a custom UIView subclass in Swift that overrides the 'draw(_:)' method to draw a red circle centered in the view using UIBezierPath.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let radius = min(rect.width, rect.height) / 2 - 10\n        let center = CGPoint(x: rect.width / 2, y: rect.height / 2)\n        \n        let path = UIBezierPath(arcCenter: center,\n                                radius: radius,\n                                startAngle: 0,\n                                endAngle: .pi * 2,\n                                clockwise: true)\n        \n        UIColor.red.setFill()\n        path.fill()\n    }\n}"}
{"instruction": "Write an Objective-C implementation of the Singleton pattern for a class named 'NetworkManager'.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n- (instancetype)init {\n    if (self = [super init]) {\n        // Initialization code here\n    }\n    return self;\n}\n\n@end"}
{"instruction": "Using Combine in Swift, create a function that fetches JSON data from a URL, decodes it into a generic Codable type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a Swift class named `NetworkService` that performs a simulated network call using a closure. Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) when calling this closure from a View Controller.", "output": "class NetworkService {\n    func fetchData(completion: @escaping (String) -> Void) {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            completion(\"Data received\")\n        }\n    }\n}\n\nclass MyViewController: UIViewController {\n    let service = NetworkService()\n    var statusLabel: String = \"Loading...\"\n\n    func updateData() {\n        // Usage of [weak self] to prevent retain cycle\n        service.fetchData { [weak self] data in\n            guard let self = self else { return }\n            \n            // Dispatch to main thread for UI updates\n            DispatchQueue.main.async {\n                self.statusLabel = data\n                print(self.statusLabel)\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift code snippet using the Combine framework to fetch JSON data from a URL, decode it into a `User` struct, and assign it to a published property on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nclass UserViewModel: ObservableObject {\n    @Published var user: User?\n    var cancellables = Set<AnyCancellable>()\n\n    func fetchUser() {\n        guard let url = URL(string: \"https://api.example.com/user/1\") else { return }\n\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: User.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .finished: break\n                case .failure(let error):\n                    print(\"Error: \\(error)\")\n                }\n            }, receiveValue: { [weak self] user in\n                self?.user = user\n            })\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Set up a basic Core Data stack in a Swift Singleton class named `CoreDataManager`. Include the initialization of the `NSPersistentContainer` and a method to save the context.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using SwiftUI, create a view that filters a list of strings based on a search text binding using the `.searchable` modifier.", "output": "import SwiftUI\n\nstruct SearchView: View {\n    let names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\n    @State private var searchText = \"\"\n\n    var filteredNames: [String] {\n        if searchText.isEmpty {\n            return names\n        } else {\n            return names.filter { $0.localizedCaseInsensitiveContains(searchText) }\n        }\n    }\n\n    var body: some View {\n        NavigationStack {\n            List(filteredNames, id: \\.self) { name in\n                Text(name)\n            }\n            .navigationTitle(\"Contacts\")\n            .searchable(text: $searchText, prompt: \"Search name\")\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating how to execute a block safely without causing a retain cycle, using the `__weak` and `__strong` dance.", "output": "@interface MyClass : NSObject\n@property (nonatomic, copy) void (^completionBlock)(void);\n@property (nonatomic, strong) NSString *data;\n@end\n\n@implementation MyClass\n\n- (void)performTask {\n    __weak typeof(self) weakSelf = self;\n    \n    self.completionBlock = ^{\n        // Promote weak reference to strong to ensure self stays alive during execution\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        \n        if (strongSelf) {\n            strongSelf.data = @\"Updated Data\";\n            NSLog(@\"Data updated: %@\", strongSelf.data);\n        } else {\n            NSLog(@\"Self was deallocated before block execution\");\n        }\n    };\n    \n    self.completionBlock();\n}\n\n@end"}
{"instruction": "Implement a function using the Vision framework in Swift to recognize text from a `CGImage`.", "output": "import Vision\n\nfunc recognizeText(from image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed: \\(String(describing: error))\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized Text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n\n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform request: \\(error)\")\n    }\n}"}
{"instruction": "Using UIKit, demonstrate how to populate a `UITableView` using `UITableViewDiffableDataSource` with a custom Section enum and a simple String item.", "output": "import UIKit\n\nclass ListViewController: UIViewController {\n    enum Section { case main }\n    var tableView: UITableView!\n    var dataSource: UITableViewDiffableDataSource<Section, String>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupTableView()\n        configureDataSource()\n        applySnapshot()\n    }\n\n    func setupTableView() {\n        tableView = UITableView(frame: view.bounds, style: .plain)\n        tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\")\n        view.addSubview(tableView)\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource<Section, String>(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n            return cell\n        }\n    }\n\n    func applySnapshot() {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems([\"Item 1\", \"Item 2\", \"Item 3\"])\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Create a function that performs a Core Data background task to import a large array of dictionaries into an entity named `Item`, ensuring thread safety.", "output": "import CoreData\n\nfunc importItems(_ data: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Optimize performance for bulk inserts\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for dict in data {\n            guard let name = dict[\"name\"] as? String else { continue }\n            \n            // Assuming 'Item' is the NSManagedObject subclass\n            let item = NSEntityDescription.insertNewObject(forEntityName: \"Item\", into: context)\n            item.setValue(name, forKey: \"name\")\n            item.setValue(Date(), forKey: \"timestamp\")\n        }\n        \n        do {\n            try context.save()\n            print(\"Background import completed successfully.\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Use the Combine framework to implement a search bar logic where the search query is debounced by 500ms and duplicate queries are ignored.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchQuery: String = \"\"\n    var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n        // Execute API call here\n    }\n}"}
{"instruction": "Write a Swift function using Apple's CryptoKit framework to generate a SHA256 hash of a given String.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashString(_ input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    \n    // Convert the digest to a hex string representation\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}\n\n// Usage Example\n// let hashed = hashString(\"Hello World\")"}
{"instruction": "Create a Swift class named `ImageDownloader` that simulates a network call using a closure. Implement the call in a way that prevents a strong reference cycle (memory leak) when the closure captures `self`.", "output": "import UIKit\n\nclass ImageDownloader {\n    var onImageDownloaded: ((UIImage?) -> Void)?\n    \n    func downloadImage() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Guard against self being deallocated\n            guard let self = self else { return }\n            \n            let image = UIImage(systemName: \"photo\")\n            \n            DispatchQueue.main.async {\n                // Execute the closure if it exists\n                self.onImageDownloaded?(image)\n            }\n        }\n    }\n    \n    deinit {\n        print(\"ImageDownloader instance deallocated\")\n    }\n}"}
{"instruction": "Using Swift and Core Data, write a function named `createAndSaveUser` that takes a name and an `NSPersistentContainer`. The function must create a new `User` entity and save it using a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc createAndSaveUser(name: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Create the entity on the background context\n        let user = NSEntityDescription.insertNewObject(forEntityName: \"User\", into: context)\n        user.setValue(name, forKey: \"name\")\n        \n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a Combine pipeline in Swift that takes a search query string, debounces the input for 500 milliseconds, removes duplicate consecutive entries, and performs a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchQuery: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n    \n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &subscriptions)\n    }\n    \n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using Objective-C, write a code snippet demonstrating how to use `@autoreleasepool` inside a tight loop to manage memory when creating a large number of temporary objects.", "output": "#import <Foundation/Foundation.h>\n\nvoid processLargeData() {\n    for (int i = 0; i < 100000; i++) {\n        @autoreleasepool {\n            // Create temporary objects that are only needed inside this iteration\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSArray *tempArray = @[tempString, tempString, tempString];\n            \n            // Simulate work\n            NSLog(@\"Length: %lu\", (unsigned long)tempArray.count);\n            \n            // Objects created here are released at the end of the @autoreleasepool block\n            // keeping the memory footprint low during the loop execution.\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses `ObservableObject` and `@Published` to fetch data from an API using `URLSession` and Combine, displaying a loading state or the result text.", "output": "import SwiftUI\nimport Combine\n\nclass DataFetcher: ObservableObject {\n    @Published var data: String = \"No Data\"\n    @Published var isLoading: Bool = false\n    private var cancellable: AnyCancellable?\n\n    func fetchData() {\n        isLoading = true\n        let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\")!\n        \n        cancellable = URLSession.shared.dataTaskPublisher(for: url)\n            .map { String(data: $0.data, encoding: .utf8) ?? \"Error\" }\n            .replaceError(with: \"Request Failed\")\n            .receive(on: DispatchQueue.main)\n            .sink { [weak self] result in\n                self?.data = result\n                self?.isLoading = false\n            }\n    }\n}\n\nstruct ContentView: View {\n    @StateObject var fetcher = DataFetcher()\n\n    var body: some View {\n        VStack {\n            if fetcher.isLoading {\n                ProgressView()\n            } else {\n                Text(fetcher.data)\n                    .padding()\n            }\n            Button(\"Fetch\") {\n                fetcher.fetchData()\n            }\n        }\n    }\n}"}
{"instruction": "Using the Vision framework in Swift, create a function `detectText` that takes a `UIImage` and prints recognized strings found within the image.", "output": "import Vision\nimport UIKit\n\nfunc detectText(in image: UIImage) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text detection failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Detected text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform detection: \\(error)\")\n    }\n}"}
{"instruction": "Write a Swift function that uses `CryptoKit` to generate a SHA256 hash of a given String and returns the hash as a hex string.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashStringSHA256(_ input: String) -> String {\n    guard let data = input.data(using: .utf8) else { return \"\" }\n    let hashed = SHA256.hash(data: data)\n    \n    // Convert the digest to a hex string\n    return hashed.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Implement a generic Core Data `fetch` function in Swift that accepts an `NSManagedObjectContext` and a generic type `T` (constrained to `NSManagedObject`), returning an array of results.", "output": "import CoreData\n\nfunc fetchEntities<T: NSManagedObject>(ofType type: T.Type, context: NSManagedObjectContext) -> [T] {\n    let entityName = String(describing: type)\n    let fetchRequest = NSFetchRequest<T>(entityName: entityName)\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Error fetching \\(entityName): \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using Objective-C, implement Key-Value Observing (KVO) to observe a property named `status` on an object `job`. Log a message when the value changes, and remove the observer in `dealloc`.", "output": "#import <Foundation/Foundation.h>\n\n@interface Job : NSObject\n@property (nonatomic, strong) NSString *status;\n@end\n@implementation Job\n@end\n\n@interface JobObserver : NSObject\n@property (nonatomic, strong) Job *job;\n@end\n\n@implementation JobObserver\n\n- (instancetype)initWithJob:(Job *)job {\n    self = [super init];\n    if (self) {\n        _job = job;\n        [_job addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n    return self;\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed to: %@\", change[NSKeyValueChangeNewKey]);\n    }\n}\n\n- (void)dealloc {\n    [_job removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Using UIKit and Swift, configure a `UITableView` to use `UITableViewDiffableDataSource`. Create a function to apply a snapshot with a list of strings.", "output": "import UIKit\n\nclass ListViewController: UITableViewController {\n    enum Section { case main }\n    var dataSource: UITableViewDiffableDataSource<Section, String>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource<Section, String>(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n            return cell\n        }\n        tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"Cell\")\n    }\n\n    func updateList(with items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (retain cycle) in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to capture self weakly to prevent a retain cycle\n        onComplete = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            print(self.data)\n        }\n    }\n}"}
{"instruction": "Create a function in Swift using Core Data that creates a new entity named 'User' and saves it on a background context to avoid blocking the main thread.", "output": "import CoreData\n\nfunc createUserInBackground(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a function that takes a URL, fetches data using URLSession, decodes it into a generic Codable type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Codable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a SwiftUI ViewModel using Combine that listens to a text publisher, debounces the input for 500 milliseconds, and removes duplicates before triggering a search function.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        // Perform search logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "In Objective-C, declare a delegate property for a custom view controller to ensure memory safety and prevent retain cycles.", "output": "@protocol MyCustomDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyViewController : UIViewController\n\n// Use 'weak' to prevent strong reference cycles (retain cycles)\n@property (nonatomic, weak) id<MyCustomDelegate> delegate;\n\n@end"}
{"instruction": "Write a UIKit function programmatically (without Storyboards) that creates a red square UIView, adds it to a parent view, and centers it using Auto Layout constraints.", "output": "import UIKit\n\nfunc addCenteredRedSquare(to parentView: UIView) {\n    let redSquare = UIView()\n    redSquare.backgroundColor = .red\n    redSquare.translatesAutoresizingMaskIntoConstraints = false\n    parentView.addSubview(redSquare)\n\n    NSLayoutConstraint.activate([\n        redSquare.widthAnchor.constraint(equalToConstant: 100),\n        redSquare.heightAnchor.constraint(equalToConstant: 100),\n        redSquare.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n        redSquare.centerYAnchor.constraint(equalTo: parentView.centerYAnchor)\n    ])\n}"}
{"instruction": "Using Core Graphics within a UIView subclass, override the `draw(_:)` method to draw a blue circle with a 5-point stroke width.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let insetRect = rect.insetBy(dx: 10, dy: 10)\n        context.setStrokeColor(UIColor.blue.cgColor)\n        context.setLineWidth(5.0)\n        \n        context.addEllipse(in: insetRect)\n        context.strokePath()\n    }\n}"}
{"instruction": "Implement a function using Swift Concurrency (async/await) to download an image from a URL and return a UIImage. Ensure error handling is included.", "output": "import UIKit\n\nfunc downloadImage(from url: URL) async throws -> UIImage {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw URLError(.badServerResponse)\n    }\n    \n    guard let image = UIImage(data: data) else {\n        throw URLError(.cannotDecodeContentData)\n    }\n    \n    return image\n}"}
{"instruction": "Demonstrate how to set up a basic AVCaptureSession in Swift to capture video input from the default back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n\n    guard let backCamera = AVCaptureDevice.default(for: .video),\n          let input = try? AVCaptureDeviceInput(device: backCamera) else {\n        return nil\n    }\n\n    if session.canAddInput(input) {\n        session.addInput(input)\n        return session\n    }\n    return nil\n}"}
{"instruction": "Write a Swift function that saves a Codable struct to the app's Documents directory using FileManager.", "output": "import Foundation\n\nstruct UserSettings: Codable {\n    let username: String\n    let isDarkMode: Bool\n}\n\nfunc saveSettings(_ settings: UserSettings) throws {\n    let fileManager = FileManager.default\n    let urls = fileManager.urls(for: .documentDirectory, in: .userDomainMask)\n    \n    if let documentDirectory = urls.first {\n        let fileURL = documentDirectory.appendingPathComponent(\"settings.json\")\n        let data = try JSONEncoder().encode(settings)\n        try data.write(to: fileURL)\n        print(\"Settings saved to: \\(fileURL.path)\")\n    }\n}"}
{"instruction": "Identify and fix the memory leak (retain cycle) in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in // Fix: Use capture list [weak self]\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data's `NSPersistentContainer` to perform a background task that inserts 1000 'User' entities efficiently without blocking the main UI thread.", "output": "func saveUsersInBackground(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        for i in 0..<1000 {\n            let user = User(context: context)\n            user.id = UUID()\n            user.name = \"User \\(i)\"\n        }\n        \n        do {\n            try context.save()\n            print(\"Saved 1000 users in background context.\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in a SwiftUI ViewModel that observes a 'searchText' property, debounces the input for 500ms, removes duplicates, and triggers a search function.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using Objective-C, implement Key-Value Observing (KVO) to observe changes to the 'status' property of a 'Task' object.", "output": "@interface TaskObserver : NSObject\n@property (nonatomic, strong) Task *task;\n@end\n\n@implementation TaskObserver\n\n- (instancetype)initWithTask:(Task *)task {\n    self = [super init];\n    if (self) {\n        _task = task;\n        [_task addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n    return self;\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed to: %@\", change[NSKeyValueChangeNewKey]);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    [_task removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Implement a custom SwiftUI `PreferenceKey` to pass the width of a child view up to its parent view.", "output": "import SwiftUI\n\nstruct WidthPreferenceKey: PreferenceKey {\n    static var defaultValue: CGFloat = 0\n    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {\n        value = nextValue()\n    }\n}\n\nstruct ChildView: View {\n    var body: some View {\n        Text(\"Hello World\")\n            .background(GeometryReader { geo in\n                Color.clear\n                    .preference(key: WidthPreferenceKey.self, value: geo.size.width)\n            })\n    }\n}\n\nstruct ParentView: View {\n    @State private var childWidth: CGFloat = 0\n    \n    var body: some View {\n        VStack {\n            Text(\"Child Width: \\(childWidth)\")\n            ChildView()\n        }\n        .onPreferenceChange(WidthPreferenceKey.self) { value in\n            self.childWidth = value\n        }\n    }\n}"}
{"instruction": "Write a Swift function using the LocalAuthentication framework to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a Combine publisher that fetches data from a URL, retries the request 3 times on failure, and then replaces the error with a default value if it still fails.", "output": "import Combine\nimport Foundation\n\nfunc fetchReliableData() -> AnyPublisher<Data, Never> {\n    let url = URL(string: \"https://api.example.com/data\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .retry(3) // Retry 3 times on failure\n        .catch { error -> Just<Data> in\n            print(\"Request failed after retries: \\(error)\")\n            return Just(Data()) // Return empty data on final failure\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Using Objective-C, write a loop that creates a large number of temporary objects (e.g., NSString) and uses `@autoreleasepool` to keep memory footprint low during execution.", "output": "- (void)processLargeDataSet {\n    for (int i = 0; i < 1000000; i++) {\n        @autoreleasepool {\n            // Creates a temporary object that would normally wait until the end of the run loop to deallocate\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            [self logString:tempString];\n            \n            // Without @autoreleasepool, memory would spike significantly here\n        }\n    }\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift that draws a red circle with a 5px border using `CoreGraphics` inside `draw(_:)`.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let insetRect = rect.insetBy(dx: 5, dy: 5)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.setStrokeColor(UIColor.black.cgColor)\n        context.setLineWidth(5.0)\n        \n        context.addEllipse(in: insetRect)\n        context.drawPath(using: .fillStroke)\n    }\n}"}
{"instruction": "Write a Swift function using `async/await` to fetch a user profile and their profile image concurrently using `async let`.", "output": "struct UserProfile { let name: String; let image: Data }\n\nfunc fetchProfileData() async throws -> UserProfile {\n    async let name = fetchUserName() // Assume returns String\n    async let imageData = fetchUserImage() // Assume returns Data\n    \n    // Await both results simultaneously\n    return try await UserProfile(name: name, image: imageData)\n}\n\n// Mock functions for context\nfunc fetchUserName() async throws -> String { return \"Alice\" }\nfunc fetchUserImage() async throws -> Data { return Data() }"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift closure within a ViewController.", "output": "class MyViewController: UIViewController {\n    var dataLoader: DataLoader?\n    var statusLabel: UILabel = UILabel()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        dataLoader = DataLoader()\n        \n        // FIX: Use [weak self] to break the retain cycle\n        dataLoader?.onDataLoaded = { [weak self] result in\n            guard let self = self else { return }\n            self.statusLabel.text = \"Loaded: \\(result)\"\n        }\n    }\n}"}
{"instruction": "Write a function using Core Data's NSPersistentContainer to perform a background task that inserts a massive amount of user objects to avoid blocking the main UI thread.", "output": "func importUsers(_ users: [UserJSON], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // This runs on a background queue\n        for userJSON in users {\n            let userEntity = UserEntity(context: context)\n            userEntity.id = userJSON.id\n            userEntity.name = userJSON.name\n        }\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that searches for a query, debounces the input for 500ms, removes duplicates, and fetches data from a URL.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchQuery: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n    \n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .flatMap { query in\n                URLSession.shared.dataTaskPublisher(for: URL(string: \"https://api.example.com/search?q=\\(query)\")!)\n                    .map { $0.data }\n                    .decode(type: [String].self, decoder: JSONDecoder())\n                    .replaceError(with: [])\n            }\n            .receive(on: RunLoop.main)\n            .sink { results in\n                print(\"Search results: \\(results)\")\n            }\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "Implement standard Key-Value Observing (KVO) in Objective-C to watch for changes on a 'status' property of a 'NetworkManager' object.", "output": "@interface MyObserver : NSObject\n@property (nonatomic, strong) NetworkManager *manager;\n@end\n\n@implementation MyObserver\n\n- (void)startObserving {\n    self.manager = [[NetworkManager alloc] init];\n    [self.manager addObserver:self\n                   forKeyPath:@\"status\"\n                      options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                      context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSString *newStatus = change[NSKeyValueChangeNewKey];\n        NSLog(@\"Status changed to: %@\", newStatus);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    [self.manager removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Demonstrate the correct usage of @StateObject versus @ObservedObject in SwiftUI to ensure a ViewModel's lifecycle is tied to the View's creation and not destroyed on redraws.", "output": "import SwiftUI\n\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct ProfileView: View {\n    // @StateObject ensures the instance is created once and survives view updates/redraws.\n    @StateObject private var viewModel = ProfileViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Hello, \\(viewModel.username)\")\n            SubView(viewModel: viewModel)\n        }\n    }\n}\n\nstruct SubView: View {\n    // @ObservedObject is used for dependency injection; it does not own the lifecycle.\n    @ObservedObject var viewModel: ProfileViewModel\n\n    var body: some View {\n        Button(\"Change Name\") {\n            viewModel.username = \"User\"\n        }\n    }\n}"}
{"instruction": "Using Grand Central Dispatch (GCD) in Swift, execute three independent asynchronous network calls and run a completion block only when all three have finished.", "output": "func fetchDashboardData(completion: @escaping () -> Void) {\n    let dispatchGroup = DispatchGroup()\n    \n    // Task 1\n    dispatchGroup.enter()\n    Network.fetchProfile { _ in\n        dispatchGroup.leave()\n    }\n    \n    // Task 2\n    dispatchGroup.enter()\n    Network.fetchFriends { _ in\n        dispatchGroup.leave()\n    }\n    \n    // Task 3\n    dispatchGroup.enter()\n    Network.fetchSettings { _ in\n        dispatchGroup.leave()\n    }\n    \n    dispatchGroup.notify(queue: .main) {\n        print(\"All requests finished.\")\n        completion()\n    }\n}"}
{"instruction": "Write a Swift function using Core Image (CIContext) to apply a Sepia Tone filter to a UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Using Objective-C, mitigate high memory peaks when creating temporary objects inside a tight loop using an autorelease pool.", "output": "- (void)processLargeDataSet {\n    for (int i = 0; i < 100000; i++) {\n        @autoreleasepool {\n            // Objects created here are released at the end of this block,\n            // preventing memory spikes during the loop execution.\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSData *tempData = [tempString dataUsingEncoding:NSUTF8StringEncoding];\n            [self saveToDisk:tempData];\n        }\n    }\n}"}
{"instruction": "Bind a UITextField's text changes to a Combine publisher in a UIKit ViewController without using SwiftUI.", "output": "import UIKit\nimport Combine\n\nclass LoginViewController: UIViewController {\n    @IBOutlet weak var emailTextField: UITextField!\n    private var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: emailTextField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .sink { text in\n                print(\"User typed: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Construct a complex NSFetchRequest in Swift using Core Data that filters by a compound predicate (isActive AND age > 18) and sorts by name ascending.", "output": "func fetchActiveAdultUsers() -> NSFetchRequest<UserEntity> {\n    let request: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()\n    \n    let activePredicate = NSPredicate(format: \"isActive == YES\")\n    let agePredicate = NSPredicate(format: \"age > 18\")\n    \n    request.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [activePredicate, agePredicate])\n    request.sortDescriptors = [NSSortDescriptor(key: \"name\", ascending: true)]\n    \n    return request\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures `self` strongly. The class `DataFetcher` has a property `onComplete` which references `self` inside its assignment.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        onComplete = { [weak self] in\n            // Guard to safely unwrap weak self\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            print(self.data)\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses `@FetchRequest` to display a list of `TodoItem` entities (with properties `title` and `createdAt`) from Core Data, sorted by `createdAt` in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TodoListView: View {\n    // The FetchRequest property wrapper handles the fetching and updating\n    @FetchRequest(\n        entity: TodoItem.entity(),\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TodoItem.createdAt, ascending: false)]\n    ) var items: FetchedResults<TodoItem>\n\n    var body: some View {\n        List(items, id: \\.self) { item in\n            Text(item.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that takes a publisher `searchText`, debounces the input for 500 milliseconds, removes duplicate consecutive values, and sinks the result to print to the console.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Searching for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating the 'Weak-Strong Dance' within a block to prevent a retain cycle while updating a UI label after an asynchronous delay.", "output": "// Assume self is a UIViewController with a property 'statusLabel'\n__weak typeof(self) weakSelf = self;\n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    // Convert weak reference to strong reference to ensure self exists during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        strongSelf.statusLabel.text = @\"Updated\";\n    }\n});"}
{"instruction": "Implement a function in Swift using `NSBatchUpdateRequest` to update the `isRead` boolean property to `true` for all `Message` entities in Core Data without loading the objects into memory.", "output": "import CoreData\n\nfunc markAllMessagesAsRead(context: NSManagedObjectContext) throws {\n    // Create the batch update request\n    let batchUpdate = NSBatchUpdateRequest(entityName: \"Message\")\n    \n    // Set the properties to update\n    batchUpdate.propertiesToUpdate = [\"isRead\": true]\n    \n    // Specify that we want the result as object IDs (or count, depending on need)\n    batchUpdate.resultType = .updatedObjectIDsResultType\n    \n    // Execute the request\n    let result = try context.execute(batchUpdate) as? NSBatchUpdateResult\n    \n    // Merge changes into the context to keep UI in sync if necessary\n    if let objectIDs = result?.result as? [NSManagedObjectID] {\n        let changes = [NSUpdatedObjectsKey: objectIDs]\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [context])\n    }\n}"}
{"instruction": "Programmatically center a red `UIView` (sized 100x100) within a parent view controller's view using `NSLayoutConstraint` anchors in UIKit (Swift).", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let redBox = UIView()\n        redBox.backgroundColor = .red\n        redBox.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(redBox)\n        \n        NSLayoutConstraint.activate([\n            redBox.widthAnchor.constraint(equalToConstant: 100),\n            redBox.heightAnchor.constraint(equalToConstant: 100),\n            redBox.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            redBox.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Use `Publishers.CombineLatest` in Swift to create a publisher `isFormValid` that emits `true` only when a `username` string is at least 3 characters long and a `password` string is at least 8 characters long.", "output": "import Combine\n\nclass LoginViewModel {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    \n    var isFormValid: AnyPublisher<Bool, Never> {\n        Publishers.CombineLatest($username, $password)\n            .map { user, pass in\n                return user.count >= 3 && pass.count >= 8\n            }\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Using Grand Central Dispatch (GCD) in Swift, execute two simulated asynchronous network requests in parallel and print \"All Finished\" only when both requests have completed.", "output": "import Foundation\n\nlet group = DispatchGroup()\n\n// Task 1\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n    print(\"Task 1 Complete\")\n    group.leave()\n}\n\n// Task 2\ngroup.enter()\nDispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n    print(\"Task 2 Complete\")\n    group.leave()\n}\n\n// Notify when both are done\ngroup.notify(queue: .main) {\n    print(\"All Finished\")\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift that draws a blue circle filled with yellow color using Core Graphics in the `draw(_:)` method.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        // Set stroke and fill colors\n        context.setStrokeColor(UIColor.blue.cgColor)\n        context.setFillColor(UIColor.yellow.cgColor)\n        context.setLineWidth(4.0)\n        \n        // Define the rectangle for the circle (inset slightly to account for line width)\n        let circleRect = rect.insetBy(dx: 5, dy: 5)\n        \n        // Add ellipse to context\n        context.addEllipse(in: circleRect)\n        \n        // Draw path (fill and stroke)\n        context.drawPath(using: .fillStroke)\n    }\n}"}
{"instruction": "Use Apple's CryptoKit framework in Swift to generate a SHA256 hash of a String and return the hexadecimal representation.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashString(input: String) -> String {\n    guard let data = input.data(using: .utf8) else { return \"\" }\n    \n    let digest = SHA256.hash(data: data)\n    \n    // Convert the digest to a hex string\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Identify and fix the strong reference cycle in the following Swift code snippet where a class `DataLoader` holds a closure that references `self`.", "output": "class DataLoader {\n    var onDataLoaded: (() -> Void)?\n    var data: [String] = []\n\n    func loadData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in\n            // Capture self weakly to prevent retain cycle\n            guard let self = self else { return }\n            \n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataLoaded?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Core Data fetch request in Swift to retrieve 'User' entities where the 'age' attribute is greater than 21, sorted by 'lastName' in ascending order.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Predicate: Age > 21\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    // Sort Descriptor: LastName ascending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that observes a text field's text publisher, waits for a 0.5-second pause (debounce), removes duplicate inputs, and prints the result.", "output": "import Combine\nimport UIKit\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { text in\n                print(\"Search query: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "// NetworkManager.h\n@interface NetworkManager : NSObject\n+ (instancetype)sharedInstance;\n@end\n\n// NetworkManager.m\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Using UIKit and Core Graphics, create a custom UIView subclass that draws a red circle with a 2-point black border in the center of the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let radius = min(rect.width, rect.height) / 2 - 2\n        let center = CGPoint(x: rect.width / 2, y: rect.height / 2)\n        \n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: .pi * 2, clockwise: true)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.setStrokeColor(UIColor.black.cgColor)\n        context.setLineWidth(2.0)\n        \n        context.drawPath(using: .fillStroke)\n    }\n}"}
{"instruction": "Demonstrate how to use `NSBatchDeleteRequest` in Swift to delete all entities of type 'LogEntry' from Core Data without loading them into memory.", "output": "import CoreData\n\nfunc deleteAllLogs(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let fetchRequest: NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName: \"LogEntry\")\n        let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n        \n        // Specify result type if you need the IDs of deleted objects\n        batchDeleteRequest.resultType = .resultTypeCount\n        \n        do {\n            let result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult\n            print(\"Deleted \\(result?.result ?? 0) records.\")\n            \n            // Merge changes to main context if necessary\n            try context.save()\n        } catch {\n            print(\"Batch delete failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using SwiftUI, create a view that uses the `LocalAuthentication` framework to authenticate a user via FaceID or TouchID when a button is pressed.", "output": "import SwiftUI\nimport LocalAuthentication\n\nstruct BiometricAuthView: View {\n    @State private var isUnlocked = false\n\n    var body: some View {\n        VStack {\n            if isUnlocked {\n                Text(\"Unlocked!\")\n            } else {\n                Button(\"Authenticate\") {\n                    authenticate()\n                }\n            }\n        }\n    }\n\n    func authenticate() {\n        let context = LAContext()\n        var error: NSError?\n\n        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: \"Access requires authentication\") { success, authenticationError in\n                DispatchQueue.main.async {\n                    if success {\n                        self.isUnlocked = true\n                    } else {\n                        // Handle failure\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet that uses `@autoreleasepool` inside a loop to manage memory when creating a large number of temporary objects.", "output": "NSArray *largeDataArray = ...; // Assume this has thousands of items\n\nfor (id data in largeDataArray) {\n    @autoreleasepool {\n        // Create temporary objects that are only needed for this iteration\n        NSString *processedString = [[NSString alloc] initWithFormat:@\"Processed: %@\", data];\n        NSData *temporaryData = [processedString dataUsingEncoding:NSUTF8StringEncoding];\n        \n        // Perform operation...\n        [self saveToDisk:temporaryData];\n        \n        // Without autoreleasepool, temporaryData might persist until the loop finishes,\n        // causing a memory spike.\n    }\n}"}
{"instruction": "Use Combine to merge the results of two concurrent URLSession data tasks (zipping them) and handle errors.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable { let id: Int }\nstruct Profile: Decodable { let bio: String }\n\nfunc fetchUserData() -> AnyPublisher<(User, Profile), Error> {\n    let userURL = URL(string: \"https://api.example.com/user\")!\n    let profileURL = URL(string: \"https://api.example.com/profile\")!\n\n    let userPub = URLSession.shared.dataTaskPublisher(for: userURL)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n\n    let profilePub = URLSession.shared.dataTaskPublisher(for: profileURL)\n        .map(\\.data)\n        .decode(type: Profile.self, decoder: JSONDecoder())\n\n    return Publishers.Zip(userPub, profilePub)\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a Swift Actor to safely manage a mutable counter variable in a concurrent environment.", "output": "actor SafeCounter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage\nlet counter = SafeCounter()\nTask {\n    await counter.increment()\n    let currentValue = await counter.getValue()\n    print(currentValue)\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a view controller captures itself strongly inside a closure.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n\n    func setupClosure() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            self.doSomething()\n        }\n    }\n\n    func doSomething() {\n        print(\"Action performed\")\n    }\n}"}
{"instruction": "Create a singleton Core Data stack manager in Swift using `NSPersistentContainer`.", "output": "import CoreData\n\nclass PersistenceController {\n    static let shared = PersistenceController()\n\n    let container: NSPersistentContainer\n\n    private init() {\n        container = NSPersistentContainer(name: \"MyModel\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n    }\n\n    var context: NSManagedObjectContext {\n        return container.viewContext\n    }\n}"}
{"instruction": "Using Combine, create a function that fetches data from a URL, decodes it into a `User` struct, and returns an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Declare a delegate property in an Objective-C interface that adheres to ARC memory management rules to prevent retain cycles.", "output": "@protocol NetworkDelegate <NSObject>\n- (void)didFinishLoading;\n@end\n\n@interface NetworkManager : NSObject\n\n// Use 'weak' to prevent a retain cycle between the manager and its delegate\n@property (nonatomic, weak) id<NetworkDelegate> delegate;\n\n@end"}
{"instruction": "Write a SwiftUI View that uses `@StateObject` to initialize a ViewModel, ensuring the ViewModel's lifecycle is tied to the View's identity and not recreated on every redraw.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    func increment() { count += 1 }\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the instance is created once and survives view updates\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Implement a function in Swift using `DispatchQueue` to perform a heavy calculation on a background thread and update a UIKit label on the main thread.", "output": "func performHeavyTask(completion: @escaping (String) -> Void) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        // Simulate heavy work\n        let result = \"Calculation Complete\"\n        \n        DispatchQueue.main.async {\n            // Update UI on the main thread\n            completion(result)\n        }\n    }\n}"}
{"instruction": "Write a Core Data fetch request in Swift to retrieve all `Task` entities where `isCompleted` is false, sorted by `dueDate`.", "output": "import CoreData\n\nfunc fetchIncompleteTasks(context: NSManagedObjectContext) -> [Task] {\n    let fetchRequest: NSFetchRequest<Task> = Task.fetchRequest()\n    \n    // Predicate: isCompleted == false\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false))\n    \n    // Sort: Earliest due date first\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"dueDate\", ascending: true)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using Combine, merge two `CurrentValueSubject` publishers (email and password) to enable a login button only when both fields are not empty.", "output": "import Combine\n\nclass LoginViewModel {\n    var email = CurrentValueSubject<String, Never>(\"\")\n    var password = CurrentValueSubject<String, Never>(\"\")\n    \n    var isLoginEnabled: AnyPublisher<Bool, Never> {\n        return Publishers.CombineLatest(email, password)\n            .map { email, password in\n                return !email.isEmpty && !password.isEmpty\n            }\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to check if Face ID or Touch ID is available on the device.", "output": "import LocalAuthentication\n\nfunc checkBiometricAvailability() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    \n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        return true\n    } else {\n        print(\"Biometrics not available: \\(error?.localizedDescription ?? \"Unknown error\")\")\n        return false\n    }\n}"}
{"instruction": "Implement the `deinit` method in a Swift class to remove a NotificationCenter observer, demonstrating explicit memory cleanup (necessary for older iOS versions or block-based observers).", "output": "class NotificationObserver {\n    var observerToken: NSObjectProtocol?\n\n    init() {\n        observerToken = NotificationCenter.default.addObserver(\n            forName: .NSCalendarDayChanged,\n            object: nil,\n            queue: .main\n        ) { _ in\n            print(\"Day changed\")\n        }\n    }\n\n    deinit {\n        if let token = observerToken {\n            NotificationCenter.default.removeObserver(token)\n            print(\"Observer removed and instance deallocated\")\n        }\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n    var status = \"Ready\"\n\n    func setupClosure() {\n        // Fix: Use [weak self] to break the retain cycle\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            print(\"Status: \\(self.status)\")\n        }\n    }\n}"}
{"instruction": "Create a Core Data function in Swift using `NSPersistentContainer` to perform a background task that inserts a new 'User' entity and saves the context safely.", "output": "func createBackgroundUser(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.id = UUID()\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a ViewModel that validates a password input. The password is valid if it has more than 8 characters. Expose an `isValid` publisher.", "output": "import Combine\nimport Foundation\n\nclass PasswordViewModel: ObservableObject {\n    @Published var password: String = \"\"\n    @Published var isValid: Bool = false\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $password\n            .map { $0.count > 8 }\n            .assign(to: \\.isValid, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C code snippet to perform Method Swizzling on `UIViewController`'s `viewWillAppear:` method to inject custom logging.", "output": "#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(log_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    });\n}\n\n- (void)log_viewWillAppear:(BOOL)animated {\n    [self log_viewWillAppear:animated]; // Call original implementation\n    NSLog(@\"View Will Appear: %@\", self);\n}\n\n@end"}
{"instruction": "Implement a `CABasicAnimation` in Swift to rotate a UIView's layer 360 degrees indefinitely.", "output": "func rotateView(view: UIView) {\n    let rotation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n    rotation.toValue = NSNumber(value: Double.pi * 2)\n    rotation.duration = 1.0\n    rotation.isCumulative = true\n    rotation.repeatCount = Float.greatestFiniteMagnitude\n    view.layer.add(rotation, forKey: \"rotationAnimation\")\n}"}
{"instruction": "Demonstrate how to reduce high memory pressure in a tight loop creating many temporary objects (like UIImages) using `autoreleasepool` in Swift.", "output": "func processImages(_ heavyData: [Data]) {\n    for data in heavyData {\n        // Use autoreleasepool to release temporary objects immediately after each iteration\n        autoreleasepool {\n            if let image = UIImage(data: data) {\n                // Process image (e.g., resize, filter)\n                print(\"Processed image size: \\(image.size)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Swift function using `NSBatchUpdateRequest` to update the 'isRead' property of all 'Message' entities in Core Data to true without loading them into memory.", "output": "func markAllAsRead(context: NSManagedObjectContext) throws {\n    let batchUpdate = NSBatchUpdateRequest(entityName: \"Message\")\n    batchUpdate.propertiesToUpdate = [\"isRead\": true]\n    batchUpdate.resultType = .updatedObjectIDsResultType\n\n    let result = try context.execute(batchUpdate) as? NSBatchUpdateResult\n    \n    // Merge changes into the context to keep UI consistent\n    if let objectIDs = result?.result as? [NSManagedObjectID] {\n        let changes = [NSUpdatedObjectsKey: objectIDs]\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [context])\n    }\n}"}
{"instruction": "Using Combine, create a networking publisher that fetches data from a URL, retries 3 times on failure, and decodes a JSON object.", "output": "struct APIClient {\n    struct User: Decodable { let id: Int; let name: String }\n\n    func fetchUser() -> AnyPublisher<User, Error> {\n        let url = URL(string: \"https://api.example.com/user\")!\n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: User.self, decoder: JSONDecoder())\n            .retry(3)\n            .receive(on: DispatchQueue.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Implement a thread-safe counter in Swift using the Actor model (Concurrency framework) to prevent data races.", "output": "actor SafeCounter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage\nlet counter = SafeCounter()\nTask {\n    await counter.increment()\n    print(await counter.getValue())\n}"}
{"instruction": "Use `DispatchGroup` in Swift to wait for two asynchronous network requests to complete before executing a completion block.", "output": "func fetchDashboardData(completion: @escaping () -> Void) {\n    let group = DispatchGroup()\n\n    group.enter()\n    fetchUserProfile { _ in \n        print(\"Profile loaded\")\n        group.leave()\n    }\n\n    group.enter()\n    fetchRecentOrders { _ in \n        print(\"Orders loaded\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All data loaded\")\n        completion()\n    }\n}"}
{"instruction": "Create a Swift function that fetches data asynchronously and updates a property within a class. Ensure you handle memory management correctly by preventing a retain cycle in the closure.", "output": "class DataFetcher {\n    var data: String = \"\"\n    \n    func fetchData(completion: @escaping (String) -> Void) {\n        // Simulating network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            completion(\"New Data\")\n        }\n    }\n    \n    func update() {\n        // usage of [weak self] to prevent retain cycle\n        fetchData { [weak self] result in\n            guard let self = self else { return }\n            self.data = result\n            print(\"Data updated: \\(self.data)\")\n        }\n    }\n}"}
{"instruction": "Implement a function using Core Data's `NSBatchInsertRequest` in Swift to efficiently insert a large array of dictionaries into an entity named 'LogEntry' with attributes 'message' and 'timestamp'.", "output": "import CoreData\n\nfunc batchInsertLogs(logs: [[String: Any]], context: NSManagedObjectContext) {\n    let batchInsert = NSBatchInsertRequest(entityName: \"LogEntry\", objects: logs)\n    \n    do {\n        let result = try context.execute(batchInsert) as? NSBatchInsertResult\n        if let success = result?.result as? Bool, success {\n            print(\"Batch insert successful.\")\n        }\n    } catch {\n        print(\"Batch insert failed: \\(error.localizedDescription)\")\n    }\n}"}
{"instruction": "Using the Combine framework, create a ViewModel that observes a `searchText` publisher, debounces the input for 500 milliseconds, removes duplicates, and triggers a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Write a snippet in Swift for UIKit that programmatically adds a UILabel to a parent view and centers it horizontally and vertically using Auto Layout constraints (without Storyboards).", "output": "import UIKit\n\nfunc setupCenteredLabel(in parentView: UIView) {\n    let label = UILabel()\n    label.text = \"Hello World\"\n    label.translatesAutoresizingMaskIntoConstraints = false\n    parentView.addSubview(label)\n    \n    NSLayoutConstraint.activate([\n        label.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n        label.centerYAnchor.constraint(equalTo: parentView.centerYAnchor)\n    ])\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C for a class named `NetworkManager`.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Convert a standard completion-handler based network call to use Swift's modern Concurrency (async/await). Create a function that fetches data from a URL.", "output": "import Foundation\n\nfunc fetchData(from url: URL) async throws -> Data {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    return data\n}"}
{"instruction": "Using CoreLocation in Swift, write a class that requests 'When In Use' authorization and handles the delegate callback for authorization changes.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location access granted.\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Location access denied.\")\n        case .notDetermined:\n            print(\"Waiting for user selection.\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Write a Swift function using AVFoundation to configure an `AVCaptureSession` with the default video device input.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.beginConfiguration()\n    \n    guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),\n          let videoInput = try? AVCaptureDeviceInput(device: videoDevice) else {\n        return nil\n    }\n    \n    if session.canAddInput(videoInput) {\n        session.addInput(videoInput)\n    }\n    \n    session.commitConfiguration()\n    return session\n}"}
{"instruction": "Create a SwiftUI `PreferenceKey` and a ViewModifier to read the size of a view and pass it up to a parent view.", "output": "import SwiftUI\n\nstruct SizePreferenceKey: PreferenceKey {\n    static var defaultValue: CGSize = .zero\n    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {\n        value = nextValue()\n    }\n}\n\nstruct SizeReaderModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content.background(\n            GeometryReader { geometry in\n                Color.clear\n                    .preference(key: SizePreferenceKey.self, value: geometry.size)\n            }\n        )\n    }\n}\n\n// Usage: .modifier(SizeReaderModifier())"}
{"instruction": "Implement a `UICollectionViewDiffableDataSource` setup in Swift for a simple list of strings using a standard `UICollectionViewListCell`.", "output": "import UIKit\n\nenum Section { case main }\n\nfunc configureDataSource(collectionView: UICollectionView) -> UICollectionViewDiffableDataSource<Section, String> {\n    let cellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, String> { cell, indexPath, item in\n        var content = cell.defaultContentConfiguration()\n        content.text = item\n        cell.contentConfiguration = content\n    }\n    \n    return UICollectionViewDiffableDataSource<Section, String>(collectionView: collectionView) { (collectionView, indexPath, item) -> UICollectionViewCell? in\n        return collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: item)\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in // Fix: Capture self weakly\n            guard let self = self else { return }\n            // Simulate data loading\n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Core Data fetch request in Swift to retrieve all 'User' entities where the 'age' attribute is greater than 18, sorted by 'name' in ascending order.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User]? {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Predicate: age > 18\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 18)\n    \n    // Sort Descriptor: name ascending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"name\", ascending: true)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that observes a text string publisher, debounces the input for 500 milliseconds, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { text in\n                print(\"Search query: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "In Objective-C, write a loop that creates a large number of temporary objects (e.g., NSString). Wrap the loop body in an autorelease pool to ensure memory is released immediately after each iteration to prevent high memory spikes.", "output": "for (int i = 0; i < 1000000; i++) {\n    @autoreleasepool {\n        NSString *tempString = [NSString stringWithFormat:@\"String number %d\", i];\n        // Simulate heavy processing with tempString\n        NSLog(@\"Processing: %@\", tempString);\n    }\n}"}
{"instruction": "Create a SwiftUI View and a corresponding ViewModel. The ViewModel should fetch data asynchronously and update the View. Ensure the ViewModel conforms to ObservableObject and uses @Published.", "output": "import SwiftUI\n\nclass ContentViewModel: ObservableObject {\n    @Published var message: String = \"Loading...\"\n\n    func loadData() {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            self.message = \"Data Loaded Successfully!\"\n        }\n    }\n}\n\nstruct ContentView: View {\n    @StateObject private var viewModel = ContentViewModel()\n\n    var body: some View {\n        VStack {\n            Text(viewModel.message)\n                .padding()\n        }\n        .onAppear {\n            viewModel.loadData()\n        }\n    }\n}"}
{"instruction": "Demonstrate how to perform a background save in Core Data using `performBackgroundTask` to avoid blocking the main UI thread.", "output": "import CoreData\n\nfunc saveEntityInBackground(persistentContainer: NSPersistentContainer) {\n    persistentContainer.performBackgroundTask { context in\n        let newEntity = NSEntityDescription.insertNewObject(forEntityName: \"LogEntry\", into: context)\n        newEntity.setValue(Date(), forKey: \"timestamp\")\n        \n        do {\n            try context.save()\n            print(\"Saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a custom Delegate pattern in Swift for a UIViewController. Ensure the delegate property is weak to prevent a memory leak (retain cycle).", "output": "protocol DataSelectionDelegate: AnyObject {\n    func didSelectData(_ data: String)\n}\n\nclass SelectionViewController: UIViewController {\n    // weak reference prevents retain cycle\n    weak var delegate: DataSelectionDelegate?\n\n    func handleSelection() {\n        let data = \"Selected Item\"\n        delegate?.didSelectData(data)\n        dismiss(animated: true)\n    }\n}"}
{"instruction": "Use the Vision framework in Swift to perform text recognition (OCR) on a given CGImage.", "output": "import Vision\nimport CoreGraphics\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { (request, error) in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed.\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Detected text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Using Combine, create a networking function that fetches JSON from a URL, decodes it into a Codable struct, and handles errors.", "output": "import Combine\nimport Foundation\n\nstruct Todo: Codable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchTodo() -> AnyPublisher<Todo, Error> {\n    let url = URL(string: \"https://jsonplaceholder.typicode.com/todos/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: Todo.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement biometric authentication (FaceID/TouchID) using the LocalAuthentication framework in Swift.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication successful\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometry unavailable\")\n    }\n}"}
{"instruction": "Create a Swift class named `ImageDownloader` that has a closure property `onImageDownloaded`. Write a method `downloadImage` that simulates an async network call using `DispatchQueue.global().asyncAfter`. Inside the closure, access a property of the class (e.g., `downloadCount`) and ensure you avoid a strong reference cycle (memory leak) by using a capture list.", "output": "class ImageDownloader {\n    var downloadCount = 0\n    var onImageDownloaded: ((UIImage?) -> Void)?\n\n    func downloadImage() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) { [weak self] in\n            // Guard against self being nil (released)\n            guard let self = self else { return }\n            \n            // Access property safely without retaining self strongly\n            self.downloadCount += 1\n            let image = UIImage(systemName: \"photo\")\n            \n            DispatchQueue.main.async {\n                self.onImageDownloaded?(image)\n            }\n        }\n    }\n}"}
{"instruction": "Using Core Data in Swift, write a function `performBackgroundSave` that takes an `NSPersistentContainer`. The function should create a new background context, insert a new `User` entity (assume attributes `name` and `age`), and save the context. Ensure the save operation is wrapped in a `perform` block to ensure thread safety.", "output": "import CoreData\n\nfunc performBackgroundSave(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Create entity on the background context\n        let newUser = NSEntityDescription.insertNewObject(forEntityName: \"User\", into: context)\n        newUser.setValue(\"John Doe\", forKey: \"name\")\n        newUser.setValue(30, forKey: \"age\")\n\n        do {\n            try context.save()\n            print(\"Saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI ViewModel using Combine. The ViewModel should have a `@Published` property `searchText` and a `@Published` property `searchResults`. Set up a pipeline in the `init` method that listens to `searchText`, debounces the input for 500 milliseconds, removes duplicates, and simulates a search operation that updates `searchResults`.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var searchResults: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        guard !query.isEmpty else {\n            searchResults = []\n            return\n        }\n        // Simulate search result\n        searchResults = [\"Result for \\(query)\", \"More \\(query)\"]\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating how to handle memory management in a tight loop. Assume you have a large array of image data objects (`NSData`) and you need to process them into `UIImage` objects. Use `@autoreleasepool` to ensure temporary objects are drained from memory in each iteration to prevent high memory spikes.", "output": "NSArray *imageDataArray = ...; // Assume populated\n\nfor (NSData *data in imageDataArray) {\n    @autoreleasepool {\n        // Objects created inside this block are released at the end of the block\n        UIImage *image = [UIImage imageWithData:data];\n        \n        // Perform processing...\n        NSLog(@\"Processed image size: %@\", NSStringFromCGSize(image.size));\n        \n        // Without @autoreleasepool, 'image' might wait until the run loop drains,\n        // causing memory to spike if the array is large.\n    }\n}"}
{"instruction": "Using Swift's `NSCache`, implement a simple class `ImageCache` that saves and retrieves `UIImage` objects using a String key. Ensure the cache implements `NSCacheDelegate` to print a message when an object is evicted.", "output": "import UIKit\n\nclass ImageCache: NSObject, NSCacheDelegate {\n    private let cache = NSCache<NSString, UIImage>()\n\n    override init() {\n        super.init()\n        cache.delegate = self\n        // Optional: Set limits\n        cache.countLimit = 100\n    }\n\n    func save(image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n\n    func get(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n\n    // NSCacheDelegate method\n    func cache(_ cache: NSCache<AnyObject, AnyObject>, willEvictObject obj: Any) {\n        print(\"Object evicted from cache\")\n    }\n}"}
{"instruction": "Create a Swift function `fetchHighPriorityTasks` using Core Data. The function should create an `NSFetchRequest` for an entity named `Task`, filter results where the `priority` attribute is greater than 5 using an `NSPredicate`, and sort them by `creationDate` in descending order.", "output": "import CoreData\n\nfunc fetchHighPriorityTasks(context: NSManagedObjectContext) -> [NSManagedObject] {\n    let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: \"Task\")\n    \n    // Predicate: Priority > 5\n    fetchRequest.predicate = NSPredicate(format: \"priority > %d\", 5)\n    \n    // Sort: Newest first\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"creationDate\", ascending: false)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Fetch error: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using UIKit and Auto Layout programmatically (no Storyboards), write a `viewDidLoad` method that adds a red `UIView` to the center of the screen with a fixed width and height of 100 points.", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let redBox = UIView()\n        redBox.backgroundColor = .red\n        redBox.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(redBox)\n        \n        NSLayoutConstraint.activate([\n            redBox.widthAnchor.constraint(equalToConstant: 100),\n            redBox.heightAnchor.constraint(equalToConstant: 100),\n            redBox.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            redBox.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Demonstrate the use of `Combine` to merge two user input streams. Create a function that takes two `PassthroughSubject<String, Never>` publishers (username and password) and returns an `AnyPublisher<Bool, Never>` that emits `true` only if the username is at least 3 characters long and the password is at least 8 characters long.", "output": "import Combine\n\nfunc validateForm(usernameSubject: PassthroughSubject<String, Never>, \n                  passwordSubject: PassthroughSubject<String, Never>) -> AnyPublisher<Bool, Never> {\n    \n    return Publishers.CombineLatest(usernameSubject, passwordSubject)\n        .map { username, password in\n            return username.count >= 3 && password.count >= 8\n        }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write a Swift code snippet using the modern `async/await` concurrency framework to fetch JSON data from a URL. Define a struct `Post` (Codable) and a function `fetchPosts` that decodes the data into an array of `Post`.", "output": "import Foundation\n\nstruct Post: Codable, Identifiable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPosts() async throws -> [Post] {\n    guard let url = URL(string: \"https://jsonplaceholder.typicode.com/posts\") else {\n        throw URLError(.badURL)\n    }\n    \n    // Async network call\n    let (data, _) = try await URLSession.shared.data(from: url)\n    \n    // Decode JSON\n    let posts = try JSONDecoder().decode([Post].self, from: data)\n    return posts\n}"}
{"instruction": "Create a Swift class `CreditCard` and a class `Person`. Establish a parent-child relationship where `Person` owns `CreditCard`. Use an `unowned` reference in `CreditCard` pointing back to `Person` to prevent a retain cycle, assuming a CreditCard cannot exist without a Person.", "output": "class Person {\n    let name: String\n    var card: CreditCard?\n    \n    init(name: String) {\n        self.name = name\n    }\n    \n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {\n    let number: String\n    // 'unowned' is used because a Card assumes the Person always exists \n    // during its lifetime and is not optional.\n    unowned let owner: Person\n    \n    init(number: String, owner: Person) {\n        self.number = number\n        self.owner = owner\n    }\n    \n    deinit { print(\"Card \\(number) is being deinitialized\") }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onDataFetched = { [weak self] in\n            guard let self = self else { return }\n            self.data = [\"Item 1\", \"Item 2\"]\n            print(\"Data fetched: \\(self.data)\")\n        }\n    }\n}"}
{"instruction": "Create a Singleton Core Data Manager class in Swift that initializes an NSPersistentContainer named 'Model' and provides a function to save the context.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"Model\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using Combine, create a view model property that subscribes to a 'searchText' publisher, debounces the input by 500ms, removes duplicates, and maps it to a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var searchResults: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        // Mock search logic\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Implement a SwiftUI struct that wraps a WKWebView using UIViewRepresentable to load a specific URL.", "output": "import SwiftUI\nimport WebKit\n\nstruct WebView: UIViewRepresentable {\n    let url: URL\n\n    func makeUIView(context: Context) -> WKWebView {\n        return WKWebView()\n    }\n\n    func updateUIView(_ uiView: WKWebView, context: Context) {\n        let request = URLRequest(url: url)\n        uiView.load(request)\n    }\n}\n\n// Usage:\n// WebView(url: URL(string: \"https://www.apple.com\")!)"}
{"instruction": "Write an Objective-C property declaration for a delegate to prevent a retain cycle, and synthesize it.", "output": "// MyClass.h\n@protocol MyClassDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n// Use 'weak' to prevent retain cycles (or 'assign' for non-ARC legacy code)\n@property (nonatomic, weak) id<MyClassDelegate> delegate;\n@end\n\n// MyClass.m\n@implementation MyClass\n// In modern Obj-C, @synthesize is optional, but if used:\n@synthesize delegate = _delegate;\n@end"}
{"instruction": "Demonstrate how to fetch entities named 'User' where the 'age' attribute is greater than 21 using Swift and Core Data.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [NSManagedObject]? {\n    let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: \"User\")\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Create a UIKit UITableViewDiffableDataSource setup for a simple list of Strings.", "output": "import UIKit\n\nclass ListViewController: UITableViewController {\n    enum Section { case main }\n    var dataSource: UITableViewDiffableDataSource<Section, String>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n        applySnapshot(items: [\"Apple\", \"Banana\", \"Cherry\"])\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource<Section, String>(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n            return cell\n        }\n    }\n\n    func applySnapshot(items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Using Swift 5.5+ Concurrency, write a function that downloads an image from a URL, handles errors, and returns a UIImage.", "output": "import UIKit\n\nenum ImageError: Error {\n    case invalidData\n    case invalidURL\n}\n\nfunc downloadImage(from urlString: String) async throws -> UIImage {\n    guard let url = URL(string: urlString) else {\n        throw ImageError.invalidURL\n    }\n\n    let (data, _) = try await URLSession.shared.data(from: url)\n    \n    guard let image = UIImage(data: data) else {\n        throw ImageError.invalidData\n    }\n    \n    return image\n}"}
{"instruction": "Fix the memory leak in this Objective-C block where an instance variable is accessed directly inside the block.", "output": "// Assuming this is inside a method of 'MyViewController'\n\n// 1. Create a weak reference to self\n__weak typeof(self) weakSelf = self;\n\n[self.dataLoader loadDataWithCompletion:^(NSArray *results) {\n    // 2. Create a strong reference inside the block to ensure self exists during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        // 3. Access instance variable via the strong reference\n        strongSelf->_data = results;\n        [strongSelf.tableView reloadData];\n    }\n}];"}
{"instruction": "Combine two publishers (usernameValid and passwordValid) into a single boolean publisher 'isFormValid' using Combine.", "output": "import Combine\n\nclass LoginViewModel {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    \n    var isFormValidPublisher: AnyPublisher<Bool, Never> {\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                return username.count >= 3 && password.count >= 8\n            }\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Write a Swift function using Combine to fetch data from a URL, decode it into a generic 'Codable' type, and return a type-erased publisher (AnyPublisher). Include error handling for network and decoding errors.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a View Controller. Use a capture list to reference 'self' weakly.", "output": "class MyViewController: UIViewController {\n    var completionHandler: (() -> Void)?\n\n    func setupClosure() {\n        // capture 'self' weakly to avoid retain cycle\n        completionHandler = { [weak self] in\n            guard let self = self else { return }\n            self.doSomething()\n        }\n    }\n\n    func doSomething() {\n        print(\"Action performed\")\n    }\n}"}
{"instruction": "Create a Core Data stack extension in Swift that performs a background save operation using 'performBackgroundTask' to ensure thread safety.", "output": "import CoreData\n\nextension NSPersistentContainer {\n    func saveInBackground(changes: @escaping (NSManagedObjectContext) -> Void) {\n        self.performBackgroundTask { context in\n            changes(context)\n            do {\n                try context.save()\n            } catch {\n                print(\"Core Data save error: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using SwiftUI, create a View that uses '@StateObject' to initialize a ViewModel. Explain via code why '@StateObject' is used instead of '@ObservedObject' for the initial creation.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the ViewModel instance is retained\n    // even if the View struct is recreated/redrawn by the parent.\n    // If @ObservedObject were used here, the data might reset on redraw.\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.count += 1\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating the 'weak-strong dance' inside a block to safely access 'self' without causing a retain cycle or crashing if 'self' is deallocated.", "output": "__weak typeof(self) weakSelf = self;\nself.completionBlock = ^{\n    // Convert weak reference to strong to ensure self stays alive during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf performAction];\n    } else {\n        NSLog(@\"Self was deallocated before block execution\");\n    }\n};"}
{"instruction": "Implement a Combine pipeline in a ViewModel that listens to a text search publisher, debounces the input for 500ms, removes duplicates, and filters out empty strings.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using Swift's CryptoKit, write a function that accepts a String and returns its SHA-256 hash as a hexadecimal String.", "output": "import CryptoKit\nimport Foundation\n\nfunc sha256Hash(of input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Create a custom UIView subclass in Swift that overrides 'draw(_ rect:)' to draw a red circle using Core Graphics.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        // Inset to avoid clipping at the edges\n        let circleRect = rect.insetBy(dx: 5, dy: 5)\n        context.addEllipse(in: circleRect)\n        context.fillPath()\n    }\n}"}
{"instruction": "Demonstrate the usage of 'unowned' versus 'weak' in Swift to model a Customer and CreditCard relationship where the CreditCard cannot exist without a Customer.", "output": "class Customer {\n    var card: CreditCard?\n}\n\nclass CreditCard {\n    // 'unowned' is used here because a CreditCard is assumed to always\n    // have an associated Customer during its lifetime (non-optional).\n    // Unlike 'weak', this does not become nil, but will crash if accessed after dealloc.\n    unowned let customer: Customer\n\n    init(customer: Customer) {\n        self.customer = customer\n    }\n}"}
{"instruction": "Using Core Location in Swift, write a class that requests 'When In Use' authorization and implements the delegate method to handle authorization status changes.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n\n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location Access Granted\")\n        case .denied, .restricted:\n            print(\"Location Access Denied\")\n        case .notDetermined:\n            print(\"Waiting for user selection\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Create a Swift function using Combine to fetch JSON data from a URL, decode it into a custom struct `User`, and handle errors by replacing them with a default value. Ensure the result is received on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Never> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .replaceError(with: User(id: 0, name: \"Unknown\"))\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a ViewController class that updates a property after a delay.", "output": "class MyViewController: UIViewController {\n    var status: String = \"Loading\"\n\n    func performTask() {\n        // Use [weak self] to avoid capturing the view controller strongly\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Safely unwrap self\n            guard let self = self else { return }\n            \n            self.status = \"Completed\"\n            print(self.status)\n        }\n    }\n}"}
{"instruction": "Write a SwiftUI view that uses `@FetchRequest` to display a list of `TaskEntity` Core Data objects, sorted by their `createdAt` date in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    // Automatically fetches and listens for changes in Core Data\n    @FetchRequest(\n        entity: TaskEntity.entity(),\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: false)]\n    ) var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        List(tasks, id: \\.self) { task in\n            Text(task.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Using UIKit and programmatic Auto Layout, create a `UIView` subclass that centers a red square (50x50) within itself.", "output": "import UIKit\n\nclass CenteredView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    private func setupView() {\n        let redSquare = UIView()\n        redSquare.backgroundColor = .red\n        redSquare.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(redSquare)\n        \n        NSLayoutConstraint.activate([\n            redSquare.widthAnchor.constraint(equalToConstant: 50),\n            redSquare.heightAnchor.constraint(equalToConstant: 50),\n            redSquare.centerXAnchor.constraint(equalTo: centerXAnchor),\n            redSquare.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write an Objective-C interface for a class `NetworkManager` that defines a delegate property. Ensure the delegate property uses the correct attribute to prevent memory leaks.", "output": "@protocol NetworkManagerDelegate <NSObject>\n- (void)didFinishLoadingData;\n@end\n\n@interface NetworkManager : NSObject\n\n// Use 'weak' to prevent retain cycles between the manager and its delegate\n@property (nonatomic, weak) id<NetworkManagerDelegate> delegate;\n\n- (void)startRequest;\n\n@end"}
{"instruction": "Create a Swift function using `NSBatchDeleteRequest` in Core Data to delete all entities of type `LogEntry` older than a specific date, without loading them into memory.", "output": "import CoreData\n\nfunc deleteOldLogs(olderThan date: Date, context: NSManagedObjectContext) throws {\n    let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"LogEntry\")\n    fetchRequest.predicate = NSPredicate(format: \"timestamp < %@\", date as NSDate)\n    \n    // Batch delete request avoids loading objects into memory\n    let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n    \n    // Specify result type if you need the count of deleted objects\n    deleteRequest.resultType = .resultTypeCount\n    \n    try context.execute(deleteRequest)\n}"}
{"instruction": "Implement a Combine pipeline in a ViewModel that takes a user's search text input (Publisher), debounces it for 500ms to avoid excessive API calls, and removes duplicate inputs.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // Mock API call\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using `AVFoundation`, write a function to check for camera permissions. If not determined, request access; if denied, print a warning.", "output": "import AVFoundation\n\nfunc checkCameraPermissions() {\n    switch AVCaptureDevice.authorizationStatus(for: .video) {\n    case .authorized:\n        print(\"Camera access authorized.\")\n        \n    case .notDetermined:\n        AVCaptureDevice.requestAccess(for: .video) { granted in\n            if granted {\n                print(\"Access granted.\")\n            } else {\n                print(\"Access denied.\")\n            }\n        }\n        \n    case .denied, .restricted:\n        print(\"Camera access is denied or restricted.\")\n        \n    @unknown default:\n        print(\"Unknown authorization status.\")\n    }\n}"}
{"instruction": "Create a Swift class that uses `CLLocationManager` to request 'When In Use' authorization and handles the delegate method for authorization changes.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        // Ensure NSLocationWhenInUseUsageDescription is in Info.plist\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location authorized\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Location denied\")\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Demonstrate the usage of Swift Concurrency (`async`/`await`) and `@MainActor` to fetch data on a background thread and update the UI state safely.", "output": "import SwiftUI\n\n@MainActor\nclass DataViewModel: ObservableObject {\n    @Published var data: String = \"\"\n    \n    func loadData() async {\n        do {\n            // Background work (simulated network request)\n            let fetchedData = try await fetchDataFromNetwork()\n            \n            // Because the class is @MainActor, this property assignment runs on the main thread\n            self.data = fetchedData\n        } catch {\n            print(\"Error loading data\")\n        }\n    }\n    \n    nonisolated private func fetchDataFromNetwork() async throws -> String {\n        // Simulate network delay\n        try await Task.sleep(nanoseconds: 1_000_000_000)\n        return \"Hello from the server\"\n    }\n}"}
{"instruction": "Write a Swift function that fetches 'User' entities from Core Data where the 'age' attribute is greater than 21, sorted by 'lastName' in ascending order.", "output": "func fetchAdultUsers(context: NSManagedObjectContext) -> [User]? {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n\n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Error fetching users: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Demonstrate how to prevent a strong reference cycle (retain cycle) in a Swift closure when updating a property on 'self' after a delay.", "output": "class DataFetcher {\n    var data: String = \"\"\n\n    func performTask() {\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) { [weak self] in\n            // Capture self weakly to avoid retain cycle\n            guard let self = self else { return }\n            self.data = \"Updated Data\"\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that subscribes to a 'searchText' publisher, debounces the input for 500 milliseconds, removes duplicates, and prints the result.", "output": "import Combine\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Search query: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "+ (instancetype)sharedInstance {\n    static MySingleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}"}
{"instruction": "Using SwiftUI, create a view that uses '@FetchRequest' to display a list of 'Item' entities sorted by 'timestamp'.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using the LocalAuthentication framework to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a generic networking function in Swift using Combine's 'dataTaskPublisher' to fetch and decode a JSON object.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "In Objective-C, create a block property that takes an NSString and returns void, then invoke it safely checking for nil.", "output": "// Interface\n@property (nonatomic, copy) void (^completionHandler)(NSString *result);\n\n// Implementation usage\n- (void)doWork {\n    // ... work done\n    if (self.completionHandler) {\n        self.completionHandler(@\"Work Complete\");\n    }\n}"}
{"instruction": "Use 'UnsafeMutablePointer' in Swift to allocate memory for an integer, initialize it with the value 42, read the value, and properly deallocate the memory.", "output": "func unsafePointerDemo() {\n    let count = 1\n    let pointer = UnsafeMutablePointer<Int>.allocate(capacity: count)\n    \n    // Initialize\n    pointer.initialize(to: 42)\n    \n    // Read\n    print(\"Value: \\(pointer.pointee)\")\n    \n    // Clean up\n    pointer.deinitialize(count: count)\n    pointer.deallocate()\n}"}
{"instruction": "Implement a UICollectionViewCompositionalLayout in Swift that creates a simple list configuration.", "output": "import UIKit\n\nfunc createListLayout() -> UICollectionViewLayout {\n    let config = UICollectionLayoutListConfiguration(appearance: .insetGrouped)\n    return UICollectionViewCompositionalLayout.list(using: config)\n}"}
{"instruction": "Write a Swift code snippet demonstrating how to fix a strong reference cycle (retain cycle) in a closure within a class named `DataFetcher`. The closure is assigned to a property and accesses `self`.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async {\n            // Fix: Use [weak self] to break the retain cycle\n            self.onDataFetched = { [weak self] in\n                guard let self = self else { return }\n                self.data = [\"Item 1\", \"Item 2\"]\n                print(\"Data updated: \\(self.data)\")\n            }\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a singleton Core Data stack manager in Swift named `CoreDataManager` that initializes an `NSPersistentContainer` named 'Model'.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n\n    let persistentContainer: NSPersistentContainer\n\n    private init() {\n        persistentContainer = NSPersistentContainer(name: \"Model\")\n        persistentContainer.loadPersistentStores { description, error in\n            if let error = error {\n                fatalError(\"Unable to load persistent stores: \\(error)\")\n            }\n        }\n    }\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function `fetchUser(from url: URL)` that returns an `AnyPublisher<User, Error>`. Assume `User` is a Decodable struct.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a SwiftUI view hierarchy where a parent view passes a mutable integer state to a child view using `@Binding`, allowing the child to increment the counter.", "output": "import SwiftUI\n\nstruct ParentView: View {\n    @State private var counter: Int = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(counter)\")\n            ChildView(counter: $counter)\n        }\n    }\n}\n\nstruct ChildView: View {\n    @Binding var counter: Int\n\n    var body: some View {\n        Button(\"Increment\") {\n            counter += 1\n        }\n        .padding()\n        .background(Color.blue)\n        .foregroundColor(.white)\n        .cornerRadius(8)\n    }\n}"}
{"instruction": "Write a programmatic UIKit setup (Swift) to center a red `UIView` (100x100) inside a parent `ViewController` using Auto Layout anchors.", "output": "import UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.backgroundColor = .white\n\n        let redBox = UIView()\n        redBox.backgroundColor = .red\n        redBox.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(redBox)\n\n        NSLayoutConstraint.activate([\n            redBox.widthAnchor.constraint(equalToConstant: 100),\n            redBox.heightAnchor.constraint(equalToConstant: 100),\n            redBox.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            redBox.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Define an Objective-C class interface named `CustomDelegateView` that declares a delegate property using the correct memory management attribute to avoid retain cycles.", "output": "@protocol CustomDelegateViewDelegate <NSObject>\n- (void)didTapButton;\n@end\n\n@interface CustomDelegateView : UIView\n\n// Use 'weak' to prevent retain cycles\n@property (nonatomic, weak) id<CustomDelegateViewDelegate> delegate;\n\n@end"}
{"instruction": "Implement a Combine pipeline in a ViewModel that listens to a `searchText` publisher, debounces the input for 500ms, removes duplicates, and performs a search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to fetch `TaskItem` entities where `isCompleted` is true, sorted by `createdAt` in descending order.", "output": "import CoreData\n\nfunc fetchCompletedTasks(context: NSManagedObjectContext) -> [TaskItem] {\n    let fetchRequest: NSFetchRequest<TaskItem> = TaskItem.fetchRequest()\n    \n    // Filter: isCompleted == true\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == %@\", NSNumber(value: true))\n    \n    // Sort: createdAt descending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"createdAt\", ascending: false)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Convert a legacy closure-based function `fetchImage(completion: @escaping (UIImage?) -> Void)` into a modern Swift `async` function using `CheckedContinuation`.", "output": "import UIKit\n\n// Legacy function\nfunc fetchImageLegacy(completion: @escaping (UIImage?) -> Void) {\n    // Implementation hidden\n    completion(UIImage())\n}\n\n// Modern Async Wrapper\nfunc fetchImageAsync() async -> UIImage? {\n    return await withCheckedContinuation { continuation in\n        fetchImageLegacy { image in\n            continuation.resume(returning: image)\n        }\n    }\n}"}
{"instruction": "Implement a function `authenticateUser` using the `LocalAuthentication` framework to verify identity via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access the app.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (retain cycle) in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to prevent retain cycle\n        let task = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            self.onDataFetched?()\n        }\n        task()\n    }\n}"}
{"instruction": "Create a Singleton class named 'CoreDataStack' in Swift that initializes an NSPersistentContainer named 'Model'.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n\n    private init() {}\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"Model\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n}"}
{"instruction": "Write a function using the Combine framework to fetch JSON data from a URL, decode it into a 'User' struct, and return an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a SwiftUI view structure where a parent view passes an integer state to a child view using @Binding, allowing the child to increment the parent's counter.", "output": "import SwiftUI\n\nstruct ParentView: View {\n    @State private var counter = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(counter)\")\n            ChildView(count: $counter)\n        }\n    }\n}\n\nstruct ChildView: View {\n    @Binding var count: Int\n\n    var body: some View {\n        Button(\"Increment\") {\n            count += 1\n        }\n    }\n}"}
{"instruction": "Using UIKit programmatically (no Storyboards), create a UIView subclass that centers a UILabel with the text 'Hello' in the center of the view using Auto Layout anchors.", "output": "import UIKit\n\nclass CenteredLabelView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    private func setupView() {\n        let label = UILabel()\n        label.text = \"Hello\"\n        label.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(label)\n        \n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write an Objective-C class interface (@interface) for a 'Person' class with a strong string property for 'name', a weak property for a 'delegate', and an assign property for 'age'.", "output": "@interface Person : NSObject\n\n@property (nonatomic, strong) NSString *name;\n@property (nonatomic, weak) id<PersonDelegate> delegate;\n@property (nonatomic, assign) NSInteger age;\n\n@end"}
{"instruction": "Implement a function in Swift that applies a Sepia Tone filter to a UIImage using Core Image.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image), \n          let filter = CIFilter(name: \"CISepiaTone\") else { return nil }\n    \n    filter.setValue(ciImage, forKey: kCIInputImageKey)\n    filter.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter.outputImage else { return nil }\n    \n    let context = CIContext()\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Using Combine, create a ViewModel that validates a username (min 4 chars) and password (min 8 chars) to enable a login button.", "output": "import Combine\n\nclass LoginViewModel: ObservableObject {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    @Published var isSubmitAllowed = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        Publishers.CombineLatest($username, $password)\n            .map { user, pass in\n                return user.count >= 4 && pass.count >= 8\n            }\n            .assign(to: \\.isSubmitAllowed, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Convert the following completion-handler based network call to a Swift async/await function.", "output": "// Old way: func fetchData(completion: @escaping (Data?, Error?) -> Void)\n\n// New Async/Await way:\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse, \n          httpResponse.statusCode == 200 else {\n        throw URLError(.badServerResponse)\n    }\n    \n    return data\n}"}
{"instruction": "Write a Swift function to fetch all 'Employee' entities from Core Data where the 'department' attribute equals 'Engineering'.", "output": "import CoreData\n\nfunc fetchEngineeringEmployees(context: NSManagedObjectContext) -> [Employee] {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Error fetching data: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly. The class 'DataFetcher' holds a closure 'onComplete' which calls a method on 'self'.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    \n    func start() {\n        // Use [weak self] to prevent strong reference cycle\n        onComplete = { [weak self] in\n            self?.handleCompletion()\n        }\n    }\n    \n    func handleCompletion() {\n        print(\"Operation finished\")\n    }\n    \n    deinit {\n        print(\"DataFetcher deallocated\")\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that performs a save operation on a specific NSManagedObjectContext. Ensure the save happens on the context's private queue to avoid concurrency violations.", "output": "import CoreData\n\nfunc saveContext safely(_ context: NSManagedObjectContext) {\n    // perform ensures the block runs on the context's specific queue\n    context.perform {\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                print(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that fetches JSON data from a URL, decodes it into a 'User' struct, handles errors by returning nil, and assigns the result to a published property on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable { let name: String }\n\nclass UserViewModel: ObservableObject {\n    @Published var user: User? = nil\n    private var cancellables = Set<AnyCancellable>()\n    \n    func fetchUser(url: URL) {\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: User?.self, decoder: JSONDecoder())\n            .replaceError(with: nil) // Handle error by emitting nil\n            .receive(on: DispatchQueue.main) // Update UI on main thread\n            .assign(to: \\.user, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Define a property for a delegate in an Objective-C interface. Ensure the property attributes prevent a retain cycle (memory leak).", "output": "@protocol MyCustomDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' to prevent strong reference cycles with delegates\n@property (nonatomic, weak) id<MyCustomDelegate> delegate;\n\n@end"}
{"instruction": "Implement a SwiftUI view model using Combine to debounce search text input. It should only trigger a search 500ms after the user stops typing.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        // Search logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Write a Swift code snippet using Grand Central Dispatch (GCD) and a DispatchGroup to wait for two asynchronous network operations to finish before executing a completion block.", "output": "func syncMultipleNetworkCalls() {\n    let group = DispatchGroup()\n    \n    group.enter()\n    fetchUserProfile { _ in\n        print(\"Profile fetched\")\n        group.leave()\n    }\n    \n    group.enter()\n    fetchUserImage { _ in\n        print(\"Image fetched\")\n        group.leave()\n    }\n    \n    group.notify(queue: .main) {\n        print(\"All network operations completed.\")\n    }\n}"}
{"instruction": "Create a custom UIView subclass in Swift that overrides 'draw(_:)' to draw a red circle centered in the view using Core Graphics (UIBezierPath).", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        // Calculate center and radius\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 5\n        \n        // Create path\n        let path = UIBezierPath(arcCenter: center,\n                                radius: radius,\n                                startAngle: 0,\n                                endAngle: 2 * .pi,\n                                clockwise: true)\n        \n        // Set fill color and draw\n        UIColor.red.setFill()\n        path.fill()\n    }\n}"}
{"instruction": "Write a Core Data fetch request in Swift to retrieve 'Employee' entities where the 'department' attribute is 'Engineering', sorted by 'hireDate' in descending order.", "output": "import CoreData\n\nfunc fetchEngineers(context: NSManagedObjectContext) -> [Employee] {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    \n    // Predicate for filtering\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    // Sort descriptor for ordering\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"hireDate\", ascending: false)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Implement a memory-efficient SwiftUI list that displays a large array of images using 'LazyVStack' and 'AsyncImage' to ensure views are only loaded when they appear on screen.", "output": "import SwiftUI\n\nstruct EfficientImageList: View {\n    let imageUrls: [URL]\n    \n    var body: some View {\n        ScrollView {\n            // LazyVStack loads views only when they enter the viewport\n            LazyVStack {\n                ForEach(imageUrls, id: \\.self) { url in\n                    AsyncImage(url: url) { phase in\n                        if let image = phase.image {\n                            image.resizable().aspectRatio(contentMode: .fit)\n                        } else if phase.error != nil {\n                            Color.red // Error placeholder\n                        } else {\n                            ProgressView() // Loading placeholder\n                        }\n                    }\n                    .frame(height: 200)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift class that uses the native 'LocalAuthentication' framework to authenticate a user via Face ID or Touch ID.", "output": "import LocalAuthentication\n\nclass BiometricAuth {\n    func authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n        let context = LAContext()\n        var error: NSError?\n        \n        // Check if hardware is available\n        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n            let reason = \"Authenticate to access your account\"\n            \n            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n                DispatchQueue.main.async {\n                    completion(success, authenticationError)\n                }\n            }\n        } else {\n            // Biometrics not available\n            completion(false, error)\n        }\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n    var status = \"Loading\"\n\n    func setup() {\n        // Fixed: Added [weak self] to break the strong reference cycle\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            self.status = \"Finished\"\n            print(self.status)\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that fetches JSON data from a URL, decodes it into a 'User' struct, and publishes the result on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "+ (instancetype)sharedInstance {\n    static MySingleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}"}
{"instruction": "Write a Swift function using Core Data's 'performBackgroundTask' to create and save a new 'LogEntry' entity asynchronously to avoid blocking the main thread.", "output": "import CoreData\n\nfunc createLogEntry(message: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let log = LogEntry(context: context)\n        log.timestamp = Date()\n        log.message = message\n\n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a SwiftUI ViewModel using Combine that debounces a search text input to prevent excessive API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        // API call logic here\n    }\n}"}
{"instruction": "Using the LocalAuthentication framework, write a Swift function to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses '@FetchRequest' to display a list of 'Item' entities sorted by 'createdAt' date.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.createdAt, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.name ?? \"Unknown\")\n            }\n        }\n    }\n}"}
{"instruction": "Demonstrate how to use 'DispatchGroup' in Swift to wait for two concurrent network requests to finish before updating the UI.", "output": "func syncData() {\n    let group = DispatchGroup()\n\n    group.enter()\n    networkService.fetchProfile { _ in \n        print(\"Profile fetched\")\n        group.leave()\n    }\n\n    group.enter()\n    networkService.fetchFriends { _ in \n        print(\"Friends fetched\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All data fetched, updating UI now.\")\n        self.updateUI()\n    }\n}"}
{"instruction": "Write a Swift code snippet demonstrating the difference between 'weak' and 'unowned' references to prevent memory leaks.", "output": "class BankAccount {\n    var owner: Person?\n}\n\nclass Person {\n    var account: BankAccount?\n}\n\nclass CreditCard {\n    // Unowned: Assumes 'owner' will always exist as long as the card exists.\n    // If 'owner' is deallocated, accessing this causes a crash.\n    unowned let owner: Person\n    \n    init(owner: Person) {\n        self.owner = owner\n    }\n}\n\n// Usage context\n// Weak: 'account' can be nil. Used when the reference might become nil.\n// Unowned: 'owner' cannot be nil. Used when the other instance has the same or longer lifetime."}
{"instruction": "Configure a basic 'UICollectionViewDiffableDataSource' in UIKit to manage data for a collection view.", "output": "var dataSource: UICollectionViewDiffableDataSource<Section, Item>!\n\nfunc configureDataSource() {\n    dataSource = UICollectionViewDiffableDataSource<Section, Item>(collectionView: collectionView) { (collectionView, indexPath, item) -> UICollectionViewCell? in\n        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"ItemCell\", for: indexPath) as? ItemCell else {\n            fatalError(\"Cannot create new cell\")\n        }\n        cell.configure(with: item)\n        return cell\n    }\n}\n\nfunc applySnapshot(items: [Item]) {\n    var snapshot = NSDiffableDataSourceSnapshot<Section, Item>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(items)\n    dataSource.apply(snapshot, animatingDifferences: true)\n}"}
{"instruction": "Write a Swift function that fetches 'User' entities from Core Data where the 'age' attribute is greater than 21, sorted by 'lastName' in ascending order.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Predicate: age > 21\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    // Sort Descriptor: lastName ascending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    \n    do {\n        let results = try context.fetch(fetchRequest)\n        return results\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a ViewController class when updating the UI after a network delay.", "output": "class MyViewController: UIViewController {\n    var dataLoader: DataLoader?\n    @IBOutlet weak var statusLabel: UILabel!\n\n    func performUpdate() {\n        // Use [weak self] to prevent the closure from strongly holding the ViewController\n        dataLoader?.fetchData { [weak self] result in\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                switch result {\n                case .success(let data):\n                    self.statusLabel.text = \"Success: \\(data)\"\n                case .failure(let error):\n                    self.statusLabel.text = \"Error: \\(error.localizedDescription)\"\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a thread-safe Singleton pattern in Objective-C.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    \n    return sharedInstance;\n}\n\n- (instancetype)init {\n    if (self = [super init]) {\n        // Initialization code here\n    }\n    return self;\n}\n\n@end"}
{"instruction": "Using the Combine framework in Swift, create a pipeline that listens to a text publisher (like a search bar), debounces the input for 500 milliseconds, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                guard !query.isEmpty else { return }\n                print(\"Perform search for: \\(query)\")\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        // API call logic here\n    }\n}"}
{"instruction": "Implement a SwiftUI View that uses `@StateObject` to own a ViewModel and `@ObservedObject` to pass it to a child view, ensuring correct memory management.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    func increment() { count += 1 }\n}\n\nstruct ParentView: View {\n    // @StateObject ensures this view owns the instance and it persists across redraws\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Parent Count: \\(viewModel.count)\")\n            ChildView(viewModel: viewModel)\n        }\n    }\n}\n\nstruct ChildView: View {\n    // @ObservedObject watches the object but does not own it\n    @ObservedObject var viewModel: CounterViewModel\n\n    var body: some View {\n        Button(\"Increment\") {\n            viewModel.increment()\n        }\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to request FaceID/TouchID biometric authentication.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if biometric authentication is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Log in to your account\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Write a Swift function using `async/await` to fetch and decode JSON data from a URL, handling errors appropriately.", "output": "struct Todo: Codable {\n    let id: Int\n    let title: String\n    let completed: Bool\n}\n\nfunc fetchTodos() async throws -> [Todo] {\n    guard let url = URL(string: \"https://jsonplaceholder.typicode.com/todos\") else {\n        throw URLError(.badURL)\n    }\n\n    // Use async data(from:) method\n    let (data, response) = try await URLSession.shared.data(from: url)\n\n    guard let httpResponse = response as? HTTPURLResponse, \n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n\n    let decoder = JSONDecoder()\n    let todos = try decoder.decode([Todo].self, from: data)\n    return todos\n}"}
{"instruction": "Use the Vision framework to perform text recognition (OCR) on a `UIImage`.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage) {\n    guard let cgImage = image.cgImage else { return }\n\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed: \\(String(describing: error))\")\n            return\n        }\n\n        let recognizedStrings = observations.compactMap { observation in\n            // Return the top candidate\n            return observation.topCandidates(1).first?.string\n        }\n\n        print(\"Recognized text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n\n    request.recognitionLevel = .accurate\n\n    let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    do {\n        try requestHandler.perform([request])\n    } catch {\n        print(\"Failed to perform request: \\(error)\")\n    }\n}"}
{"instruction": "Implement a custom `UIView` in UIKit that draws a red circle in the center of the view using `draw(_:)`.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n\n        // Calculate center and radius\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10 // 10pt padding\n\n        let circlePath = UIBezierPath(arcCenter: center,\n                                      radius: radius,\n                                      startAngle: 0,\n                                      endAngle: CGFloat.pi * 2,\n                                      clockwise: true)\n\n        UIColor.red.setFill()\n        circlePath.fill()\n        \n        // Optional: Add a border\n        UIColor.black.setStroke()\n        circlePath.lineWidth = 2.0\n        circlePath.stroke()\n    }\n}"}
{"instruction": "Use `Publishers.Zip` in Combine to wait for two independent network requests to finish before processing the combined result.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable { let id: Int }\nstruct Profile: Decodable { let bio: String }\n\nfunc fetchUserData() -> AnyPublisher<(User, Profile), Error> {\n    let userURL = URL(string: \"https://api.example.com/user\")!\n    let profileURL = URL(string: \"https://api.example.com/profile\")!\n\n    let userPublisher = URLSession.shared.dataTaskPublisher(for: userURL)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n\n    let profilePublisher = URLSession.shared.dataTaskPublisher(for: profileURL)\n        .map(\\.data)\n        .decode(type: Profile.self, decoder: JSONDecoder())\n\n    // Zip waits for both to emit a value, then emits them as a tuple\n    return Publishers.Zip(userPublisher, profilePublisher)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Create a Swift class named `Downloader` that demonstrates how to prevent a strong reference cycle (retain cycle) when using a closure to handle a completion event. Use a capture list to reference `self` weakly.", "output": "class Downloader {\n    var onComplete: (() -> Void)?\n    var data: Data?\n\n    func startDownload() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in\n            // Guard against self being nil (deallocated)\n            guard let self = self else { return }\n            \n            self.data = Data()\n            \n            DispatchQueue.main.async {\n                self.onComplete?()\n            }\n        }\n    }\n    \n    deinit {\n        print(\"Downloader deinitialized\")\n    }\n}"}
{"instruction": "Write a Swift function using `NSPersistentContainer` that performs a background task to create and save a new `User` entity. Ensure the context is saved properly and errors are handled.", "output": "import CoreData\n\nfunc createBackgroundUser(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.timestamp = Date()\n\n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"User saved successfully in background.\")\n            } catch {\n                print(\"Failed to save background context: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework in Swift, create a function that fetches a JSON object from a URL, decodes it into a generic `Decodable` type, and returns an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift named `CircleView` that uses Core Graphics within the `draw(_:)` method to draw a filled red circle centered in the view.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Calculate a centered square for the circle\n        let diameter = min(rect.width, rect.height)\n        let x = (rect.width - diameter) / 2\n        let y = (rect.height - diameter) / 2\n        let circleRect = CGRect(x: x, y: y, width: diameter, height: diameter)\n        \n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Create a SwiftUI view structure that uses `@StateObject` to observe a view model. The view model should have a `@Published` counter property that the view increments on button tap.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    \n    func increment() {\n        count += 1\n    }\n}\n\nstruct CounterView: View {\n    @StateObject private var viewModel = CounterViewModel()\n    \n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet demonstrating the 'weak-strong dance' inside a block to avoid a retain cycle while ensuring the object stays alive during the block's execution.", "output": "__weak typeof(self) weakSelf = self;\n[self.someAsyncMethodWithCompletion:^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (!strongSelf) {\n        return;\n    }\n    \n    [strongSelf doSomething];\n    strongSelf.someProperty = @\"Updated\";\n}];"}
{"instruction": "Create a Swift class named `LocationManager` that acts as a wrapper for `CLLocationManager`. It should request 'When In Use' authorization upon initialization and conform to `CLLocationManagerDelegate`.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    private let manager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        manager.delegate = self\n        manager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location authorized\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Location denied\")\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Using Combine, write a pipeline that takes a `PassthroughSubject` of strings (representing search queries), debounces the input for 500 milliseconds, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nlet searchTextSubject = PassthroughSubject<String, Never>()\nvar cancellables = Set<AnyCancellable>()\n\nsearchTextSubject\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .sink { query in\n        print(\"Searching for: \\(query)\")\n    }\n    .store(in: &cancellables)"}
{"instruction": "Write a Swift function that adds a Core Animation (`CABasicAnimation`) to a `CALayer` to rotate it 360 degrees indefinitely along the Z-axis.", "output": "import UIKit\n\nfunc rotateLayerIndefinitely(layer: CALayer) {\n    let rotation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n    rotation.toValue = NSNumber(value: Double.pi * 2)\n    rotation.duration = 2.0\n    rotation.isCumulative = true\n    rotation.repeatCount = Float.greatestFiniteMagnitude\n    \n    layer.add(rotation, forKey: \"rotationAnimation\")\n}"}
{"instruction": "Create a SwiftUI view that retrieves a list of `ToDoItem` entities from Core Data using `@FetchRequest`, sorted by a `createdAt` date attribute.", "output": "import SwiftUI\nimport CoreData\n\nstruct ToDoListView: View {\n    @FetchRequest(\n        entity: ToDoItem.entity(),\n        sortDescriptors: [NSSortDescriptor(keyPath: \\ToDoItem.createdAt, ascending: true)]\n    ) var items: FetchedResults<ToDoItem>\n\n    var body: some View {\n        List(items, id: \\.self) { item in\n            Text(item.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Create a Swift class named `ImageDownloader` that demonstrates how to prevent a Strong Reference Cycle (Retain Cycle) when using a closure to handle a completion event. The closure should capture `self` weakly and handle the case where `self` might be nil.", "output": "class ImageDownloader {\n    var onImageDownloaded: ((UIImage?) -> Void)?\n    \n    func downloadImage(url: URL) {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) { [weak self] in\n            // Guard against self being deallocated\n            guard let self = self else {\n                print(\"Self was deallocated before download completed.\")\n                return\n            }\n            \n            let mockImage = UIImage() // Assume image data was processed\n            \n            DispatchQueue.main.async {\n                self.onImageDownloaded?(mockImage)\n            }\n        }\n    }\n    \n    deinit {\n        print(\"ImageDownloader deinitialized\")\n    }\n}"}
{"instruction": "Write a SwiftUI View that utilizes `@FetchRequest` to retrieve a list of `ToDoItem` entities from Core Data, sorted by a `createdAt` date attribute. Display the `title` of each item in a List.", "output": "import SwiftUI\nimport CoreData\n\nstruct ToDoListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\ToDoItem.createdAt, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<ToDoItem>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.title ?? \"Untitled\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"To Do List\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that takes a URL, performs a data task, decodes a JSON response into a generic `Decodable` type `T`, and returns an `AnyPublisher<T, Error>`.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a method in Objective-C that performs a batch update on a Core Data entity named `User`. The goal is to set the `isActive` boolean attribute to `NO` for all users efficiently without loading the objects into memory.", "output": "- (void)deactivateAllUsersWithContext:(NSManagedObjectContext *)context {\n    NSBatchUpdateRequest *batchRequest = [[NSBatchUpdateRequest alloc] initWithEntityName:@\"User\"];\n    batchRequest.propertiesToUpdate = @{ @\"isActive\": @NO };\n    batchRequest.resultType = NSUpdatedObjectIDsResultType;\n    \n    NSError *error = nil;\n    NSBatchUpdateResult *result = [context executeRequest:batchRequest error:&error];\n    \n    if (error) {\n        NSLog(@\"Batch update failed: %@\", error.localizedDescription);\n    } else {\n        // Merge changes back into the context to keep UI consistent\n        NSArray *objectIDs = result.result;\n        NSDictionary *changes = @{ NSUpdatedObjectsKey: objectIDs };\n        [NSManagedObjectContext mergeChangesFromRemoteContextSave:changes intoContexts:@[context]];\n        NSLog(@\"Successfully deactivated users.\");\n    }\n}"}
{"instruction": "Create a Swift function using `withCheckedThrowingContinuation` to wrap a legacy callback-based API (`legacyFetchData`) into a modern `async/await` pattern.", "output": "func legacyFetchData(completion: @escaping (Result<String, Error>) -> Void) {\n    // Simulation of legacy code\n    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n        completion(.success(\"Data received\"))\n    }\n}\n\nfunc fetchDataAsync() async throws -> String {\n    return try await withCheckedThrowingContinuation { continuation in\n        legacyFetchData { result in\n            switch result {\n            case .success(let data):\n                continuation.resume(returning: data)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}"}
{"instruction": "Write a UIKit implementation of a `UITableViewDiffableDataSource` setup. Assume a `UITableView` and a simple `Hashable` model struct `Person` exist. Show how to apply a snapshot.", "output": "import UIKit\n\nstruct Person: Hashable {\n    let id = UUID()\n    let name: String\n}\n\nclass PeopleViewController: UIViewController {\n    enum Section { case main }\n    \n    var tableView: UITableView!\n    var dataSource: UITableViewDiffableDataSource<Section, Person>!\n    var people: [Person] = []\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource<Section, Person>(tableView: tableView) { (tableView, indexPath, person) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n            cell.textLabel?.text = person.name\n            return cell\n        }\n    }\n\n    func updateSnapshot(with newPeople: [Person]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, Person>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(newPeople)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Define an Objective-C protocol for a delegate pattern to handle a selection event, and declare a property for that delegate in a class interface ensuring memory safety (avoiding retain cycles).", "output": "// MyCustomView.h\n#import <UIKit/UIKit.h>\n\n@class MyCustomView;\n\n@protocol MyCustomViewDelegate <NSObject>\n- (void)customView:(MyCustomView *)view didSelectItemAtIndex:(NSInteger)index;\n@end\n\n@interface MyCustomView : UIView\n\n// using 'weak' to prevent retain cycle\n@property (nonatomic, weak) id<MyCustomViewDelegate> delegate;\n\n@end"}
{"instruction": "Using Combine in a ViewModel, combine two `@Published` properties (`username` and `password`) to drive a third published property `isLoginEnabled`. The button should be enabled only if the username is at least 3 characters and the password is at least 6 characters.", "output": "import Combine\nimport Foundation\n\nclass LoginViewModel: ObservableObject {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    @Published var isLoginEnabled = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                return username.count >= 3 && password.count >= 6\n            }\n            .assign(to: \\.isLoginEnabled, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Create a `UIView` subclass that uses Core Graphics in the `draw(_:)` method to draw a red circle centered in the view with a 10-point padding from the edges.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let padding: CGFloat = 10.0\n        let diameter = min(rect.width, rect.height) - (padding * 2)\n        let x = (rect.width - diameter) / 2\n        let y = (rect.height - diameter) / 2\n        \n        let circleRect = CGRect(x: x, y: y, width: diameter, height: diameter)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Implement a function using `CLLocationManager` to request 'When In Use' authorization. Include the delegate method to handle the authorization status change.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        // Must have NSLocationWhenInUseUsageDescription in Info.plist\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location access granted.\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Location access denied.\")\n        case .notDetermined:\n            print(\"Permission not determined yet.\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Write a Swift code snippet demonstrating how to prevent a strong reference cycle (retain cycle) when using a closure inside a class, specifically within a Dispatch function.", "output": "class DataFetcher {\n    var data: String = \"\"\n\n    func fetchData() {\n        // Use [weak self] to prevent the closure from strongly holding the class instance\n        DispatchQueue.global().async { [weak self] in\n            let result = \"Fetched Data\"\n            \n            // Safely unwrap self to access properties\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                self.data = result\n                print(self.data)\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Core Data stack setup in Swift using NSPersistentContainer, including a method to save the context.", "output": "import CoreData\n\nclass CoreDataManager {\n    static let shared = CoreDataManager()\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that takes a text Publisher (e.g., from a search bar), debounces the input for 500ms, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { text in\n                print(\"Search query: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Write an Objective-C property declaration for a delegate to avoid memory leaks, and synthesize it.", "output": "@protocol MyDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' to prevent retain cycles between the delegator and delegate\n@property (nonatomic, weak) id<MyDelegate> delegate;\n\n@end\n\n@implementation MyClass\n// In modern Objective-C, @synthesize is usually optional, but if used:\n// @synthesize delegate = _delegate;\n@end"}
{"instruction": "Implement a SwiftUI view that uses `@FetchRequest` to retrieve 'Item' entities from Core Data, sorted by 'timestamp'.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(\"Item at \\(item.timestamp ?? Date(), formatter: itemFormatter)\")\n            }\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Demonstrate how to perform a batch delete request in Core Data using Swift to efficiently delete all records of a specific entity named 'LogEntry'.", "output": "import CoreData\n\nfunc deleteAllLogs(context: NSManagedObjectContext) {\n    let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"LogEntry\")\n    \n    // Create a batch delete request\n    let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)\n    \n    // Configure the result type if you need the IDs of deleted objects\n    batchDeleteRequest.resultType = .resultTypeObjectIDs\n    \n    do {\n        let result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult\n        \n        // Important: Merge changes back into the context to keep UI in sync\n        let changes: [AnyHashable: Any] = [\n            NSDeletedObjectsKey: result?.result as? [NSManagedObjectID] ?? []\n        ]\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [context])\n        \n    } catch {\n        print(\"Batch delete failed: \\(error)\")\n    }\n}"}
{"instruction": "Create a programmatic UIKit `UIView` subclass that centers a red square (100x100) within itself using Auto Layout constraints.", "output": "import UIKit\n\nclass CenteredSquareView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        let redSquare = UIView()\n        redSquare.backgroundColor = .red\n        redSquare.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(redSquare)\n        \n        NSLayoutConstraint.activate([\n            redSquare.widthAnchor.constraint(equalToConstant: 100),\n            redSquare.heightAnchor.constraint(equalToConstant: 100),\n            redSquare.centerXAnchor.constraint(equalTo: centerXAnchor),\n            redSquare.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Use Combine to combine two publishers (username and password) to enable a login button only when the username is at least 3 characters and the password is at least 8 characters.", "output": "import Combine\nimport UIKit\n\nclass LoginViewModel {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    @Published var isLoginEnabled = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                return username.count >= 3 && password.count >= 8\n            }\n            .assign(to: \\.isLoginEnabled, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Demonstrate the use of `autoreleasepool` in Swift to manage memory when processing a large loop creating many temporary objects.", "output": "import Foundation\n\nfunc processLargeData() {\n    // Without autoreleasepool, memory usage might spike significantly\n    for i in 0..<10000 {\n        autoreleasepool {\n            // Create temporary objects that are only needed inside this iteration\n            let fileContent = Data(count: 1024 * 1024) // 1MB dummy data\n            let processedString = String(decoding: fileContent, as: UTF8.self)\n            \n            print(\"Processed item \\(i) with length \\(processedString.count)\")\n            // fileContent and processedString are deallocated here\n        }\n    }\n}"}
{"instruction": "Write a Swift `actor` to handle a thread-safe counter, demonstrating the concurrency model introduced in Swift 5.5.", "output": "actor SafeCounter {\n    private var value = 0\n    \n    func increment() {\n        value += 1\n    }\n    \n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage Example inside a Task\n// Task {\n//     let counter = SafeCounter()\n//     await counter.increment()\n//     let currentValue = await counter.getValue()\n//     print(currentValue)\n// }"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onDataLoaded: (() -> Void)?\n    var data: [String] = []\n\n    func loadData() {\n        // Fixed: Added [weak self] capture list to break the strong reference cycle\n        Service.fetch { [weak self] result in\n            guard let self = self else { return }\n            self.data = result\n            self.onDataLoaded?()\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to fetch all 'User' entities where the 'age' attribute is greater than or equal to 18. Return the array of User objects.", "output": "import CoreData\n\nfunc fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    // Predicate to filter age >= 18\n    fetchRequest.predicate = NSPredicate(format: \"age >= %d\", 18)\n    \n    do {\n        let users = try context.fetch(fetchRequest)\n        return users\n    } catch {\n        print(\"Failed to fetch users: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Create a simple networking layer using Combine in Swift that fetches JSON from a URL, decodes it into a generic 'Decodable' type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement the 'cellForRowAtIndexPath' method in Objective-C for a simple UITableView, ensuring cell reuse and setting the text label.", "output": "- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    static NSString *cellIdentifier = @\"CellID\";\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];\n    \n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];\n    }\n    \n    cell.textLabel.text = [NSString stringWithFormat:@\"Row %ld\", (long)indexPath.row];\n    return cell;\n}"}
{"instruction": "Create a SwiftUI view that utilizes Core Image to apply a Sepia Tone filter to a provided UIImage and displays the result.", "output": "import SwiftUI\nimport CoreImage\nimport CoreImage.CIFilterBuiltins\n\nstruct SepiaView: View {\n    let inputImage: UIImage\n    @State private var outputImage: Image?\n\n    var body: some View {\n        VStack {\n            if let image = outputImage {\n                image.resizable().scaledToFit()\n            } else {\n                ProgressView()\n            }\n        }\n        .onAppear(perform: applySepiaFilter)\n    }\n\n    func applySepiaFilter() {\n        let context = CIContext()\n        let currentFilter = CIFilter.sepiaTone()\n        currentFilter.inputImage = CIImage(image: inputImage)\n        currentFilter.intensity = 1.0\n\n        if let output = currentFilter.outputImage,\n           let cgImage = context.createCGImage(output, from: output.extent) {\n            self.outputImage = Image(uiImage: UIImage(cgImage: cgImage))\n        }\n    }\n}"}
{"instruction": "Define a property for a delegate in an Objective-C class header file ensuring proper memory management to avoid retain cycles.", "output": "@protocol MyClassDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' attribute for delegates to prevent strong reference cycles (ARC)\n@property (nonatomic, weak) id<MyClassDelegate> delegate;\n\n@end"}
{"instruction": "Write a Swift code snippet using Core Location to request 'When In Use' authorization and handle the delegate method for authorization changes.", "output": "import CoreLocation\n\nclass LocationManager: NSObject, CLLocationManagerDelegate {\n    let manager = CLLocationManager()\n\n    override init() {\n        super.init()\n        manager.delegate = self\n    }\n\n    func requestPermission() {\n        manager.requestWhenInUseAuthorization()\n    }\n\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Access granted\")\n            manager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Access denied\")\n        case .notDetermined:\n            print(\"Waiting for user selection\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Use Combine to implement a search debounce mechanism. Subscribe to a UITextField's text changes (via NotificationCenter), wait for 500ms, and print the text.", "output": "import UIKit\nimport Combine\n\nclass SearchViewController: UIViewController {\n    @IBOutlet weak var searchTextField: UITextField!\n    var subscriptions = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: searchTextField)\n            .map { ($0.object as! UITextField).text ?? \"\" }\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { searchText in\n                print(\"Searching for: \\(searchText)\")\n            }\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "Demonstrate how to perform a background save operation safely using `NSPersistentContainer`'s `performBackgroundTask` method in Swift.", "output": "func saveInBackground(container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Create a new entity in the background context\n        let newEntity = MyEntity(context: context)\n        newEntity.timestamp = Date()\n        newEntity.name = \"Background Data\"\n\n        do {\n            try context.save()\n            print(\"Background save successful\")\n        } catch {\n            print(\"Background save failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI ViewModel conforming to `ObservableObject` that manages a list of strings, exposing it via the `@Published` property wrapper.", "output": "import SwiftUI\nimport Combine\n\nclass ListViewModel: ObservableObject {\n    @Published var items: [String] = []\n\n    func addItem(_ item: String) {\n        items.append(item)\n    }\n\n    func removeItem(at offsets: IndexSet) {\n        items.remove(atOffsets: offsets)\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a class property holds a closure that captures 'self'.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in \n            // Fix: Capture self weakly to avoid retain cycle\n            guard let self = self else { return }\n            \n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a simple Core Data stack in Swift using `NSPersistentContainer` that includes a utility method to save the context if changes exist.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"ModelName\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n\n    func saveContext() {\n        let context = persistentContainer.viewContext\n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nserror = error as NSError\n                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            }\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that takes a search text publisher, debounces it for 500ms, removes duplicates, and filters out empty strings.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "In Objective-C, define a protocol for a delegate and a class that holds a reference to that delegate. Ensure the delegate property is defined correctly to avoid a strong reference cycle (memory leak).", "output": "@protocol NetworkManagerDelegate <NSObject>\n- (void)didReceiveData:(NSData *)data;\n@end\n\n@interface NetworkManager : NSObject\n\n// Use 'weak' to prevent retain cycles. \n// If supporting very old iOS versions without ARC, use 'assign'.\n@property (nonatomic, weak) id<NetworkManagerDelegate> delegate;\n\n- (void)startRequest;\n\n@end"}
{"instruction": "Using SwiftUI, create a view that utilizes `@FetchRequest` to retrieve 'Task' entities from Core Data, sorted by a 'createdAt' date attribute.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Task.createdAt, ascending: true)],\n        animation: .default)\n    private var tasks: FetchedResults<Task>\n\n    var body: some View {\n        List {\n            ForEach(tasks) { task in\n                Text(task.title ?? \"Untitled\")\n            }\n            .onDelete(perform: deleteItems)\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { tasks[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Implement a generic network layer function using Combine's `URLSession.dataTaskPublisher` to fetch and decode a JSON object.", "output": "import Combine\nimport Foundation\n\nfunc fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Using UIKit programmatically (no Storyboards), create a `UIView` subclass that centers a red square (100x100) within itself using Auto Layout constraints.", "output": "import UIKit\n\nclass CustomView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    private func setupView() {\n        backgroundColor = .white\n        \n        let redSquare = UIView()\n        redSquare.backgroundColor = .red\n        redSquare.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(redSquare)\n        \n        NSLayoutConstraint.activate([\n            redSquare.widthAnchor.constraint(equalToConstant: 100),\n            redSquare.heightAnchor.constraint(equalToConstant: 100),\n            redSquare.centerXAnchor.constraint(equalTo: centerXAnchor),\n            redSquare.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Write an Objective-C block that captures a local variable. Demonstrate how to avoid a strong reference cycle if capturing `self` inside the block, using the `__weak` and `__strong` dance.", "output": "__weak typeof(self) weakSelf = self;\n\nvoid (^completionBlock)(void) = ^{\n    // Promote to strong reference to ensure self exists during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf updateUI];\n    } else {\n        NSLog(@\"Self was deallocated before block executed\");\n    }\n};"}
{"instruction": "Use the Vision framework in Swift to perform a text recognition request on a `CGImage`.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { (request, error) in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Combine multiple publishers using `CombineLatest` to enable a login button only when the username is valid (3+ chars) and the password is valid (8+ chars).", "output": "import Combine\nimport UIKit\n\nclass LoginViewModel {\n    @Published var username = \"\"\n    @Published var password = \"\"\n    @Published var isLoginEnabled = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                return username.count >= 3 && password.count >= 8\n            }\n            .assign(to: \\.isLoginEnabled, on: self)\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Create a Swift class named `NetworkManager` that simulates a data fetch using a closure. Implement a function `fetchData` that takes a completion handler. Call this function from another class `ViewModel` and assign the result to a property, ensuring you avoid a retain cycle (memory leak) by using a capture list.", "output": "class NetworkManager {\n    func fetchData(completion: @escaping (String) -> Void) {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            completion(\"Data received\")\n        }\n    }\n}\n\nclass ViewModel {\n    var data: String = \"\"\n    let networkManager = NetworkManager()\n\n    func updateData() {\n        // usage of [weak self] to prevent retain cycle\n        networkManager.fetchData { [weak self] result in\n            guard let self = self else { return }\n            self.data = result\n            print(\"Data updated: \\(self.data)\")\n        }\n    }\n}"}
{"instruction": "Write a function using Core Data and Swift to perform a batch insert of 10,000 user records. Use `NSBatchInsertRequest` to ensure memory efficiency and performance compared to inserting objects individually into the context.", "output": "import CoreData\n\nfunc batchInsertUsers(viewContext: NSManagedObjectContext) {\n    var index = 0\n    let total = 10000\n    \n    // Define the batch insert request\n    let batchInsert = NSBatchInsertRequest(entity: User.entity(), dictionaryHandler: { dictionary in\n        guard index < total else { return true } // Return true to stop\n        \n        dictionary.addEntries(from: [\n            \"id\": UUID(),\n            \"username\": \"User_\\(index)\",\n            \"createdAt\": Date()\n        ])\n        \n        index += 1\n        return false // Return false to continue\n    })\n    \n    // Execute request\n    do {\n        try viewContext.execute(batchInsert)\n        print(\"Batch insert completed.\")\n    } catch {\n        print(\"Failed to execute batch insert: \\(error)\")\n    }\n}"}
{"instruction": "Using the Combine framework in Swift, create a function that performs a network request to a specific URL, decodes the JSON response into a `Codable` struct `Post`, and handles errors. Return `AnyPublisher<Post, Error>`.", "output": "import Combine\nimport Foundation\n\nstruct Post: Codable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPost() -> AnyPublisher<Post, Error> {\n    guard let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\") else {\n        return Fail(error: URLError(.badURL)).eraseToAnyPublisher()\n    }\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: Post.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement the Delegate Pattern in Objective-C to allow a `ChildViewController` to notify a `ParentViewController` when a button is tapped. Specifically, define the protocol and the property in the child to avoid a Strong Reference Cycle (Retain Cycle).", "output": "// ChildViewController.h\n#import <UIKit/UIKit.h>\n\n@protocol ChildViewControllerDelegate <NSObject>\n- (void)didTapButton;\n@end\n\n@interface ChildViewController : UIViewController\n\n// Use 'weak' to prevent retain cycle\n@property (nonatomic, weak) id<ChildViewControllerDelegate> delegate;\n\n@end\n\n// ChildViewController.m\n@implementation ChildViewController\n- (void)buttonAction {\n    if ([self.delegate respondsToSelector:@selector(didTapButton)]) {\n        [self.delegate didTapButton];\n    }\n}\n@end"}
{"instruction": "Using SwiftUI, create a View that utilizes `StateObject` to initialize a ViewModel. Explain via code implementation why `StateObject` is used instead of `ObservedObject` for the owner of the data.", "output": "import SwiftUI\n\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    \n    func increment() {\n        count += 1\n    }\n}\n\nstruct CounterView: View {\n    // @StateObject ensures the ViewModel persists even if the View redraws/reinitializes.\n    // If @ObservedObject were used here, the count might reset on View updates.\n    @StateObject private var viewModel = CounterViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(viewModel.count)\")\n            Button(\"Increment\") {\n                viewModel.increment()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that observes a `UITextField`'s text changes (via a custom publisher or `@Published` property), debounces the input for 500 milliseconds, removes duplicate consecutive values, and prints the result. This is commonly used for Search bars.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Use the Vision framework (Native Apple Framework) in Swift to recognize text in a given `UIImage`. Create a function that processes the image and prints the recognized strings.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized Text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Demonstrate thread-safe Core Data usage by creating a function that performs a background task using a private queue context. Use `perform` (or `performAndWait`) to ensure the operations happen on the correct thread.", "output": "import CoreData\n\nfunc performBackgroundTask(persistentContainer: NSPersistentContainer) {\n    persistentContainer.performBackgroundTask { backgroundContext in\n        // This block runs on a background thread automatically\n        \n        let newEntity = NSEntityDescription.insertNewObject(forEntityName: \"LogEntry\", into: backgroundContext)\n        newEntity.setValue(Date(), forKey: \"timestamp\")\n        newEntity.setValue(\"Background update\", forKey: \"message\")\n        \n        do {\n            try backgroundContext.save()\n            print(\"Saved on background context\")\n        } catch {\n            print(\"Background save failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using UIKit and Swift, set up a `UITableView` using the modern `UITableViewDiffableDataSource` to manage data. Assume a simple struct `Item` that conforms to `Hashable`. Show how to apply a snapshot.", "output": "import UIKit\n\nstruct Item: Hashable {\n    let id = UUID()\n    let title: String\n}\n\nclass ListViewController: UITableViewController {\n    enum Section { case main }\n    var dataSource: UITableViewDiffableDataSource<Section, Item>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n        applySnapshot()\n    }\n\n    func configureDataSource() {\n        dataSource = UITableViewDiffableDataSource(tableView: tableView) { (tableView, indexPath, item) -> UITableViewCell? in\n            let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\") ?? UITableViewCell(style: .default, reuseIdentifier: \"cell\")\n            cell.textLabel?.text = item.title\n            return cell\n        }\n    }\n\n    func applySnapshot() {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, Item>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems([Item(title: \"Apple\"), Item(title: \"Banana\"), Item(title: \"Cherry\")])\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Implement Biometric Authentication using the LocalAuthentication framework in Swift. Create a function that checks if FaceID/TouchID is available and then attempts to authenticate the user.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check for biometric availability\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    completion(true, nil)\n                } else {\n                    completion(false, authenticationError)\n                }\n            }\n        }\n    } else {\n        // Biometry not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a Swift function that fetches 'Employee' entities from Core Data where the 'department' attribute equals 'Engineering', sorted by 'hireDate' in descending order.", "output": "import CoreData\n\nfunc fetchEngineeringEmployees(context: NSManagedObjectContext) -> [Employee]? {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    \n    // Predicate: Department is Engineering\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    // Sort: Hire Date Descending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"hireDate\", ascending: false)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a View Controller when accessing 'self'.", "output": "class MyViewController: UIViewController {\n    var completionHandler: (() -> Void)?\n    var status = \"Loading\"\n\n    func setupClosure() {\n        // Use [weak self] to capture self weakly to prevent a retain cycle\n        completionHandler = { [weak self] in\n            // Safely unwrap self\n            guard let self = self else { return }\n            self.status = \"Complete\"\n            self.updateUI()\n        }\n    }\n\n    func updateUI() {\n        print(status)\n    }\n}"}
{"instruction": "Using Combine, create a pipeline that takes a search string publisher, debounces it for 500ms, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nvar cancellables = Set<AnyCancellable>()\nlet searchTextPublisher = PassthroughSubject<String, Never>()\n\nsearchTextPublisher\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .sink { searchText in\n        print(\"Searching for: \\(searchText)\")\n    }\n    .store(in: &cancellables)\n\n// Usage\nsearchTextPublisher.send(\"Swif\")\nsearchTextPublisher.send(\"Swift\") // Only this emits if sent rapidly"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedInstance;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a SwiftUI view that uses @FetchRequest to display a list of 'Item' entities sorted by 'timestamp'.", "output": "import SwiftUI\nimport CoreData\n\nstruct ItemListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n                }\n            }\n        }\n    }\n}\n\nprivate let itemFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .short\n    formatter.timeStyle = .medium\n    return formatter\n}()"}
{"instruction": "Use the Vision framework in Swift to perform a text recognition request on a CGImage.", "output": "import Vision\nimport CoreImage\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            return\n        }\n        \n        for observation in observations {\n            // Get the top candidate\n            if let candidate = observation.topCandidates(1).first {\n                print(\"Recognized text: \\(candidate.string)\")\n            }\n        }\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform detection: \\(error)\")\n    }\n}"}
{"instruction": "Wrap a legacy callback-based API into a Combine Future publisher.", "output": "import Combine\n\nfunc performLegacyFetch() -> Future<String, Error> {\n    return Future { promise in\n        legacyAPICall { result, error in\n            if let error = error {\n                promise(.failure(error))\n            } else if let result = result {\n                promise(.success(result))\n            } else {\n                promise(.failure(URLError(.unknown)))\n            }\n        }\n    }\n}\n\n// Mock legacy function\nfunc legacyAPICall(completion: @escaping (String?, Error?) -> Void) {\n    completion(\"Data\", nil)\n}"}
{"instruction": "Implement the `cellForRowAtIndexPath` method in Objective-C to dequeue a reusable cell and set its text label.", "output": "- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    static NSString *cellIdentifier = @\"Cell\";\n    \n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];\n    \n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];\n    }\n    \n    cell.textLabel.text = [NSString stringWithFormat:@\"Row %ld\", (long)indexPath.row];\n    \n    return cell;\n}"}
{"instruction": "Write a Swift class modeling a 'Person' and an 'Apartment' to demonstrate 'unowned' references to break a retain cycle where an Apartment cannot exist without a Tenant.", "output": "class Person {\n    let name: String\n    var apartment: Apartment?\n    \n    init(name: String) {\n        self.name = name\n    }\n    \n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let unit: String\n    // 'unowned' is used because an Apartment is expected to always have a tenant \n    // and the tenant outlives the apartment in this specific lifecycle model.\n    // If the tenant could be nil, 'weak' should be used instead.\n    unowned let tenant: Person\n    \n    init(unit: String, tenant: Person) {\n        self.unit = unit\n        self.tenant = tenant\n    }\n    \n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}"}
{"instruction": "Create a generic Async/Await function in Swift to fetch and decode JSON data from a URL.", "output": "import Foundation\n\nfunc fetch<T: Decodable>(_ url: URL) async throws -> T {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    let decoder = JSONDecoder()\n    return try decoder.decode(T.self, from: data)\n}"}
{"instruction": "Write a Swift code snippet demonstrating how to avoid a retain cycle (memory leak) when using a closure inside a class, specifically referencing `self`.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate async operation\n        DispatchQueue.global().async { [weak self] in\n            // Capture self weakly to avoid strong reference cycle\n            guard let self = self else { return }\n            \n            let results = [\"Item 1\", \"Item 2\"]\n            self.data = results\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a Core Data fetch request in Swift to retrieve 'Task' entities where 'isCompleted' is false, sorted by 'dueDate' in ascending order.", "output": "import CoreData\n\nfunc fetchIncompleteTasks(context: NSManagedObjectContext) -> [Task] {\n    let fetchRequest: NSFetchRequest<Task> = Task.fetchRequest()\n    \n    // Predicate: isCompleted == false\n    fetchRequest.predicate = NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false))\n    \n    // Sort Descriptor: Ascending by dueDate\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"dueDate\", ascending: true)]\n    \n    do {\n        let tasks = try context.fetch(fetchRequest)\n        return tasks\n    } catch {\n        print(\"Failed to fetch tasks: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using Combine and SwiftUI, create a ViewModel that debounces a search text input for 500 milliseconds before triggering a search action.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var searchResults: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching for: \\(query)\")\n        // logic to update searchResults\n    }\n}"}
{"instruction": "Write an Objective-C code snippet to set up a property for a delegate protocol. Ensure the memory management attribute is correct to prevent retain cycles.", "output": "@protocol CustomDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface TaskManager : NSObject\n\n// Use 'weak' to prevent retain cycles between the manager and its delegate\n@property (nonatomic, weak) id<CustomDelegate> delegate;\n\n@end"}
{"instruction": "Implement a basic URLSession network call in Swift using the modern async/await concurrency model to fetch Data from a URL.", "output": "import Foundation\n\nfunc fetchData(from urlString: String) async throws -> Data {\n    guard let url = URL(string: urlString) else {\n        throw URLError(.badURL)\n    }\n    \n    // Use the async variant of data(from:)\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse, \n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    \n    return data\n}"}
{"instruction": "Create a custom SwiftUI ViewModifier that adds a blue border and rounded corners to any view.", "output": "import SwiftUI\n\nstruct BlueBorderedCard: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .overlay(\n                RoundedRectangle(cornerRadius: 10)\n                    .stroke(Color.blue, lineWidth: 2)\n            )\n            .background(Color.white)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\nextension View {\n    func blueBorderedStyle() -> some View {\n        self.modifier(BlueBorderedCard())\n    }\n}"}
{"instruction": "Demonstrate how to use Core Animation (CALayer) in Swift to animate a view's opacity from 0 to 1 over 2 seconds.", "output": "import UIKit\n\nfunc fadeInView(view: UIView) {\n    let animation = CABasicAnimation(keyPath: \"opacity\")\n    animation.fromValue = 0.0\n    animation.toValue = 1.0\n    animation.duration = 2.0\n    \n    // Keep the state after animation finishes\n    animation.fillMode = .forwards\n    animation.isRemovedOnCompletion = false\n    \n    view.layer.add(animation, forKey: \"fadeIn\")\n}"}
{"instruction": "Write an Objective-C method to initialize a UITableView programmatically and register a standard cell class.", "output": "- (void)setupTableView {\n    self.tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain];\n    \n    // Register a standard UITableViewCell\n    [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"CellIdentifier\"];\n    \n    self.tableView.dataSource = self;\n    self.tableView.delegate = self;\n    \n    [self.view addSubview:self.tableView];\n}"}
{"instruction": "Using Combine, create a pipeline that fetches a JSON from a URL, decodes it into a struct, and handles errors by replacing them with a default value.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUserPublisher(url: URL) -> AnyPublisher<User, Never> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .replaceError(with: User(id: 0, name: \"Unknown\")) // Error handling\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write a Swift function using Core Location to request 'When In Use' authorization.", "output": "import CoreLocation\n\nclass LocationHandler: NSObject, CLLocationManagerDelegate {\n    let locationManager = CLLocationManager()\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n\n    func requestPermission() {\n        // Check current authorization status\n        let status = locationManager.authorizationStatus\n        \n        if status == .notDetermined {\n            locationManager.requestWhenInUseAuthorization()\n        }\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Permission granted.\")\n        case .denied, .restricted:\n            print(\"Permission denied.\")\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        DispatchQueue.global().async { [weak self] in\n            // Guard against self being nil\n            guard let self = self else { return }\n            \n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Create a basic Core Data stack in Swift by initializing a persistent container named 'AppModel' and loading its stores.", "output": "import CoreData\n\nclass CoreDataStack {\n    static let shared = CoreDataStack()\n\n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"AppModel\")\n        container.loadPersistentStores { (storeDescription, error) in\n            if let error = error as NSError? {\n                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n            }\n        }\n        return container\n    }()\n\n    var context: NSManagedObjectContext {\n        return persistentContainer.viewContext\n    }\n}"}
{"instruction": "Using the Combine framework, create a function that takes a URL and returns an AnyPublisher<Data, URLError>.", "output": "import Combine\nimport Foundation\n\nfunc fetchData(from url: URL) -> AnyPublisher<Data, URLError> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C property declaration for a delegate to ensure memory safety (avoiding retain cycles).", "output": "@protocol MyCustomDelegate <NSObject>\n- (void)didCompleteTask;\n@end\n\n@interface MyClass : NSObject\n\n// Use 'weak' to prevent a strong reference cycle with the delegate\n@property (nonatomic, weak) id<MyCustomDelegate> delegate;\n\n@end"}
{"instruction": "Implement a SwiftUI view that uses @FetchRequest to retrieve 'Task' entities sorted by 'dueDate' from Core Data.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Task.dueDate, ascending: true)],\n        animation: .default)\n    private var tasks: FetchedResults<Task>\n\n    var body: some View {\n        List {\n            ForEach(tasks) { task in\n                Text(task.title ?? \"Untitled\")\n            }\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline that observes a text field input, debounces it for 500ms, removes duplicates, and performs a search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Programmatically create a generic UIView subclass in UIKit that centers a UILabel using Auto Layout anchors.", "output": "import UIKit\n\nclass CenteredLabelView: UIView {\n    let label = UILabel()\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    private func setupView() {\n        addSubview(label)\n        label.translatesAutoresizingMaskIntoConstraints = false\n        \n        NSLayoutConstraint.activate([\n            label.centerXAnchor.constraint(equalTo: centerXAnchor),\n            label.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Demonstrate how to safely save a Core Data context only if changes exist.", "output": "import CoreData\n\nfunc saveContext(context: NSManagedObjectContext) {\n    if context.hasChanges {\n        do {\n            try context.save()\n        } catch {\n            let nserror = error as NSError\n            print(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n        }\n    }\n}"}
{"instruction": "Using the native CryptoKit framework, generate a SHA256 hash of a String.", "output": "import CryptoKit\nimport Foundation\n\nfunc hashString(_ input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    return digest.map { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Implement a 'User' struct that conforms to Codable and Identifiable, tailored for JSON parsing.", "output": "import Foundation\n\nstruct User: Codable, Identifiable {\n    let id: Int\n    let username: String\n    let email: String\n    let isActive: Bool\n\n    // Custom mapping if JSON keys differ from property names\n    enum CodingKeys: String, CodingKey {\n        case id\n        case username = \"user_name\"\n        case email\n        case isActive = \"is_active\"\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet where a closure captures 'self'.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        onDataFetched = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Updated Data\"\n            print(self.data)\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to fetch all 'Employee' entities where the 'department' attribute equals 'Engineering', sorted by 'hireDate' in descending order.", "output": "func fetchEngineers(context: NSManagedObjectContext) -> [Employee] {\n    let fetchRequest: NSFetchRequest<Employee> = Employee.fetchRequest()\n    \n    // Filter by department\n    fetchRequest.predicate = NSPredicate(format: \"department == %@\", \"Engineering\")\n    \n    // Sort by hireDate descending\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"hireDate\", ascending: false)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Failed to fetch employees: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that observes text changes from a UITextField, debounces the input for 500 milliseconds, removes duplicates, and prints the result.", "output": "import UIKit\nimport Combine\n\nclass SearchViewController: UIViewController {\n    @IBOutlet weak var searchTextField: UITextField!\n    var subscriptions = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: searchTextField)\n            .map { ($0.object as! UITextField).text ?? \"\" }\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { searchText in\n                print(\"Search query: \\(searchText)\")\n            }\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "Create an Objective-C property declaration for a delegate to ensure memory safety and prevent retain cycles.", "output": "@protocol NetworkManagerDelegate <NSObject>\n- (void)didFinishLoadingData;\n@end\n\n@interface NetworkManager : NSObject\n\n// Use 'weak' to prevent a retain cycle between the manager and its delegate\n@property (nonatomic, weak) id<NetworkManagerDelegate> delegate;\n\n@end"}
{"instruction": "Create a generic networking function in Swift using Combine's 'dataTaskPublisher' to fetch and decode a JSON object.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a SwiftUI View that uses '@StateObject' to manage the lifecycle of a ViewModel and displays a list of items.", "output": "import SwiftUI\n\nclass ListViewModel: ObservableObject {\n    @Published var items: [String] = [\"Apple\", \"Banana\", \"Cherry\"]\n}\n\nstruct FruitListView: View {\n    // @StateObject ensures the ViewModel is only initialized once\n    @StateObject private var viewModel = ListViewModel()\n\n    var body: some View {\n        List(viewModel.items, id: \\.self) { item in\n            Text(item)\n        }\n    }\n}"}
{"instruction": "Write a Swift function using the 'LocalAuthentication' framework to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself to access secure data.\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        completion(false, error)\n    }\n}"}
{"instruction": "Create a thread-safe counter in Swift using the 'actor' keyword to handle concurrency.", "output": "actor SafeCounter {\n    private var value = 0\n\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage example:\n// Task {\n//     let counter = SafeCounter()\n//     let newValue = await counter.increment()\n// }"}
{"instruction": "Implement the 'cellForRowAtIndexPath' method in Objective-C for a simple UITableView displaying a list of strings.", "output": "- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    static NSString *cellIdentifier = @\"CellID\";\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];\n    \n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];\n    }\n    \n    cell.textLabel.text = [self.dataArray objectAtIndex:indexPath.row];\n    return cell;\n}"}
{"instruction": "Create a custom UIView subclass in Swift that draws a red circle in the center of the view using Core Graphics inside 'draw(_:)'.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2 - 10\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.addArc(center: center, radius: radius, startAngle: 0, endAngle: 2 * .pi, clockwise: true)\n        context.fillPath()\n    }\n}"}
{"instruction": "Write a Swift function inside a ViewModel class that fetches data asynchronously. Ensure you prevent a strong reference cycle (retain cycle) by using a capture list in the closure.", "output": "import Foundation\n\nclass UserViewModel {\n    var userData: String = \"\"\n    let service = APIService()\n\n    func fetchUser() {\n        service.getData { [weak self] result in\n            // Use a guard to safely unwrap self\n            guard let self = self else { return }\n            \n            switch result {\n            case .success(let data):\n                self.userData = data\n                print(\"User data updated: \\(self.userData)\")\n            case .failure(let error):\n                print(\"Error: \\(error)\")\n            }\n        }\n    }\n}\n\n// Mock Service for context\nclass APIService {\n    func getData(completion: @escaping (Result<String, Error>) -> Void) {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n            completion(.success(\"John Doe\"))\n        }\n    }\n}"}
{"instruction": "Create a Core Data function in Swift using `NSPersistentContainer` to perform a large batch insert of 'Log' entities on a background context to avoid blocking the main UI thread.", "output": "import CoreData\n\nfunc saveLogsInBackground(logs: [String], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // 'context' is a private queue context distinct from the main thread\n        \n        for message in logs {\n            let logEntity = NSEntityDescription.insertNewObject(forEntityName: \"Log\", into: context)\n            logEntity.setValue(message, forKey: \"message\")\n            logEntity.setValue(Date(), forKey: \"timestamp\")\n        }\n        \n        do {\n            try context.save()\n            print(\"Background save successful\")\n        } catch {\n            print(\"Background save failed: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework in Swift, create a pipeline that observes a text publisher (e.g., a search bar), debounces the input for 500 milliseconds, removes duplicates, and maps the result to a URL request.", "output": "import Combine\nimport Foundation\n\nclass SearchManager {\n    var subscriptions = Set<AnyCancellable>()\n    \n    func setupSearchSubscription(searchTextPublisher: AnyPublisher<String, Never>) {\n        searchTextPublisher\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .compactMap { query -> URL? in\n                guard !query.isEmpty else { return nil }\n                return URL(string: \"https://api.example.com/search?q=\\(query)\")\n            }\n            .sink { url in\n                print(\"Ready to fetch: \\(url)\")\n                // Trigger network request here\n            }\n            .store(in: &subscriptions)\n    }\n}"}
{"instruction": "Write an Objective-C code snippet that processes a large loop of temporary image objects. Use `@autoreleasepool` to ensure memory is released during each iteration to prevent high peak memory usage.", "output": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\nvoid processImages(NSArray<NSString *> *imagePaths) {\n    for (NSString *path in imagePaths) {\n        @autoreleasepool {\n            // Load image - autoreleased object\n            UIImage *image = [UIImage imageWithContentsOfFile:path];\n            \n            if (image) {\n                // Perform heavy processing\n                NSData *pngData = UIImagePNGRepresentation(image);\n                [pngData writeToFile:[path stringByAppendingString:@\".bak\"] atomically:YES];\n            }\n            \n            // The image and pngData are released here, keeping memory footprint low\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses `StateObject` to manage the lifecycle of a `TimerModel`. The timer should start when the view appears and stop when it disappears.", "output": "import SwiftUI\nimport Combine\n\nclass TimerModel: ObservableObject {\n    @Published var counter = 0\n    var timer: AnyCancellable?\n\n    func start() {\n        timer = Timer.publish(every: 1.0, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak self] _ in\n                self?.counter += 1\n            }\n    }\n\n    func stop() {\n        timer?.cancel()\n    }\n}\n\nstruct TimerView: View {\n    // StateObject ensures the model persists even if the View struct is recreated\n    @StateObject private var model = TimerModel()\n\n    var body: some View {\n        Text(\"Counter: \\(model.counter)\")\n            .font(.largeTitle)\n            .onAppear {\n                model.start()\n            }\n            .onDisappear {\n                model.stop()\n            }\n    }\n}"}
{"instruction": "Write a Swift function using `BGTaskScheduler` (Background Tasks framework) to register and handle a background processing task.", "output": "import BackgroundTasks\n\nfunc registerBackgroundTask() {\n    let taskId = \"com.example.app.refresh\"\n    \n    BGTaskScheduler.shared.register(forTaskWithIdentifier: taskId, using: nil) { task in\n        guard let processingTask = task as? BGProcessingTask else { return }\n        handleProcessingTask(processingTask)\n    }\n}\n\nfunc handleProcessingTask(_ task: BGProcessingTask) {\n    // Schedule the next task\n    scheduleNextTask()\n    \n    // Handle expiration (system kills the task)\n    task.expirationHandler = {\n        // Cancel operations/cleanup\n    }\n    \n    // Perform work (simulated)\n    let queue = OperationQueue()\n    let operation = BlockOperation {\n        // Heavy lifting here\n        Thread.sleep(forTimeInterval: 2)\n    }\n    \n    operation.completionBlock = {\n        task.setTaskCompleted(success: !operation.isCancelled)\n    }\n    \n    queue.addOperation(operation)\n}\n\nfunc scheduleNextTask() {\n    let request = BGProcessingTaskRequest(identifier: \"com.example.app.refresh\")\n    request.requiresNetworkConnectivity = true\n    try? BGTaskScheduler.shared.submit(request)\n}"}
{"instruction": "Implement a `NSManagedObject` subclass in Swift. Override `awakeFromInsert` to populate a default creation date and a unique UUID when the object is first created.", "output": "import CoreData\n\n@objc(Item)\npublic class Item: NSManagedObject {\n    @NSManaged public var id: UUID?\n    @NSManaged public var createdAt: Date?\n    @NSManaged public var name: String?\n\n    public override func awakeFromInsert() {\n        super.awakeFromInsert()\n        \n        // Set primitive values to avoid triggering KVO notifications during initialization\n        setPrimitiveValue(Date(), forKey: \"createdAt\")\n        setPrimitiveValue(UUID(), forKey: \"id\")\n    }\n}"}
{"instruction": "Demonstrate how to manually allocate, initialize, and deallocate memory using `UnsafeMutablePointer` in Swift, ensuring no memory leaks.", "output": "func unsafeMemoryManipulation() {\n    let count = 5\n    // 1. Allocate memory for 5 Integers\n    let pointer = UnsafeMutablePointer<Int>.allocate(capacity: count)\n    \n    // 2. Initialize memory\n    pointer.initialize(repeating: 0, count: count)\n    \n    // 3. Use memory\n    for i in 0..<count {\n        pointer[i] = i * 10\n        print(\"Value at index \\(i): \\(pointer[i])\")\n    }\n    \n    // 4. Deinitialize memory (clean up values if they were objects)\n    pointer.deinitialize(count: count)\n    \n    // 5. Deallocate memory (free the block)\n    pointer.deallocate()\n}"}
{"instruction": "Write an Objective-C class that implements Key-Value Observing (KVO). Observe the `status` property of a `Job` object and update a label when it changes.", "output": "#import <UIKit/UIKit.h>\n\n@interface Job : NSObject\n@property (nonatomic, strong) NSString *status;\n@end\n@implementation Job\n@end\n\n@interface JobObserver : NSObject\n@property (nonatomic, strong) Job *job;\n@property (nonatomic, strong) UILabel *statusLabel;\n@end\n\n@implementation JobObserver\n\n- (instancetype)initWithJob:(Job *)job label:(UILabel *)label {\n    self = [super init];\n    if (self) {\n        _job = job;\n        _statusLabel = label;\n        // Register Observer\n        [_job addObserver:self \n               forKeyPath:@\"status\" \n                  options:NSKeyValueObservingOptionNew \n                  context:nil];\n    }\n    return self;\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath \n                      ofObject:(id)object \n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change \n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSString *newStatus = change[NSKeyValueChangeNewKey];\n        self.statusLabel.text = newStatus;\n        NSLog(@\"Status changed to: %@\", newStatus);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    // Remove Observer\n    [_job removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Use Core Image in Swift to apply a Sepia Tone filter to a `UIImage`. Ensure proper context creation to render the output image.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    // Create filter\n    guard let filter = CIFilter(name: \"CISepiaTone\") else { return nil }\n    filter.setValue(ciImage, forKey: kCIInputImageKey)\n    filter.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    // Get output image\n    guard let outputImage = filter.outputImage else { return nil }\n    \n    // Render using CIContext (reusing a context is better for performance in real apps)\n    let context = CIContext(options: nil)\n    \n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    \n    return nil\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a `ViewController` holds a reference to a `ViewModel`, and the `ViewModel` holds a closure that captures the `ViewController`.", "output": "class ViewModel {\n    var onDataUpdated: (() -> Void)?\n    func fetchData() {\n        // Simulate network call\n        onDataUpdated?()\n    }\n}\n\nclass ViewController: UIViewController {\n    let viewModel = ViewModel()\n    var titleLabel = UILabel()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // FIX: Use [weak self] to break the strong reference cycle\n        viewModel.onDataUpdated = { [weak self] in\n            guard let self = self else { return }\n            self.titleLabel.text = \"Data Updated\"\n        }\n        \n        viewModel.fetchData()\n    }\n}"}
{"instruction": "Write a function using Core Data in Swift to perform a large batch insertion of entities on a background context to avoid blocking the main thread.", "output": "func importUsers(userDicts: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // The context is automatically created for a background queue\n        for dict in userDicts {\n            let user = UserEntity(context: context)\n            user.id = dict[\"id\"] as? UUID\n            user.name = dict[\"name\"] as? String\n        }\n        \n        do {\n            try context.save()\n            print(\"Background import successful\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a function that fetches JSON data from a URL, decodes it into a `User` model, and returns an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data } // Extract data from (data, response)\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main) // Ensure delivery on main thread\n        .eraseToAnyPublisher()\n}"}
{"instruction": "In Objective-C, demonstrate how to use `@autoreleasepool` to optimize memory usage within a loop that creates a large number of temporary objects.", "output": "- (void)processLargeDataSet {\n    for (int i = 0; i < 1000000; i++) {\n        @autoreleasepool {\n            // Creates a temporary object that would normally wait until the run loop spins to drain\n            NSString *tempString = [NSString stringWithFormat:@\"Processing item %d\", i];\n            NSArray *tempArray = @[tempString, tempString, tempString];\n            \n            // Without the autoreleasepool, memory would spike significantly here\n            NSLog(@\"Length: %lu\", (unsigned long)tempArray.count);\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI `ObservableObject` that uses Combine to implement a debounce mechanism for a search bar, updating a `searchResults` array only after the user stops typing for 500ms.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var query: String = \"\"\n    @Published var searchResults: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $query\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] searchText in\n                self?.performSearch(with: searchText)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(with text: String) {\n        guard !text.isEmpty else {\n            searchResults = []\n            return\n        }\n        // Simulate search\n        searchResults = [\"Result for \\(text)\"]\n    }\n}"}
{"instruction": "Write a Swift function using `AVFoundation` to configure an `AVCaptureSession` with the back camera as the input device.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.beginConfiguration()\n    session.sessionPreset = .high\n    \n    // Get the back video camera\n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else { return nil }\n    \n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        session.commitConfiguration()\n        return session\n    } catch {\n        print(\"Error setting up camera input: \\(error)\")\n        return nil\n    }\n}"}
{"instruction": "Implement a `CLLocationManagerDelegate` in Swift to request 'When In Use' authorization and handle the authorization status change.", "output": "import CoreLocation\nimport UIKit\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location Access Granted\")\n            locationManager.startUpdatingLocation()\n        case .denied, .restricted:\n            print(\"Location Access Denied\")\n        case .notDetermined:\n            print(\"Asking for permission...\")\n        @unknown default:\n            break\n        }\n    }\n}"}
{"instruction": "Using Objective-C and the Runtime API, write a method to Swizzle `viewWillAppear:` of `UIViewController` to log a message every time a view appears.", "output": "#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n        \n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(log_viewWillAppear:);\n        \n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        \n        BOOL didAddMethod = class_addMethod(class,\n                                            originalSelector,\n                                            method_getImplementation(swizzledMethod),\n                                            method_getTypeEncoding(swizzledMethod));\n        \n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)log_viewWillAppear:(BOOL)animated {\n    [self log_viewWillAppear:animated]; // Call original implementation\n    NSLog(@\"View Controller Appeared: %@\", self);\n}\n\n@end"}
{"instruction": "Write a Swift function using `CryptoKit` to generate a SHA256 hash string from a given input string.", "output": "import CryptoKit\nimport Foundation\n\nfunc generateSHA256(from input: String) -> String? {\n    guard let data = input.data(using: .utf8) else { return nil }\n    let digest = SHA256.hash(data: data)\n    \n    // Convert digest to hex string\n    return digest.compactMap { String(format: \"%02x\", $0) }.joined()\n}"}
{"instruction": "Demonstrate how to use `NSCache` in Swift to cache `UIImage` objects, implementing the `NSCacheDelegate` to handle object eviction.", "output": "import UIKit\n\nclass ImageCache: NSObject, NSCacheDelegate {\n    static let shared = ImageCache()\n    private let cache = NSCache<NSString, UIImage>()\n    \n    override init() {\n        super.init()\n        cache.delegate = self\n        cache.countLimit = 100 // Max 100 images\n        cache.totalCostLimit = 1024 * 1024 * 50 // Max 50MB\n    }\n    \n    func getImage(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n    \n    func save(image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n    \n    // NSCacheDelegate method\n    func cache(_ cache: NSCache<AnyObject, AnyObject>, willEvictObject obj: Any) {\n        print(\"Evicting object from cache to free memory.\")\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onComplete: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1) { [weak self] in\n            // Fix: Use [weak self] to break the retain cycle\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            self.onComplete?()\n        }\n    }\n}"}
{"instruction": "Write a Swift function using Core Data's `NSPersistentContainer` to perform a bulk import of data on a background context to avoid blocking the main thread.", "output": "func importUsers(data: [UserJSON], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // 'context' is created specifically for this background block\n        for item in data {\n            let user = UserEntity(context: context)\n            user.id = item.id\n            user.name = item.name\n        }\n\n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that listens to a text publisher (like a search bar), debounces the input for 500ms, removes duplicates, and prints the result.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Search query: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a thread-safe counter in Swift using the `actor` keyword to prevent data races.", "output": "actor SafeCounter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage:\n// let counter = SafeCounter()\n// Task {\n//     await counter.increment()\n//     print(await counter.getValue())\n// }"}
{"instruction": "Write an Objective-C code snippet that uses `@autoreleasepool` inside a tight loop to keep memory footprint low when creating temporary objects.", "output": "for (int i = 0; i < 100000; i++) {\n    @autoreleasepool {\n        // Temporary objects created here are released at the end of each iteration\n        NSString *tempString = [NSString stringWithFormat:@\"Iteration %d\", i];\n        NSData *data = [tempString dataUsingEncoding:NSUTF8StringEncoding];\n        // Process data...\n    }\n}"}
{"instruction": "Configure a `UICollectionViewDiffableDataSource` in UIKit for a simple list of strings.", "output": "var dataSource: UICollectionViewDiffableDataSource<Int, String>!\n\nfunc configureDataSource(collectionView: UICollectionView) {\n    dataSource = UICollectionViewDiffableDataSource<Int, String>(collectionView: collectionView) { (collectionView, indexPath, itemIdentifier) -> UICollectionViewCell? in\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)\n        cell.contentConfiguration = UIListContentConfiguration.cell().updated(for: state)\n        var content = cell.defaultContentConfiguration()\n        content.text = itemIdentifier\n        cell.contentConfiguration = content\n        return cell\n    }\n}\n\nfunc applySnapshot(items: [String]) {\n    var snapshot = NSDiffableDataSourceSnapshot<Int, String>()\n    snapshot.appendSections([0])\n    snapshot.appendItems(items)\n    dataSource.apply(snapshot, animatingDifferences: true)\n}"}
{"instruction": "Using Core Image in Swift, apply a Sepia Tone filter to a `UIImage`.", "output": "import CoreImage\nimport UIKit\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext()\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Create a SwiftUI View that observes an external `ObservableObject` passed via dependency injection using `@StateObject` in the parent and `@ObservedObject` (or `@EnvironmentObject`) in the child, ensuring the object's lifecycle is tied to the owner.", "output": "import SwiftUI\n\nclass UserSettings: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct ParentView: View {\n    // StateObject owns the data source\n    @StateObject var settings = UserSettings()\n\n    var body: some View {\n        ChildView(settings: settings)\n    }\n}\n\nstruct ChildView: View {\n    // ObservedObject watches the data source but does not own it\n    @ObservedObject var settings: UserSettings\n\n    var body: some View {\n        Text(\"Hello, \\(settings.username)\")\n    }\n}"}
{"instruction": "Write a Combine function that fetches JSON data from a URL, decodes it into a struct, and handles errors using `mapError` and `catch`.", "output": "import Combine\nimport Foundation\n\nstruct Post: Decodable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPost() -> AnyPublisher<Post, Error> {\n    let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: Post.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write a Swift function using `FileManager` to save a text string to a file named 'log.txt' in the App's Documents directory.", "output": "func saveLog(message: String) {\n    let fileManager = FileManager.default\n    do {\n        let documentsURL = try fileManager.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false)\n        let fileURL = documentsURL.appendingPathComponent(\"log.txt\")\n        \n        try message.write(to: fileURL, atomically: true, encoding: .utf8)\n        print(\"Log saved to \\(fileURL.path)\")\n    } catch {\n        print(\"Error saving file: \\(error)\")\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    func fetchData() {\n        // Simulate network call\n        DispatchQueue.global().async { [weak self] in // Fix: Capture self weakly\n            guard let self = self else { return }\n            self.data = [\"Item 1\", \"Item 2\"]\n            \n            DispatchQueue.main.async {\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Write a Core Data fetch request in Swift to retrieve 'User' entities where the 'age' attribute is greater than 21, sorted by 'lastName' in ascending order.", "output": "func fetchAdultUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Predicate\n    fetchRequest.predicate = NSPredicate(format: \"age > %d\", 21)\n    \n    // Sort Descriptor\n    fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Using Combine, create a pipeline that listens to a text publisher (e.g., a search bar), debounces the input for 500 milliseconds, removes duplicates, and sinks the value.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { query in\n                print(\"Perform search for: \\(query)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement a 'weak' delegate pattern in Objective-C to prevent memory leaks between a view and its controller.", "output": "// MyCustomView.h\n@protocol MyCustomViewDelegate <NSObject>\n- (void)didTapButton;\n@end\n\n@interface MyCustomView : UIView\n// Use 'weak' property attribute for delegates\n@property (nonatomic, weak) id<MyCustomViewDelegate> delegate;\n@end\n\n// MyCustomView.m\n@implementation MyCustomView\n- (void)buttonAction {\n    if ([self.delegate respondsToSelector:@selector(didTapButton)]) {\n        [self.delegate didTapButton];\n    }\n}\n@end"}
{"instruction": "Create a thread-safe counter in Swift using the 'actor' keyword to prevent data races.", "output": "actor SafeCounter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func getValue() -> Int {\n        return value\n    }\n}\n\n// Usage\nlet counter = SafeCounter()\nTask {\n    await counter.increment()\n    let currentValue = await counter.getValue()\n    print(currentValue)\n}"}
{"instruction": "Using the Vision framework in Swift, set up a request to recognize text in a CGImage.", "output": "import Vision\n\nfunc recognizeText(in image: CGImage) {\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized Text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Perform a batch update in Core Data to set the 'isRead' property to true for all 'Message' entities without loading the objects into memory.", "output": "func markAllMessagesAsRead(context: NSManagedObjectContext) throws {\n    let batchUpdate = NSBatchUpdateRequest(entityName: \"Message\")\n    batchUpdate.propertiesToUpdate = [\"isRead\": true]\n    batchUpdate.resultType = .updatedObjectIDsResultType\n    \n    let result = try context.execute(batchUpdate) as? NSBatchUpdateResult\n    \n    if let objectIDs = result?.result as? [NSManagedObjectID] {\n        let changes = [NSUpdatedObjectsKey: objectIDs]\n        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [context])\n    }\n}"}
{"instruction": "Center a view programmatically using NSLayoutAnchor in Objective-C.", "output": "UIView *childView = [[UIView alloc] init];\nchildView.backgroundColor = [UIColor redColor];\nchildView.translatesAutoresizingMaskIntoConstraints = NO;\n[self.view addSubview:childView];\n\n[NSLayoutConstraint activateConstraints:@[\n    [childView.widthAnchor constraintEqualToConstant:100],\n    [childView.heightAnchor constraintEqualToConstant:100],\n    [childView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],\n    [childView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor]\n]];"}
{"instruction": "Use Combine to fetch JSON data from a URL, decode it into a struct, and handle errors on the main thread.", "output": "struct Post: Decodable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPost() -> AnyPublisher<Post, Error> {\n    let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map(\\.data)\n        .decode(type: Post.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' in an Objective-C block to safely access 'self' asynchronously.", "output": "__weak typeof(self) weakSelf = self;\n[self.dataLoader loadDataWithCompletion:^(NSArray *results) {\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (!strongSelf) {\n        return;\n    }\n    \n    // Safe to use strongSelf here; it ensures self is kept alive \n    // for the duration of this scope, but doesn't cause a retain cycle.\n    [strongSelf updateUIWithResults:results];\n}];"}
{"instruction": "Write a Swift function within a `UIViewController` that sets up a timer. Ensure you prevent a strong reference cycle (retain cycle) between the timer and the view controller using closure capture lists.", "output": "class TimerViewController: UIViewController {\n    var timer: Timer?\n    var counter = 0\n\n    func startTimer() {\n        // Use [weak self] to break the retain cycle\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            guard let self = self else { return }\n            self.counter += 1\n            print(\"Counter: \\(self.counter)\")\n        }\n    }\n\n    deinit {\n        timer?.invalidate()\n        print(\"TimerViewController deallocated\")\n    }\n}"}
{"instruction": "Create a Core Data stack helper method in Swift that saves the background context only if there are changes, handling potential errors.", "output": "import CoreData\n\nextension NSManagedObjectContext {\n    func saveIfNeeded() {\n        guard self.hasChanges else { return }\n        \n        self.perform {\n            do {\n                try self.save()\n            } catch {\n                let nsError = error as NSError\n                print(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n                // Handle error appropriately (e.g., rollback or alert)\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that takes a user's search query string, debounces it for 500ms, removes duplicates, and ensures the results are received on the main thread.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchQuery: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        $searchQuery\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &subscriptions)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Write an Objective-C method that processes a large array of images. Use `@autoreleasepool` inside the loop to ensure temporary memory used by intermediate image processing is released immediately after each iteration.", "output": "- (void)processImages:(NSArray<UIImage *> *)images {\n    for (UIImage *image in images) {\n        @autoreleasepool {\n            // Simulate heavy image processing creating temporary objects\n            NSData *imageData = UIImagePNGRepresentation(image);\n            UIImage *processedImage = [UIImage imageWithData:imageData];\n            NSLog(@\"Processed image size: %lu\", (unsigned long)imageData.length);\n            // Without this pool, auto-released objects accumulate until the run loop ends\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that uses an `actor` to safely manage a counter variable across concurrent tasks, demonstrating Swift 5.5+ concurrency memory safety.", "output": "import SwiftUI\n\nactor SafeCounter {\n    private var value = 0\n    \n    func increment() -> Int {\n        value += 1\n        return value\n    }\n}\n\nstruct CounterView: View {\n    let counter = SafeCounter()\n    @State private var currentCount = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(currentCount)\")\n            Button(\"Increment Safely\") {\n                Task {\n                    let newValue = await counter.increment()\n                    await MainActor.run {\n                        currentCount = newValue\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Implement a function using `CoreImage` to apply a Sepia Tone filter to a given `UIImage`.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let context = CIContext(options: nil)\n    guard let filter = CIFilter(name: \"CISepiaTone\") else { return nil }\n    \n    filter.setValue(ciImage, forKey: kCIInputImageKey)\n    filter.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    if let outputImage = filter.outputImage,\n       let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Create a custom `UIView` subclass in Swift that draws a red circle using `CoreGraphics` within the `draw(_:)` method.", "output": "import UIKit\n\nclass RedCircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        \n        // Calculate circle rect to be centered\n        let diameter = min(rect.width, rect.height)\n        let circleRect = CGRect(x: (rect.width - diameter) / 2,\n                                y: (rect.height - diameter) / 2,\n                                width: diameter,\n                                height: diameter)\n        \n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Write a Swift function utilizing `URLSession` to download a file to a temporary location using `async/await` syntax.", "output": "import Foundation\n\nfunc downloadFile(from url: URL) async throws -> URL {\n    let (tempURL, response) = try await URLSession.shared.download(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw URLError(.badServerResponse)\n    }\n    \n    // Move file to a permanent location if needed, otherwise return temp URL\n    return tempURL\n}"}
{"instruction": "Create an Objective-C class interface and implementation that defines a block property (closure) and executes it. Ensure the block is copied to the heap to prevent scope issues.", "output": "// MyTaskHandler.h\n#import <Foundation/Foundation.h>\n\ntypedef void (^CompletionBlock)(BOOL success);\n\n@interface MyTaskHandler : NSObject\n@property (nonatomic, copy) CompletionBlock onComplete;\n- (void)performTask;\n@end\n\n// MyTaskHandler.m\n#import \"MyTaskHandler.h\"\n\n@implementation MyTaskHandler\n\n- (void)performTask {\n    // Simulate work\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(1);\n        if (self.onComplete) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                self.onComplete(YES);\n            });\n        }\n    });\n}\n@end"}
{"instruction": "Construct a Core Data `NSFetchRequest` in Swift that fetches `User` entities sorted by `creationDate` in descending order, limiting the result to the top 10.", "output": "import CoreData\n\nfunc fetchRecentUsers(context: NSManagedObjectContext) -> [User] {\n    let fetchRequest: NSFetchRequest<User> = User.fetchRequest()\n    \n    // Sort by creationDate descending\n    let sortDescriptor = NSSortDescriptor(key: \"creationDate\", ascending: false)\n    fetchRequest.sortDescriptors = [sortDescriptor]\n    \n    // Limit results\n    fetchRequest.fetchLimit = 10\n    \n    do {\n        return try context.fetch(fetchRequest)\n    } catch {\n        print(\"Fetch failed: \\(error)\")\n        return []\n    }\n}"}
{"instruction": "Prevent a strong reference cycle (memory leak) in a Swift closure when fetching data in a ViewModel class.", "output": "class UserViewModel {\n    var onDataUpdated: (() -> Void)?\n    let service = APIService()\n\n    func fetchData() {\n        // Use [weak self] to avoid retaining the ViewModel inside the closure\n        service.getData { [weak self] result in\n            guard let self = self else { return }\n            \n            switch result {\n            case .success(let data):\n                self.process(data)\n                self.onDataUpdated?()\n            case .failure(let error):\n                print(error)\n            }\n        }\n    }\n\n    private func process(_ data: Data) {\n        // Processing logic\n    }\n}"}
{"instruction": "Implement a thread-safe background save operation using Core Data's `performBackgroundTask` in Swift.", "output": "func saveNewUser(name: String, email: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = UserEntity(context: context)\n        user.name = name\n        user.email = email\n        user.id = UUID()\n\n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a search string, debounces the input, removes duplicates, and performs a search action.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    var subscriptions = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &subscriptions)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Create a `UIView` programmatically in Objective-C, add it to a view controller, and center it using Auto Layout constraints.", "output": "- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UIView *redBox = [[UIView alloc] init];\n    redBox.backgroundColor = [UIColor redColor];\n    redBox.translatesAutoresizingMaskIntoConstraints = NO;\n    [self.view addSubview:redBox];\n\n    [NSLayoutConstraint activateConstraints:@[\n        [redBox.widthAnchor constraintEqualToConstant:100],\n        [redBox.heightAnchor constraintEqualToConstant:100],\n        [redBox.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],\n        [redBox.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor]\n    ]];\n}"}
{"instruction": "Create a SwiftUI view that observes a `TimerManager` class conforming to `ObservableObject` to display a ticking timer.", "output": "import SwiftUI\n\nclass TimerManager: ObservableObject {\n    @Published var timeCount = 0\n    var timer: Timer?\n\n    func start() {\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in\n            self.timeCount += 1\n        }\n    }\n\n    func stop() {\n        timer?.invalidate()\n    }\n}\n\nstruct TimerView: View {\n    @StateObject var timerManager = TimerManager()\n\n    var body: some View {\n        VStack {\n            Text(\"Seconds: \\(timerManager.timeCount)\")\n                .font(.largeTitle)\n            \n            HStack {\n                Button(\"Start\") { timerManager.start() }\n                Button(\"Stop\") { timerManager.stop() }\n            }\n        }\n    }\n}"}
{"instruction": "Use `DispatchGroup` in Swift to synchronize two asynchronous network requests and execute code only after both have completed.", "output": "func fetchDashboardData() {\n    let group = DispatchGroup()\n    \n    // Task 1\n    group.enter()\n    apiService.fetchUserProfile { user in\n        print(\"User fetched\")\n        group.leave()\n    }\n\n    // Task 2\n    group.enter()\n    apiService.fetchNotifications { notifications in\n        print(\"Notifications fetched\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All dashboard data loaded. Update UI.\")\n    }\n}"}
{"instruction": "Demonstrate the 'Weak-Strong Dance' in Objective-C to avoid retain cycles inside a block.", "output": "__weak typeof(self) weakSelf = self;\n[self.dataLoader loadDataWithCompletion:^(NSData *data) {\n    // Convert weak reference to strong to ensure self stays alive during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf updateUIWithData:data];\n    } else {\n        // self was deallocated before the block executed\n    }\n}];"}
{"instruction": "Fetch JSON data from a URL, decode it into a struct, and handle errors using `URLSession` and Combine.", "output": "import Combine\nimport Foundation\n\nstruct Todo: Decodable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchTodo() -> AnyPublisher<Todo, Error> {\n    let url = URL(string: \"https://jsonplaceholder.typicode.com/todos/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: Todo.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Configure an `AVCaptureSession` in Swift to capture video input from the back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n\n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else { return nil }\n\n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n            return session\n        }\n    } catch {\n        print(\"Error setting up camera input: \\(error)\")\n    }\n    return nil\n}"}
{"instruction": "Use Core Motion in Swift to count steps using `CMPedometer`.", "output": "import CoreMotion\n\nclass StepCounter {\n    let pedometer = CMPedometer()\n\n    func startCountingSteps() {\n        guard CMPedometer.isStepCountingAvailable() else { return }\n        \n        pedometer.startUpdates(from: Date()) { data, error in\n            if let error = error {\n                print(\"Pedometer error: \\(error)\")\n                return\n            }\n            \n            if let numberOfSteps = data?.numberOfSteps {\n                print(\"Steps taken: \\(numberOfSteps)\")\n            }\n        }\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet where a closure captures 'self'.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        let task = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Fetched Data\"\n            self.onDataFetched?()\n        }\n        task()\n    }\n}"}
{"instruction": "Create a Swift function using Core Data to save a new 'TodoItem' entity with a 'title' attribute and a 'timestamp' attribute into the provided NSManagedObjectContext.", "output": "import CoreData\n\nfunc saveTodoItem(title: String, context: NSManagedObjectContext) {\n    context.perform {\n        let newItem = TodoItem(context: context)\n        newItem.title = title\n        newItem.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Saved successfully\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a function that takes a URL, fetches JSON data, decodes it into a generic 'Decodable' type, and returns an AnyPublisher.", "output": "import Combine\nimport Foundation\n\nfunc fetchData<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: T.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedManager;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a SwiftUI ViewModel that uses Combine to debounce a search text input by 500 milliseconds before triggering a search action.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] text in\n                self?.performSearch(query: text)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        // Search logic here\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Using UIKit and Auto Layout in Swift, programmatically add a red UIView (100x100) to the center of a parent view controller.", "output": "override func viewDidLoad() {\n    super.viewDidLoad()\n    \n    let redBox = UIView()\n    redBox.backgroundColor = .red\n    redBox.translatesAutoresizingMaskIntoConstraints = false\n    view.addSubview(redBox)\n    \n    NSLayoutConstraint.activate([\n        redBox.widthAnchor.constraint(equalToConstant: 100),\n        redBox.heightAnchor.constraint(equalToConstant: 100),\n        redBox.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n        redBox.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n    ])\n}"}
{"instruction": "Write an Objective-C property declaration for a completion block that takes a BOOL and an NSError, and show how to invoke it safely.", "output": "// Interface\n@property (nonatomic, copy) void (^completionHandler)(BOOL success, NSError *error);\n\n// Implementation invocation\n- (void)doWork {\n    // ... work done ...\n    if (self.completionHandler) {\n        self.completionHandler(YES, nil);\n    }\n}"}
{"instruction": "Use the LocalAuthentication framework in Swift to authenticate a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser() {\n    let context = LAContext()\n    var error: NSError?\n\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Identify yourself!\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                if success {\n                    print(\"Authentication success\")\n                } else {\n                    print(\"Authentication failed\")\n                }\n            }\n        }\n    } else {\n        print(\"Biometrics not available\")\n    }\n}"}
{"instruction": "Create a Core Data fetch request in Swift using 'NSFetchRequest' to retrieve all 'User' entities sorted by 'lastName' in ascending order.", "output": "import CoreData\n\nfunc fetchUsers() -> NSFetchRequest<User> {\n    let request: NSFetchRequest<User> = User.fetchRequest()\n    request.sortDescriptors = [NSSortDescriptor(key: \"lastName\", ascending: true)]\n    return request\n}"}
{"instruction": "Demonstrate how to use 'unowned' to prevent a retain cycle in Swift when the captured reference will never be nil during the closure's execution (e.g., a credit card owned by a customer).", "output": "class Customer {\n    let name: String\n    var card: CreditCard?\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass CreditCard {\n    let number: String\n    unowned let customer: Customer // 'unowned' because a card must have a customer\n    \n    init(number: String, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    \n    func printCustomer() {\n        print(\"Card owned by \\(customer.name)\")\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n    var status = \"Loading\"\n\n    func setupClosure() {\n        // Fixed: Added [weak self] to break the retain cycle\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            print(self.status)\n            self.updateUI()\n        }\n    }\n\n    func updateUI() {\n        // Update logic\n    }\n}"}
{"instruction": "Create a Swift function using Core Data that performs a background save for a new 'User' entity to avoid blocking the main thread.", "output": "func saveUser(name: String, email: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.email = email\n        \n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save user in background: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a pipeline that takes a search string publisher, debounces it for 500 milliseconds, removes duplicates, and filters out empty strings.", "output": "import Combine\nimport Foundation\n\nfunc setupSearchPipeline(searchPublisher: AnyPublisher<String, Never>) -> AnyCancellable {\n    return searchPublisher\n        .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n        .removeDuplicates()\n        .filter { !$0.isEmpty }\n        .sink { searchText in\n            print(\"Perform API search for: \\(searchText)\")\n        }\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "+ (instancetype)sharedInstance {\n    static MySingleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[MySingleton alloc] init];\n    });\n    return sharedInstance;\n}"}
{"instruction": "Create a SwiftUI ObservableObject that fetches data asynchronously and ensures the 'published' property is updated on the Main Actor to prevent thread warnings.", "output": "import SwiftUI\n\nclass DataViewModel: ObservableObject {\n    @Published var items: [String] = []\n\n    func fetchData() {\n        Task {\n            // Simulate network delay\n            try? await Task.sleep(nanoseconds: 1 * 1_000_000_000)\n            let newItems = [\"Item 1\", \"Item 2\", \"Item 3\"]\n            \n            await MainActor.run {\n                self.items = newItems\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using `withCheckedThrowingContinuation` to bridge an older closure-based API to modern Async/Await.", "output": "func fetchImage(url: URL, completion: @escaping (Result<UIImage, Error>) -> Void) {\n    // Legacy implementation\n}\n\nfunc fetchImageAsync(url: URL) async throws -> UIImage {\n    return try await withCheckedThrowingContinuation { continuation in\n        fetchImage(url: url) { result in\n            switch result {\n            case .success(let image):\n                continuation.resume(returning: image)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}"}
{"instruction": "Construct an NSFetchRequest in Swift to retrieve 'Order' entities from Core Data where the 'status' is 'pending', sorted by 'dateCreated' in descending order.", "output": "let fetchRequest: NSFetchRequest<Order> = Order.fetchRequest()\nfetchRequest.predicate = NSPredicate(format: \"status == %@\", \"pending\")\nfetchRequest.sortDescriptors = [NSSortDescriptor(key: \"dateCreated\", ascending: false)]\n\ndo {\n    let pendingOrders = try context.fetch(fetchRequest)\n} catch {\n    print(\"Fetch failed\")\n}"}
{"instruction": "Using UIKit and Combine, bind a UITextField's text changes to a publisher using NotificationCenter.", "output": "import UIKit\nimport Combine\n\nclass ViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .sink { text in\n                print(\"Text changed to: \\(text)\")\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Implement the `draw(_:)` method in a custom UIView subclass to draw a red circle centered in the view using Core Graphics.", "output": "override func draw(_ rect: CGRect) {\n    guard let context = UIGraphicsGetCurrentContext() else { return }\n    \n    context.setFillColor(UIColor.red.cgColor)\n    \n    // Calculate circle rect centered in view\n    let diameter = min(rect.width, rect.height) * 0.8\n    let x = (rect.width - diameter) / 2\n    let y = (rect.height - diameter) / 2\n    let circleRect = CGRect(x: x, y: y, width: diameter, height: diameter)\n    \n    context.fillEllipse(in: circleRect)\n}"}
{"instruction": "Register a background app refresh task using the BackgroundTasks framework in the AppDelegate.", "output": "import BackgroundTasks\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    BGTaskScheduler.shared.register(forTaskWithIdentifier: \"com.example.app.refresh\", using: nil) { task in\n        self.handleAppRefresh(task: task as! BGAppRefreshTask)\n    }\n    return true\n}\n\nfunc handleAppRefresh(task: BGAppRefreshTask) {\n    task.expirationHandler = {\n        // Cancel operations\n    }\n    \n    // Perform work\n    let queue = OperationQueue()\n    queue.maxConcurrentOperationCount = 1\n    \n    let operation = BlockOperation {\n        // Refresh logic here\n        task.setTaskCompleted(success: true)\n    }\n    \n    queue.addOperation(operation)\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet involving a closure.", "output": "// ORIGINAL CODE (Has Leak):\n/*\nclass DataFetcher {\n    var onData: (() -> Void)?\n    func start() {\n        onData = { \n            self.processData() // Strong capture of 'self'\n        }\n    }\n    func processData() { print(\"Processing\") }\n}\n*/\n\n// FIXED CODE:\nclass DataFetcher {\n    var onData: (() -> Void)?\n    \n    func start() {\n        // Use [weak self] to break the retain cycle\n        onData = { [weak self] in\n            guard let self = self else { return }\n            self.processData()\n        }\n    }\n    \n    func processData() {\n        print(\"Processing\")\n    }\n}"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to retrieve `ToDoItem` entities from Core Data, sorted by a `createdAt` timestamp in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TodoListView: View {\n    // The FetchRequest property wrapper automatically updates the view when data changes\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\ToDoItem.createdAt, ascending: false)],\n        animation: .default)\n    private var items: FetchedResults<ToDoItem>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    Text(item.title ?? \"Untitled\")\n                }\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n}"}
{"instruction": "Write a function using the Combine framework to fetch a User object from a URL, decode it, and return it as an `AnyPublisher`.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser(from url: URL) -> AnyPublisher<User, Error> {\n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data } // Extract data from (data, response) tuple\n        .decode(type: User.self, decoder: JSONDecoder()) // Decode JSON\n        .receive(on: DispatchQueue.main) // Ensure delivery on main thread\n        .eraseToAnyPublisher() // Type erasure\n}"}
{"instruction": "Implement a thread-safe Singleton pattern in Objective-C.", "output": "#import <Foundation/Foundation.h>\n\n@interface NetworkManager : NSObject\n+ (instancetype)sharedInstance;\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedInstance {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    // dispatch_once ensures the block is executed only once for the lifetime of the app\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    \n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Create a programmatic UIKit `UIView` subclass that centers a red square (100x100) within itself using Auto Layout anchors.", "output": "import UIKit\n\nclass RedBoxView: UIView {\n    \n    private let box = UIView()\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    private func setupView() {\n        backgroundColor = .white\n        box.backgroundColor = .red\n        box.translatesAutoresizingMaskIntoConstraints = false\n        addSubview(box)\n        \n        NSLayoutConstraint.activate([\n            box.widthAnchor.constraint(equalToConstant: 100),\n            box.heightAnchor.constraint(equalToConstant: 100),\n            box.centerXAnchor.constraint(equalTo: centerXAnchor),\n            box.centerYAnchor.constraint(equalTo: centerYAnchor)\n        ])\n    }\n}"}
{"instruction": "Using Swift Concurrency (Async/Await), convert a legacy callback-based function `fetchImage(completion:)` into an async throwing function.", "output": "import UIKit\n\n// Legacy function\nfunc fetchImage(completion: @escaping (Result<UIImage, Error>) -> Void) {\n    // Simulate network delay\n    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n        completion(.success(UIImage()))\n    }\n}\n\n// Modern Async Wrapper\nfunc fetchImageAsync() async throws -> UIImage {\n    return try await withCheckedThrowingContinuation { continuation in\n        fetchImage { result in\n            switch result {\n            case .success(let image):\n                continuation.resume(returning: image)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}"}
{"instruction": "Set up a basic `AVCaptureSession` in Swift to capture video input from the default back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n    \n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {\n        print(\"No back camera found\")\n        return nil\n    }\n    \n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n            return session\n        }\n    } catch {\n        print(\"Error setting up input: \\(error)\")\n    }\n    \n    return nil\n}"}
{"instruction": "Using Combine and UIKit, create a pipeline that observes text changes in a `UITextField`, debounces the input for 500ms, and updates a label.", "output": "import UIKit\nimport Combine\n\nclass SearchViewController: UIViewController {\n    let textField = UITextField()\n    let label = UILabel()\n    var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .map { ($0.object as? UITextField)?.text ?? \"\" }\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main) // Wait for pause in typing\n            .removeDuplicates() // Ignore if same value\n            .sink { [weak self] text in\n                self?.label.text = \"Searching for: \\(text)\"\n            }\n            .store(in: &cancellables)\n    }\n}"}
{"instruction": "Perform a Core Data save operation on a background context to avoid blocking the main UI thread.", "output": "import CoreData\n\nfunc saveInBackground(container: NSPersistentContainer) {\n    // Create a new background context\n    let backgroundContext = container.newBackgroundContext()\n    \n    // Perform block ensures code runs on the correct queue for this context\n    backgroundContext.perform {\n        let entity = NSEntityDescription.insertNewObject(forEntityName: \"LogEntry\", into: backgroundContext)\n        entity.setValue(Date(), forKey: \"timestamp\")\n        entity.setValue(\"Background Save\", forKey: \"message\")\n        \n        do {\n            try backgroundContext.save()\n            print(\"Saved successfully on background thread\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a class that requests 'When In Use' location permissions using `CLLocationManager`.", "output": "import CoreLocation\n\nclass LocationService: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n    }\n    \n    func requestPermission() {\n        // Check current authorization status\n        let status = locationManager.authorizationStatus\n        \n        if status == .notDetermined {\n            locationManager.requestWhenInUseAuthorization()\n        }\n    }\n    \n    // Delegate method to handle status changes\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        switch manager.authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location Access Granted\")\n        case .denied, .restricted:\n            print(\"Location Access Denied\")\n        default:\n            break\n        }\n    }\n}"}
{"instruction": "Identify and fix the memory leak (retain cycle) in the following Swift class where a lazy closure captures 'self' strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: [String] = []\n\n    lazy var startFetching: () -> Void = { [weak self] in // Fix: Add capture list\n        guard let self = self else { return }\n        // Simulating fetch\n        self.data = [\"Item 1\", \"Item 2\"]\n        self.onDataFetched?()\n    }\n}"}
{"instruction": "Write a Swift function using Core Data to safely create and save a new 'User' entity on a background context to avoid blocking the main thread.", "output": "func createUser(name: String, container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.id = UUID()\n\n        do {\n            try context.save()\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that observes a text search publisher, debounces the input for 500 milliseconds, removes duplicates, and filters out empty strings.", "output": "import Combine\n\nvar cancellables = Set<AnyCancellable>()\nlet searchTextPublisher = PassthroughSubject<String, Never>()\n\nsearchTextPublisher\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .removeDuplicates()\n    .filter { !$0.isEmpty }\n    .sink { text in\n        print(\"Searching for: \\(text)\")\n    }\n    .store(in: &cancellables)"}
{"instruction": "Using Objective-C and UIKit, programmatically center a red UIView (100x100) inside the main view controller's view using NSLayoutAnchor.", "output": "UIView *redView = [[UIView alloc] init];\nredView.backgroundColor = [UIColor redColor];\nredView.translatesAutoresizingMaskIntoConstraints = NO;\n[self.view addSubview:redView];\n\n[NSLayoutConstraint activateConstraints:@[\n    [redView.widthAnchor constraintEqualToConstant:100],\n    [redView.heightAnchor constraintEqualToConstant:100],\n    [redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],\n    [redView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor]\n]];"}
{"instruction": "Create a SwiftUI view that fetches a list of 'Task' entities using the @FetchRequest property wrapper, sorted by a 'createdAt' date in descending order.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @FetchRequest(\n        entity: Task.entity(),\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Task.createdAt, ascending: false)]\n    ) var tasks: FetchedResults<Task>\n\n    var body: some View {\n        List(tasks, id: \\.self) { task in\n            Text(task.title ?? \"Untitled\")\n        }\n    }\n}"}
{"instruction": "Implement the 'Weak-Strong Dance' pattern in an Objective-C block to safely access 'self' and prevent a retain cycle, while ensuring 'self' remains alive during the block's execution.", "output": "__weak typeof(self) weakSelf = self;\nself.completionBlock = ^{\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf updateUI];\n        [strongSelf logAnalytics];\n    }\n};"}
{"instruction": "Use the Vision framework in Swift to perform a text recognition request (OCR) on a UIImage.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage) {\n    guard let cgImage = image.cgImage else { return }\n\n    let request = VNRecognizeTextRequest { request, error in\n        guard let observations = request.results as? [VNRecognizedTextObservation] else { return }\n        for observation in observations {\n            guard let topCandidate = observation.topCandidates(1).first else { continue }\n            print(\"Recognized text: \\(topCandidate.string)\")\n        }\n    }\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Convert the following closure-based URLSession data task to Swift 5.5+ async/await syntax.", "output": "// Old: func fetch(url: URL, completion: @escaping (Data?, Error?) -> Void)\n\n// New Async/Await\nfunc fetchData(from url: URL) async throws -> Data {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          (200...299).contains(httpResponse.statusCode) else {\n        throw URLError(.badServerResponse)\n    }\n    return data\n}"}
{"instruction": "Demonstrate how to bind a UITextField's text property to a PassthroughSubject in a ViewModel using Combine and UIKit.", "output": "import UIKit\nimport Combine\n\nclass ViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    var viewModel = ViewModel()\n    var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        NotificationCenter.default\n            .publisher(for: UITextField.textDidChangeNotification, object: textField)\n            .compactMap { ($0.object as? UITextField)?.text }\n            .assign(to: \\.query, on: viewModel)\n            .store(in: &cancellables)\n    }\n}\n\nclass ViewModel {\n    var query: String = \"\"\n}"}
{"instruction": "Create a custom UIView subclass in Swift that draws a red circle using Core Graphics (Quartz 2D) within the draw(_:) method.", "output": "class CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        // Inset slightly to ensure the stroke isn't clipped if added later\n        let circleRect = rect.insetBy(dx: 5, dy: 5)\n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (retain cycle) in the following Swift closure within a ViewController class.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n}\n\nclass MyViewController: UIViewController {\n    let fetcher = DataFetcher()\n    var status = \"Loading\"\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // FIXED: Added [weak self] to break the retain cycle\n        fetcher.onDataFetched = { [weak self] in\n            // Safely unwrap self\n            guard let self = self else { return }\n            self.status = \"Finished\"\n            self.updateUI()\n        }\n    }\n\n    func updateUI() {\n        print(status)\n    }\n}"}
{"instruction": "Create a Combine pipeline in Swift that takes a search term from a UITextField's text publisher, debounces it for 500ms, removes duplicates, and performs a network search.", "output": "import Combine\nimport UIKit\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] term in\n                self?.performSearch(term)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(_ term: String) {\n        print(\"Searching API for: \\(term)\")\n    }\n}"}
{"instruction": "Implement a high-performance Core Data batch insert using `NSBatchInsertRequest` in Swift to insert 1000 records of an entity named 'LogEntry'.", "output": "import CoreData\n\nfunc batchInsertLogs(viewContext: NSManagedObjectContext) {\n    var index = 0\n    let total = 1000\n\n    // The batch insert request asks for a dictionary for each row\n    let batchInsert = NSBatchInsertRequest(entityName: \"LogEntry\", managedObjectHandler: { (managedObject: NSManagedObject) -> Bool in\n        guard index < total else { return true } // Done\n        \n        if let log = managedObject as? LogEntry {\n            log.timestamp = Date()\n            log.message = \"Log entry #\\(index)\"\n            log.id = UUID()\n        }\n        \n        index += 1\n        return false // Continue inserting\n    })\n\n    do {\n        try viewContext.execute(batchInsert)\n        print(\"Batch insert completed.\")\n    } catch {\n        print(\"Batch insert failed: \\(error)\")\n    }\n}"}
{"instruction": "Write an Objective-C method to implement a thread-safe Singleton pattern.", "output": "+ (instancetype)sharedInstance {\n    static MySingleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}"}
{"instruction": "Create a custom SwiftUI ViewModifier that adds a 'glassmorphism' effect (blur and semi-transparent background) to any view.", "output": "import SwiftUI\n\nstruct Glassmorphism: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .background(.ultraThinMaterial)\n            .cornerRadius(16)\n            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 5)\n            .overlay(\n                RoundedRectangle(cornerRadius: 16)\n                    .stroke(Color.white.opacity(0.2), lineWidth: 1)\n            )\n    }\n}\n\nextension View {\n    func glassEffect() -> some View {\n        self.modifier(Glassmorphism())\n    }\n}"}
{"instruction": "Use the Vision framework in Swift to detect rectangles in a given `CGImage`.", "output": "import Vision\n\nfunc detectRectangles(in image: CGImage) {\n    let request = VNDetectRectanglesRequest { (request, error) in\n        guard let results = request.results as? [VNRectangleObservation] else { return }\n        \n        for observation in results {\n            print(\"Detected rectangle at bounding box: \\(observation.boundingBox)\")\n        }\n    }\n    \n    // Configure request\n    request.minimumConfidence = 0.5\n    request.maximumObservations = 5\n\n    let handler = VNImageRequestHandler(cgImage: image, options: [:])\n    \n    do {\n        try handler.perform([request])\n    } catch {\n        print(\"Failed to perform Vision request: \\(error)\")\n    }\n}"}
{"instruction": "Implement a `UICollectionViewDiffableDataSource` setup in a UIViewController to manage a list of Users with sections.", "output": "import UIKit\n\nenum Section { case main }\nstruct User: Hashable { let id = UUID(); let name: String }\n\nclass UserListVC: UIViewController {\n    var collectionView: UICollectionView!\n    var dataSource: UICollectionViewDiffableDataSource<Section, User>!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n        applySnapshot()\n    }\n\n    func configureDataSource() {\n        let cellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, User> { cell, indexPath, user in\n            var content = cell.defaultContentConfiguration()\n            content.text = user.name\n            cell.contentConfiguration = content\n        }\n\n        dataSource = UICollectionViewDiffableDataSource<Section, User>(collectionView: collectionView) { (collectionView, indexPath, user) -> UICollectionViewCell? in\n            return collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: user)\n        }\n    }\n\n    func applySnapshot() {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, User>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems([User(name: \"Alice\"), User(name: \"Bob\")])\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
{"instruction": "Demonstrate how to use `NSPersistentContainer` to perform a background task in Core Data to avoid blocking the main thread.", "output": "func performBackgroundTask(container: NSPersistentContainer) {\n    container.performBackgroundTask { (backgroundContext) in\n        // Create a new object in the background context\n        let newEntity = MyEntity(context: backgroundContext)\n        newEntity.attribute = \"Background Data\"\n\n        do {\n            try backgroundContext.save()\n            print(\"Saved on background thread\")\n        } catch {\n            print(\"Error saving: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Use Swift's `UnsafeMutableRawPointer` to manually allocate memory for an integer, set its value, read it, and deallocate it.", "output": "func manualMemoryManagement() {\n    // 1. Allocate memory for one Int\n    let pointer = UnsafeMutableRawPointer.allocate(byteCount: MemoryLayout<Int>.size, alignment: MemoryLayout<Int>.alignment)\n    \n    // 2. Store value (bind memory to Int and store)\n    pointer.storeBytes(of: 42, as: Int.self)\n    \n    // 3. Load value\n    let value = pointer.load(as: Int.self)\n    print(\"Loaded value: \\(value)\")\n    \n    // 4. Deallocate\n    pointer.deallocate()\n}"}
{"instruction": "Create a custom `UIView` that draws a red circle with a black border using `draw(_:)` and Core Graphics.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let inset: CGFloat = 5.0\n        let rectToDraw = rect.insetBy(dx: inset, dy: inset)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.setStrokeColor(UIColor.black.cgColor)\n        context.setLineWidth(4.0)\n        \n        context.addEllipse(in: rectToDraw)\n        context.drawPath(using: .fillStroke)\n    }\n}"}
{"instruction": "Fix the retain cycle in the following Swift closure where a view controller captures itself strongly inside a timer block.", "output": "class MyViewController: UIViewController {\n    var timer: Timer?\n    var counter = 0\n\n    func startTimer() {\n        // Solution: Use [weak self] to break the strong reference cycle\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            guard let self = self else { return }\n            self.counter += 1\n            print(\"Counter: \\(self.counter)\")\n        }\n    }\n\n    deinit {\n        timer?.invalidate()\n        print(\"MyViewController deallocated\")\n    }\n}"}
{"instruction": "Create a Swift function using Core Data to perform a background save operation safely, ensuring changes are saved to the persistent container.", "output": "import CoreData\n\nfunc saveInBackground(container: NSPersistentContainer, name: String) {\n    container.performBackgroundTask { context in\n        let entity = MyEntity(context: context)\n        entity.name = name\n        entity.timestamp = Date()\n\n        do {\n            try context.save()\n            print(\"Saved successfully on background thread\")\n        } catch {\n            print(\"Failed to save: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, create a publisher pipeline that fetches data from a URL, decodes it into a struct, and publishes the result on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map(\\.data)\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Write an Objective-C code snippet to implement Key-Value Observing (KVO) on a property named 'status' of an object 'task'. Include the observer registration and the observation method.", "output": "// Register Observer\n[self.task addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew context:nil];\n\n// Handle Change\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSString *newStatus = change[NSKeyValueChangeNewKey];\n        NSLog(@\"Status changed to: %@\", newStatus);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n// Cleanup in dealloc\n- (void)dealloc {\n    [self.task removeObserver:self forKeyPath:@\"status\"];\n}"}
{"instruction": "In SwiftUI, demonstrate how to correctly instantiate a ViewModel that owns its data lifecycle using the appropriate property wrapper to prevent recreation during view updates.", "output": "import SwiftUI\n\nclass ProfileViewModel: ObservableObject {\n    @Published var username: String = \"Guest\"\n}\n\nstruct ProfileView: View {\n    // Solution: Use @StateObject for the source of truth when the View creates the instance.\n    // If we used @ObservedObject here, the model might reset when the parent view redraws.\n    @StateObject private var viewModel = ProfileViewModel()\n\n    var body: some View {\n        Text(\"Hello, \\(viewModel.username)\")\n    }\n}"}
{"instruction": "Use Grand Central Dispatch (GCD) and a DispatchGroup in Swift to wait for two asynchronous network calls to complete before executing a completion handler.", "output": "func syncMultipleAPICalls(completion: @escaping () -> Void) {\n    let group = DispatchGroup()\n\n    group.enter()\n    networkService.fetchProfile { _ in\n        print(\"Profile fetched\")\n        group.leave()\n    }\n\n    group.enter()\n    networkService.fetchFriends { _ in\n        print(\"Friends fetched\")\n        group.leave()\n    }\n\n    group.notify(queue: .main) {\n        print(\"All operations completed\")\n        completion()\n    }\n}"}
{"instruction": "Implement a text search handling pipeline using Combine in Swift that debounces input for 500ms and removes duplicates before triggering an API search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Write a Swift function using Core Image to apply a Sepia Tone filter to a UIImage.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext(options: nil)\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Demonstrate how to update a UITableView using UICollectionViewDiffableDataSource (or UITableViewDiffableDataSource) in Swift to animate changes.", "output": "enum Section { case main }\n\nfunc updateTableView(with items: [String], dataSource: UITableViewDiffableDataSource<Section, String>) {\n    var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(items)\n    \n    // animatingDifferences: true triggers the automatic row animations\n    dataSource.apply(snapshot, animatingDifferences: true)\n}"}
{"instruction": "Solve a high memory footprint issue in Objective-C caused by a loop creating temporary objects by using an autorelease pool.", "output": "for (int i = 0; i < 1000000; i++) {\n    @autoreleasepool {\n        // Objects created here are released at the end of each iteration\n        // preventing memory spikes during the loop execution.\n        NSString *tempString = [NSString stringWithFormat:@\"Index: %d\", i];\n        NSData *data = [tempString dataUsingEncoding:NSUTF8StringEncoding];\n        [self processData:data];\n    }\n}"}
{"instruction": "Write a Swift code snippet demonstrating how to prevent a strong reference cycle (retain cycle) when using a closure within a View Controller to update a property after an asynchronous network call.", "output": "class UserProfileViewController: UIViewController {\n    var viewModel = UserViewModel()\n    var usernameLabel = UILabel()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        fetchData()\n    }\n\n    func fetchData() {\n        // Capture 'self' weakly to prevent a retain cycle\n        viewModel.fetchUserData { [weak self] result in\n            // Guard to ensure self still exists and unwrap it safely\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                switch result {\n                case .success(let user):\n                    self.usernameLabel.text = user.name\n                case .failure(let error):\n                    print(\"Error: \\(error)\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view that safely instantiates a Core Data `NSManagedObjectContext` fetch request using `@FetchRequest`. The request should sort `Item` entities by `timestamp` in descending order and filter results where `isArchived` is false.", "output": "import SwiftUI\nimport CoreData\n\nstruct ActiveItemsView: View {\n    // The @FetchRequest property wrapper automatically handles fetching and updating the view\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: false)],\n        predicate: NSPredicate(format: \"isArchived == %@\", NSNumber(value: false)),\n        animation: .default)\n    private var items: FetchedResults<Item>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.name ?? \"Unknown\")\n            }\n        }\n    }\n}"}
{"instruction": "Using the Combine framework, write a function that performs a search based on user text input. The pipeline should debounce the input for 500ms, remove duplicate consecutive strings, and execute a network request on a background thread while updating the UI on the main thread.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .map { [weak self] query -> AnyPublisher<[String], Never> in\n                // Assume performSearch returns a publisher\n                return self?.performSearch(query: query) ?? Just([]).eraseToAnyPublisher()\n            }\n            .switchToLatest() // Switch to the most recent search request\n            .receive(on: RunLoop.main)\n            .assign(to: \\.results, on: self)\n            .store(in: &cancellables)\n    }\n\n    func performSearch(query: String) -> AnyPublisher<[String], Never> {\n        // Mock network call\n        return Just([\"Result for \\(query)\"])\n            .delay(for: .seconds(1), scheduler: DispatchQueue.global())\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Implement a background task in Core Data using `NSPersistentContainer` to perform a batch import of data. Ensure the operation happens on a background queue to avoid blocking the Main Thread and save the context only if changes exist.", "output": "func importDataInBackground(container: NSPersistentContainer, data: [String]) {\n    container.performBackgroundTask { context in\n        // 'context' here is a private queue context distinct from the main context\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        for name in data {\n            let entity = Item(context: context)\n            entity.name = name\n            entity.timestamp = Date()\n        }\n        \n        if context.hasChanges {\n            do {\n                try context.save()\n                print(\"Background save successful\")\n            } catch {\n                print(\"Background save failed: \\(error)\")\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C code snippet implementing Key-Value Observing (KVO). A view controller should observe the `progress` property of a `DownloadManager` instance and update a progress bar when the value changes. Include the observer removal in `dealloc`.", "output": "@interface DownloadViewController () \n@property (nonatomic, strong) DownloadManager *downloadManager;\n@property (nonatomic, strong) UIProgressView *progressBar;\n@end\n\n@implementation DownloadViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.downloadManager = [[DownloadManager alloc] init];\n    \n    // Register Observer\n    [self.downloadManager addObserver:self\n                           forKeyPath:@\"progress\"\n                              options:NSKeyValueObservingOptionNew\n                              context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"progress\"]) {\n        NSNumber *progressValue = change[NSKeyValueChangeNewKey];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            self.progressBar.progress = [progressValue floatValue];\n        });\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    [self.downloadManager removeObserver:self forKeyPath:@\"progress\"];\n}\n\n@end"}
{"instruction": "Demonstrate how to use `MetricKit` in Swift to subscribe to daily diagnostic payloads, specifically looking for app hang diagnostics to improve performance monitoring.", "output": "import MetricKit\n\nclass AppMetricsManager: NSObject, MXMetricManagerSubscriber {\n    static let shared = AppMetricsManager()\n    \n    private override init() {\n        super.init()\n        let metricManager = MXMetricManager.shared\n        metricManager.add(self)\n    }\n    \n    // Receive daily metrics\n    func didReceive(_ payloads: [MXMetricPayload]) {\n        for payload in payloads {\n            if let hangMetrics = payload.applicationResponsivenessMetrics {\n                print(\"Histogram of hang durations: \\(hangMetrics.histogrammedApplicationHangTime)\")\n            }\n        }\n    }\n    \n    // Receive diagnostic payloads (crashes, hangs, etc.)\n    func didReceive(_ payloads: [MXDiagnosticPayload]) {\n        for payload in payloads {\n            if let hangDiagnostics = payload.hangDiagnostics {\n                for diagnostic in hangDiagnostics {\n                    print(\"Hang detected: \\(diagnostic.callStackTree)\")\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Using `DispatchGroup` in Swift, write a function that downloads three images asynchronously and executes a completion handler only after all three downloads have finished.", "output": "func downloadImages(urls: [URL], completion: @escaping ([UIImage?]) -> Void) {\n    let group = DispatchGroup()\n    var images = [UIImage?](repeating: nil, count: urls.count)\n    \n    for (index, url) in urls.enumerated() {\n        group.enter()\n        URLSession.shared.dataTask(with: url) { data, _, _ in\n            defer { group.leave() }\n            if let data = data, let image = UIImage(data: data) {\n                images[index] = image\n            }\n        }.resume()\n    }\n    \n    group.notify(queue: .main) {\n        completion(images)\n    }\n}"}
{"instruction": "Create a SwiftUI `ImageLoader` class using `ObservableObject` that manages memory efficiently by checking a strict in-memory NSCache before attempting a network download.", "output": "import SwiftUI\nimport Combine\n\nclass ImageLoader: ObservableObject {\n    @Published var image: UIImage?\n    private let url: URL\n    private static let cache = NSCache<NSURL, UIImage>()\n\n    init(url: URL) {\n        self.url = url\n        loadImage()\n    }\n\n    func loadImage() {\n        // Check Cache first\n        if let cachedImage = Self.cache.object(forKey: url as NSURL) {\n            self.image = cachedImage\n            return\n        }\n\n        // Download if not in cache\n        URLSession.shared.dataTask(with: url) { [weak self] data, _, _ in\n            guard let data = data, let downloadedImage = UIImage(data: data) else { return }\n            \n            // Set Cache\n            Self.cache.setObject(downloadedImage, forKey: self?.url as NSURL? ?? NSURL())\n            \n            DispatchQueue.main.async {\n                self?.image = downloadedImage\n            }\n        }.resume()\n    }\n}"}
{"instruction": "Write a Swift function using the `Security` framework to save a user's authentication token string into the iOS Keychain securely.", "output": "import Security\n\nfunc saveTokenToKeychain(token: String, account: String) -> OSStatus {\n    let data = token.data(using: .utf8)!\n    \n    // Create query dictionary\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: account,\n        kSecValueData as String: data\n    ]\n    \n    // Delete any existing item to prevent duplicate errors\n    SecItemDelete(query as CFDictionary)\n    \n    // Add new item\n    return SecItemAdd(query as CFDictionary, nil)\n}"}
{"instruction": "Implement a custom `UIView` subclass in Swift that overrides `draw(_:)` to draw a red circle with a black border using Core Graphics (CGContext). This avoids the memory overhead of creating a UIImageView for simple shapes.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        // Calculate circle rect with padding for border\n        let strokeWidth: CGFloat = 4.0\n        let insetRect = rect.insetBy(dx: strokeWidth / 2, dy: strokeWidth / 2)\n        \n        context.setFillColor(UIColor.red.cgColor)\n        context.setStrokeColor(UIColor.black.cgColor)\n        context.setLineWidth(strokeWidth)\n        \n        // Add and draw path\n        context.addEllipse(in: insetRect)\n        context.drawPath(using: .fillStroke)\n    }\n}"}
{"instruction": "Identify and fix the strong reference cycle (memory leak) in the following Swift code snippet where a closure captures `self` strongly.", "output": "class DataFetcher {\n    var onDataFetched: (() -> Void)?\n    var data: String = \"\"\n\n    func fetchData() {\n        // Fix: Use [weak self] to break the retain cycle\n        DispatchQueue.global().async { [weak self] in\n            // Guard to ensure self still exists\n            guard let self = self else { return }\n            \n            let result = \"Fetched Data\"\n            DispatchQueue.main.async {\n                self.data = result\n                self.onDataFetched?()\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using `NSPersistentContainer` to safely create a new `User` entity on a background context and save it to persistent storage.", "output": "func createUser(named name: String, container: NSPersistentContainer) {\n    // performBackgroundTask ensures the block runs on a private queue associated with the context\n    container.performBackgroundTask { context in\n        let user = User(context: context)\n        user.name = name\n        user.id = UUID()\n\n        do {\n            try context.save()\n            print(\"User saved successfully on background thread.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI `ObservableObject` named `SearchViewModel` that uses Combine to debounce a search query string by 0.5 seconds before printing the value, to reduce excessive API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n\n    private func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching for: \\(query)\")\n    }\n}"}
{"instruction": "Implement the 'Weak-Strong Dance' pattern in Objective-C to prevent a retain cycle inside a block property named `completionBlock`.", "output": "// Assume self.completionBlock is a property of type void(^)(void)\n\n__weak typeof(self) weakSelf = self;\nself.completionBlock = ^{\n    // Upgrade weak reference to strong reference to ensure self stays alive during execution\n    __strong typeof(weakSelf) strongSelf = weakSelf;\n    \n    if (strongSelf) {\n        [strongSelf doSomethingImportant];\n        strongSelf.status = @\"Completed\";\n    }\n};"}
{"instruction": "Using Swift 5.5+ Concurrency, create a thread-safe `Actor` named `ScoreCounter` that manages an integer score to prevent data races.", "output": "actor ScoreCounter {\n    private var score: Int = 0\n\n    func increment(by value: Int) {\n        score += value\n    }\n\n    func getScore() -> Int {\n        return score\n    }\n}\n\n// Usage:\n// Task {\n//     let counter = ScoreCounter()\n//     await counter.increment(by: 10)\n//     let currentScore = await counter.getScore()\n// }"}
{"instruction": "Write a Combine pipeline in Swift that fetches data from a URL, maps the data to a Decodable struct `Post`, and handles errors by replacing them with a default value.", "output": "import Combine\nimport Foundation\n\nstruct Post: Decodable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPost(url: URL) -> AnyPublisher<Post, Never> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: Post.self, decoder: JSONDecoder())\n        .replaceError(with: Post(id: 0, title: \"Unknown\")) // Error handling\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Implement a memory-efficient image grid in SwiftUI using `LazyVGrid` that loads images from a URL using `AsyncImage`.", "output": "import SwiftUI\n\nstruct ImageGridView: View {\n    let imageUrls: [URL] // Assume this is populated\n    let columns = [GridItem(.adaptive(minimum: 100))]\n\n    var body: some View {\n        ScrollView {\n            // LazyVGrid ensures views are only created when they appear on screen\n            LazyVGrid(columns: columns, spacing: 10) {\n                ForEach(imageUrls, id: \\.self) { url in\n                    AsyncImage(url: url) { phase in\n                        if let image = phase.image {\n                            image.resizable().scaledToFit()\n                        } else if phase.error != nil {\n                            Color.red // Error placeholder\n                        } else {\n                            ProgressView() // Loading state\n                        }\n                    }\n                    .frame(height: 100)\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write a Swift function using the `LocalAuthentication` framework to authenticate a user using FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if biometric authentication is available\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Authenticate to access secure data\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Implement a thread-safe Singleton in Objective-C using `dispatch_once`.", "output": "+ (instancetype)sharedInstance {\n    static MySingleton *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[MySingleton alloc] init];\n        // Perform other initialization here\n    });\n    \n    return sharedInstance;\n}"}
{"instruction": "Write a Swift function using Core Image to apply a Sepia Tone filter to a `UIImage`.", "output": "import UIKit\nimport CoreImage\n\nfunc applySepiaFilter(to image: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: image) else { return nil }\n    \n    let filter = CIFilter(name: \"CISepiaTone\")\n    filter?.setValue(ciImage, forKey: kCIInputImageKey)\n    filter?.setValue(0.8, forKey: kCIInputIntensityKey)\n    \n    guard let outputImage = filter?.outputImage else { return nil }\n    \n    let context = CIContext()\n    // Render the CIImage back to a CGImage\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Create a Swift function that fetches a JSON array of 'Post' objects from a URL using Combine, decodes the data, and returns an AnyPublisher<[Post], Error>. Ensure the stream runs on a background thread and updates the UI on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct Post: Codable {\n    let id: Int\n    let title: String\n}\n\nfunc fetchPosts() -> AnyPublisher<[Post], Error> {\n    let url = URL(string: \"https://api.example.com/posts\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: [Post].self, decoder: JSONDecoder())\n        .subscribe(on: DispatchQueue.global(qos: .background))\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Demonstrate how to prevent a Strong Reference Cycle (Retain Cycle) in a Swift closure within a class, where the closure modifies a property of that class.", "output": "class DataManager {\n    var data: String = \"Initial Data\"\n    var onCompletion: (() -> Void)?\n\n    func performTask() {\n        // Use [weak self] to prevent the closure from strongly holding the class instance\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            self.data = \"Updated Data\"\n            print(\"Data updated: \\(self.data)\")\n        }\n    }\n\n    deinit {\n        print(\"DataManager is being deallocated\")\n    }\n}"}
{"instruction": "Write an Objective-C code snippet using `@autoreleasepool` inside a loop to manage memory efficiently when processing a large number of temporary objects, such as creating images from data.", "output": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\nvoid processImages(NSArray<NSData *> *imageDataArray) {\n    for (NSData *data in imageDataArray) {\n        @autoreleasepool {\n            // The UIImage created here is autoreleased.\n            // Without the pool, memory would spike until the loop finishes.\n            UIImage *image = [UIImage imageWithData:data];\n            NSLog(@\"Processed image size: %@\", NSStringFromCGSize(image.size));\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view model using the `ObservableObject` protocol that debounces user input from a search text field using Combine to prevent excessive API calls.", "output": "import SwiftUI\nimport Combine\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func performSearch(query: String) {\n        guard !query.isEmpty else { return }\n        print(\"Searching API for: \\(query)\")\n        // Simulate API call result\n        self.results = [\"Result for \\(query)\"]\n    }\n}"}
{"instruction": "Write a Swift function using Core Data that performs a background save operation. It should create a private queue context, insert a new 'User' entity, and save changes, handling potential errors.", "output": "import CoreData\n\nfunc saveUserInBackground(name: String, persistentContainer: NSPersistentContainer) {\n    persistentContainer.performBackgroundTask { context in\n        let user = NSEntityDescription.insertNewObject(forEntityName: \"User\", into: context)\n        user.setValue(name, forKey: \"name\")\n        \n        do {\n            try context.save()\n            print(\"User saved successfully on background context.\")\n        } catch {\n            print(\"Failed to save user: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Implement a `DispatchGroup` in Swift to synchronize two asynchronous network requests, executing a completion handler only after both requests have finished.", "output": "import Foundation\n\nfunc syncNetworkCalls(completion: @escaping () -> Void) {\n    let group = DispatchGroup()\n    \n    // Task 1\n    group.enter()\n    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {\n        print(\"Task 1 finished\")\n        group.leave()\n    }\n    \n    // Task 2\n    group.enter()\n    DispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n        print(\"Task 2 finished\")\n        group.leave()\n    }\n    \n    // Notify when both are done\n    group.notify(queue: .main) {\n        print(\"All tasks completed\")\n        completion()\n    }\n}"}
{"instruction": "Write an Objective-C method swizzling snippet to intercept the `viewWillAppear:` method of `UIViewController` using the Objective-C Runtime.", "output": "#import <objc/runtime.h>\n#import <UIKit/UIKit.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n        \n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(log_viewWillAppear:);\n        \n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        \n        BOOL didAddMethod = class_addMethod(class,\n                                            originalSelector,\n                                            method_getImplementation(swizzledMethod),\n                                            method_getTypeEncoding(swizzledMethod));\n        \n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)log_viewWillAppear:(BOOL)animated {\n    [self log_viewWillAppear:animated]; // Calls original implementation due to swizzling\n    NSLog(@\"View Will Appear: %@\", self);\n}\n\n@end"}
{"instruction": "Create a custom `UIView` subclass in Swift that draws a red circle with a black border in the center of the view using `draw(_:)` and `UIBezierPath`.", "output": "import UIKit\n\nclass CircleView: UIView {\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        let radius = min(rect.width, rect.height) / 2 - 5\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        \n        let path = UIBezierPath(arcCenter: center,\n                                radius: radius,\n                                startAngle: 0,\n                                endAngle: .pi * 2,\n                                clockwise: true)\n        \n        // Fill\n        UIColor.red.setFill()\n        path.fill()\n        \n        // Stroke\n        UIColor.black.setStroke()\n        path.lineWidth = 4.0\n        path.stroke()\n    }\n}"}
{"instruction": "Setup a basic `AVCaptureSession` in Swift to capture video input from the back camera. Include error handling for device availability.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.sessionPreset = .high\n    \n    guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {\n        print(\"No back camera available\")\n        return nil\n    }\n    \n    do {\n        let input = try AVCaptureDeviceInput(device: device)\n        if session.canAddInput(input) {\n            session.addInput(input)\n            return session\n        }\n    } catch {\n        print(\"Error setting up camera input: \\(error)\")\n    }\n    \n    return nil\n}"}
{"instruction": "Implement a 'NSCache' in Swift to store and retrieve images by a string key, ensuring the cache has a limit on the count of objects to manage memory usage.", "output": "import UIKit\n\nclass ImageCache {\n    static let shared = ImageCache()\n    private let cache = NSCache<NSString, UIImage>()\n    \n    private init() {\n        cache.countLimit = 100 // Maximum 100 images in memory\n    }\n    \n    func getImage(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n    \n    func save(image: UIImage, forKey key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n}"}
{"instruction": "Identify and fix the retain cycle in the following Swift code snippet where a closure captures 'self' strongly within a ViewController.", "output": "class MyViewController: UIViewController {\n    var onCompletion: (() -> Void)?\n    var status = \"Loading\"\n\n    func setupClosure() {\n        // Fix: Use [weak self] to break the strong reference cycle\n        onCompletion = { [weak self] in\n            guard let self = self else { return }\n            self.status = \"Finished\"\n            print(self.status)\n        }\n    }\n\n    deinit {\n        print(\"MyViewController deallocated\")\n    }\n}"}
{"instruction": "Create a Swift function using Core Data that performs a large data import on a background context to avoid blocking the main thread.", "output": "func importDataInBackground(jsonArray: [[String: Any]], container: NSPersistentContainer) {\n    container.performBackgroundTask { context in\n        // Set merge policy to handle conflicts\n        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n\n        for dict in jsonArray {\n            // Assuming 'Item' is a Core Data entity\n            let item = Item(context: context)\n            item.id = dict[\"id\"] as? UUID\n            item.name = dict[\"name\"] as? String\n            item.timestamp = Date()\n        }\n\n        do {\n            try context.save()\n            print(\"Background import successful\")\n        } catch {\n            print(\"Failed to save background context: \\(error)\")\n        }\n    }\n}"}
{"instruction": "Write a Combine pipeline in Swift that takes a search query string, debounces the input by 500ms, removes duplicates, and triggers an API search.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var query: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        $query\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] searchText in\n                self?.performSearch(with: searchText)\n            }\n            .store(in: &cancellables)\n    }\n\n    func performSearch(with text: String) {\n        print(\"Searching API for: \\(text)\")\n    }\n}"}
{"instruction": "Demonstrate how to manually create an @autoreleasepool block in Objective-C to manage memory usage inside a tight loop processing heavy images.", "output": "- (void)processHeavyImages {\n    NSArray *largeImagePaths = [self getLargeImagePaths];\n    \n    for (NSString *path in largeImagePaths) {\n        // Use autoreleasepool to release temporary objects created in each iteration immediately\n        @autoreleasepool {\n            UIImage *image = [UIImage imageWithContentsOfFile:path];\n            NSData *processedData = [self applyHeavyFilterToImage:image];\n            [processedData writeToFile:[path stringByAppendingString:@\".processed\"] atomically:YES];\n            // 'image' and 'processedData' are released here, preventing memory spikes\n        }\n    }\n}"}
{"instruction": "Create a SwiftUI view utilizing @FetchRequest to display a list of 'Task' entities sorted by creation date from Core Data.", "output": "import SwiftUI\nimport CoreData\n\nstruct TaskListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\TaskEntity.createdAt, ascending: true)],\n        animation: .default)\n    private var tasks: FetchedResults<TaskEntity>\n\n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    Text(task.title ?? \"Untitled\")\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .navigationTitle(\"Tasks\")\n        }\n    }\n\n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { tasks[$0] }.forEach(viewContext.delete)\n            try? viewContext.save()\n        }\n    }\n}"}
{"instruction": "Implement a generic network manager using Swift and Combine that fetches a Decodable object from a URL.", "output": "import Combine\nimport Foundation\n\nstruct NetworkManager {\n    func fetch<T: Decodable>(url: URL) -> AnyPublisher<T, Error> {\n        return URLSession.shared.dataTaskPublisher(for: url)\n            .tryMap { data, response in\n                guard let httpResponse = response as? HTTPURLResponse,\n                      (200...299).contains(httpResponse.statusCode) else {\n                    throw URLError(.badServerResponse)\n                }\n                return data\n            }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .eraseToAnyPublisher()\n    }\n}"}
{"instruction": "Write an Objective-C code snippet implementing Key-Value Observing (KVO) to observe the 'status' property of a 'DownloadTask' object.", "output": "@interface Observer : NSObject\n@property (nonatomic, strong) DownloadTask *task;\n@end\n\n@implementation Observer\n\n- (void)startObserving {\n    [self.task addObserver:self\n                forKeyPath:@\"status\"\n                   options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                   context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change\n                       context:(void *)context {\n    if ([keyPath isEqualToString:@\"status\"]) {\n        NSLog(@\"Status changed from %@ to %@\", change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);\n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)dealloc {\n    [self.task removeObserver:self forKeyPath:@\"status\"];\n}\n\n@end"}
{"instruction": "Use the Vision framework in Swift to perform text recognition (OCR) on a UIImage.", "output": "import Vision\nimport UIKit\n\nfunc recognizeText(in image: UIImage) {\n    guard let cgImage = image.cgImage else { return }\n    \n    let request = VNRecognizeTextRequest { (request, error) in\n        guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {\n            print(\"Text recognition failed\")\n            return\n        }\n        \n        let recognizedStrings = observations.compactMap { observation in\n            observation.topCandidates(1).first?.string\n        }\n        \n        print(\"Recognized text: \\(recognizedStrings.joined(separator: \" \"))\")\n    }\n    \n    request.recognitionLevel = .accurate\n    \n    let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n    try? handler.perform([request])\n}"}
{"instruction": "Create a custom UIView in Swift using UIKit that draws a red circle using Core Graphics (draw method).", "output": "import UIKit\n\nclass CircleView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = .clear\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        self.backgroundColor = .clear\n    }\n\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n        \n        context.setFillColor(UIColor.red.cgColor)\n        // Inset by 5 to ensure the stroke/fill stays within bounds\n        let circleRect = rect.insetBy(dx: 5, dy: 5)\n        context.fillEllipse(in: circleRect)\n    }\n}"}
{"instruction": "Setup a basic AVCaptureSession in Swift to capture video input from the default back camera.", "output": "import AVFoundation\n\nfunc setupCameraSession() -> AVCaptureSession? {\n    let session = AVCaptureSession()\n    session.beginConfiguration()\n    session.sessionPreset = .high\n\n    guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),\n          let videoInput = try? AVCaptureDeviceInput(device: videoDevice) else {\n        return nil\n    }\n\n    if session.canAddInput(videoInput) {\n        session.addInput(videoInput)\n    }\n    \n    // Add output (e.g., AVCaptureVideoDataOutput) here if needed\n\n    session.commitConfiguration()\n    return session\n}"}
{"instruction": "Identify and fix the strong reference cycle in the following Swift code snippet where a closure captures `self` within a ViewModel.", "output": "class DataFetcher {\n    var onDataFetched: ((String) -> Void)?\n    \n    func fetchData() {\n        // Simulate network delay\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {\n            self.onDataFetched?(\"New Data\")\n        }\n    }\n}\n\nclass ViewModel {\n    let fetcher = DataFetcher()\n    var data: String = \"\"\n    \n    init() {\n        // FIX: Use [weak self] to break the retain cycle\n        fetcher.onDataFetched = { [weak self] newData in\n            guard let self = self else { return }\n            self.data = newData\n            print(\"Data updated: \\(self.data)\")\n        }\n    }\n    \n    deinit {\n        print(\"ViewModel is being deallocated\")\n    }\n}"}
{"instruction": "Create a SwiftUI View that uses `@FetchRequest` to retrieve `ToDoItem` Core Data entities, sorted by `createdAt` in descending order, and filtered to show only uncompleted items.", "output": "import SwiftUI\nimport CoreData\n\nstruct TodoListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n\n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\ToDoItem.createdAt, ascending: false)],\n        predicate: NSPredicate(format: \"isCompleted == %@\", NSNumber(value: false)),\n        animation: .default)\n    private var items: FetchedResults<ToDoItem>\n\n    var body: some View {\n        List {\n            ForEach(items) { item in\n                Text(item.title ?? \"Untitled\")\n            }\n        }\n    }\n}"}
{"instruction": "Write an Objective-C class method that implements a thread-safe Singleton pattern.", "output": "#import \"NetworkManager.h\"\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    \n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n        // Additional initialization if needed\n    });\n    \n    return sharedInstance;\n}\n\n@end"}
{"instruction": "Using Combine in Swift, implement a search bar logic that debounces user input for 500ms, removes duplicates, and filters out empty strings before triggering an API call.", "output": "import Combine\nimport Foundation\n\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .filter { !$0.isEmpty }\n            .sink { [weak self] query in\n                self?.performSearch(query: query)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(query: String) {\n        print(\"Searching API for: \\(query)\")\n    }\n}"}
{"instruction": "Create a Swift `actor` named `BankAccount` to safely manage concurrent deposits and withdrawals, ensuring the balance never drops below zero.", "output": "actor BankAccount {\n    private(set) var balance: Double\n    \n    init(initialBalance: Double) {\n        self.balance = initialBalance\n    }\n    \n    func deposit(amount: Double) {\n        balance += amount\n    }\n    \n    func withdraw(amount: Double) -> Bool {\n        if balance >= amount {\n            balance -= amount\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\n// Usage\n// Task {\n//     let account = BankAccount(initialBalance: 100)\n//     await account.deposit(amount: 50)\n// }"}
{"instruction": "Demonstrate how to reduce memory footprint when processing a large array of high-resolution images in a loop using `autoreleasepool`.", "output": "import UIKit\n\nfunc processImages(_ imagePaths: [String]) {\n    for path in imagePaths {\n        // Use autoreleasepool to ensure temporary objects (like heavy UIImages)\n        // are deallocated immediately after each iteration, rather than waiting\n        // for the loop to finish.\n        autoreleasepool {\n            if let image = UIImage(contentsOfFile: path) {\n                let processed = applyFilter(to: image)\n                save(processed, to: path)\n            }\n        }\n    }\n}\n\nfunc applyFilter(to image: UIImage) -> UIImage { return image } // Placeholder\nfunc save(_ image: UIImage, to path: String) {} // Placeholder"}
{"instruction": "Use the Native `LocalAuthentication` framework to create a function that authenticates a user via FaceID or TouchID.", "output": "import LocalAuthentication\n\nfunc authenticateUser(completion: @escaping (Bool, Error?) -> Void) {\n    let context = LAContext()\n    var error: NSError?\n\n    // Check if the device handles biometrics\n    if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {\n        let reason = \"Log in to your account\"\n\n        context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in\n            DispatchQueue.main.async {\n                completion(success, authenticationError)\n            }\n        }\n    } else {\n        // Biometrics not available\n        completion(false, error)\n    }\n}"}
{"instruction": "Implement a network request using `URLSession` and Combine to fetch a JSON object, decode it into a `User` struct, and handle errors on the main thread.", "output": "import Combine\nimport Foundation\n\nstruct User: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchUser() -> AnyPublisher<User, Error> {\n    let url = URL(string: \"https://api.example.com/user/1\")!\n    \n    return URLSession.shared.dataTaskPublisher(for: url)\n        .map { $0.data }\n        .decode(type: User.self, decoder: JSONDecoder())\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}"}
{"instruction": "Use Core Image to apply a Sepia Tone filter to a `UIImage`.", "output": "import UIKit\nimport CoreImage\nimport CoreImage.CIFilterBuiltins\n\nfunc applySepiaFilter(to inputImage: UIImage) -> UIImage? {\n    guard let ciImage = CIImage(image: inputImage) else { return nil }\n    \n    let context = CIContext()\n    let filter = CIFilter.sepiaTone()\n    filter.inputImage = ciImage\n    filter.intensity = 1.0\n    \n    if let outputImage = filter.outputImage,\n       let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n        return UIImage(cgImage: cgImage)\n    }\n    return nil\n}"}
{"instruction": "Implement a `UICollectionView` Diffable Data Source in UIKit to update a list of strings with animation.", "output": "import UIKit\n\nclass ListViewController: UIViewController {\n    enum Section { case main }\n    \n    var collectionView: UICollectionView!\n    var dataSource: UICollectionViewDiffableDataSource<Section, String>!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        configureDataSource()\n        updateData(items: [\"Apple\", \"Banana\", \"Cherry\"])\n    }\n    \n    func configureDataSource() {\n        // Assuming collectionView is already initialized with layout\n        let cellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, String> { cell, indexPath, item in\n            var content = cell.defaultContentConfiguration()\n            content.text = item\n            cell.contentConfiguration = content\n        }\n        \n        dataSource = UICollectionViewDiffableDataSource<Section, String>(collectionView: collectionView) { \n            (collectionView, indexPath, item) -> UICollectionViewCell? in\n            return collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: item)\n        }\n    }\n    \n    func updateData(items: [String]) {\n        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()\n        snapshot.appendSections([.main])\n        snapshot.appendItems(items)\n        dataSource.apply(snapshot, animatingDifferences: true)\n    }\n}"}
