{"instruction": "Create a custom Expo Module using the Expo Modules API (Swift) to expose a function that returns the device's system name, and provide the TypeScript usage code.", "output": "// 1. iOS Implementation (MyModule.swift)\nimport ExpoModulesCore\n\npublic class MyModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyModule\")\n\n    Function(\"getSystemName\") { () -> String in\n      return UIDevice.current.systemName\n    }\n  }\n}\n\n// 2. TypeScript Usage (MyModule.ts)\nimport { requireNativeModule } from 'expo-modules-core';\n\ninterface MyModuleInterface {\n  getSystemName(): string;\n}\n\nconst MyModule = requireNativeModule<MyModuleInterface>('MyModule');\n\nexport function getDeviceSystemName(): string {\n  return MyModule.getSystemName();\n}"}
{"instruction": "Implement a Reanimated 3 component where a box fades in when mounted and slides out to the right when unmounted using Layout Animations.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nexport default function AnimatedBox() {\n  const [visible, setVisible] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setVisible(!visible)} />\n      {visible && (\n        <Animated.View\n          entering={FadeIn.duration(500)}\n          exiting={SlideOutRight.duration(500)}\n          style={styles.box}\n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', marginTop: 20 },\n});"}
{"instruction": "Create a draggable View using `react-native-gesture-handler` and `react-native-reanimated` that snaps back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n    })\n    .onFinalize(() => {\n      start.value = { x: 0, y: 0 };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ translateX: offset.value.x }, { translateY: offset.value.y }],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Android Native Module (Java) that creates a method `showToast` to display a native Android Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Write a legacy iOS Native Module (Objective-C) header and implementation that exposes a method to resolve a Promise with the app bundle identifier.", "output": "// AppInfoModule.h\n#import <React/RCTBridgeModule.h>\n@interface AppInfoModule : NSObject <RCTBridgeModule>\n@end\n\n// AppInfoModule.m\n#import \"AppInfoModule.h\"\n\n@implementation AppInfoModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getBundleId:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSString *bundleId = [[NSBundle mainBundle] bundleIdentifier];\n  if (bundleId) {\n    resolve(bundleId);\n  } else {\n    reject(@\"no_bundle_id\", @\"Cannot get bundle identifier\", nil);\n  }\n}\n\n@end"}
{"instruction": "Use Reanimated `runOnUI` to perform a heavy calculation (Fibonacci) on the UI thread to avoid blocking the JS thread, and update the state back on the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalc() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      const value = fibonacci(30); // Heavy calc on UI thread\n      runOnJS(setResult)(value);   // Update React state on JS thread\n    })();\n  };\n\n  return (\n    <View>\n      <Button title=\"Calculate Fib(30)\" onPress={handleCalculation} />\n      <Text>Result: {result}</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a hook using `expo-file-system` to download a remote image to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\nimport { useState } from 'react';\n\nexport const useImageDownloader = () => {\n  const [localUri, setLocalUri] = useState<string | null>(null);\n\n  const downloadImage = async (remoteUrl: string, fileName: string) => {\n    try {\n      const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n      const { uri } = await FileSystem.downloadAsync(remoteUrl, fileUri);\n      setLocalUri(uri);\n    } catch (error) {\n      console.error('Download failed', error);\n    }\n  };\n\n  return { localUri, downloadImage };\n};"}
{"instruction": "Bridge Optimization: Create a TypeScript utility class that batches analytics events and sends them to a native module every 2 seconds (or when 10 events accumulate) to reduce bridge traffic.", "output": "import { NativeModules } from 'react-native';\nconst { AnalyticsModule } = NativeModules;\n\nclass BatchAnalytics {\n  private queue: any[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private readonly BATCH_SIZE = 10;\n  private readonly INTERVAL = 2000;\n\n  logEvent(event: string, data: object) {\n    this.queue.push({ event, data, timestamp: Date.now() });\n\n    if (this.queue.length >= this.BATCH_SIZE) {\n      this.flush();\n    } else if (!this.timer) {\n      this.timer = setTimeout(() => this.flush(), this.INTERVAL);\n    }\n  }\n\n  private flush() {\n    if (this.queue.length === 0) return;\n    \n    const batch = [...this.queue];\n    this.queue = [];\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n\n    // Single bridge call for multiple events\n    AnalyticsModule.trackBatch(batch);\n  }\n}\n\nexport const Analytics = new BatchAnalytics();"}
{"instruction": "Create a Reanimated component that applies a parallax effect to an image based on the device gyroscope sensor data.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withSpring } from 'react-native-reanimated';\n\nexport default function ParallaxImage() {\n  // Access gyroscope on the UI thread directly\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, { interval: 10 });\n\n  const style = useAnimatedStyle(() => {\n    const { x, y } = animatedSensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(y * 20) }, // Tilt horizontal moves image X\n        { translateY: withSpring(x * 20) }  // Tilt vertical moves image Y\n      ],\n    };\n  });\n\n  return <Animated.Image source={{ uri: 'https://via.placeholder.com/300' }} style={[styles.img, style]} />;\n}\n\nconst styles = StyleSheet.create({\n  img: { width: 300, height: 300, borderRadius: 10 },\n});"}
{"instruction": "Provide the C++ JSI (JavaScript Interface) implementation stub for a Host Function `multiply` that accepts two numbers and returns their product.", "output": "jsi::Function::createFromHostFunction(\n  runtime,\n  jsi::PropNameID::forAscii(runtime, \"multiply\"),\n  2, // Number of arguments\n  [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n    if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n      throw jsi::JSError(runtime, \"multiply expects 2 number arguments\");\n    }\n\n    double result = arguments[0].asNumber() * arguments[1].asNumber();\n    return jsi::Value(result);\n  }\n);"}
{"instruction": "Create a simple Expo Module using the modern Swift API (Expo Modules API) that exposes a function to get the device model name synchronously.", "output": "import ExpoModulesCore\n\npublic class DeviceInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Expose a synchronous function to JavaScript\n    Function(\"getDeviceModel\") {\n      return UIDevice.current.model\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should spring back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Native Module in Java (Android) that exposes a method to show a Toast message. Include the ReactMethod annotation.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a TypeScript interface specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method to add two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Use Reanimated's `runOnUI` to offload a heavy synchronous calculation (e.g., Fibonacci) to the UI thread to prevent blocking the JS thread (Bridge optimization technique).", "output": "import { Button, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n) => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      // Calculate fib(35) on UI thread\n      const result = fib(35);\n      console.log(`Calculation result: ${result}`);\n    })();\n  };\n\n  return <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />;\n}"}
{"instruction": "Create a legacy Native Module in Objective-C (iOS) that exports a method to trigger a standard vibration.", "output": "#import \"RCTBridgeModule.h\"\n#import <AudioToolbox/AudioToolbox.h>\n\n@interface VibrationModule : NSObject <RCTBridgeModule>\n@end\n\n@implementation VibrationModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(vibrate) {\n  AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n}\n\n@end"}
{"instruction": "Implement a Reanimated Layout Animation where items in a list Fade In Up when added and Fade Out Down when removed.", "output": "import React, { useState } from 'react';\nimport { View, Button } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          style={{ height: 50, backgroundColor: 'tomato', margin: 5 }}\n        />\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Optimize bridge traffic by using `useAnimatedProps` with Reanimated and `react-native-svg` to animate a circle's radius directly on the UI thread without React re-renders.", "output": "import React, { useEffect } from 'react';\nimport Svg, { Circle } from 'react-native-svg';\nimport Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming } from 'react-native-reanimated';\n\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport default function PulseCircle() {\n  const r = useSharedValue(10);\n\n  useEffect(() => {\n    r.value = withRepeat(withTiming(50, { duration: 1000 }), -1, true);\n  }, []);\n\n  const animatedProps = useAnimatedProps(() => ({\n    r: r.value,\n  }));\n\n  return (\n    <Svg height=\"200\" width=\"200\">\n      <AnimatedCircle cx=\"100\" cy=\"100\" fill=\"purple\" animatedProps={animatedProps} />\n    </Svg>\n  );\n}"}
{"instruction": "Use Expo Sensors (Accelerometer) combined with Reanimated to rotate an image based on device tilt. This demonstrates bridging sensor data to UI thread animations.", "output": "import React, { useEffect } from 'react';\nimport { Image, StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function TiltImage() {\n  const tilt = useSharedValue(0);\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(({ x }) => {\n      // Update shared value directly from sensor callback\n      tilt.value = x;\n    });\n    Accelerometer.setUpdateInterval(16);\n    return () => subscription.remove();\n  }, []);\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ rotate: `${tilt.value * 90}deg` }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image \n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }} \n        style={[styles.img, rStyle]} \n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  img: { width: 100, height: 100 }\n});"}
{"instruction": "Implement a custom Frame Callback using Reanimated's `useFrameCallback` to create a JS-thread independent animation loop (e.g., for a game loop or high-frequency update).", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, useFrameCallback } from 'react-native-reanimated';\n\nexport default function GameLoop() {\n  const x = useSharedValue(0);\n\n  // Runs on every frame on the UI thread\n  useFrameCallback((frameInfo) => {\n    if (!frameInfo.timeSincePreviousFrame) return;\n    // Move 100 pixels per second\n    const delta = (frameInfo.timeSincePreviousFrame / 1000) * 100;\n    x.value = (x.value + delta) % 300;\n  });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: x.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, rStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  box: { width: 50, height: 50, backgroundColor: 'green' }\n});"}
{"instruction": "Create a modern Expo Native Module (Swift) that exposes a function to get the device's battery level.", "output": "import ExpoModulesCore\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeCalculator' to support the New Architecture (Fabric/TurboModules).", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a legacy Android Native Module (Java) that opens the device's specific application settings.", "output": "package com.myapp;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class OpenSettingsModule extends ReactContextBaseJavaModule {\n    OpenSettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"OpenSettings\";\n    }\n\n    @ReactMethod\n    public void open() {\n        Activity currentActivity = getCurrentActivity();\n        if (currentActivity == null) return;\n\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.setData(Uri.parse(\"package:\" + getReactApplicationContext().getPackageName()));\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);\n        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n        \n        currentActivity.startActivity(intent);\n    }\n}"}
{"instruction": "Use Reanimated to create a scroll header that interpolates opacity and height based on the scroll offset.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 200;\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(scrollY.value, [0, HEADER_HEIGHT], [HEADER_HEIGHT, 50], Extrapolation.CLAMP);\n    const opacity = interpolate(scrollY.value, [0, HEADER_HEIGHT / 2], [1, 0], Extrapolation.CLAMP);\n    return { height, opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.text}>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.listItem}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', overflow: 'hidden' },\n  text: { color: 'white', fontSize: 24, fontWeight: 'bold' },\n  listItem: { height: 100, borderBottomWidth: 1, justifyContent: 'center', padding: 20 }\n});"}
{"instruction": "Implement a C++ JSI binding function (conceptually) to expose a synchronous 'fibonacci' function to the JavaScript runtime, bypassing the async bridge.", "output": "// Inside a cpp-adapter.cpp or similar JSI setup file\n\nvoid install(jsi::Runtime& runtime) {\n  auto fibonacci = jsi::Function::createFromHostFunction(\n    runtime,\n    jsi::PropNameID::forAscii(runtime, \"fibonacci\"),\n    1, // argument count\n    [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n      double n = arguments[0].asNumber();\n      // Simple iterative logic for demo\n      if (n <= 1) return n;\n      double a = 0, b = 1, c;\n      for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n      }\n      return jsi::Value(b);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"fibonacci\", std::move(fibonacci));\n}"}
{"instruction": "Create an Objective-C ViewManager to wrap a native MKMapView for use in React Native.", "output": "#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  MKMapView *map = [[MKMapView alloc] init];\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\nRCT_EXPORT_VIEW_PROPERTY(scrollEnabled, BOOL)\n\n@end"}
{"instruction": "Use Expo FileSystem to download an image to the local cache directory and display it.", "output": "import React, { useEffect, useState } from 'react';\nimport { Image, View } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nexport default function CachedImage({ sourceUrl }: { sourceUrl: string }) {\n  const [localUri, setLocalUri] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fileName = sourceUrl.split('/').pop();\n    const fileUri = FileSystem.cacheDirectory + fileName;\n\n    FileSystem.getInfoAsync(fileUri).then((info) => {\n      if (info.exists) {\n        setLocalUri(fileUri);\n      } else {\n        FileSystem.downloadAsync(sourceUrl, fileUri)\n          .then(({ uri }) => setLocalUri(uri))\n          .catch(e => console.error(e));\n      }\n    });\n  }, [sourceUrl]);\n\n  if (!localUri) return <View style={{ width: 100, height: 100, backgroundColor: '#eee' }} />;\n  return <Image source={{ uri: localUri }} style={{ width: 100, height: 100 }} />;\n}"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [Date.now(), ...prev]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeInUp} \n          exiting={FadeOutDown} \n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, marginTop: 50 },\n  card: { flexDirection: 'row', justifyContent: 'space-between', padding: 20, marginVertical: 5, backgroundColor: '#f9c2ff', borderRadius: 8 }\n});"}
{"instruction": "Optimize a React Native FlatList to reduce bridge traffic and improve performance using 'getItemLayout', 'initialNumToRender', and memoized render items.", "output": "import React, { useCallback, memo } from 'react';\nimport { FlatList, View, Text, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 80;\n\n// Memoized Item to prevent re-renders if props don't change\nconst ListItem = memo(({ title }: { title: string }) => (\n  <View style={styles.item}>\n    <Text>{title}</Text>\n  </View>\n));\n\nexport default function OptimizedList() {\n  // Generate large data\n  const data = Array.from({ length: 1000 }).map((_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\n  const renderItem = useCallback(({ item }: { item: { title: string } }) => (\n    <ListItem title={item.title} />\n  ), []);\n\n  const getItemLayout = useCallback((_: any, index: number) => (\n    { length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index }\n  ), []);\n\n  const keyExtractor = useCallback((item: { id: string }) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { height: ITEM_HEIGHT, justifyContent: 'center', paddingHorizontal: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable box. The animation logic must run on the UI thread to optimize bridge usage.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      // Logic runs on UI thread, bypassing the bridge for 60fps\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift file for a minimal Expo Module (using the Expo Modules API) that exposes a synchronous function 'getDeviceName' and an asynchronous function 'setValueAsync'.", "output": "import ExpoModulesCore\n\npublic class MyDeviceModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyDeviceModule\")\n\n    // Synchronous function (faster, blocks JS thread slightly but good for simple data)\n    Function(\"getDeviceName\") { () -> String in\n      return UIDevice.current.name\n    }\n\n    // Asynchronous function (Promise-based in JS)\n    AsyncFunction(\"setValueAsync\") { (value: String) in\n      UserDefaults.standard.set(value, forKey: \"my_custom_value\")\n    }\n  }\n}"}
{"instruction": "Create a native Android Java module that exposes a method to show a Toast message. Include the required `getName` and `@ReactMethod` annotations.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeCalculator'. This is part of the New Architecture to ensure type safety and lazy loading of native modules.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous method for high performance\n  add(a: number, b: number): number;\n  \n  // Define async method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 'Layout Animation' to automatically animate items when they are added to or removed from a list, using `Entering` and `Exiting` modifiers.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutLeft } from 'react-native-reanimated';\n\nexport default function ListAnimator() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn.duration(500)}\n          exiting={SlideOutLeft.duration(300)}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's `runOnUI` to perform a heavy calculation on the UI thread preventing the JS thread from freezing during an animation.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that would block the JS thread if run there\nfunction heavyCalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(input + i);\n  }\n  console.log('Calculation done on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // We call this from JS, but execution happens on the UI thread\n  // This keeps the Bridge free for other React updates\n  runOnUI(heavyCalculation)(42);\n};"}
{"instruction": "Create a custom iOS Native UI Component (View Manager) in Objective-C to expose a simple 'RNTMap' view to JavaScript.", "output": "// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\n// Expose a property to change zoom enabled status\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end"}
{"instruction": "Write a React Native component that uses `useAnimatedScrollHandler` from Reanimated to drive a header's opacity based on scroll position directly on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], 'clamp'),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <Text key={i} style={styles.item}>Item {i}</Text>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 60, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1, justifyContent: 'center', alignItems: 'center' },\n  item: { padding: 20, borderBottomWidth: 1, borderBottomColor: '#ccc' },\n});"}
{"instruction": "Implement an Android Native Module method in Java that sends an event to JavaScript using `DeviceEventManagerModule`. This is useful for push notifications or hardware updates.", "output": "private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {\n    reactContext\n        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n        .emit(eventName, params);\n}\n\n@ReactMethod\npublic void triggerHardwareUpdate() {\n    WritableMap params = Arguments.createMap();\n    params.putString(\"status\", \"active\");\n    params.putDouble(\"battery\", 0.95);\n    sendEvent(getReactApplicationContext(), \"HardwareUpdate\", params);\n}"}
{"instruction": "Use the Expo FileSystem API to download a file to the local cache directory. This demonstrates utilizing the Expo ecosystem for native capabilities without writing native code.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'downloaded_image.jpg';\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    console.log('Finished downloading to ', result?.uri);\n    return result?.uri;\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Demonstrate how to create a custom Expo Module definition in TypeScript. Create a module named 'MySettings' that has a synchronous function 'getTheme' and an asynchronous function 'setValueAsync'.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native module\ninterface MySettingsModule {\n  getTheme(): string;\n  setValueAsync(key: string, value: string): Promise<void>;\n}\n\n// Require the native module\n// This assumes the native iOS (Swift) and Android (Kotlin) code is already linked via the Expo Modules API\nconst MySettings = requireNativeModule<MySettingsModule>('MySettings');\n\n// Usage wrapper\nexport const getAppTheme = (): string => {\n  return MySettings.getTheme();\n};\n\nexport const setAppSetting = async (key: string, value: string) => {\n  await MySettings.setValueAsync(key, value);\n};"}
{"instruction": "Implement a high-performance synchronous storage solution using 'react-native-mmkv' to demonstrate Bridge Optimization via JSI (JavaScript Interface), replacing the asynchronous AsyncStorage pattern.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Create a new instance. \n// This bypasses the React Native Bridge by using C++ JSI bindings directly.\nexport const storage = new MMKV({\n  id: 'user-storage',\n  encryptionKey: 'secure-key-example'\n});\n\n// Helper functions\nexport const getUserSession = (): string | undefined => {\n  // Synchronous read (much faster than await AsyncStorage.getItem())\n  return storage.getString('user.session_token');\n};\n\nexport const saveUserSession = (token: string) => {\n  // Synchronous write\n  storage.set('user.session_token', token);\n};\n\nexport const clearSession = () => {\n  storage.delete('user.session_token');\n};"}
{"instruction": "Use React Native Reanimated to run a heavy calculation on the UI thread (using a Worklet) to prevent blocking the JavaScript thread during an animation.", "output": "import React from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n  const result = useSharedValue(0);\n\n  // This function is marked as a 'worklet' to run on the UI thread\n  const heavyTask = (input: number) => {\n    'worklet';\n    let sum = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 5000000; i++) {\n      sum += i * input;\n    }\n    console.log('Calculation done on UI thread');\n    return sum;\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      const calcResult = heavyTask(2);\n      result.value = calcResult;\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};\n"}
{"instruction": "Create a typed interface for a Custom Native UI Component named 'RNCameraView' using `requireNativeComponent`.", "output": "import { requireNativeComponent, ViewProps, HostComponent } from 'react-native';\n\n// Define props expected by the native view\ninterface RNCameraViewProps extends ViewProps {\n  zoomLevel: number;\n  isOn: boolean;\n  onBarcodeScanned?: (event: { nativeEvent: { data: string } }) => void;\n}\n\n// Register the component\n// 'RNCameraView' must match the name returned by the native ViewManager\nconst RNCameraView: HostComponent<RNCameraViewProps> = requireNativeComponent('RNCameraView');\n\nexport default RNCameraView;"}
{"instruction": "Use the Expo FileSystem API to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string, fileName: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Download progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Set up a `NativeEventEmitter` to listen for a specific event sent from a Native Module (e.g., 'HardwareVolumeEvent'). Include cleanup logic.", "output": "import { useEffect } from 'react';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\n// Assume 'VolumeModule' is exposed natively\nconst { VolumeModule } = NativeModules;\n\nexport const useVolumeListener = (callback: (volume: number) => void) => {\n  useEffect(() => {\n    if (!VolumeModule) return;\n\n    const eventEmitter = new NativeEventEmitter(VolumeModule);\n    \n    // Subscribe to the event\n    const subscription = eventEmitter.addListener('HardwareVolumeEvent', (event) => {\n      callback(event.volume);\n    });\n\n    // Cleanup subscription on unmount\n    return () => {\n      subscription.remove();\n    };\n  }, [callback]);\n};"}
{"instruction": "Implement Reanimated Layout Animations to automatically animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text onPress={() => removeItem(item)}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20 },\n  card: { height: 50, backgroundColor: '#ddd', marginVertical: 5, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Configure a Background Fetch task using Expo's TaskManager and BackgroundFetch APIs to run a periodic job.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_TASK_NAME = 'MY_BACKGROUND_TASK';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_TASK_NAME, async () => {\n  try {\n    const now = new Date();\n    console.log(`Background task running at: ${now.toISOString()}`);\n    // Perform fetch or logic here\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App initialization)\nexport const registerBackgroundTask = async () => {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_TASK_NAME, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // Android only\n    startOnBoot: true, // Android only\n  });\n};"}
{"instruction": "Optimize a FlatList to reduce bridge traffic and frame drops by implementing `getItemLayout`, `initialNumToRender`, and `maxToRenderPerBatch`.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst ITEM_HEIGHT = 60;\n\ninterface Item { id: string; title: string; }\n\nexport const OptimizedList = ({ data }: { data: Item[] }) => {\n  \n  // Optimizes rendering by skipping measurement calculations on the bridge\n  const getItemLayout = (data: any, index: number) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  const renderItem = ({ item }: { item: Item }) => (\n    <View style={{ height: ITEM_HEIGHT, justifyContent: 'center' }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10} // Render enough to fill the screen initially\n      maxToRenderPerBatch={10} // Limit items rendered per batch to keep JS thread free\n      windowSize={5} // Reduce memory usage by keeping fewer items in memory outside viewport\n      removeClippedSubviews={true} // Unmount views off-screen (Android)\n    />\n  );\n};"}
{"instruction": "Create a React Native Reanimated component using TypeScript that implements a draggable box using `react-native-gesture-handler` and `react-native-reanimated`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nconst DraggableBox = () => {\n  const pressed = useSharedValue<boolean>(false);\n  const offset = useSharedValue<{ x: number; y: number }>({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      pressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.changeX + offset.value.x,\n        y: event.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      pressed.value = false;\n      // Return to origin on release\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n      { scale: withSpring(pressed.value ? 1.2 : 1) },\n    ],\n    backgroundColor: pressed.value ? '#FFE04B' : '#B58DF1',\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.ball, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 100, height: 100, borderRadius: 50 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a native iOS module (Swift) and the corresponding TypeScript interface to expose a method that returns the device's battery level via a Promise.", "output": "// 1. iOS Swift Code (BatteryModule.swift)\n/*\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level >= 0 {\n      resolve(level)\n    } else {\n      reject(\"BATTERY_ERROR\", \"Unable to determine battery level\", nil)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n*/\n\n// 2. TypeScript Interface (BatteryModule.ts)\nimport { NativeModules } from 'react-native';\n\ninterface BatteryModuleInterface {\n  getBatteryLevel(): Promise<number>;\n}\n\nconst { BatteryModule } = NativeModules;\n\nexport default BatteryModule as BatteryModuleInterface;"}
{"instruction": "Demonstrate bridge optimization by passing a large dataset from JavaScript to a Native Module as a JSON string rather than a JS Object to avoid costly serialization overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { DataProcessor } = NativeModules;\n\n// Inefficient way (Bridge has to serialize deep objects individually)\n// const sendDataInefficiently = (data: ComplexObject[]) => {\n//   DataProcessor.processArray(data);\n// };\n\n// Optimized way\n// By stringifying in JS, we pass a single string across the bridge.\n// The Native side (Java/Obj-C) then parses this string once.\n// This is often faster for large datasets than the RN Bridge serialization.\nconst sendDataOptimized = async (data: any[]) => {\n  try {\n    const jsonString = JSON.stringify(data);\n    const result = await DataProcessor.processJSONString(jsonString);\n    console.log('Processed:', result);\n  } catch (error) {\n    console.error('Bridge error', error);\n  }\n};\n\nexport { sendDataOptimized };"}
{"instruction": "Create an Expo component using `expo-haptics` to trigger different haptic feedback styles based on user interaction.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nconst HapticFeedbackDemo = () => {\n  const triggerSelection = () => {\n    // Light feedback for selection changes\n    Haptics.selectionAsync();\n  };\n\n  const triggerSuccess = () => {\n    // Success notification pattern\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  };\n\n  const triggerImpact = () => {\n    // Heavy physical impact feel\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Selection (Light)\" onPress={triggerSelection} />\n      <View style={styles.spacer} />\n      <Button title=\"Success (Notification)\" onPress={triggerSuccess} />\n      <View style={styles.spacer} />\n      <Button title=\"Heavy Impact\" onPress={triggerImpact} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  spacer: { height: 20 },\n});\n\nexport default HapticFeedbackDemo;"}
{"instruction": "Define a TypeScript specification for a Fabric TurboModule (New Architecture) that includes a method to get a string and a method to calculate a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\n// The interface must extend TurboModule\nexport interface Spec extends TurboModule {\n  // Method returning a simple string\n  getConstants: () => { const1: string };\n  \n  // Method to get a simple string\n  getString(id: string): string;\n\n  // Method performing a calculation\n  addNumbers(a: number, b: number): number;\n}\n\n// Load the module, enforcing the Spec. \n// 'NativeCalculator' is the name used in the C++/Java/Obj-C implementation.\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 'Worklet' to offload a heavy synchronous calculation (like Fibonacci) to the UI thread to prevent blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nconst HeavyCalculationComponent = () => {\n  const [result, setResult] = useState<number | null>(null);\n\n  // This function is marked as a 'worklet' automatically when passed to runOnUI\n  // or defined with 'worklet' directive.\n  const calculateFibonacci = (n: number) => {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return num;\n      return fib(num - 1) + fib(num - 2);\n    };\n    \n    const res = fib(n);\n    \n    // Call back to JS thread to update React state\n    runOnJS(setResult)(res);\n  };\n\n  const handlePress = () => {\n    // Offload to UI thread\n    runOnUI(calculateFibonacci)(35);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Calculating...'}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};\n\nexport default HeavyCalculationComponent;"}
{"instruction": "Write a Native Module for Android (Java) that exposes a method to show a Toast message, and consume it in React Native.", "output": "// 1. Android Java Code (ToastModule.java)\n/*\npackage com.myapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// 2. JavaScript Usage\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\nexport const showToast = (message: string) => {\n  // 0 = SHORT, 1 = LONG (standard Android Toast constants)\n  ToastModule.show(message, 0);\n};"}
{"instruction": "Use Expo's `expo-file-system` to download an image to the local document directory and log the URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (imageUrl: string) => {\n  try {\n    const filename = imageUrl.split('/').pop() || 'downloaded.jpg';\n    const fileUri = FileSystem.documentDirectory + filename;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      imageUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n};\n\n// Usage Example\n// downloadImage('https://example.com/image.png');"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on the scroll Y position.", "output": "import React from 'react';\nimport { View, StyleSheet, Text } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nconst ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      \n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={styles.scrollContent}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0, left: 0, right: 0,\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  scrollContent: { paddingTop: 60 },\n  item: { height: 100, borderBottomWidth: 1, justifyContent: 'center', padding: 20 }\n});\n\nexport default ScrollHeader;"}
{"instruction": "Setup a `NativeEventEmitter` in TypeScript to listen for events sent from a Native Module (e.g., a pedometer step counter).", "output": "import { NativeModules, NativeEventEmitter, EmitterSubscription } from 'react-native';\nimport { useEffect } from 'react';\n\n// Assume PedometerModule is linked natively\nconst { PedometerModule } = NativeModules;\n\nconst pedometerEvents = new NativeEventEmitter(PedometerModule);\n\nexport const useStepCounter = () => {\n  useEffect(() => {\n    // Subscribe to event\n    const subscription: EmitterSubscription = pedometerEvents.addListener(\n      'onStepCount',\n      (event: { steps: number }) => {\n        console.log('Steps detected:', event.steps);\n      }\n    );\n\n    // Start the native service if required\n    PedometerModule.startPedometerUpdates();\n\n    return () => {\n      // Cleanup\n      PedometerModule.stopPedometerUpdates();\n      subscription.remove();\n    };\n  }, []);\n};"}
{"instruction": "Create a Swift Native Module (iOS) named 'Counter' that exposes a method 'increment' and 'getCount' to React Native.", "output": "// Counter.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(Counter, NSObject)\nRCT_EXTERN_METHOD(increment)\nRCT_EXTERN_METHOD(getCount: (RCTResponseSenderBlock)callback)\n@end\n\n// Counter.swift\nimport Foundation\n\n@objc(Counter)\nclass Counter: NSObject {\n  private var count = 0\n\n  @objc\n  func increment() {\n    count += 1\n  }\n\n  @objc\n  func getCount(_ callback: RCTResponseSenderBlock) {\n    callback([count])\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Implement a Reanimated 3 scroll handler to animate a header's opacity based on the scroll Y position on the UI thread.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [1, 0], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 60, backgroundColor: 'red', width: '100%' },\n  content: { height: 1000, backgroundColor: '#eee' }\n});"}
{"instruction": "Create an Android Native Module (Java) to retrieve the device battery level.", "output": "package com.myapp;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n   BatteryModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"BatteryModule\";\n   }\n\n   @ReactMethod\n   public void getBatteryLevel(Promise promise) {\n       try {\n           IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n           Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n           int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n           int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n           float batteryPct = level * 100 / (float)scale;\n           promise.resolve(batteryPct);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeLocalStorage'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  setItem(key: string, value: string): Promise<void>;\n  getItem(key: string): Promise<string | null>;\n  removeItem(key: string): Promise<void>;\n  clear(): Promise<void>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeLocalStorage');"}
{"instruction": "Use Expo FileSystem to download an image from a URL and save it to the app's cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    const downloadRes = await FileSystem.downloadAsync(url, fileUri);\n    \n    if (downloadRes.status === 200) {\n      console.log('Finished downloading to ', downloadRes.uri);\n      return downloadRes.uri;\n    } else {\n      console.error('Download failed');\n      return null;\n    }\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Implement a draggable box using Reanimated 3 and React Native Gesture Handler without triggering JS thread re-renders.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const pan = Gesture.Pan()\n    .onChange((event) => {\n      translateX.value += event.changeX;\n      translateY.value += event.changeY;\n    })\n    .onFinalize(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Create an Expo component that uses the Accelerometer sensor to rotate a View based on device tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltView() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(setData);\n    Accelerometer.setUpdateInterval(100);\n    return () => subscription.remove();\n  }, []);\n\n  const rotation = Math.atan2(y, x) * (180 / Math.PI);\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: `${rotation}deg` }] }]}>\n        <Text>Tilt Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'coral', justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Setup a custom Native UI Component (iOS) named 'RNTMap' to be used in JS via `requireNativeComponent`.", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end\n\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nmodule.exports = requireNativeComponent('RNTMap');"}
{"instruction": "Optimize Bridge communication by using `runOnJS` in Reanimated to only trigger a state update when a threshold is crossed, preventing a flood of events across the bridge.", "output": "import React, { useState } from 'react';\nimport { Text, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedReaction, runOnJS } from 'react-native-reanimated';\n\nexport default function BridgeOptimizer() {\n  const [status, setStatus] = useState('Idle');\n  const progress = useSharedValue(0);\n\n  const handleThreshold = (isActive: boolean) => {\n    // This function runs on the JS thread, but is only called when necessary\n    setStatus(isActive ? 'Active' : 'Idle');\n  };\n\n  useAnimatedReaction(\n    () => progress.value > 0.5, // Worklet: runs on UI thread\n    (isAboveThreshold, previous) => {\n      if (isAboveThreshold !== previous) {\n        // Only cross the bridge when the boolean value changes\n        runOnJS(handleThreshold)(isAboveThreshold);\n      }\n    },\n    [progress]\n  );\n\n  return (\n    <View>\n      <Text>Status: {status}</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a Reanimated Layout Animation for a list item that slides in from the right and fades out upon removal.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { SlideInRight, FadeOut } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={SlideInRight.duration(500)}\n          exiting={FadeOut.duration(300)}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  item: { height: 50, backgroundColor: 'teal', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a custom React Native hook using Expo's `expo-sensors` and `react-native-reanimated` to animate a View based on the device's accelerometer data. The animation should run on the UI thread to minimize bridge traffic.", "output": "import { useState, useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring, SensorType, useAnimatedSensor } from 'react-native-reanimated';\n\nexport default function AccelerometerAnimation() {\n  // Reanimated 2+ offers useAnimatedSensor which runs directly on the UI thread\n  // bypassing the bridge for every sensor update.\n  const sensor = useAnimatedSensor(SensorType.ACCELEROMETER, { interval: 10 });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(x * 100) },\n        { translateY: withSpring(y * 100) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a native iOS Swift module (header and implementation) that exposes a method `getDeviceName` to React Native. Then show the TypeScript interface to consume it.", "output": "// DeviceInfo.swift\nimport Foundation\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// DeviceInfo.ts (React Native Usage)\nimport { NativeModules } from 'react-native';\n\nconst { DeviceInfo } = NativeModules;\n\ninterface DeviceInfoInterface {\n  getDeviceName(): Promise<string>;\n}\n\nexport const DeviceInfoModule = DeviceInfo as DeviceInfoInterface;"}
{"instruction": "Implement a draggable box using `react-native-reanimated` and `react-native-gesture-handler`. The solution must run entirely on the UI thread using worklets.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      'worklet'; // Explicitly marking for clarity, though auto-detected\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      'worklet';\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Create a native Android Kotlin module that creates a simple Toast message. Provide the Kotlin code and the React Native TypeScript wrapper.", "output": "// ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName() = \"ToastModule\"\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n\n    override fun getConstants(): MutableMap<String, Any> = hashMapOf(\n        \"SHORT\" to Toast.LENGTH_SHORT,\n        \"LONG\" to Toast.LENGTH_LONG\n    )\n}\n\n// ToastModule.ts\nimport { NativeModules } from 'react-native';\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n  SHORT: number;\n  LONG: number;\n}\n\nconst { ToastModule } = NativeModules;\nexport default ToastModule as ToastInterface;"}
{"instruction": "Demonstrate bridge optimization by implementing a layout animation for a list item removal using `react-native-reanimated` Layout Animations (Entering/Exiting). This avoids imperatively calculating layout on the JS thread.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutRight } from 'react-native-reanimated';\n\nexport default function ListRemover() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (id: number) => {\n    setItems((current) => current.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Animation logic runs on UI thread\n          entering={FadeIn}\n          exiting={SlideOutRight}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item {item}</Text>\n          <Button title=\"Remove\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 50 },\n  card: { \n    height: 50, \n    backgroundColor: '#ddd', \n    marginBottom: 10, \n    flexDirection: 'row', \n    justifyContent: 'space-between', \n    alignItems: 'center', \n    paddingHorizontal: 10 \n  },\n});"}
{"instruction": "Use Expo's `expo-file-system` to download an image from a URL and save it to the local cache directory. Handle the asynchronous nature properly.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Define a TurboModule Specification (New Architecture) in TypeScript for a calculator module that adds two numbers. This is for the codegen to generate C++ bindings.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Using typed definitions allows Codegen to create C++ bindings\n  // reducing bridge overhead compared to legacy modules.\n  add(a: number, b: number): Promise<number>;\n  \n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a high-performance list using `FlashList` (by Shopify) instead of `FlatList` to optimize bridge serialization for large datasets. Include estimated item size.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        // Critical for performance: minimizes layout measurement passes across the bridge\n        estimatedItemSize={50}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    padding: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});\n\nexport default MyList;"}
{"instruction": "Implement a `runOnUI` function using Reanimated to perform a heavy calculation on the UI thread and update a shared value, blocking the JS thread as little as possible.", "output": "import React from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  const result = useSharedValue(0);\n\n  // This function is defined in JS but will run entirely on the UI thread (C++)\n  const heavyTask = () => {\n    'worklet';\n    let sum = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 10000000; i++) {\n      sum += i;\n    }\n    result.value = sum;\n    console.log('Calculation done on UI thread:', sum);\n  };\n\n  const handlePress = () => {\n    // Offload to UI thread to keep JS thread responsive for other logic\n    runOnUI(heavyTask)();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native UI Component manager for iOS (Objective-C) to expose a native `UIView` with a specific background color property to React Native.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\n// Expose the 'color' prop. \n// When JS changes this prop, the setter on the native view is called.\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// ColorView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTColorView'\nmodule.exports = requireNativeComponent('RNTColorView');"}
{"instruction": "Create a custom React Native hook using Expo APIs (expo-file-system and expo-sharing) to download an image from a URL to the local cache and immediately invoke the system share dialog.", "output": "import * as FileSystem from 'expo-file-system';\nimport * as Sharing from 'expo-sharing';\nimport { useState } from 'react';\nimport { Alert } from 'react-native';\n\nexport const useDownloadAndShare = () => {\n  const [loading, setLoading] = useState(false);\n\n  const downloadAndShare = async (url: string, fileName: string) => {\n    try {\n      setLoading(true);\n      const result = await FileSystem.downloadAsync(\n        url,\n        FileSystem.cacheDirectory + fileName\n      );\n\n      if (!(await Sharing.isAvailableAsync())) {\n        Alert.alert('Error', 'Sharing is not available on this device');\n        return;\n      }\n\n      await Sharing.shareAsync(result.uri);\n    } catch (error) {\n      console.error(error);\n      Alert.alert('Error', 'Failed to download or share file');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return { downloadAndShare, loading };\n};"}
{"instruction": "Implement a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a basic Android Native Module in Java that exposes a method to get the device's battery level. Include the ReactMethod annotation and the Promise handling.", "output": "package com.myapp;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n            \n            int level = batteryStatus != null ? batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) : -1;\n            int scale = batteryStatus != null ? batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1) : -1;\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Demonstrate Bridge Optimization by creating a Swift Native Module method that accepts an array of strings to process in a single batch, rather than calling the native method multiple times from JavaScript.", "output": "@objc(DataProcessor)\nclass DataProcessor: NSObject {\n  \n  @objc\n  func processBatch(_ data: [String], resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    // Optimization: Processing N items in one bridge call instead of N calls\n    let processedData = data.map { $0.uppercased() }\n    \n    // Simulate heavy work or DB insertion here\n    \n    resolve(processedData)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a synchronous method 'add'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous execution is a key feature of JSI/TurboModules\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Use React Native Reanimated to offload a heavy calculation (e.g., Fibonacci) to the UI thread using a worklet to prevent blocking the JavaScript thread.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n  \n  // This function is marked as a worklet to run on the UI thread\n  const heavyWorklet = (n: number) => {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return 1;\n      return fib(num - 1) + fib(num - 2);\n    };\n    const result = fib(n);\n    console.log(`Fibonacci result on UI Thread: ${result}`);\n  };\n\n  const handlePress = () => {\n    // Dispatch work to UI thread\n    runOnUI(heavyWorklet)(35);\n  };\n\n  return (\n    <View>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};"}
{"instruction": "Implement a parallax scroll effect using Reanimated 3, where a header image translates at half the speed of the scroll view.", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate } from 'react-native-reanimated';\nimport { StyleSheet, View, Dimensions } from 'react-native';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport const ParallaxHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75]),\n        },\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [2, 1, 1]),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/600x400' }}\n        style={[styles.image, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Content goes here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: width, height: IMG_HEIGHT, position: 'absolute' },\n  content: { paddingTop: IMG_HEIGHT, height: 1000, backgroundColor: 'white' },\n});"}
{"instruction": "Create a C++ JSI binding setup (conceptual code) to expose a synchronous global function 'nativeMultiply' to JavaScript. This avoids the asynchronous bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"nativeMultiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          if (count < 2) return Value::undefined();\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Use Expo Sensors (Accelerometer) to create a custom hook that returns the device's current tilt (x, y, z) with a configurable update interval.", "output": "import { useState, useEffect } from 'react';\nimport { Accelerometer } from 'expo-sensors';\n\ninterface AccelerometerData {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport const useDeviceTilt = (interval: number = 100) => {\n  const [data, setData] = useState<AccelerometerData>({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(interval);\n\n    const subscription = Accelerometer.addListener(accelerometerData => {\n      setData(accelerometerData);\n    });\n\n    return () => subscription && subscription.remove();\n  }, [interval]);\n\n  return data;\n};\n"}
{"instruction": "Write an iOS Native Module (Swift) to trigger Haptic Feedback using UIImpactFeedbackGenerator, exposed to React Native.", "output": "import Foundation\nimport UIKit\n\n@objc(HapticFeedback)\nclass HapticFeedback: NSObject {\n\n  @objc\n  func trigger(_ style: String) {\n    DispatchQueue.main.async {\n      let feedbackStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      \n      switch style {\n      case \"light\": feedbackStyle = .light\n      case \"medium\": feedbackStyle = .medium\n      case \"heavy\": feedbackStyle = .heavy\n      default: feedbackStyle = .medium\n      }\n      \n      let generator = UIImpactFeedbackGenerator(style: feedbackStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Create a custom Expo Native Module in Swift that exposes a function to get the device's system name. Include the TypeScript definition.", "output": "// 1. ios/MyDeviceModule.swift\nimport ExpoModulesCore\n\npublic class MyDeviceModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyDevice\")\n\n    Function(\"getSystemName\") { () -> String in\n      return UIDevice.current.systemName\n    }\n  }\n}\n\n// 2. index.ts\nimport { requireNativeModule } from 'expo-modules-core';\n\n// It loads the native module object from the JSI or falls back to the bridge\nconst MyDevice = requireNativeModule('MyDevice');\n\nexport function getSystemName(): string {\n  return MyDevice.getSystemName();\n}"}
{"instruction": "Implement a drag-and-drop interaction using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.changeX + offset.value.x,\n        y: event.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      // Return to origin on release\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native/Libraries/TurboModule/RCTExport';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the arithmetic method\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  getConstants(): {|\n    const1: boolean;\n  |};\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a simple Android Native Module in Kotlin that exposes a 'showToast' method to React Native.", "output": "package com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's 'runOnJS' to call a JavaScript function from the UI thread only when an animation finishes, preventing excessive bridge traffic.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport Animated, { useSharedValue, withTiming, runOnJS } from 'react-native-reanimated';\n\nexport default function OptimizationExample() {\n  const opacity = useSharedValue(0);\n\n  // This function runs on the JavaScript thread\n  const onAnimationFinished = (finished: boolean) => {\n    if (finished) {\n      console.log('Animation finished! JS thread notified.');\n      // Perform JS-heavy logic here (e.g., API calls, state updates)\n    }\n  };\n\n  const startFade = () => {\n    opacity.value = withTiming(1, { duration: 1000 }, (finished) => {\n      // 'finished' callback runs on UI thread.\n      // We invoke runOnJS to cross the bridge explicitly only once.\n      if (finished) {\n        runOnJS(onAnimationFinished)(true);\n      }\n    });\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Animated.View style={{ opacity, width: 100, height: 100, backgroundColor: 'red' }} />\n      <Button title=\"Fade In\" onPress={startFade} />\n    </View>\n  );\n}"}
{"instruction": "Implement an iOS Native Module header and implementation in Objective-C that exports a method to resolve a promise with a random number.", "output": "// RCTRandomNumber.h\n#import <React/RCTBridgeModule.h>\n@interface RCTRandomNumber : NSObject <RCTBridgeModule>\n@end\n\n// RCTRandomNumber.m\n#import \"RCTRandomNumber.h\"\n\n@implementation RCTRandomNumber\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(generate:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSNumber *randomNumber = @(arc4random_uniform(100));\n  resolve(randomNumber);\n}\n\n@end"}
{"instruction": "Use Reanimated to create a sensor-based animation where an image moves based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function GyroScopeParallax() {\n  // Initialize the gyroscope sensor\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, {\n    interval: 10, // Update every 10ms\n  });\n\n  const style = useAnimatedStyle(() => {\n    const { x, y } = animatedSensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(y * 50) }, // Map rotation Y to translation X\n        { translateY: withSpring(x * 50) }, // Map rotation X to translation Y\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, style]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Write a utility function using Expo FileSystem to download an image to the local cache, optimizing performance by avoiding passing base64 strings over the bridge.", "output": "import * as FileSystem from 'expo-file-system';\n\n/**\n * Downloads a file directly to the native file system.\n * This avoids serializing the file data across the JS bridge (base64),\n * which significantly reduces memory usage and frame drops.\n */\nexport const cacheImage = async (remoteUrl: string, fileName: string): Promise<string> => {\n  const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n  \n  try {\n    const { uri } = await FileSystem.downloadAsync(\n      remoteUrl,\n      fileUri\n    );\n    return uri; // Return the local file URI to be used in <Image source={{ uri }} />\n  } catch (e) {\n    console.error('Download failed', e);\n    throw e;\n  }\n};"}
{"instruction": "Implement a Reanimated Layout Animation to automatically animate list items appearing and disappearing without complex state management.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      \n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Enter animation: Fades in and moves up\n          entering={FadeInUp}\n          // Exit animation: Fades out and moves down\n          exiting={FadeOutDown}\n          // Layout transition: Smoothly moves other items when one is removed\n          layout={Layout.springify()}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', marginBottom: 20, gap: 10 },\n  card: { width: 300, height: 50, backgroundColor: '#4CAF50', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Register a custom Native View Manager in Android (Java) to expose a simple TextView to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        TextView textView = new TextView(reactContext);\n        textView.setTextColor(Color.BLACK);\n        return textView;\n    }\n\n    // Expose a property 'text' to JS\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Create a React Native Native Module interface in TypeScript and the corresponding Android Java code to show a native Toast message. This demonstrates the basic Bridge architecture.", "output": "// 1. ToastModule.ts\nimport { NativeModules } from 'react-native';\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\nconst { ToastModule } = NativeModules;\nexport default ToastModule as ToastInterface;\n\n// 2. ToastModule.java (Android)\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should use spring physics when released to return to its original position.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use the modern Expo Modules API (Kotlin) to create a simple native function that returns the device name synchronously. This avoids the asynchronous nature of the legacy bridge.", "output": "// 1. DeviceNameModule.kt (android/src/main/java/...)\npackage expo.modules.devicename\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceNameModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceName\")\n\n    // Synchronous function accessible from JS\n    Function(\"getDeviceName\") {\n      return@Function \"${Build.MANUFACTURER} ${Build.MODEL}\"\n    }\n  }\n}\n\n// 2. index.ts (JavaScript usage)\nimport { requireNativeModule } from 'expo-modules-core';\n\nconst DeviceName = requireNativeModule('DeviceName');\n\nexport function getDeviceName(): string {\n  return DeviceName.getDeviceName();\n}"}
{"instruction": "Optimize Bridge performance by offloading a heavy calculation (e.g., Fibonacci) to the UI thread using a Reanimated Worklet, preventing the JS thread from dropping frames.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcOptimization() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      // Calculate heavy task on UI thread\n      const value = fib(35);\n      \n      // Return result to JS thread\n      runOnJS(setResult)(value);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Task (UI Thread)\" onPress={handleCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom iOS Native UI Component (a simple colored View) and expose it to React Native using `requireNativeComponent`.", "output": "// 1. RNTColorViewManager.m (iOS)\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\nRCT_EXPORT_MODULE(RNTColorView)\nRCT_EXPORT_VIEW_PROPERTY(color, NSString)\n\n- (UIView *)view {\n  return [[UIView alloc] init];\n}\n@end\n\n// 2. ColorView.tsx (React Native)\nimport React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface NativeProps extends ViewProps {\n  color: string;\n}\n\nconst RNTColorView = requireNativeComponent<NativeProps>('RNTColorView');\n\nexport const ColorView = (props: NativeProps) => {\n  return <RNTColorView {...props} style={props.style} />;\n};"}
{"instruction": "Implement a Reanimated ScrollView where the header image scales up (parallax effect) when the user scrolls down (pulls down).", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedRef, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxHeader() {\n  const scrollRef = useAnimatedRef<Animated.ScrollView>();\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler(event => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0], [2, 1], Extrapolation.CLAMP),\n        },\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0], [-IMG_HEIGHT / 2, 0], Extrapolation.CLAMP),\n        }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.ScrollView ref={scrollRef} onScroll={scrollHandler} scrollEventThrottle={16}>\n        <Animated.Image \n          source={{ uri: 'https://via.placeholder.com/300' }} \n          style={[styles.image, imageStyle]} \n        />\n        <View style={{ height: 1000, backgroundColor: 'white' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: '100%', resizeMode: 'cover' },\n});"}
{"instruction": "Use the Expo SecureStore API to securely save and retrieve an authentication token, demonstrating how to handle sensitive data in React Native.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const AuthService = {\n  async saveToken(token: string) {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n      console.log('Token saved securely');\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  async getToken(): Promise<string | null> {\n    try {\n      return await SecureStore.getItemAsync(KEY);\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  async deleteToken() {\n    try {\n      await SecureStore.deleteItemAsync(KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  }\n};"}
{"instruction": "Define a TurboModule specification (New Architecture) in TypeScript. This is the first step in creating a C++ backed module that uses JSI.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Spec file: NativeCalculator.ts\nexport interface Spec extends TurboModule {\n  // Define synchronous methods supported by JSI\n  add(a: number, b: number): number;\n  \n  // Define async methods\n  promiseAdd(a: number, b: number): Promise<number>;\n}\n\n// Get the module. \n// 'Calculator' must match the name in the C++/Java/Obj-C implementation.\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Implement a Reanimated Layout Animation to automatically animate list items appearing and disappearing without manually managing interpolation values.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Remove\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { padding: 20, marginVertical: 10, backgroundColor: '#f0f0f0', borderRadius: 8 }\n});"}
{"instruction": "Utilize `InteractionManager` to optimize bridge traffic by deferring a heavy state update until after a navigation animation or interaction completes.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function HeavyScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Defer execution until animations/interactions are done\n    // This prevents frame drops during screen transitions\n    const interactionPromise = InteractionManager.runAfterInteractions(() => {\n      setIsReady(true);\n      // Perform heavy data fetching or complex rendering prep here\n    });\n\n    return () => interactionPromise.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n        <Text>Waiting for bridge/animations...</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Text>Heavy UI Loaded Safely</Text>\n    </View>\n  );\n}"}
{"instruction": "Create a Native Module in iOS using Swift that exposes a method to get the device's real name, handling the Objective-C bridging.", "output": "// 1. DeviceName.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceName)\nclass DeviceName: NSObject {\n  @objc func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    let name = UIDevice.current.name\n    resolve(name)\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. DeviceName.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceName, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. Usage in TypeScript\nimport { NativeModules } from 'react-native';\nconst { DeviceName } = NativeModules;\n\nexport const getDeviceName = async (): Promise<string> => {\n  return await DeviceName.getDeviceName();\n};"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Native Module in Android using Java that opens the specific application settings page.", "output": "// 1. OpenSettingsModule.java\npackage com.myapp;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class OpenSettingsModule extends ReactContextBaseJavaModule {\n    OpenSettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"OpenSettings\";\n    }\n\n    @ReactMethod\n    public void open() {\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        Uri uri = Uri.fromParts(\"package\", getReactApplicationContext().getPackageName(), null);\n        intent.setData(uri);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        getReactApplicationContext().startActivity(intent);\n    }\n}\n\n// 2. Usage in JS\nimport { NativeModules } from 'react-native';\nconst { OpenSettings } = NativeModules;\n\n// Call OpenSettings.open() to trigger."}
{"instruction": "Define a TurboModule specification (TypeScript) for the New Architecture to create a synchronous calculator module.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition\n  add(a: number, b: number): number;\n  \n  // Asynchronous method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a custom Expo Module using the modern Expo Modules API (Kotlin) that returns a simple string value synchronously.", "output": "// AsyncFunction is standard, but Function allows synchronous return in Expo Modules API\npackage expo.modules.custom\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass CustomModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"CustomModule\")\n\n    // Defines a synchronous function\n    Function(\"hello\") { name: String ->\n      \"Hello, $name!\"\n    }\n  }\n}\n\n// JavaScript Usage:\n// import { requireNativeModule } from 'expo-modules-core';\n// const CustomModule = requireNativeModule('CustomModule');\n// console.log(CustomModule.hello('World')); // Output: \"Hello, World!\""}
{"instruction": "Implement a C++ JSI (JavaScript Interface) installer function to expose a high-performance native method `nativeMultiply` directly to the JS runtime, bypassing the bridge.", "output": "// cpp-adapter.cpp\n#include <jni.h>\n#include <jsi/jsi.h>\n#include \"example.h\"\n\nusing namespace facebook;\n\nvoid install(jsi::Runtime& jsiRuntime) {\n    auto nativeMultiply = jsi::Function::createFromHostFunction(\n        jsiRuntime,\n        jsi::PropNameID::forAscii(jsiRuntime, \"nativeMultiply\"),\n        2, // argument count\n        [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n            double a = arguments[0].asNumber();\n            double b = arguments[1].asNumber();\n            return jsi::Value(a * b);\n        }\n    );\n\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", std::move(nativeMultiply));\n}"}
{"instruction": "Use Reanimated Worklets to offload a heavy calculation (Fibonacci) to the UI thread to prevent blocking the JavaScript thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyTask() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      // This runs on the UI thread (separate from JS thread)\n      const heavyResult = fibonacci(35);\n      \n      // Pass result back to JS thread to update state\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View>\n      <Button title=\"Run Heavy Task\" onPress={handleCalculation} />\n      <Text>Result: {result}</Text>\n    </View>\n  );\n}"}
{"instruction": "Wrap a native iOS UIView (e.g., a colored view) into a React Native component using RCTViewManager.", "output": "// 1. RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// 2. ColorView.tsx\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColorViewProps extends ViewProps {\n  backgroundColor?: string;\n}\n\nconst RNTColorView = requireNativeComponent<ColorViewProps>('RNTColorView');\n\nexport default RNTColorView;"}
{"instruction": "Implement a scroll-driven animation using Reanimated where a header's opacity changes based on the ScrollView's offset.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 60, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#eee' }\n});"}
{"instruction": "Optimize a FlatList by implementing `getItemLayout` to skip measurement calculations, reducing bridge traffic during scroll.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\nconst ITEM_HEIGHT = 50;\n\nconst OptimizedList = () => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: ITEM_HEIGHT, justifyContent: 'center' }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  // Optimization: Allows RN to calculate layout without measuring every item\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  return (\n    <FlatList\n      data={DATA}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nexport default OptimizedList;"}
{"instruction": "Create a basic iOS Native Module using Swift that exposes a method `getDeviceName` to React Native. The method should return the device name via a Promise. Include the Objective-C bridging header export.", "output": "// DeviceModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceModule.m (Objective-C Export)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a simple Android Native Module using Kotlin that exposes a `showToast` method. This method takes a string message and displays a short Android Toast.", "output": "// ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String) {\n        val toast = Toast.makeText(reactApplicationContext, message, Toast.LENGTH_SHORT)\n        toast.show()\n    }\n}"}
{"instruction": "Implement a draggable box component using `react-native-reanimated` (v3) and `react-native-gesture-handler`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const pan = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use `expo-secure-store` to create a TypeScript utility object with methods to safely save, retrieve, and delete a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst TOKEN_KEY = 'user_auth_token';\n\nexport const AuthStorage = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(TOKEN_KEY, token);\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    try {\n      await SecureStore.deleteItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  },\n};"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator`. It should support a synchronous `add` method.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // TurboModules allow synchronous execution if defined in the spec\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's `runOnUI` to execute a heavy calculation synchronously on the UI thread without blocking the JS thread, triggered by a button press.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nfunction heavyCalculationUI(input: number) {\n  'worklet';\n  // This runs on the UI thread via JSI, bypassing the async bridge\n  const result = Math.pow(input, 50); \n  console.log('Calculation result on UI Thread:', result);\n}\n\nexport default function BridgeOptimizationExample() {\n  const handlePress = () => {\n    // Dispatch work to UI thread immediately\n    runOnUI(heavyCalculationUI)(100);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy UI Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a Reanimated component that uses Layout Animations to fade and slide in a list item when it mounts (`Entering`).", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<string[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, `Item ${prev.length + 1}`]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <View style={styles.list}>\n        {items.map((item, index) => (\n          <Animated.View \n            key={index} \n            entering={FadeInLeft.delay(index * 100).springify()} \n            layout={Layout.springify()}\n            style={styles.card}\n          >\n            <Text style={styles.text}>{item}</Text>\n          </Animated.View>\n        ))}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  list: { marginTop: 20 },\n  card: { height: 50, backgroundColor: '#4CAF50', marginBottom: 10, justifyContent: 'center', paddingLeft: 15, borderRadius: 8 },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write an Expo component using `expo-camera` (modern `CameraView`) to display a camera preview and a button to toggle the facing mode.", "output": "import { CameraView, useCameraPermissions, CameraType } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View, TouchableOpacity } from 'react-native';\n\nexport default function App() {\n  const [facing, setFacing] = useState<CameraType>('back');\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) return <View />;\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  function toggleCameraFacing() {\n    setFacing(current => (current === 'back' ? 'front' : 'back'));\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing={facing}>\n        <View style={styles.buttonContainer}>\n          <TouchableOpacity style={styles.button} onPress={toggleCameraFacing}>\n            <Text style={styles.text}>Flip Camera</Text>\n          </TouchableOpacity>\n        </View>\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: { flex: 1, flexDirection: 'row', backgroundColor: 'transparent', margin: 64 },\n  button: { flex: 1, alignSelf: 'flex-end', alignItems: 'center' },\n  text: { fontSize: 24, fontWeight: 'bold', color: 'white' },\n});"}
{"instruction": "Expose a native iOS `UIView` (colored red) as a component named `RNTMap` using the Bridge architecture (requireNativeComponent).", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  UIView *view = [[UIView alloc] init];\n  view.backgroundColor = [UIColor redColor];\n  return view;\n}\n\n@end\n\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nmodule.exports = requireNativeComponent('RNTMap');"}
{"instruction": "Optimize a large list rendering using `FlashList` (from Shopify) to improve performance over `FlatList`. Create a simple component rendering 1000 items.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nexport default function OptimizedList() {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});"}
{"instruction": "Create a draggable box component using 'react-native-reanimated' and 'react-native-gesture-handler' that runs on the UI thread to optimize bridge usage.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      // Runs on UI thread, no bridge crossing per frame\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      // Spring back to start\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a basic Android Native Module in Java that exposes a method to show a native Toast message.", "output": "package com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to React Native: NativeModules.ToastModule\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the function signature\n  add(a: number, b: number): Promise<number>;\n}\n\n// Load the module; 'NativeCalculator' must match the native name\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Use Expo's 'expo-file-system' to create a function that writes a text string to a file in the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const saveFile = async (filename: string, content: string): Promise<void> => {\n  const fileUri = FileSystem.documentDirectory + filename;\n  try {\n    await FileSystem.writeAsStringAsync(fileUri, content, {\n      encoding: FileSystem.EncodingType.UTF8,\n    });\n    console.log('File saved to:', fileUri);\n  } catch (error) {\n    console.error('Error saving file:', error);\n  }\n};"}
{"instruction": "Implement a Reanimated 'worklet' to offload a heavy calculation (e.g., Fibonacci) to the UI thread, ensuring the JS thread remains responsive.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  // This function is defined in JS but marked as worklet to run on UI thread\n  const heavyTask = () => {\n    'worklet';\n    const fib = (n) => {\n      if (n <= 1) return n;\n      return fib(n - 1) + fib(n - 2);\n    };\n    const result = fib(35); // Heavy calculation\n    console.log(`Calculation finished on UI thread: ${result}`);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button \n        title=\"Run Heavy Task on UI Thread\"\n        onPress={() => runOnUI(heavyTask)()} \n      />\n    </View>\n  );\n}"}
{"instruction": "Create a simple iOS Native Module in Swift (with Obj-C bridging header assumed) that exposes a function to get the device name.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc\n  func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m (Obj-C Export)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n// RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n// @end"}
{"instruction": "Use 'react-native-reanimated' `useAnimatedProps` to animate the radius of an SVG Circle directly on the UI thread (requires react-native-svg).", "output": "import React, { useEffect } from 'react';\nimport Svg, { Circle } from 'react-native-svg';\nimport Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming } from 'react-native-reanimated';\n\n// Create an animated component from the SVG Circle\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport default function PulsingCircle() {\n  const r = useSharedValue(10);\n\n  useEffect(() => {\n    // Animate radius from 10 to 50 repeatedly\n    r.value = withRepeat(withTiming(50, { duration: 1000 }), -1, true);\n  }, []);\n\n  // Map shared value to props. Runs on UI thread.\n  const animatedProps = useAnimatedProps(() => ({\n    r: r.value,\n  }));\n\n  return (\n    <Svg height=\"200\" width=\"200\">\n      <AnimatedCircle \n        cx=\"100\" \n        cy=\"100\" \n        fill=\"red\" \n        animatedProps={animatedProps} \n      />\n    </Svg>\n  );\n}"}
{"instruction": "Implement an Expo 'BarCodeScanner' component to scan QR codes using 'expo-camera'.", "output": "import React, { useState, useEffect } from 'react';\nimport { Text, View, StyleSheet, Button } from 'react-native';\nimport { CameraView, Camera } from 'expo-camera';\n\nexport default function QRScanner() {\n  const [hasPermission, setHasPermission] = useState<boolean | null>(null);\n  const [scanned, setScanned] = useState(false);\n\n  useEffect(() => {\n    (async () => {\n      const { status } = await Camera.requestCameraPermissionsAsync();\n      setHasPermission(status === 'granted');\n    })();\n  }, []);\n\n  const handleBarCodeScanned = ({ type, data }: { type: string; data: string }) => {\n    setScanned(true);\n    alert(`Bar code with type ${type} and data ${data} has been scanned!`);\n  };\n\n  if (hasPermission === null) return <Text>Requesting for camera permission</Text>;\n  if (hasPermission === false) return <Text>No access to camera</Text>;\n\n  return (\n    <View style={StyleSheet.absoluteFillObject}>\n      <CameraView\n        onBarcodeScanned={scanned ? undefined : handleBarCodeScanned}\n        barcodeScannerSettings={{ barcodeTypes: ['qr'] }}\n        style={StyleSheet.absoluteFillObject}\n      />\n      {scanned && <Button title={'Tap to Scan Again'} onPress={() => setScanned(false)} />}\n    </View>\n  );\n}"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on scroll position.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100], // Input range\n      [0, 1],   // Output range\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 80, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  headerText: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Use 'expo-haptics' to trigger a tactile feedback when a user presses a button.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Triggers a light impact feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Haptic feedback triggered');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that creates a draggable box. Use the 'react-native-gesture-handler' library to handle the Pan gesture and update the X and Y coordinates of the box smoothly on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Spring back to center on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a native Android Java module for React Native that exposes a method 'getDeviceName' which returns the device model name via a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                promise.resolve(capitalize(model));\n            } else {\n                promise.resolve(capitalize(manufacturer) + \" \" + model);\n            }\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n\n    private String capitalize(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        char first = s.charAt(0);\n        if (Character.isUpperCase(first)) return s;\n        return Character.toUpperCase(first) + s.substring(1);\n    }\n}"}
{"instruction": "Using Expo, create a function that requests biometric authentication (FaceID/TouchID) using 'expo-local-authentication' and returns a boolean indicating success.", "output": "import * as LocalAuthentication from 'expo-local-authentication';\n\nexport const authenticateUser = async (): Promise<boolean> => {\n  try {\n    const hasHardware = await LocalAuthentication.hasHardwareAsync();\n    if (!hasHardware) return false;\n\n    const isEnrolled = await LocalAuthentication.isEnrolledAsync();\n    if (!isEnrolled) return false;\n\n    const result = await LocalAuthentication.authenticateAsync({\n      promptMessage: 'Authenticate to continue',\n      fallbackLabel: 'Use Passcode',\n    });\n\n    return result.success;\n  } catch (error) {\n    console.error('Biometric Auth Error:', error);\n    return false;\n  }\n};"}
{"instruction": "Implement a 'Collapsible Header' using 'react-native-reanimated'. The header should fade out and translate upwards as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nconst CollapsibleHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const translateY = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, -100],\n      Extrapolation.CLAMP\n    );\n    \n    const opacity = interpolate(\n      scrollY.value,\n      [0, 80],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n\n    return {\n      transform: [{ translateY }],\n      opacity,\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>My Header</Text>\n      </Animated.View>\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={styles.scrollContent}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}>\n            <Text>Item {i + 1}</Text>\n          </View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 100,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontSize: 20, fontWeight: 'bold' },\n  scrollContent: { paddingTop: 100 },\n  item: { height: 80, borderBottomWidth: 1, borderColor: '#ccc', justifyContent: 'center', padding: 20 },\n});\n\nexport default CollapsibleHeader;"}
{"instruction": "Demonstrate bridge optimization by using 'react-native-mmkv' (which uses JSI) instead of 'AsyncStorage' to synchronously read and write a user object.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize MMKV instance\nexport const storage = new MMKV();\n\ninterface User {\n  id: string;\n  name: string;\n  preferences: { theme: 'dark' | 'light' };\n}\n\n// JSI allows synchronous execution, avoiding the async bridge serialization overhead\nexport const saveUser = (user: User) => {\n  storage.set('user_session', JSON.stringify(user));\n};\n\nexport const getUser = (): User | null => {\n  const userJson = storage.getString('user_session');\n  if (userJson) {\n    return JSON.parse(userJson);\n  }\n  return null;\n};\n\nexport const deleteUser = () => {\n  storage.delete('user_session');\n};"}
{"instruction": "Create a simple Native Module in Swift (iOS) that creates a system alert dialog. Include the Objective-C bridge macro export.", "output": "// AlertModule.swift\nimport Foundation\nimport UIKit\n\n@objc(AlertModule)\nclass AlertModule: NSObject {\n  \n  @objc(showAlert:message:)\n  func showAlert(_ title: String, message: String) {\n    DispatchQueue.main.async {\n      let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)\n      alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))\n      \n      if let rootVC = UIApplication.shared.windows.first?.rootViewController {\n        rootVC.present(alert, animated: true, completion: nil)\n      }\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// AlertModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(AlertModule, NSObject)\n  RCT_EXTERN_METHOD(showAlert:(NSString *)title message:(NSString *)message)\n@end"}
{"instruction": "Optimize a large list rendering in React Native using 'FlashList' (by Shopify) to minimize blank cells and improve JS thread performance compared to FlatList.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 2000 }).map((_, i) => ({\n  id: i.toString(),\n  title: `Item ${i}`,\n}));\n\nconst MyOptimizedList = () => {\n  return (\n    <View style={styles.container}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        // estimatedItemSize is crucial for FlashList performance optimization\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, width: '100%' },\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderColor: '#eee',\n  },\n});\n\nexport default MyOptimizedList;"}
{"instruction": "Use Expo's 'expo-haptics' and 'react-native-reanimated' to create a button that scales down when pressed and triggers a haptic feedback.", "output": "import React from 'react';\nimport { Pressable, StyleSheet, Text } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nconst HapticButton = () => {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ scale: scale.value }],\n    };\n  });\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1);\n  };\n\n  return (\n    <AnimatedPressable\n      style={[styles.button, animatedStyle]}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n    >\n      <Text style={styles.text}>Press Me</Text>\n    </AnimatedPressable>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    backgroundColor: '#6200ee',\n    paddingVertical: 15,\n    paddingHorizontal: 30,\n    borderRadius: 8,\n  },\n  text: { color: 'white', fontWeight: 'bold', fontSize: 16 },\n});\n\nexport default HapticButton;"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list when a 'Delete' button is pressed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet, TouchableOpacity } from 'react-native';\nimport Animated, { FadeInUp, FadeOutLeft, Layout } from 'react-native-reanimated';\n\nconst LayoutAnimationExample = () => {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (idToRemove: number) => {\n    setItems((current) => current.filter((id) => id !== idToRemove));\n  };\n\n  const addItem = () => {\n    const newId = items.length > 0 ? Math.max(...items) + 1 : 1;\n    setItems((current) => [newId, ...current]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutLeft}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item {item}</Text>\n          <TouchableOpacity onPress={() => removeItem(item)}>\n            <Text style={styles.deleteText}>Delete</Text>\n          </TouchableOpacity>\n        </Animated.View>\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, paddingTop: 50 },\n  card: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    padding: 20,\n    backgroundColor: 'white',\n    marginBottom: 10,\n    borderRadius: 8,\n    elevation: 2,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n  },\n  deleteText: { color: 'red' },\n});\n\nexport default LayoutAnimationExample;"}
{"instruction": "Create a TurboModule specification (TypeScript interface) for the New Architecture to expose a calculator with a 'add' method. This demonstrates Type-Safe Native Modules.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\n// The interface must extend TurboModule\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n  \n  // Synchronous method example (JSI)\n  multiply(a: number, b: number): number;\n}\n\n// Load the module, defaulting to null if not linked\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method to get the device model name via a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n\n    DeviceInfoModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceInfo\";\n    }\n\n    @ReactMethod\n    public void getModel(Promise promise) {\n        try {\n            String model = Build.MODEL;\n            promise.resolve(model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The logic must run on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write an Expo Config Plugin to automatically add the 'android.permission.CAMERA' permission to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const permissions = androidManifest.manifest['uses-permission'];\n    const hasCamera = permissions.some(p => p.$['android:name'] === 'android.permission.CAMERA');\n\n    if (!hasCamera) {\n      permissions.push({\n        $: { 'android:name': 'android.permission.CAMERA' }\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) named 'NativeCalculator' that includes a synchronous 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method execution via JSI\n  add(a: number, b: number): number;\n  \n  // Async method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on scroll position, ensuring no bridge traffic during scrolling.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { \n    position: 'absolute', top: 0, left: 0, right: 0, \n    height: 60, backgroundColor: 'white', elevation: 5, \n    zIndex: 1, justifyContent: 'center', alignItems: 'center' \n  }\n});"}
{"instruction": "Create an iOS Native Module (Swift) setup that exposes a method to open the device Settings app.", "output": "// CalendarManager.swift\nimport Foundation\nimport React\n\n@objc(SettingsModule)\nclass SettingsModule: NSObject {\n\n  @objc\n  func openSettings() {\n    DispatchQueue.main.async {\n      if let url = URL(string: UIApplication.openSettingsURLString) {\n        if UIApplication.shared.canOpenURL(url) {\n          UIApplication.shared.open(url, options: [:], completionHandler: nil)\n        }\n      }\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// SettingsModule.m (Objective-C Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(SettingsModule, NSObject)\n// RCT_EXTERN_METHOD(openSettings)\n// @end"}
{"instruction": "Use `expo-file-system` to download an image to the local cache and read it as a Base64 string.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadAndReadImage = async (remoteUrl: string): Promise<string | null> => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'temp_image.jpg';\n    \n    const downloadRes = await FileSystem.downloadAsync(remoteUrl, fileUri);\n    \n    if (downloadRes.status === 200) {\n      const base64 = await FileSystem.readAsStringAsync(downloadRes.uri, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n      return base64;\n    }\n    return null;\n  } catch (error) {\n    console.error('Download failed', error);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate Bridge Optimization by calling a JavaScript function from the UI thread using Reanimated's `runOnJS` only when a gesture ends.", "output": "import { runOnJS } from 'react-native-reanimated';\nimport { Gesture } from 'react-native-gesture-handler';\n\nexport const useEndGesture = (onFinished: () => void) => {\n  // This function lives in the JS thread\n  const handleFinish = () => {\n    console.log('Gesture finished, heavy JS logic here');\n    onFinished();\n  };\n\n  // The gesture handler runs on the UI thread to prevent lag\n  const gesture = Gesture.Pan()\n    .onEnd(() => {\n      'worklet';\n      // Cross the bridge only once at the end\n      runOnJS(handleFinish)();\n    });\n\n  return gesture;\n};"}
{"instruction": "Create a secure storage helper using `expo-secure-store` to save and retrieve a user token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const TokenService = {\n  saveToken: async (token: string): Promise<void> => {\n    await SecureStore.setItemAsync(KEY, token, {\n      keychainAccessible: SecureStore.WHEN_UNLOCKED,\n    });\n  },\n\n  getToken: async (): Promise<string | null> => {\n    return await SecureStore.getItemAsync(KEY);\n  },\n\n  deleteToken: async (): Promise<void> => {\n    await SecureStore.deleteItemAsync(KEY);\n  }\n};"}
{"instruction": "Implement an Android Native Module method that sends a 'Progress' event to JavaScript repeatedly using `DeviceEventManagerModule`.", "output": "private void sendEvent(ReactContext reactContext, String eventName, WritableMap params) {\n    reactContext\n        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n        .emit(eventName, params);\n}\n\n@ReactMethod\npublic void startProgress() {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            for (int i = 0; i <= 100; i += 10) {\n                try {\n                    Thread.sleep(500);\n                    WritableMap params = Arguments.createMap();\n                    params.putInt(\"progress\", i);\n                    sendEvent(getReactApplicationContext(), \"onProgress\", params);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }).start();\n}"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport const DraggableBox = () => {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method to add numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  multiply(a: number, b: number): number;\n}\n\n// Retrieve the module, enforcing the Spec\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Create a minimal Expo Module definition (using the Expo Modules API) in TypeScript that exposes a synchronous function to get the device model name.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// 1. Define the interface for the events and methods\ninterface DeviceInfoModule {\n  getDeviceModel(): string;\n}\n\n// 2. Import the native module\n// This assumes you have created the native code (Swift/Kotlin) registered as 'DeviceInfo'\nconst DeviceInfo = requireNativeModule<DeviceInfoModule>('DeviceInfo');\n\n// 3. Export a wrapper function\nexport function getModel(): string {\n  return DeviceInfo.getDeviceModel();\n}"}
{"instruction": "Implement a 'runOnUI' worklet using Reanimated to perform a heavy calculation on the UI thread to avoid blocking the JS thread.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n\n  // This function is marked as a worklet automatically by Reanimated babel plugin\n  // when used inside runOnUI, or can be explicitly marked with 'worklet';\n  const heavyTask = (input: number) => {\n    'worklet';\n    let result = 0;\n    // Simulate heavy synchronous work on the UI thread\n    for (let i = 0; i < input * 1000000; i++) {\n      result += Math.sqrt(i);\n    }\n    console.log('Calculation done on UI thread:', result);\n  };\n\n  const handlePress = () => {\n    // Dispatch work to UI thread\n    runOnUI(heavyTask)(5);\n    Alert.alert('Task dispatched', 'Check console logs');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />\n    </View>\n  );\n};\n"}
{"instruction": "Write a Java class for a legacy Android Native Module that exposes a method to show a Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to JavaScript\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    // Method exposed to JavaScript\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Optimize a FlatList rendering by using `memo` and `useCallback` to prevent unnecessary bridge traffic and re-renders of list items.", "output": "import React, { useCallback, memo } from 'react';\nimport { FlatList, Text, View, StyleSheet, ListRenderItem } from 'react-native';\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\n// 1. Memoize the child component to prevent re-renders if props haven't changed\nconst ListItem = memo(({ title, onPress }: { title: string; onPress: () => void }) => {\n  console.log(`Rendering ${title}`);\n  return (\n    <View style={styles.item}>\n      <Text onPress={onPress}>{title}</Text>\n    </View>\n  );\n});\n\nexport const OptimizedList = ({ data }: { data: ItemData[] }) => {\n  \n  // 2. Use useCallback to ensure the function reference remains stable across renders\n  const handlePress = useCallback((item: ItemData) => {\n    console.log('Pressed', item.id);\n  }, []);\n\n  // 3. RenderItem function logic\n  const renderItem: ListRenderItem<ItemData> = useCallback(({ item }) => (\n    <ListItem \n      title={item.title} \n      onPress={() => handlePress(item)} // Passing a stable function reference if possible, or wrapping ListItem logic\n    />\n  ), [handlePress]);\n\n  const keyExtractor = useCallback((item: ItemData) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      // Optimization props\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { padding: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Create a Swift Native Module (iOS) that resolves a Promise with the system version.", "output": "@objc(SystemInfo)\nclass SystemInfo: NSObject {\n\n  // Required to expose to React Native\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n\n  // Exposed method with Promise (Resolver/Rejecter)\n  @objc(getSystemVersion:rejecter:)\n  func getSystemVersion(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let version = UIDevice.current.systemVersion\n    if !version.isEmpty {\n      resolve(version)\n    } else {\n      let error = NSError(domain: \"SystemInfo\", code: 200, userInfo: nil)\n      reject(\"NO_VERSION\", \"Could not get system version\", error)\n    }\n  }\n}"}
{"instruction": "Use Reanimated's `useAnimatedScrollHandler` to create a collapsing header effect based on scroll position.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const CollapsingHeader = () => {\n  const scrollY = useSharedValue(0);\n  const HEADER_HEIGHT = 200;\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(\n      scrollY.value,\n      [0, HEADER_HEIGHT],\n      [HEADER_HEIGHT, 50],\n      Extrapolation.CLAMP\n    );\n    \n    const opacity = interpolate(\n      scrollY.value,\n      [0, HEADER_HEIGHT / 2],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n\n    return { height, opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: 10 }}\n      >\n        {/* Content placeholders */}\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.listItem} />\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { width: '100%', backgroundColor: 'tomato', position: 'absolute', top: 0, zIndex: 1 },\n  listItem: { height: 100, backgroundColor: '#eee', margin: 10, borderRadius: 8 }\n});"}
{"instruction": "Bridge Optimization: Create a JavaScript helper that passes large data to a native module as a JSON string instead of a JS Object to avoid costly serialization over the bridge.", "output": "import { NativeModules } from 'react-native';\n\nconst { LargeDataModule } = NativeModules;\n\n/**\n * Sends large datasets to native side.\n * Optimization: Serialization of large nested objects over the Bridge is expensive.\n * JSON.stringify() in V8/Hermes is often faster than the Bridge's object traversal.\n * \n * @param data - Complex object to send\n */\nexport const processLargeData = async (data: Record<string, any>) => {\n  try {\n    // Convert to string in JS thread\n    const jsonString = JSON.stringify(data);\n    \n    // Pass a single string across the bridge rather than a deep map\n    const result = await LargeDataModule.processDataString(jsonString);\n    \n    return JSON.parse(result);\n  } catch (error) {\n    console.error('Bridge transfer failed', error);\n    throw error;\n  }\n};"}
{"instruction": "Use Expo FileSystem to download a file and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress * 100}%`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a basic iOS Native Module using Swift and the classic Bridge that exports a method to get the device name. Provide both the Swift implementation and the Objective-C bridge header.", "output": "// DeviceInfoModule.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfoModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// DeviceInfoModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfoModule)\nclass DeviceInfoModule: NSObject {\n  \n  @objc\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Create a draggable box component using `react-native-reanimated` (v3) and `react-native-gesture-handler`. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' that includes a method to add two numbers.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('Calculator') as Spec | null;"}
{"instruction": "Write an Android Native Module in Kotlin that opens a specific URL in the system's default browser.", "output": "package com.myapp.modules\n\nimport android.content.Intent\nimport android.net.Uri\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass BrowserLinkModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"BrowserLinkModule\"\n    }\n\n    @ReactMethod\n    fun openLink(url: String) {\n        val intent = Intent(Intent.ACTION_VIEW)\n        intent.data = Uri.parse(url)\n        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n        reactApplicationContext.startActivity(intent)\n    }\n}"}
{"instruction": "Demonstrate how to offload a heavy synchronous calculation to the UI thread using Reanimated 'worklets' to prevent the JavaScript thread (and the Bridge) from freezing.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A heavy function defined as a worklet\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = input;\n  for (let i = 0; i < 10000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished on UI thread:', result);\n}\n\nexport default function HeavyTaskComponent() {\n  const handlePress = () => {\n    // Execute on UI thread, bypassing the JS thread entirely for the loop\n    runOnUI(heavyCalculation)(5);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a native module using the modern Expo Modules API (Swift) that exposes a function to get the current battery level.", "output": "import ExpoModulesCore\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a Reanimated Layout Animation to animate items appearing and disappearing in a list, replacing the need for complex LayoutAnimation bridge calls.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          style={styles.item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', gap: 10, marginBottom: 20 },\n  item: { width: 300, height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nasync function downloadImage(remoteUrl: string, fileName: string) {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}"}
{"instruction": "Optimize a long list using `@shopify/flash-list` instead of `FlatList` to improve performance on the bridge by recycling views more efficiently.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }).map((_, i) => ({ id: i, title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, justifyContent: 'center', padding: 10, borderBottomWidth: 1, borderColor: '#ccc' },\n});\n\nexport default MyList;"}
{"instruction": "Demonstrate the usage of `react-native-mmkv` to store and retrieve data synchronously using JSI, bypassing the asynchronous bridge calls typical of `AsyncStorage`.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize the storage (JSI binding happens here)\nexport const storage = new MMKV();\n\n// Synchronous set\nexport const saveUser = (user: { id: string; name: string }) => {\n  storage.set('user.id', user.id);\n  storage.set('user.name', user.name);\n  storage.set('user.isLoggedIn', true);\n};\n\n// Synchronous get\nexport const getUser = () => {\n  const id = storage.getString('user.id');\n  const name = storage.getString('user.name');\n  const isLoggedIn = storage.getBoolean('user.isLoggedIn');\n\n  if (isLoggedIn && id && name) {\n    return { id, name };\n  }\n  return null;\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: isPressed.value ? 1.2 : 1 },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Write a Native Module in Java (Android) to expose a method `getBatteryLevel` to React Native.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create a minimal Expo Module using the Expo Modules API (Kotlin) that returns the device name synchronously.", "output": "package expo.modules.devicename\n\nimport android.os.Build\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass DeviceNameModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceName\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getDeviceName\") {\n      return@Function Build.MODEL\n    }\n  }\n}"}
{"instruction": "Implement a Reanimated 'Scroll to Top' button that smoothly fades in only after the user scrolls down 100 pixels.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, withTiming, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollToTopExample() {\n  const scrollY = useSharedValue(0);\n  const listRef = React.useRef(null);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const buttonStyle = useAnimatedStyle(() => {\n    return {\n      opacity: withTiming(scrollY.value > 100 ? 1 : 0),\n      transform: [\n        { scale: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP) }\n      ]\n    };\n  });\n\n  const scrollToTop = () => {\n    listRef.current?.scrollTo({ y: 0, animated: true });\n  };\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.ScrollView\n        ref={listRef}\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n      >\n        {Array.from({ length: 50 }).map((_, i) => (\n          <View key={i} style={styles.item} />\n        ))}\n      </Animated.ScrollView>\n\n      <Animated.View style={[styles.floatingBtn, buttonStyle]}>\n        <Button title=\"Top\" onPress={scrollToTop} />\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { height: 50, margin: 10, backgroundColor: '#ddd' },\n  floatingBtn: { position: 'absolute', bottom: 20, right: 20 },\n});"}
{"instruction": "Demonstrate Bridge Optimization by avoiding passing a Base64 string over the bridge. Instead, write a function that saves data to a file and passes the URI.", "output": "// Optimization Strategy: Avoid serializing large Base64 strings across the JSON bridge.\n// Instead, write to the filesystem on the native side and pass the file path (string) to JS.\n\n// 1. Native Module Method (Pseudocode/Java)\n/*\n@ReactMethod\npublic void processLargeImage(String inputUri, Promise promise) {\n    // Perform heavy image processing in native code...\n    File outputFile = new File(getReactApplicationContext().getCacheDir(), \"processed.jpg\");\n    // Save bitmap to outputFile...\n    \n    // Return ONLY the path, not the base64 data\n    promise.resolve(\"file://\" + outputFile.getAbsolutePath());\n}\n*/\n\n// 2. React Native Usage\nimport { NativeModules, Image } from 'react-native';\nconst { ImageProcessor } = NativeModules;\n\nasync function handleImage(originalUri: string) {\n  try {\n    // Good: Passing small strings (URIs)\n    const newUri = await ImageProcessor.processLargeImage(originalUri);\n    \n    // Display using URI, bypassing JS thread heavy lifting\n    return <Image source={{ uri: newUri }} style={{ width: 100, height: 100 }} />;\n  } catch (e) {\n    console.error(e);\n  }\n}"}
{"instruction": "Create a custom Native UI Component (ViewManager) in Java to expose a native Android TextView to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        return new TextView(reactContext);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(TextView view, String color) {\n        view.setTextColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Use Reanimated `useAnimatedSensor` to create a 3D rotation effect on an image based on the device gyroscope.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, { interval: 10 });\n\n  const style = useAnimatedStyle(() => {\n    const pitch = animatedSensor.sensor.value.x;\n    const roll = animatedSensor.sensor.value.y;\n\n    return {\n      transform: [\n        { perspective: 1000 },\n        { rotateX: withTiming(`${pitch * 20}deg`, { duration: 50 }) },\n        { rotateY: withTiming(`${roll * 20}deg`, { duration: 50 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={[styles.image, style]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  image: { width: 200, height: 200 },\n});"}
{"instruction": "Implement a Swift (iOS) Native Module that exposes a method to trigger Haptic Feedback.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func trigger(_ type: String) {\n    DispatchQueue.main.async {\n      let generator = UIImpactFeedbackGenerator(style: .medium)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Objective-C Bridge)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(HapticModule, NSObject)\nRCT_EXTERN_METHOD(trigger:(NSString *)type)\n@end\n*/"}
{"instruction": "Using Expo's `expo-file-system`, download a file from a URL and save it locally.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadFile = async (url: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a JSI (JavaScript Interface) setup snippet in C++ to demonstrate how to bind a synchronous C++ function to the global JavaScript object (Bridge Optimization).", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\n// This function would be called from your Native Module's install/initialize method\nvoid installJSIBindings(Runtime &runtime) {\n  \n  // Define a C++ function\n  auto multiply = Function::createFromHostFunction(\n      runtime,\n      PropNameID::forAscii(runtime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n      }\n  );\n\n  // Bind it to the global object so JS can call global.multiply(2, 4)\n  runtime.global().setProperty(runtime, \"multiply\", move(multiply));\n}"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should include a synchronous method `add(a: number, b: number): number`.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition\n  add(a: number, b: number): number;\n}\n\n// Load the module, enforcing the Spec\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a legacy Android Native Module in Java that exposes a method to show a Toast message, and provide the JavaScript wrapper.", "output": "// Android: ToastModule.java\n/*\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// JavaScript: ToastModule.ts\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Implement a scroll-based animation using Reanimated where a header's opacity decreases as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Fading Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, padding: 20 }}>\n          <Text>Scroll content...</Text>\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Demonstrate how to optimize a heavy calculation by running it on the UI thread using Reanimated's `runOnUI`, completely bypassing the React Native Bridge.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that runs purely in the JS context (if called normally) \n// or on the UI thread (if called via runOnUI).\nfunction heavyCalculation(input: number) {\n  'worklet';\n  // Simulate work\n  let result = input;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation result on UI thread:', result);\n}\n\nexport default function HeavyTaskComponent() {\n  const handlePress = () => {\n    // Dispatch work to UI thread to avoid freezing JS thread (Bridge optimization)\n    runOnUI(heavyCalculation)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Worklet\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native UI Component wrapper for a hypothetical iOS 'RNTMap' view using `requireNativeComponent`.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface NativeMapProps extends ViewProps {\n  zoomEnabled?: boolean;\n  region?: {\n    latitude: number;\n    longitude: number;\n    latitudeDelta: number;\n    longitudeDelta: number;\n  };\n  onRegionChange?: (event: any) => void;\n}\n\n// 'RNTMap' refers to the name registered in the Objective-C/Swift ViewManager\nconst RNTMap = requireNativeComponent<NativeMapProps>('RNTMap');\n\nexport default RNTMap;"}
{"instruction": "Use the Expo Modules API (TypeScript/JavaScript side) to implement a class-based module definition for a Battery module, including a listener for level changes.", "output": "import { EventEmitter, Subscription } from 'expo-modules-core';\nimport ExpoBatteryModule from './ExpoBatteryModule'; // The Native Module binding\n\nconst emitter = new EventEmitter(ExpoBatteryModule);\n\nexport function getBatteryLevel(): number {\n  return ExpoBatteryModule.getBatteryLevel();\n}\n\nexport function addBatteryLevelListener(listener: (event: { level: number }) => void): Subscription {\n  return emitter.addListener('onBatteryLevelChange', listener);\n}\n\n// Usage example:\n// useEffect(() => {\n//   const sub = addBatteryLevelListener(({ level }) => console.log(level));\n//   return () => sub.remove();\n// }, []);"}
{"instruction": "Implement a layout animation using Reanimated's `Entering` and `Exiting` modifiers for a list item to animate mounting and unmounting.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function LayoutAnimationExample() {\n  const [show, setShow] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View \n          entering={FadeInUp.duration(500)} \n          exiting={FadeOutDown.duration(500)} \n          style={styles.box} \n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', marginTop: 100 },\n  box: { width: 100, height: 100, backgroundColor: 'green', marginTop: 20, borderRadius: 10 }\n});"}
{"instruction": "Use `InteractionManager` to defer a heavy operation until after animations/transitions are complete to ensure UI smoothness.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function DeferredRender() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Schedule the heavy task after animations/transitions finish\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy setup or data processing here\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>Heavy content loaded smoothly!</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a custom Expo hook `useCameraPermissions` that requests camera permissions on mount.", "output": "import { useEffect, useState } from 'react';\nimport { Camera, PermissionResponse } from 'expo-camera';\n\nexport function useCameraPermissions() {\n  const [permission, setPermission] = useState<PermissionResponse | null>(null);\n\n  useEffect(() => {\n    (async () => {\n      const response = await Camera.requestCameraPermissionsAsync();\n      setPermission(response);\n    })();\n  }, []);\n\n  return {\n    granted: permission?.granted ?? false,\n    canAskAgain: permission?.canAskAgain ?? true,\n    status: permission?.status,\n  };\n}"}
{"instruction": "Create a React Native component using `react-native-reanimated` and `react-native-gesture-handler` that implements a draggable square box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a native Android module (Java) for React Native to expose a method `getDeviceName` that returns the Android model name via a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n   DeviceInfoModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceInfo\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           String model = Build.MODEL;\n           promise.resolve(model);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Demonstrate how to offload a heavy calculation (e.g., Fibonacci sequence) to the UI thread using a Reanimated Worklet to prevent blocking the JavaScript bridge.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculationWorklet() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      // Heavy calculation on UI thread\n      const value = fib(35);\n\n      runOnJS(setResult)(value);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Not calculated'}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Expo Hook using `expo-sensors` to rotate a view based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\nimport Animated, { useAnimatedStyle, useSharedValue, withTiming } from 'react-native-reanimated';\n\nexport default function GyroRotator() {\n  const rotation = useSharedValue(0);\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n    const subscription = Gyroscope.addListener(data => {\n      // Simple integration of z-axis rotation\n      rotation.value = withTiming(rotation.value + data.z, { duration: 100 });\n    });\n\n    return () => subscription.remove();\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ rotateZ: `${rotation.value}rad` }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]}>\n        <Text style={styles.text}>Rotate Me</Text>\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write the TypeScript specification for a TurboModule (New Architecture) named `RTNCalculator` that defines an `add` method returning a Promise<number>.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('RTNCalculator');"}
{"instruction": "Implement a bridge optimization pattern where multiple small data events are batched into a single bridge call to reduce overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { AnalyticsModule } = NativeModules;\n\n// Optimization: Batching Bridge Calls\n// Instead of calling the Native Module every time an event occurs, \n// we queue them and send them in a single JSON array.\n\nclass AnalyticsBatcher {\n  private queue: any[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private readonly BATCH_DELAY = 1000;\n\n  logEvent(eventName: string, data: object) {\n    this.queue.push({ eventName, timestamp: Date.now(), data });\n\n    if (!this.timer) {\n      this.timer = setTimeout(this.flush, this.BATCH_DELAY);\n    }\n  }\n\n  flush = () => {\n    if (this.queue.length === 0) return;\n\n    // Send one large payload over the bridge instead of N small ones\n    AnalyticsModule.trackEventsBatch(this.queue);\n    \n    this.queue = [];\n    this.timer = null;\n  };\n}\n\nexport const analytics = new AnalyticsBatcher();"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error('Download error:', e);\n    return null;\n  }\n};"}
{"instruction": "Create a native iOS module (Swift) that exposes a method `changeIcon` to programmatically change the app icon (requires `Info.plist` configuration).", "output": "// CalendarModule.swift\nimport Foundation\nimport React\n\n@objc(AppIconModule)\nclass AppIconModule: NSObject {\n\n  @objc(changeIcon:resolver:rejecter:)\n  func changeIcon(_ iconName: String?, resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    DispatchQueue.main.async {\n      if UIApplication.shared.supportsAlternateIcons {\n        UIApplication.shared.setAlternateIconName(iconName) { error in\n          if let error = error {\n            reject(\"ICON_CHANGE_ERROR\", error.localizedDescription, error)\n          } else {\n            resolve(\"Icon changed successfully\")\n          }\n        }\n      } else {\n        reject(\"NOT_SUPPORTED\", \"Alternate icons not supported\", nil)\n      }\n    }\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use `react-native-reanimated` to create a scroll handler that interpolates the background color of a Header based on the scroll position.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolateColor } from 'react-native-reanimated';\n\nexport default function ScrollHeaderColor() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const backgroundColor = interpolateColor(\n      scrollY.value,\n      [0, 150],\n      ['transparent', 'rgba(0,0,0,0.8)']\n    );\n    return { backgroundColor };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ height: 1000 }}\n      >\n        {/* Content goes here */}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 80,\n    zIndex: 1,\n  },\n});"}
{"instruction": "Use `expo-secure-store` to securely save, retrieve, and delete a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const AuthManager = {\n  saveToken: async (token: string) => {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n      console.log('Token saved securely');\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async () => {\n    try {\n      const token = await SecureStore.getItemAsync(KEY);\n      return token;\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async () => {\n    try {\n      await SecureStore.deleteItemAsync(KEY);\n      console.log('Token deleted');\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  }\n};"}
{"instruction": "Create a React Native Reanimated component that implements a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated'. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should have a method 'add' that takes two numbers and returns a Promise resolving to a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Write a legacy Android Native Module in Java that exposes a method 'getDeviceName' to React Native via a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n   DeviceModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceModule\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           String manufacturer = Build.MANUFACTURER;\n           String model = Build.MODEL;\n           promise.resolve(manufacturer + \" \" + model);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Create a custom Expo Module using the Expo Modules API in Swift. The module should be named 'MySettings' and expose a synchronous function 'getTheme' that returns a string.", "output": "import ExpoModulesCore\n\npublic class MySettingsModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MySettings\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getTheme\") { () -> String in\n      // In a real app, retrieve this from UserDefaults or system settings\n      return \"dark\"\n    }\n  }\n}"}
{"instruction": "Implement a bridge optimization technique in JavaScript where multiple analytics events are batched into a single Native Module call to reduce the overhead of passing data across the bridge.", "output": "import { NativeModules } from 'react-native';\n\nconst { AnalyticsModule } = NativeModules;\n\nconst BATCH_SIZE = 10;\nconst FLUSH_INTERVAL = 5000;\nlet eventQueue: any[] = [];\nlet timer: NodeJS.Timeout | null = null;\n\nconst flushEvents = () => {\n  if (eventQueue.length > 0) {\n    // Send array of events in one bridge call\n    AnalyticsModule.trackEvents(eventQueue);\n    eventQueue = [];\n  }\n  if (timer) {\n    clearTimeout(timer);\n    timer = null;\n  }\n};\n\nexport const logEvent = (eventName: string, params: object) => {\n  eventQueue.push({ name: eventName, timestamp: Date.now(), params });\n\n  if (eventQueue.length >= BATCH_SIZE) {\n    flushEvents();\n  } else if (!timer) {\n    // Ensure events are sent eventually even if batch size isn't met\n    timer = setTimeout(flushEvents, FLUSH_INTERVAL);\n  }\n};"}
{"instruction": "Create an Objective-C header and implementation for a legacy iOS Native Module named 'CalendarManager' that exposes a method 'addEvent' taking a name (string) and location (string).", "output": "// CalendarManager.h\n#import <React/RCTBridgeModule.h>\n@interface CalendarManager : NSObject <RCTBridgeModule>\n@end\n\n// CalendarManager.m\n#import \"CalendarManager.h\"\n#import <React/RCTLog.h>\n\n@implementation CalendarManager\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)\n{\n  RCTLogInfo(@\"Pretending to create an event %@ at %@\", name, location);\n}\n\n@end"}
{"instruction": "Use 'react-native-reanimated' to create a ScrollView where the opacity of a header image interpolates based on the scroll Y offset.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, interpolate, useAnimatedScrollHandler, Extrapolate } from 'react-native-reanimated';\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 200],\n      [1, 0],\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/300' }}\n        style={[styles.headerImage, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Long content here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  headerImage: { width: '100%', height: 200, position: 'absolute', top: 0 },\n  content: { paddingTop: 200, height: 1000, backgroundColor: 'white' }\n});"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function snippet that exposes a synchronous 'multiply' function to the JavaScript runtime. This bypasses the asynchronous bridge.", "output": "// Inside your JSI installation function (e.g., install(Runtime &jsiRuntime))\n\nauto multiply = jsi::Function::createFromHostFunction(\n    jsiRuntime,\n    jsi::PropNameID::forAscii(jsiRuntime, \"multiply\"),\n    2, // param count\n    [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n        if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n            return jsi::Value::undefined();\n        }\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return jsi::Value(res);\n    }\n);\n\njsiRuntime.global().setProperty(jsiRuntime, \"multiply\", std::move(multiply));"}
{"instruction": "Create a React Native component that uses 'expo-haptics' to trigger a tactile feedback when a user presses a button.", "output": "import React from 'react';\nimport { StyleSheet, View, Button } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Trigger a light impact feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button pressed with haptics');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});"}
{"instruction": "Implement a 'Layout Animation' using Reanimated 3 to animate a list item when it is mounted (entering) and unmounted (exiting) from the DOM.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  const addItem = () => {\n    setItems((prev) => [...prev, prev.length + 1]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      <View style={styles.list}>\n        {items.map((item) => (\n          <Animated.View\n            key={item}\n            entering={FadeInUp}\n            exiting={FadeOutDown}\n            layout={Layout.springify()}\n            style={styles.card}\n          />\n        ))}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  list: { marginTop: 20, width: '100%', alignItems: 'center' },\n  card: { width: 300, height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Create a React Native component using `react-native-reanimated` and `react-native-gesture-handler` that implements a draggable box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a Swift class for a React Native iOS Native Module named `CounterModule`. It should expose a method `increment` that takes a promise, resolves with the new count, and emits an event to JavaScript.", "output": "// CounterModule.swift\nimport Foundation\nimport React\n\n@objc(CounterModule)\nclass CounterModule: RCTEventEmitter {\n  private var count = 0\n  \n  override func supportedEvents() -> [String]! {\n    return [\"onCountChanged\"]\n  }\n\n  @objc\n  func increment(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    count += 1\n    sendEvent(withName: \"onCountChanged\", body: [\"count\": count])\n    resolve(count)\n  }\n\n  @objc\n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Define a TypeScript Interface Specification for a TurboModule (New Architecture) named `NativeCalculator`. It should include a method `add` that accepts two numbers and returns a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a React Native component using `expo-sensors` to rotate an image based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Image } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroImage() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n  const [subscription, setSubscription] = useState(null);\n\n  const _subscribe = () => {\n    setSubscription(\n      Gyroscope.addListener(gyroscopeData => {\n        setData(gyroscopeData);\n      })\n    );\n    Gyroscope.setUpdateInterval(100);\n  };\n\n  const _unsubscribe = () => {\n    subscription && subscription.remove();\n    setSubscription(null);\n  };\n\n  useEffect(() => {\n    _subscribe();\n    return () => _unsubscribe();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={{\n          width: 100,\n          height: 100,\n          transform: [{ rotate: `${z}rad` }],\n        }}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement a Kotlin class for an Android Native Module named `DeviceModule`. It should expose a method `getDeviceName` that returns the Android model name via a Promise.", "output": "package com.myapp\n\nimport android.os.Build\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass DeviceModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"DeviceModule\"\n    }\n\n    @ReactMethod\n    fun getDeviceName(promise: Promise) {\n        try {\n            val manufacturer = Build.MANUFACTURER\n            val model = Build.MODEL\n            promise.resolve(\"$manufacturer $model\")\n        } catch (e: Exception) {\n            promise.reject(\"ERROR\", e)\n        }\n    }\n}"}
{"instruction": "Optimize bridge traffic by offloading a heavy calculation (Fibonacci) to the UI thread using a Reanimated Worklet (`runOnUI`).", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  \n  const handleResult = (result: number) => {\n    Alert.alert(`Result: ${result}`);\n  };\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const runHeavyTask = () => {\n    runOnUI(() => {\n      const result = fibonacci(30); // Heavy calc on UI thread\n      runOnJS(handleResult)(result); // Call back to JS thread\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={runHeavyTask} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Android ViewManager in Java to expose a native `TextView` that sets its text color to red.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class RedTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RedTextView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        TextView textView = new TextView(reactContext);\n        textView.setTextColor(Color.RED);\n        return textView;\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Use `react-native-reanimated` to create an animated scroll header. The header height should interpolate based on the scroll Y position.", "output": "import React from 'react';\nimport { View, StyleSheet, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(\n      scrollY.value,\n      [0, 100],\n      [200, 80],\n      Extrapolate.CLAMP\n    );\n    return { height };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.text}>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {Array.from({ length: 20 }).map((_, i) => (\n            <View key={i} style={styles.item} />\n          ))}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n  text: { color: 'white', fontWeight: 'bold' },\n  content: { padding: 20 },\n  item: { height: 50, backgroundColor: '#ddd', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Demonstrate bridge optimization using `InteractionManager` to defer a heavy rendering task until after a navigation transition is complete.", "output": "import React, { useState, useEffect } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Complex logic or state update runs only after animations/transitions finish\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Heavy UI Rendered</Text>\n      {/* Expensive components go here */}\n    </View>\n  );\n}"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'downloaded_image.jpg';\n    \n    const { uri } = await FileSystem.downloadAsync(\n      url,\n      fileUri\n    );\n    \n    console.log('Finished downloading to ', uri);\n    return uri;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\n// Usage Example:\n// downloadImage('https://example.com/image.jpg');"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method to get the device's battery level to React Native.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n            \n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n            \n            float batteryPct = level / (float)scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create a React Native Reanimated 3 component that creates a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated' without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift Native Module (iOS) that triggers the system haptic feedback generator when called from JavaScript.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func triggerImpact(_ style: String) {\n    DispatchQueue.main.async {\n      let feedbackStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"light\": feedbackStyle = .light\n        case \"medium\": feedbackStyle = .medium\n        case \"heavy\": feedbackStyle = .heavy\n        default: feedbackStyle = .medium\n      }\n      let generator = UIImpactFeedbackGenerator(style: feedbackStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Define a TurboModule Registry specification in TypeScript for a Calculator module. This is part of the New Architecture (Fabric/TurboModules) setup.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('CalculatorModule');"}
{"instruction": "Use the Expo Modules API (Kotlin) to create a simple Native View that renders a colored box, configurable via props.", "output": "package expo.modules.colorview\n\nimport android.content.Context\nimport android.graphics.Color\nimport android.view.View\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass ColorViewModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"ColorView\")\n\n    ViewManager {\n      View { context: Context ->\n        View(context)\n      }\n\n      Prop(\"color\") { view: View, color: String ->\n        view.setBackgroundColor(Color.parseColor(color))\n      }\n    }\n  }\n}"}
{"instruction": "Implement a bridge optimization strategy using `InteractionManager` to defer a heavy calculation until after a navigation transition or animation completes.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // Defer heavy work until interactions (like navigation animations) are done\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Simulate heavy synchronous calculation or bridge call\n      const heavyResult = performHeavyCalculation();\n      setData(heavyResult);\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>Data Loaded: {data}</Text>\n    </View>\n  );\n}\n\nfunction performHeavyCalculation() {\n  // Expensive loop\n  let result = 0;\n  for(let i = 0; i < 5000000; i++) { result += i; }\n  return result;\n}"}
{"instruction": "Create a Reanimated Worklet to perform a calculation on the UI thread, bypassing the JS bridge entirely for high-frequency updates.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is defined in JS but executed on the UI thread\nfunction heavyUIThreadCalculation(input: number) {\n  'worklet';\n  console.log('[UI Thread] Calculating square root');\n  return Math.sqrt(input);\n}\n\nexport const triggerCalculation = () => {\n  runOnUI((value) => {\n    'worklet';\n    const result = heavyUIThreadCalculation(value);\n    console.log('[UI Thread] Result:', result);\n  })(144);\n};"}
{"instruction": "Expose a native iOS UI Component (an Objective-C `UIView` wrapper) to React Native using `RCTViewManager`.", "output": "// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\n// Expose a property\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end"}
{"instruction": "Use `expo-file-system` to download a file from a remote URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport async function downloadImage(remoteUrl: string, fileName: string) {\n  const fileUri = FileSystem.cacheDirectory + fileName;\n  \n  try {\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n}"}
{"instruction": "Create a custom React Hook that tracks the keyboard height using Reanimated to ensure smooth layout transitions (avoiding the bridge lag of standard Keyboard listeners).", "output": "import { useEffect } from 'react';\nimport { Keyboard, Platform } from 'react-native';\nimport { useSharedValue } from 'react-native-reanimated';\n\nexport function useAnimatedKeyboard() {\n  const keyboardHeight = useSharedValue(0);\n\n  useEffect(() => {\n    // Note: In modern Reanimated (v3+), useAnimatedKeyboard() is built-in.\n    // This demonstrates the manual bridge logic if the built-in hook wasn't available.\n    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';\n    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';\n\n    const onShow = Keyboard.addListener(showEvent, (e) => {\n      keyboardHeight.value = e.endCoordinates.height;\n    });\n\n    const onHide = Keyboard.addListener(hideEvent, () => {\n      keyboardHeight.value = 0;\n    });\n\n    return () => {\n      onShow.remove();\n      onHide.remove();\n    };\n  }, []);\n\n  return keyboardHeight;\n}"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that creates a simple fade-in and slide-up animation when the component mounts.", "output": "import React, { useEffect } from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming, withDelay } from 'react-native-reanimated';\n\nconst FadeInView = () => {\n  const opacity = useSharedValue(0);\n  const translateY = useSharedValue(50);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: opacity.value,\n      transform: [{ translateY: translateY.value }],\n    };\n  });\n\n  useEffect(() => {\n    opacity.value = withTiming(1, { duration: 800 });\n    translateY.value = withDelay(100, withTiming(0, { duration: 800 }));\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]}>\n        <Text style={styles.text}>Hello Reanimated</Text>\n      </Animated.View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 200, height: 100, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', borderRadius: 10 },\n  text: { color: 'white', fontWeight: 'bold' }\n});\n\nexport default FadeInView;"}
{"instruction": "Write the Java code for a simple Android Native Module named 'CalendarModule' that exposes a method 'createCalendarEvent' which logs a name and location to the console.", "output": "package com.yourname.calendarmodule;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.util.Log;\n\npublic class CalendarModule extends ReactContextBaseJavaModule {\n   CalendarModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"CalendarModule\";\n   }\n\n   @ReactMethod\n   public void createCalendarEvent(String name, String location) {\n       Log.d(\"CalendarModule\", \"Create event called with name: \" + name + \" and location: \" + location);\n   }\n}"}
{"instruction": "Implement a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated' (version 2/3 API).", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift class for an iOS Native Module that exposes a function to get the device's battery level. Include the necessary React Native macros.", "output": "// CalendarModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Demonstrate how to use 'expo-haptics' to trigger a light impact feedback when a user presses a button.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Trigger a light impact haptic feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button Pressed with Haptics');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Optimize Bridge traffic by using 'runOnUI' from Reanimated to handle a heavy calculation on the UI thread instead of the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that we want to run on the UI thread to avoid blocking the JS Bridge\nfunction heavyCalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  let result = 0;\n  for (let i = 0; i < input * 1000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation result on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // This call is asynchronous from the JS perspective but runs synchronously on the UI thread\n  runOnUI(heavyCalculation)(500);\n};"}
{"instruction": "Create a custom React Hook in TypeScript that listens to a specific event emitted from a Native Module using 'NativeEventEmitter'.", "output": "import { useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules, Platform } from 'react-native';\n\nconst { MyNativeModule } = NativeModules;\n\nexport const useNativeEventListener = (eventName: string, callback: (data: any) => void) => {\n  useEffect(() => {\n    if (Platform.OS === 'ios' || Platform.OS === 'android') {\n      const eventEmitter = new NativeEventEmitter(MyNativeModule);\n      const eventListener = eventEmitter.addListener(eventName, (event) => {\n        callback(event);\n      });\n\n      // Cleanup subscription on unmount\n      return () => {\n        eventListener.remove();\n      };\n    }\n  }, [eventName, callback]);\n};"}
{"instruction": "Use 'expo-secure-store' to asynchronously save and retrieve a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const saveToken = async (token: string) => {\n  try {\n    await SecureStore.setItemAsync(KEY, token);\n    console.log('Token saved successfully');\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n};\n\nexport const getToken = async () => {\n  try {\n    const token = await SecureStore.getItemAsync(KEY);\n    if (token) {\n      console.log('Token retrieved:', token);\n      return token;\n    } else {\n      console.log('No token stored');\n      return null;\n    }\n  } catch (error) {\n    console.error('Error retrieving token', error);\n    return null;\n  }\n};"}
{"instruction": "Implement a 'FlashList' (from Shopify) instead of FlatList to optimize performance for a long list of items, reducing the bridge overhead during rapid scrolling.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, justifyContent: 'center', paddingHorizontal: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});\n\nexport default MyList;"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) to enforce type safety across the Native/JS boundary.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous method\n  getString(id: string): string;\n  \n  // Define asynchronous method\n  getPromiseData(magicNumber: number): Promise<Object>;\n  \n  // Define constants\n  getConstants(): {\n    const1: boolean;\n    const2: number;\n  };\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('MyTurboModule');"}
{"instruction": "Create a Native Module in Swift (iOS) that exposes a function to get the device's battery level and exports it to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a React Native TurboModule specification (TypeScript) for a calculator module that supports the New Architecture (Fabric/TurboModules).", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v3) and `react-native-gesture-handler`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Native Module in Kotlin (Android) that opens the application settings screen.", "output": "// OpenSettingsModule.kt\npackage com.myapp\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.provider.Settings\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass OpenSettingsModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"OpenSettings\"\n    }\n\n    @ReactMethod\n    fun open() {\n        val activity = currentActivity\n        if (activity != null) {\n            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n            val uri = Uri.fromParts(\"package\", activity.packageName, null)\n            intent.data = uri\n            activity.startActivity(intent)\n        }\n    }\n}"}
{"instruction": "Use the Expo Modules API to define a simple native module that returns the device name asynchronously.", "output": "import { ModuleDefinition } from 'expo-modules-core';\nimport * as Device from 'expo-device';\n\nexport default class DeviceNameModule extends ModuleDefinition {\n  public definition() {\n    this.Name('DeviceName');\n\n    this.AsyncFunction('getDeviceNameAsync', async () => {\n      return Device.deviceName || 'Unknown';\n    });\n  }\n}"}
{"instruction": "Optimize bridge performance by offloading a heavy calculation to the UI thread using a Reanimated Worklet.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      'worklet';\n      // Simulating heavy work on UI thread (JSI)\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const heavyResult = fib(35); // Expensive calculation\n\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Calc on UI Thread\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Android Native UI Component (ViewManager) in Java that exposes a simple colored View.", "output": "// ColorViewManager.java\npackage com.myapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class ColorViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"ColorView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        return new View(context);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(View view, String color) {\n        view.setBackgroundColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Implement a Reanimated Layout Animation where items in a list fade out and shrink when removed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          layout={Layout.springify()}\n          exiting={FadeOut.duration(500)}\n          style={styles.item}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 10, padding: 20, backgroundColor: '#f0f0f0', borderRadius: 8 },\n  text: { fontSize: 18 }\n});"}
{"instruction": "Use `InteractionManager` to defer a heavy state update until after a navigation transition completes to ensure smooth animation.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function HeavyScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Defer rendering complex UI until navigation animation finishes\n    const task = InteractionManager.runAfterInteractions(() => {\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Heavy UI Loaded</Text>\n      {/* Complex components go here */}\n    </View>\n  );\n}"}
{"instruction": "Implement a simple Haptic Feedback trigger using `expo-haptics`.", "output": "import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const triggerHaptic = async () => {\n    // Triggers a light impact vibration\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press for Haptics\" onPress={triggerHaptic} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Create a React Native Reanimated 3 component that implements a draggable box using `react-native-gesture-handler` and `react-native-reanimated`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useAnimatedStyle, \n  useSharedValue, \n  withSpring, \n  useAnimatedGestureHandler \n} from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number; startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: x.value },\n        { translateY: y.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a Native Module in Java (Android) that exposes a method `getDeviceName` to React Native using a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                promise.resolve(capitalize(model));\n            } else {\n                promise.resolve(capitalize(manufacturer) + \" \" + model);\n            }\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n\n    private String capitalize(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        char first = s.charAt(0);\n        if (Character.isUpperCase(first)) return s;\n        return Character.toUpperCase(first) + s.substring(1);\n    }\n}"}
{"instruction": "Implement an optimized scroll handler using Reanimated 3 that hides a header when scrolling down and shows it when scrolling up (Sticky Header effect), running entirely on the UI thread to minimize bridge traffic.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useSharedValue, \n  useAnimatedStyle, \n  withTiming, \n  interpolate,\n  Extrapolation\n} from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 100;\n\nexport default function StickyHeaderScroll() {\n  const translationY = useSharedValue(0);\n  const lastContentOffset = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      const diff = event.contentOffset.y - lastContentOffset.value;\n      // Clamp translationY between 0 and HEADER_HEIGHT\n      translationY.value = Math.max(\n        0, \n        Math.min(translationY.value + diff, HEADER_HEIGHT)\n      );\n      lastContentOffset.value = event.contentOffset.y;\n    },\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateY: -translationY.value }],\n      opacity: interpolate(translationY.value, [0, HEADER_HEIGHT], [1, 0], Extrapolation.CLAMP)\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: HEADER_HEIGHT }}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { \n    position: 'absolute', top: 0, left: 0, right: 0, \n    height: HEADER_HEIGHT, backgroundColor: 'tomato', \n    zIndex: 1, justifyContent: 'center', alignItems: 'center' \n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  item: { height: 100, backgroundColor: '#eee', margin: 10, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Create a Swift (iOS) Native Module setup that exposes a function `addEvent` to TypeScript. Include the Bridge Header (`.m` file) and the Swift class.", "output": "// CalendarModule.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(CalendarModule, NSObject)\n  RCT_EXTERN_METHOD(addEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)\n@end\n\n// CalendarModule.swift\nimport Foundation\n\n@objc(CalendarModule)\nclass CalendarModule: NSObject {\n\n  @objc(addEvent:location:date:)\n  func addEvent(_ name: String, location: String, date: NSNumber) -> Void {\n    // Date is passed as a timestamp (number) from JS\n    print(\"Creating event \\(name) at \\(location)\")\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Demonstrate how to offload a heavy calculation (e.g., Fibonacci) from the JavaScript thread to the UI thread using Reanimated's `runOnUI` to prevent freezing the JS bridge.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport default function OffloadCalculation() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      // This runs on the UI thread, keeping JS thread free for touches/animations\n      const heavyResult = fibonacci(30); \n      \n      // Pass result back to JS thread to update React state\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Calculate Heavy Task\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Expo Module API definition (TypeScript) for a hypothetical `MySecureStore` module.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native module\ninterface MySecureStoreInterface {\n  setValue(key: string, value: string): Promise<void>;\n  getValue(key: string): string | null; // Synchronous return example\n  deleteValue(key: string): Promise<boolean>;\n}\n\n// Load the native module\nconst MySecureStore = requireNativeModule<MySecureStoreInterface>('MySecureStore');\n\n// Export wrapper functions\nexport async function setValueAsync(key: string, value: string) {\n  return await MySecureStore.setValue(key, value);\n}\n\nexport function getValue(key: string) {\n  return MySecureStore.getValue(key);\n}\n\nexport async function deleteValueAsync(key: string) {\n  return await MySecureStore.deleteValue(key);\n}"}
{"instruction": "Use `react-native-reanimated` Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, ScrollView, StyleSheet } from 'react-native';\nimport Animated, { FadeInDown, Layout, SlideOutLeft } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, Date.now()]);\n  };\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <ScrollView contentContainerStyle={styles.scroll}>\n        {items.map((item) => (\n          <Animated.View\n            key={item}\n            entering={FadeInDown}\n            exiting={SlideOutLeft}\n            layout={Layout.springify()}\n            style={styles.card}\n            onTouchEnd={() => removeItem(item)}\n          >\n            <Text style={styles.text}>Item {item}</Text>\n          </Animated.View>\n        ))}\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50 },\n  scroll: { padding: 20 },\n  card: { \n    height: 60, \n    backgroundColor: '#4CAF50', \n    marginBottom: 10, \n    borderRadius: 8, \n    justifyContent: 'center', \n    paddingLeft: 20 \n  },\n  text: { color: 'white' }\n});"}
{"instruction": "Define a TurboModule Registry specification (TypeScript) for a module named `NativeCalculator` that supports Fabric/New Architecture.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the methods available on the native side\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  \n  // Synchronous method support (JSI)\n  multiplySync(a: number, b: number): number;\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo's `expo-sensors` to rotate a View based on the device Gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroscopeView() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n  const [subscription, setSubscription] = useState<any>(null);\n\n  const _subscribe = () => {\n    setSubscription(\n      Gyroscope.addListener(gyroscopeData => {\n        setData(gyroscopeData);\n      })\n    );\n    Gyroscope.setUpdateInterval(100);\n  };\n\n  const _unsubscribe = () => {\n    subscription && subscription.remove();\n    setSubscription(null);\n  };\n\n  useEffect(() => {\n    _subscribe();\n    return () => _unsubscribe();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <View\n        style={[\n          styles.box,\n          {\n            transform: [\n              { rotateX: `${x * 10}deg` },\n              { rotateY: `${y * 10}deg` },\n              { rotateZ: `${z * 10}deg` }\n            ]\n          }\n        ]}\n      >\n        <Text>Rotate Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'orange', justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Implement a 'sensor-based' parallax effect using Reanimated's `useAnimatedSensor`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useAnimatedSensor, \n  SensorType, \n  useAnimatedStyle, \n  withTiming,\n  interpolate\n} from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const x = sensor.sensor.value.y;\n    const y = sensor.sensor.value.x;\n\n    return {\n      transform: [\n        { translateX: withTiming(interpolate(x, [-2, 2], [-50, 50]), { duration: 100 }) },\n        { translateY: withTiming(interpolate(y, [-2, 2], [-50, 50]), { duration: 100 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#111' },\n  box: { width: 200, height: 200, backgroundColor: 'cyan', borderRadius: 20 },\n});"}
{"instruction": "Create a draggable box component using React Native Reanimated 2+ and React Native Gesture Handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { Gesture, GestureDetector, GestureHandlerRootView } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { height: 100, width: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write the Java code required to create a simple Native Module for Android that exposes a 'showToast' method to JavaScript.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to JS: NativeModules.ToastModule\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a function using Expo FileSystem to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate bridge optimization by offloading a heavy calculation to the UI thread using a Reanimated Worklet.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is marked as a worklet to run on the UI thread\n// preventing the JS thread from freezing during heavy calculation.\nfunction heavyCalculationWorklet(input: number) {\n  'worklet';\n  let result = 0;\n  // Simulate heavy work\n  for (let i = 0; i < 1000000; i++) {\n     result += Math.sqrt(input * i);\n  }\n  console.log('Calculation done on UI thread:', result);\n}\n\n// Trigger from JS thread\nconst triggerCalculation = () => {\n  runOnUI(heavyCalculationWorklet)(42);\n};"}
{"instruction": "Create an iOS Native Module (Swift) setup to get the device's battery level. Show the Swift class and the Objective-C bridge export.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    resolve(level)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Export)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Use Expo Sensors to create a hook that listens to the Gyroscope data.", "output": "import { useState, useEffect } from 'react';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function useGyroscope() {\n  const [data, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n\n    const subscription = Gyroscope.addListener(gyroscopeData => {\n      setData(gyroscopeData);\n    });\n\n    return () => subscription && subscription.remove();\n  }, []);\n\n  return data;\n}"}
{"instruction": "Implement a Reanimated ScrollHandler to interpolate the opacity of a header based on the scroll position of an Animated.ScrollView.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate } from 'react-native-reanimated';\n\nconst ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(scrollY.value, [0, 100], [0, 1], 'clamp');\n    return { opacity, backgroundColor: 'red', height: 50, width: '100%' };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={headerStyle} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nexport default ScrollHeader;"}
{"instruction": "Use Expo SecureStore to securely save and retrieve a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const saveToken = async (token: string) => {\n  try {\n    await SecureStore.setItemAsync(KEY, token);\n    console.log('Token saved');\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n};\n\nexport const getToken = async () => {\n  try {\n    const token = await SecureStore.getItemAsync(KEY);\n    return token;\n  } catch (error) {\n    console.error('Error getting token', error);\n    return null;\n  }\n};"}
{"instruction": "Implement a Layout Animation using Reanimated 2+ to fade in list items when they mount and slide them out to the right when they unmount.", "output": "import React, { useState } from 'react';\nimport { View, Button, FlatList } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nconst AnimatedList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Reset\" onPress={() => setItems([1, 2, 3, 4, 5])} />\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={FadeIn.duration(500)} \n            exiting={SlideOutRight.duration(300)}\n            style={{ height: 50, backgroundColor: 'orange', margin: 10 }}\n          >\n             <Button title=\"Remove\" onPress={() => removeItem(item)} />\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n};\n\nexport default AnimatedList;"}
{"instruction": "Demonstrate how to wrap a native iOS UIView (e.g., a MapView stub) to be used as a component in React Native.", "output": "// 1. RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end\n\n// 2. MapView.js (React Native side)\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nconst RNTMap = requireNativeComponent('RNTMap');\n\nexport default RNTMap;"}
{"instruction": "Create a basic iOS Native Module in Swift that exposes a method to get the device's battery level. Include the Objective-C bridge file.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. BatteryModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Create an Android Native Module in Java that exposes a method to show a native Toast message.", "output": "// ToastModule.java\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v2+) and `react-native-gesture-handler`. Use `useSharedValue` and `useAnimatedStyle` to update the UI on the native thread without crossing the bridge.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that adds two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo's `expo-haptics` to trigger feedback on button press, demonstrating how to use Expo modules in a TypeScript component.", "output": "import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Triggers a light impact vibration\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Haptic feedback triggered');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Optimize a heavy list rendering by implementing `FlashList` (from Shopify) instead of `FlatList` to improve JS frame rate and bridge performance.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => <Text style={styles.item}>{item.title}</Text>}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, padding: 10, borderBottomWidth: 1, borderColor: '#ccc' },\n});\n\nexport default MyList;"}
{"instruction": "Create a Reanimated Layout Animation that smoothly fades out an item when it is removed from a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          style={styles.box} \n          exiting={FadeOut.duration(500)} // Animation runs on UI thread\n          layout={Layout.springify()}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  box: { width: 100, height: 50, backgroundColor: 'tomato', marginVertical: 5 },\n});"}
{"instruction": "Use `runOnUI` from Reanimated to execute logic synchronously on the UI thread, bypassing the React Native bridge for performance-critical calculations.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyUICalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  const result = Math.pow(input, 2); \n  console.log(`Calculated on UI thread: ${result}`);\n}\n\nexport const triggerCalculation = () => {\n  // This function is called from the JS thread, but executes the worklet on the UI thread\n  runOnUI(heavyUICalculation)(10);\n};"}
{"instruction": "Create an Android ViewManager to expose a simple custom Native UI Component (a red box) to JavaScript.", "output": "package com.yourapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\n\npublic class RedBoxManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"RedBox\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        View view = new View(context);\n        view.setBackgroundColor(Color.RED);\n        return view;\n    }\n}"}
{"instruction": "Use `expo-secure-store` to securely save and retrieve an authentication token, ensuring sensitive data is encrypted on the device.", "output": "import * as SecureStore from 'expo-secure-store';\n\nexport async function saveToken(key: string, value: string) {\n  try {\n    await SecureStore.setItemAsync(key, value);\n    console.log('Token saved securely');\n  } catch (e) {\n    console.error('Error saving token', e);\n  }\n}\n\nexport async function getToken(key: string) {\n  try {\n    const token = await SecureStore.getItemAsync(key);\n    return token;\n  } catch (e) {\n    console.error('Error retrieving token', e);\n    return null;\n  }\n}"}
{"instruction": "Create a custom React Native button component using 'expo-haptics' and 'react-native-reanimated' that scales down and triggers a haptic impact when pressed.", "output": "import React from 'react';\nimport { Pressable, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport const HapticButton = ({ onPress, children, style }: { onPress: () => void, children: React.ReactNode, style?: any }) => {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1);\n  };\n\n  return (\n    <AnimatedPressable\n      style={[styles.button, style, animatedStyle]}\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n    >\n      {children}\n    </AnimatedPressable>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    padding: 15,\n    backgroundColor: '#007AFF',\n    borderRadius: 10,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});"}
{"instruction": "Implement a basic Android Native Module in Java that exposes a method to show a Toast message, and provide the TypeScript interface to call it.", "output": "// 1. android/app/src/main/java/com/yourapp/ToastModule.java\n/*\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// 2. JavaScript Interface\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Create a draggable box using 'react-native-gesture-handler' (Gesture Detector) and 'react-native-reanimated'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Return to origin on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Optimize a large list rendering performance by replacing FlatList with Shopify's FlashList to reduce bridge traffic and frame drops.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\n// Optimization: FlashList recycles views more efficiently than FlatList,\n// reducing the frequency of bridge communication for UI creation.\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\nconst DATA: ItemData[] = Array.from({ length: 1000 }, (_, i) => ({\n  id: i.toString(),\n  title: `Item ${i}`,\n}));\n\nexport const OptimizedList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50} // Critical for FlashList performance\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});"}
{"instruction": "Implement an iOS Native Module using Swift to get the device battery level.", "output": "// 1. ios/BatteryModule.swift\n/*\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      reject(\"NO_BATTERY\", \"Battery level unavailable\", nil)\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n*/\n\n// 2. ios/BatteryModule.m (Bridge)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n*/\n\n// 3. JS Usage\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nexport const checkBattery = async () => {\n  try {\n    const level = await BatteryModule.getBatteryLevel();\n    console.log(`Battery Level: ${level}%`);\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create a secure storage utility using 'expo-secure-store' to handle authentication tokens.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst TOKEN_KEY = 'user_auth_token';\n\nexport const AuthStorage = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(TOKEN_KEY, token);\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error getting token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    try {\n      await SecureStore.deleteItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  },\n};"}
{"instruction": "Create a Skeleton Loader effect using Reanimated (Looping Sequence) to simulate a loading state.", "output": "import React, { useEffect } from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withRepeat, \n  withSequence, \n  withTiming, \n  Easing \n} from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\n\nexport const SkeletonItem = () => {\n  const opacity = useSharedValue(0.5);\n\n  useEffect(() => {\n    opacity.value = withRepeat(\n      withSequence(\n        withTiming(1, { duration: 1000, easing: Easing.ease }),\n        withTiming(0.5, { duration: 1000, easing: Easing.ease })\n      ),\n      -1, // Infinite loop\n      true // Reverse\n    );\n  }, []);\n\n  const rStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.skeleton, { width: width * 0.8, height: 20 }, rStyle]} />\n      <Animated.View style={[styles.skeleton, { width: width * 0.6, height: 20, marginTop: 10 }, rStyle]} />\n      <Animated.View style={[styles.skeleton, { width: width * 0.7, height: 20, marginTop: 10 }, rStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  skeleton: {\n    backgroundColor: '#E1E9EE',\n    borderRadius: 4,\n  },\n});"}
{"instruction": "Define a TurboModule specification (New Architecture) for a simple Calculator to demonstrate typed native interfaces.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Spec file: NativeCalculator.ts\n// This interface defines the contract between JS and Native (C++/ObjC/Java)\n// The New Architecture enforces this spec to generate type-safe bindings.\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a camera component using 'expo-camera' that requests permissions and takes a picture.", "output": "import React, { useState, useRef } from 'react';\nimport { View, Button, Text, StyleSheet } from 'react-native';\nimport { CameraView, useCameraPermissions } from 'expo-camera';\n\nexport const SimpleCamera = () => {\n  const [permission, requestPermission] = useCameraPermissions();\n  const cameraRef = useRef<CameraView>(null);\n\n  if (!permission) return <View />;\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  const takePicture = async () => {\n    if (cameraRef.current) {\n      const photo = await cameraRef.current.takePictureAsync();\n      console.log('Photo taken:', photo?.uri);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} ref={cameraRef} facing=\"back\">\n        <View style={styles.buttonContainer}>\n          <Button title=\"Snap\" onPress={takePicture} color=\"white\" />\n        </View>\n      </CameraView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    backgroundColor: 'transparent',\n    margin: 64,\n    alignItems: 'flex-end',\n    justifyContent: 'center',\n  },\n});"}
{"instruction": "Implement a collapsible header using Reanimated's 'useAnimatedScrollHandler' to interpolate opacity based on scroll position.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  useSharedValue, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Header Title</Text>\n      </Animated.View>\n      \n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: 60 }}\n      >\n        {Array.from({ length: 30 }).map((_, i) => (\n          <Text key={i} style={styles.text}>Scroll Item {i + 1}</Text>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  text: { padding: 20, borderBottomWidth: 1, borderColor: '#eee' },\n});"}
{"instruction": "Create a simple Reanimated 3 component that creates a draggable box using `useSharedValue`, `useAnimatedStyle`, and `GestureDetector`. The box should spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const pressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      pressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.translationX,\n        y: event.translationY,\n      };\n    })\n    .onFinalize(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n      pressed.value = false;\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n      { scale: withSpring(pressed.value ? 1.2 : 1) },\n    ],\n    backgroundColor: pressed.value ? '#FFE04B' : '#b58df1',\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 100,\n    width: 100,\n    borderRadius: 20,\n    cursor: 'grab',\n  },\n});"}
{"instruction": "Write the Java code for a basic Android Native Module that exposes a method `getDeviceName` to React Native using the legacy Bridge architecture.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n\n    DeviceInfoModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceInfo\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            promise.resolve(manufacturer + \" \" + model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Write the Objective-C code (Header and Implementation) for an iOS Native Module that exposes a method `logToConsole` which takes a string and prints it to the Xcode console.", "output": "// RCTLogModule.h\n#import <React/RCTBridgeModule.h>\n@interface RCTLogModule : NSObject <RCTBridgeModule>\n@end\n\n// RCTLogModule.m\n#import \"RCTLogModule.h\"\n#import <React/RCTLog.h>\n\n@implementation RCTLogModule\n\n// To export a module named RCTLogModule\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(logToConsole:(NSString *)message)\n{\n  RCTLogInfo(@\"Native Log: %@\", message);\n}\n\n@end"}
{"instruction": "Implement a custom Expo Module definition in TypeScript/JavaScript for a hypothetical 'MyBattery' module that has a `getBatteryLevelAsync` function.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native events and methods\ninterface MyBatteryModuleInterface {\n  getBatteryLevelAsync(): Promise<number>;\n}\n\n// Import the native module. On web, it will be null.\nconst MyBattery = requireNativeModule<MyBatteryModuleInterface>('MyBattery');\n\nexport async function getBatteryLevelAsync(): Promise<number> {\n  return await MyBattery.getBatteryLevelAsync();\n}"}
{"instruction": "Demonstrate how to optimize bridge traffic by running complex logic on the UI thread using Reanimated's `runOnUI` (Worklets) instead of the JS thread.", "output": "import { Button } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  \n  // This function is defined in JS but marked as 'worklet' automatically by the babel plugin\n  // when passed to runOnUI, allowing it to execute synchronously on the UI thread.\n  const handleHeavyTask = () => {\n    'worklet';\n    const heavyCalculation = (input) => {\n      let result = 0;\n      for(let i = 0; i < input * 1000000; i++) {\n         result += Math.sqrt(i);\n      }\n      console.log('Calculation finished on UI Thread:', result);\n    };\n\n    heavyCalculation(5);\n  };\n\n  return (\n    <Button \n      title=\"Run Heavy Task on UI Thread\"\n      onPress={() => runOnUI(handleHeavyTask)()} \n    />\n  );\n}"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download error:', e);\n  }\n  return null;\n};"}
{"instruction": "Create a custom Android Native UI Component (ViewManager) in Java that exposes a simple `ImageView` to React Native.", "output": "package com.myapp;\n\nimport android.widget.ImageView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport com.squareup.picasso.Picasso;\n\npublic class CustomImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTCustomImage\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected ImageView createViewInstance(ThemedReactContext reactContext) {\n        return new ImageView(reactContext);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        Picasso.get().load(src).into(view);\n    }\n}"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a FlatList.", "output": "import React, { useState } from 'react';\nimport { FlatList, View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { Entering, Exiting, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={Entering.FadeIn}\n            exiting={Exiting.FadeOut}\n            layout={Layout.Spring}\n            style={styles.item}\n          >\n            <Text style={styles.text}>Item {item}</Text>\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50 },\n  buttons: { flexDirection: 'row', justifyContent: 'space-around', marginBottom: 20 },\n  item: { padding: 20, backgroundColor: '#eee', marginVertical: 5, marginHorizontal: 20, borderRadius: 8 },\n  text: { fontSize: 18 }\n});"}
{"instruction": "Wrap a native component using `requireNativeComponent` in TypeScript to expose the Android `RCTCustomImage` created in the previous task.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface CustomImageProps extends ViewProps {\n  src: string;\n}\n\n// The first argument matches the getName() return value in the Java ViewManager\nconst RCTCustomImage = requireNativeComponent<CustomImageProps>('RCTCustomImage');\n\nexport const CustomImage = (props: CustomImageProps) => {\n  return <RCTCustomImage {...props} style={[{ width: 100, height: 100 }, props.style]} />;\n};"}
{"instruction": "Use `expo-sensors` to rotate a View based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroScopeView() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n    const subscription = Gyroscope.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <View\n        style={[\n          styles.box,\n          {\n            transform: [\n              { rotateX: `${x * 10}deg` },\n              { rotateY: `${y * 10}deg` },\n            ],\n          },\n        ]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Android Native Module (Java) to show a Toast message, and the JavaScript interface to call it.", "output": "// android/app/src/main/java/com/yourapp/ToastModule.java\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n\n// --- JavaScript Usage ---\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nexport const showToast = (msg: string) => {\n  ToastModule.show(msg, 1000);\n};"}
{"instruction": "Implement a hook using Expo SecureStore to save and retrieve a user authentication token asynchronously.", "output": "import * as SecureStore from 'expo-secure-store';\nimport { useState, useEffect } from 'react';\n\nexport function useAuthToken() {\n  const [token, setToken] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function loadToken() {\n      const result = await SecureStore.getItemAsync('user_auth_token');\n      if (result) setToken(result);\n    }\n    loadToken();\n  }, []);\n\n  const saveToken = async (value: string) => {\n    await SecureStore.setItemAsync('user_auth_token', value);\n    setToken(value);\n  };\n\n  const removeToken = async () => {\n    await SecureStore.deleteItemAsync('user_auth_token');\n    setToken(null);\n  };\n\n  return { token, saveToken, removeToken };\n}"}
{"instruction": "Create a Reanimated scroll handler that interpolates an image's scale based on the scroll Y offset (Parallax effect).", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\nimport { Dimensions, StyleSheet, View } from 'react-native';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [2, 1, 1], Extrapolation.CLAMP),\n        },\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75], Extrapolation.CLAMP),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/600x400' }}\n        style={[styles.image, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: 'white', marginTop: IMG_HEIGHT }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: width, position: 'absolute', top: 0, left: 0 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' with an add method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the add method which takes two numbers and returns a Promise resolving to a number\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  multiply(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Demonstrate Bridge Optimization by using Reanimated's `runOnUI` to perform a heavy calculation on the UI thread to avoid blocking the JS thread during an animation.", "output": "import { Button } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(heavyTask)();\n  };\n\n  function heavyTask() {\n    'worklet';\n    // This runs on the UI thread, keeping the JS thread free for React updates\n    let result = 0;\n    for (let i = 0; i < 10000000; i++) {\n      result += i;\n    }\n    console.log('Calculation done on UI thread:', result);\n    \n    // Call back to JS thread if state update is needed\n    runOnJS(onTaskFinished)(result);\n  }\n\n  function onTaskFinished(result: number) {\n    console.log('Received result on JS thread:', result);\n  }\n\n  return <Button title=\"Run Heavy Task\" onPress={handlePress} />;\n}"}
{"instruction": "Create a simple iOS Native Module (Objective-C) to get the device name and the JS implementation.", "output": "// ios/DeviceModule.h\n#import <React/RCTBridgeModule.h>\n@interface DeviceModule : NSObject <RCTBridgeModule>\n@end\n\n// ios/DeviceModule.m\n#import \"DeviceModule.h\"\n#import <UIKit/UIKit.h>\n\n@implementation DeviceModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  @try {\n    NSString *deviceName = [[UIDevice currentDevice] name];\n    resolve(deviceName);\n  }\n  @catch (NSException *exception) {\n    reject(@\"get_error\", @\"Cannot get device name\", nil);\n  }\n}\n@end\n\n// --- JavaScript ---\nimport { NativeModules } from 'react-native';\nconst { DeviceModule } = NativeModules;\n\nexport const getDeviceName = async () => {\n  return await DeviceModule.getDeviceName();\n};"}
{"instruction": "Use Expo Sensors (Accelerometer) to rotate a View based on device tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltView() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  // Calculate rotation based on x-axis tilt\n  const rotation = `${x * 100}deg`;\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: rotation }] }]}>\n        <Text>Tilt Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.item}\n          onTouchEnd={() => removeItem(item)}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: { height: 50, backgroundColor: '#ddd', marginVertical: 5, justifyContent: 'center', paddingLeft: 10, borderRadius: 8 },\n  text: { fontSize: 16 },\n});"}
{"instruction": "Create a custom Expo Module (using the modern Expo Modules API in Kotlin) that returns a 'Hello World' string.", "output": "// android/src/main/java/expo/modules/hello/HelloModule.kt\npackage expo.modules.hello\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass HelloModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"HelloModule\")\n\n    // Defines a synchronous function\n    Function(\"hello\") { name: String ->\n      \"Hello $name!\"\n    }\n  }\n}\n\n// --- index.ts (JavaScript) ---\nimport { requireNativeModule } from 'expo-modules-core';\n\n// It loads the native module object from the JSI binding\nconst HelloModule = requireNativeModule('HelloModule');\n\nexport function hello(name: string): string {\n  return HelloModule.hello(name);\n}"}
{"instruction": "Create a React Native component using `react-native-reanimated` and `react-native-gesture-handler` that implements a draggable square. The square should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = { x: 0, y: 0 };\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a Swift Native Module for iOS that exposes a method `getDeviceName` to React Native using the Bridge. Include the Objective-C interface export.", "output": "// DeviceModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\n\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Create a Kotlin Native Module for Android that exposes a method `showToast` to React Native.", "output": "// ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}"}
{"instruction": "Using Expo's `expo-file-system`, write a TypeScript function to download an image from a URL and save it to the local document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, fileName: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.documentDirectory}${fileName}`;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error('Download failed', e);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate how to optimize bridge traffic by moving complex animation logic to the UI thread using `runOnUI` from `react-native-reanimated`.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Heavy calculation function intended for the UI thread\nfunction complexCalculation(value: number) {\n  'worklet';\n  // Simulating heavy UI work that shouldn't block the JS thread\n  // or require round-trips over the bridge for every frame\n  const result = Math.pow(value, 3) + Math.sqrt(value);\n  console.log('Calculated on UI thread:', result);\n}\n\nconst triggerCalculation = () => {\n  // Instead of calculating here (JS thread) and passing result via bridge,\n  // we trigger the execution directly on the UI thread.\n  runOnUI(complexCalculation)(42);\n};"}
{"instruction": "Define a TypeScript specification (Interface) for a TurboModule (New Architecture) named `Calculator` with an `add` method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Use `react-native-reanimated` Layout Animations to create a list item that fades in when mounted and slides out to the right when unmounted.", "output": "import React from 'react';\nimport { Text, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\ninterface ListItemProps {\n  text: string;\n}\n\nconst ListItem: React.FC<ListItemProps> = ({ text }) => {\n  return (\n    <Animated.View \n      entering={FadeIn.duration(500)} \n      exiting={SlideOutRight.duration(300)} \n      style={styles.item}\n    >\n      <Text style={styles.text}>{text}</Text>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    padding: 20,\n    backgroundColor: '#f9c2ff',\n    marginVertical: 8,\n    borderRadius: 8,\n  },\n  text: {\n    fontSize: 16,\n  }\n});\n\nexport default ListItem;"}
{"instruction": "Using Expo's `expo-haptics`, create a function that triggers a 'success' notification feedback on iOS/Android.", "output": "import * as Haptics from 'expo-haptics';\n\nconst triggerSuccessHaptic = async () => {\n  try {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  } catch (error) {\n    console.warn('Haptics not supported on this device');\n  }\n};"}
{"instruction": "Create a `useAnimatedSensor` hook implementation using `react-native-reanimated` to rotate a View based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedStyle, \n  useAnimatedSensor, \n  SensorType, \n  withSpring \n} from 'react-native-reanimated';\n\nconst GyroscopeView = () => {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withSpring(`${x}rad`) },\n        { rotateY: withSpring(`${y}rad`) },\n      ],\n    };\n  });\n\n  return <Animated.View style={[styles.box, animatedStyle]} />;\n};\n\nconst styles = StyleSheet.create({\n  box: {\n    width: 150,\n    height: 150,\n    backgroundColor: 'tomato',\n  },\n});\n\nexport default GyroscopeView;"}
{"instruction": "Implement a performance optimization for a FlatList by using `useCallback` for the renderItem and keyExtractor functions to ensure reference stability and reduce bridge overhead during re-renders.", "output": "import React, { useCallback } from 'react';\nimport { FlatList, Text, View, ListRenderItem } from 'react-native';\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\nconst MyOptimizedList = ({ data }: { data: ItemData[] }) => {\n  \n  // Optimization: Stable reference prevents recreating the function on every render\n  const renderItem: ListRenderItem<ItemData> = useCallback(({ item }) => (\n    <View style={{ padding: 20 }}>\n      <Text>{item.title}</Text>\n    </View>\n  ), []);\n\n  // Optimization: Stable reference for key extraction\n  const keyExtractor = useCallback((item: ItemData) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      // Optimization: Helps native side calculate layout without measuring content\n      getItemLayout={(data, index) => (\n        { length: 60, offset: 60 * index, index }\n      )}\n    />\n  );\n};\n\nexport default MyOptimizedList;"}
{"instruction": "Create a React Native component using `react-native-reanimated` (v2/v3) that implements a draggable box using the Gesture Handler library.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      // Spring back to center on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Write a Java class for an Android Native Module that exposes a method `getBatteryLevel` to React Native via a Promise.", "output": "package com.myapp;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            if (batteryStatus != null) {\n                int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n                int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n                float batteryPct = level * 100 / (float)scale;\n                promise.resolve(batteryPct);\n            } else {\n                promise.reject(\"BATTERY_UNAVAILABLE\", \"Battery status is null\");\n            }\n        } catch (Exception e) {\n            promise.reject(\"ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named `NativeSecureStorage` that includes methods for `setItem` and `getItem`.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the methods available in the Native Module\n  setItem(key: string, value: string): Promise<boolean>;\n  getItem(key: string): Promise<string | null>;\n}\n\n// Load the module; 'NativeSecureStorage' must match the name in C++/Java/Obj-C\nexport default TurboModuleRegistry.get<Spec>('NativeSecureStorage') as Spec | null;"}
{"instruction": "Implement a 'Sticky Header' effect using `react-native-reanimated` where the header's opacity and translation interpolate based on the scroll position.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function StickyHeaderScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(scrollY.value, [0, 100], [0, 1], Extrapolate.CLAMP);\n    const translateY = interpolate(scrollY.value, [0, 100], [-50, 0], Extrapolate.CLAMP);\n    return {\n      opacity,\n      transform: [{ translateY }],\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {Array.from({ length: 50 }).map((_, i) => (\n            <Text key={i} style={styles.item}>Item {i}</Text>\n          ))}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { \n    position: 'absolute', top: 0, left: 0, right: 0, height: 80, \n    backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', zIndex: 1, paddingTop: 30 \n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  content: { paddingTop: 100, paddingHorizontal: 20 },\n  item: { padding: 20, borderBottomWidth: 1, borderColor: '#ccc' },\n});"}
{"instruction": "Write an iOS Native Module in Swift that triggers a haptic feedback vibration using `UIImpactFeedbackGenerator`.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func triggerImpact(_ style: String) {\n    DispatchQueue.main.async {\n      let styleEnum: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"light\": styleEnum = .light\n        case \"medium\": styleEnum = .medium\n        case \"heavy\": styleEnum = .heavy\n        default: styleEnum = .medium\n      }\n      let generator = UIImpactFeedbackGenerator(style: styleEnum)\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Use the Expo `expo-file-system` and `expo-sharing` libraries to download an image to the local cache and share it.", "output": "import * as FileSystem from 'expo-file-system';\nimport * as Sharing from 'expo-sharing';\n\nexport const downloadAndShareImage = async (imageUrl: string) => {\n  try {\n    // 1. Define local path\n    const fileUri = FileSystem.cacheDirectory + 'shared_image.jpg';\n\n    // 2. Download file\n    const downloadRes = await FileSystem.downloadAsync(imageUrl, fileUri);\n\n    // 3. Check if sharing is available and share\n    if (await Sharing.isAvailableAsync()) {\n      await Sharing.shareAsync(downloadRes.uri);\n    } else {\n      console.log('Sharing is not available on this device');\n    }\n  } catch (error) {\n    console.error('Error downloading or sharing:', error);\n  }\n};"}
{"instruction": "Optimize Bridge communication by writing a C++ JSI (JavaScript Interface) binding snippet that exposes a synchronous `multiply` function to the JS runtime, bypassing the asynchronous bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\n// Inside your install/binding function\nvoid install(Runtime &runtime) {\n  auto multiply = Function::createFromHostFunction(\n      runtime,\n      PropNameID::forAscii(runtime, \"multiply\"),\n      2, // Number of arguments\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          if (count < 2) return Value::undefined();\n          \n          double a = arguments[0].asNumber();\n          double b = arguments[1].asNumber();\n          \n          return Value(a * b);\n      }\n  );\n\n  // Attach the function to the global object\n  runtime.global().setProperty(runtime, \"multiply\", std::move(multiply));\n}"}
{"instruction": "Create a background task using `expo-task-manager` and `expo-background-fetch` that logs a message every 15 minutes.", "output": "import * as TaskManager from 'expo-task-manager';\nimport * as BackgroundFetch from 'expo-background-fetch';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date();\n    console.log(`Got background fetch call at date: ${now.toISOString()}`);\n    // Be sure to return the result\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App initialization)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,   // Android only\n    startOnBoot: true,        // Android only\n  });\n}"}
{"instruction": "Implement a simple Android ViewManager (Java) to expose a custom Native UI Component (a simple ImageView) to React Native.", "output": "package com.myapp;\n\nimport android.widget.ImageView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport com.bumptech.glide.Glide; // Assuming Glide is used for loading\n\npublic class CustomImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTCustomImage\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected ImageView createViewInstance(ThemedReactContext reactContext) {\n        return new ImageView(reactContext);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        Glide.with(view.getContext()).load(src).into(view);\n    }\n}"}
{"instruction": "Create a Reanimated Layout Animation component where items in a list slide in from the right when mounted and slide out to the left when deleted.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { SlideInRight, SlideOutLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={SlideInRight.duration(500)}\n          exiting={SlideOutLeft.duration(500)}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Delete\" color=\"red\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, paddingTop: 50 },\n  card: { \n    flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', \n    padding: 20, marginVertical: 5, backgroundColor: '#f0f0f0', borderRadius: 8 \n  },\n});"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable box. The box should follow the user's finger and spring back to the center when released. Use TypeScript.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring, \n  useAnimatedGestureHandler \n} from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\ntype ContextType = {\n  translateX: number;\n  translateY: number;\n};\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const panGestureEvent = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, ContextType>({\n    onStart: (event, context) => {\n      context.translateX = translateX.value;\n      context.translateY = translateY.value;\n    },\n    onActive: (event, context) => {\n      translateX.value = context.translateX + event.translationX;\n      translateY.value = context.translateY + event.translationY;\n    },\n    onEnd: () => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    },\n  });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={panGestureEvent}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write the Java code for a simple Android Native Module (Legacy Bridge) that exposes a method 'showToast' to React Native. The method should take a string message and a duration integer.", "output": "package com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n  private static ReactApplicationContext reactContext;\n\n  private static final String DURATION_SHORT_KEY = \"SHORT\";\n  private static final String DURATION_LONG_KEY = \"LONG\";\n\n  ToastModule(ReactApplicationContext context) {\n    super(context);\n    reactContext = context;\n  }\n\n  @Override\n  public String getName() {\n    return \"ToastModule\";\n  }\n\n  @Override\n  public Map<String, Object> getConstants() {\n    final Map<String, Object> constants = new HashMap<>();\n    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);\n    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);\n    return constants;\n  }\n\n  @ReactMethod\n  public void show(String message, int duration) {\n    Toast.makeText(getReactApplicationContext(), message, duration).show();\n  }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should include a function 'add' that takes two numbers and returns a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that utilizes Layout Animations. Create a list where items fade in when mounted and slide out to the right when unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { Entering, Exiting, FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nexport default function LayoutAnimationList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, prev.length > 0 ? prev[prev.length - 1] + 1 : 1]);\n  };\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          style={styles.listItem} \n          entering={FadeIn.duration(500)}\n          exiting={SlideOutRight.duration(300)}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  buttons: { flexDirection: 'row', justifyContent: 'space-around', marginBottom: 20 },\n  listItem: { \n    height: 50, \n    backgroundColor: '#4CAF50', \n    marginBottom: 10, \n    justifyContent: 'center', \n    paddingLeft: 15,\n    borderRadius: 8\n  },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write an Expo Module definition in Kotlin (using the Expo Modules API) that exposes a simple function `hello` which returns a string 'Hello world'.", "output": "package expo.modules.mytestmodule\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass MyTestModule : Module() {\n  // Each module class must implement the definition function. \n  // The definition consists of components that describes the module's behavior.\n  override fun definition() = ModuleDefinition {\n    // Sets the name of the module that JavaScript code will use to refer to the module.\n    Name(\"MyTestModule\")\n\n    // Defines a function that can be called from JavaScript.\n    Function(\"hello\") {\n      \"Hello world\"\n    }\n  }\n}"}
{"instruction": "Implement a high-performance list using `@shopify/flash-list` in TypeScript. The list should render 1000 items, use `estimatedItemSize` for optimization, and include a proper type interface for the data.", "output": "import React from 'react';\nimport { View, Text, StyleSheet, StatusBar } from 'react-native';\nimport { FlashList, ListRenderItem } from '@shopify/flash-list';\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\nconst DATA: ItemData[] = Array.from({ length: 1000 }, (_, i) => ({\n  id: i.toString(),\n  title: `Item #${i + 1}`,\n}));\n\nconst MyFlashList = () => {\n  const renderItem: ListRenderItem<ItemData> = ({ item }) => (\n    <View style={styles.item}>\n      <Text style={styles.title}>{item.title}</Text>\n    </View>\n  );\n\n  return (\n    <View style={styles.container}>\n      <FlashList\n        data={DATA}\n        renderItem={renderItem}\n        keyExtractor={(item) => item.id}\n        estimatedItemSize={50}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: StatusBar.currentHeight || 0,\n  },\n  item: {\n    backgroundColor: '#f9c2ff',\n    padding: 20,\n    marginVertical: 8,\n    marginHorizontal: 16,\n    height: 50, // Matches estimatedItemSize roughly\n    justifyContent: 'center'\n  },\n  title: {\n    fontSize: 16,\n  },\n});\n\nexport default MyFlashList;"}
{"instruction": "Write the Objective-C code for an iOS Native Module (Legacy Bridge) that exports a method `getDeviceName`. The method should use a callback to return the device name to JavaScript.", "output": "#import \"RCTBridgeModule.h\"\n#import <UIKit/UIKit.h>\n\n@interface DeviceInfoModule : NSObject <RCTBridgeModule>\n@end\n\n@implementation DeviceInfoModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getDeviceName:(RCTResponseSenderBlock)callback)\n{\n  NSString *deviceName = [[UIDevice currentDevice] name];\n  callback(@[[NSNull null], deviceName]);\n}\n\n@end"}
{"instruction": "Demonstrate how to move a heavy calculation off the JavaScript thread to the UI thread using Reanimated's `runOnUI`. Create a function that triggers a heavy synchronous task on the UI thread when a button is pressed.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyTaskExample() {\n\n  // This function runs entirely on the UI thread (C++ context via JSI)\n  // It avoids blocking the JS thread (Bridge).\n  const heavyWorklet = () => {\n    'worklet';\n    const start = Date.now();\n    while (Date.now() - start < 500) {\n      // Simulate 500ms of heavy synchronous work on the UI thread\n    }\n    console.log('Heavy calculation finished on UI thread');\n  };\n\n  const handlePress = () => {\n    // Dispatch the worklet to the UI thread\n    runOnUI(heavyWorklet)();\n    console.log('JS thread is free immediately');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Using `expo-file-system`, create a TypeScript function that downloads an image from a URL and saves it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Create a Reanimated `useAnimatedScrollHandler` to sync a scroll view's offset to a shared value. This is a bridge optimization technique to handle scroll events synchronously on the UI thread without sending data over the bridge.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle \n} from 'react-native-reanimated';\n\nexport default function ScrollSync() {\n  const scrollY = useSharedValue(0);\n\n  // Events are handled on the UI thread via JSI, bypassing the bridge\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: 1 - scrollY.value / 100,\n      transform: [{ translateY: scrollY.value * 0.5 }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={styles.scrollContent}\n      >\n        {/* Long content to enable scrolling */}\n        <View style={styles.dummyContent} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    height: 100,\n    backgroundColor: 'red',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  scrollContent: {\n    paddingTop: 100,\n    height: 1000,\n  },\n  dummyContent: {\n    height: 1000,\n    backgroundColor: '#eee',\n  },\n});"}
{"instruction": "Create a simple Expo Module in Kotlin (Android) that exposes a function to get the device model name synchronously.", "output": "package expo.modules.devicemodel\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceModelModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceModel\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getDeviceModel\") {\n      return@Function Build.MODEL\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a legacy Android Native Module (Java) that creates a Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    private static ReactApplicationContext reactContext;\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n        reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Define a TurboModule specification (TypeScript) for a calculator module under the New Architecture.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  greeting(name: string): string;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 'Worklet' to offload a heavy Fibonacci calculation to the UI thread to avoid blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      // Calculate 35th fib number on UI thread\n      const value = fib(35);\n      console.log('Calculated on UI thread:', value);\n      // Note: Updating React state must happen back on JS thread if needed,\n      // but for pure offloading logic, it stays here.\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Write a C++ JSI binding function to expose a synchronous 'multiply' function to JavaScript without using the asynchronous Bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &runtime) {\n  auto multiply = Function::createFromHostFunction(\n      runtime,\n      PropNameID::forAscii(runtime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n        if (count < 2) return Value::undefined();\n        double a = arguments[0].asNumber();\n        double b = arguments[1].asNumber();\n        return Value(a * b);\n      }\n  );\n\n  runtime.global().setProperty(runtime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Create a legacy iOS Native Module (Objective-C) that exports a constant value to JavaScript.", "output": "#import \"RCTCalendarModule.h\"\n\n@implementation RCTCalendarModule\n\n// To export a module named RCTCalendarModule\nRCT_EXPORT_MODULE();\n\n- (NSDictionary *)constantsToExport\n{\n  return @{ @\"DEFAULT_EVENT_NAME\": @\"New Event\" };\n}\n\n+ (BOOL)requiresMainQueueSetup\n{\n  return NO;\n}\n\n@end"}
{"instruction": "Use `useAnimatedSensor` from Reanimated to rotate an image based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`, { duration: 50 }) },\n        { rotateY: withTiming(`${y}rad`, { duration: 50 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 200, height: 200, backgroundColor: 'tomato' },\n});"}
{"instruction": "Optimize bridge traffic by creating a Native Module method in Java that accepts a batch of data (ReadableArray) instead of calling the native method multiple times in a loop.", "output": "@ReactMethod\npublic void processBatchData(ReadableArray dataBatch) {\n    // Instead of crossing the bridge N times, we cross once and iterate natively\n    ArrayList<Object> nativeList = dataBatch.toArrayList();\n    \n    for (Object item : nativeList) {\n        // Perform heavy native logic here for each item\n        performNativeOperation(item.toString());\n    }\n}"}
{"instruction": "Implement a Reanimated Layout Animation to fade in a new item when it is added to a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, Date.now()]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeInUp} \n          exiting={FadeOutDown}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  card: { width: '90%', height: 50, backgroundColor: 'limegreen', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Create a basic iOS Native Module in Swift that exposes a method to get the device's battery level. Include the Swift class, the Objective-C bridge, and the JavaScript usage.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    resolve(level)\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. App.tsx\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nconst checkBattery = async () => {\n  const level = await BatteryModule.getBatteryLevel();\n  console.log(`Battery level: ${level * 100}%`);\n};"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' and 'react-native-gesture-handler'. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, useAnimatedGestureHandler } from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number, startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: x.value }, { translateY: y.value }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write an Android Native Module in Java that exposes a method to show a Toast message. Include the Module class and the Package class registration.", "output": "// 1. ToastModule.java\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message) {\n        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n    }\n}\n\n// 2. ToastPackage.java\npackage com.yourapp;\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ToastPackage implements ReactPackage {\n    @Override\n    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {\n        List<NativeModule> modules = new ArrayList<>();\n        modules.add(new ToastModule(reactContext));\n        return modules;\n    }\n}"}
{"instruction": "Create an Expo Config Plugin (`app.plugin.js`) that automatically adds the `NSCameraUsageDescription` key to the iOS Info.plist during prebuild.", "output": "const { withInfoPlist } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config, { permissionText = \"Allow this app to access your camera\" } = {}) => {\n  return withInfoPlist(config, (config) => {\n    config.modResults.NSCameraUsageDescription = permissionText;\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Implement a synchronous calculation on the UI thread using Reanimated's `runOnUI` to offload the JS thread, simulating a bridge optimization technique where heavy logic stays native-side.", "output": "import React, { useEffect } from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nconst HeavyCalculationComponent = () => {\n\n  const heavyWorklet = (input: number) => {\n    'worklet';\n    console.log('[UI Thread] Starting heavy calculation...');\n    let result = 0;\n    for (let i = 0; i < input * 1000000; i++) {\n        result += Math.sqrt(i);\n    }\n    console.log('[UI Thread] Calculation finished:', result);\n  };\n\n  const triggerCalculation = () => {\n    // This call passes across the bridge once, but the loop runs entirely on the UI thread\n    // preventing the JS thread (and thus React updates) from freezing.\n    runOnUI(heavyWorklet)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={triggerCalculation} />\n    </View>\n  );\n};\n\nexport default HeavyCalculationComponent;"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method `add(a: number, b: number): Promise<number>`.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a custom Native UI Component wrapper in JavaScript. The component is named `RNTMap` and expects a `zoomEnabled` boolean prop.", "output": "import React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface RNTMapProps extends ViewProps {\n  zoomEnabled?: boolean;\n}\n\n// requireNativeComponent automatically resolves 'RNTMap' to the native ViewManager\nconst RNTMapNative = requireNativeComponent<RNTMapProps>('RNTMap');\n\nexport const RNTMap: React.FC<RNTMapProps> = (props) => {\n  return <RNTMapNative {...props} />;\n};"}
{"instruction": "Use `expo-haptics` to trigger tactile feedback when a user presses a specific button.", "output": "import React from 'react';\nimport { TouchableOpacity, Text, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nconst HapticButton = () => {\n  const handlePress = () => {\n    // Triggers a light impact vibration\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button Pressed');\n  };\n\n  return (\n    <TouchableOpacity style={styles.btn} onPress={handlePress}>\n      <Text style={styles.text}>Press for Haptics</Text>\n    </TouchableOpacity>\n  );\n};\n\nconst styles = StyleSheet.create({\n  btn: { padding: 20, backgroundColor: '#ddd', borderRadius: 8 },\n  text: { fontSize: 16, fontWeight: 'bold' }\n});\n\nexport default HapticButton;"}
{"instruction": "Optimize a FlatList using `getItemLayout` to skip measurement calculations on the bridge, assuming a fixed item height of 100px.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst DATA = Array.from({ length: 1000 }).map((_, i) => ({ id: i.toString(), title: `Item ${i}` }));\nconst ITEM_HEIGHT = 100;\n\nconst OptimizedList = () => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: ITEM_HEIGHT, justifyContent: 'center', borderWidth: 1 }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  return (\n    <FlatList\n      data={DATA}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nexport default OptimizedList;"}
{"instruction": "Implement a scroll-driven animation using Reanimated where a header fades out as the user scrolls down.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolate } from 'react-native-reanimated';\n\nconst ScrollFadeHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100], // Input range (pixels scrolled)\n      [1, 0],   // Output range (opacity)\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 100, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#f0f0f0', marginTop: 100 }\n});\n\nexport default ScrollFadeHeader;"}
{"instruction": "Create a simple Expo Native Module using the Expo Modules API (Kotlin) that exposes a function to get the device's battery level.", "output": "import expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.content.Context\nimport android.os.BatteryManager\n\nclass BatteryModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    Function(\"getBatteryLevel\") { \n      val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n      val level = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n      return@Function level\n    }\n  }\n  \n  private val context: Context\n    get() = requireNotNull(appContext.reactContext) { \"React Context is null\" }\n}"}
{"instruction": "Implement a draggable box using `react-native-reanimated` and `react-native-gesture-handler`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Legacy Native Module for Android (Java) that displays a Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a Legacy Native Module for iOS (Objective-C) that exports a method to log a message to the Xcode console.", "output": "// RCTLogModule.h\n#import <React/RCTBridgeModule.h>\n@interface RCTLogModule : NSObject <RCTBridgeModule>\n@end\n\n// RCTLogModule.m\n#import \"RCTLogModule.h\"\n#import <React/RCTLog.h>\n\n@implementation RCTLogModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(logMessage:(NSString *)message)\n{\n  RCTLogInfo(@\"Native Log: %@\", message);\n}\n\n@end"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator`.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n  divide(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Optimize Bridge usage by using a Reanimated Worklet to handle heavy calculation logic on the UI thread synchronously, preventing frame drops during animation.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that would block the JS thread if run there\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(input * i);\n  }\n  return result;\n}\n\nexport const triggerCalculation = () => {\n  runOnUI((seed: number) => {\n    const result = heavyCalculation(seed);\n    console.log('[UI Thread] Result:', result);\n  })(42);\n};"}
{"instruction": "Implement a Reanimated Layout Animation to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: 300, height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Use `useAnimatedSensor` from Reanimated to rotate a View based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withSpring } from 'react-native-reanimated';\n\nexport default function GyroscopeView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withSpring(`${x}rad`) },\n        { rotateY: withSpring(`${y}rad`) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'purple', borderRadius: 20 },\n});"}
{"instruction": "Implement a basic Camera view using `expo-camera`.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function App() {\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) return <View />;\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing=\"back\" />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n});"}
{"instruction": "Optimize bridge traffic when passing large data (e.g., an image) to a native module. Instead of passing a base64 string, demonstrate the TS signature for passing a file URI.", "output": "/**\n * Anti-Pattern: passing base64 strings across the bridge freezes the UI.\n * Optimization: Pass the file path (URI) and handle file reading on the Native side.\n */\n\n// Bad\n// NativeModule.processImage(base64String: string);\n\n// Good (TypeScript Interface)\ninterface ImageProcessorModule {\n  /**\n   * Processes an image directly from the filesystem to avoid \n   * serializing huge strings over the bridge.\n   * @param fileUri - The local filesystem URI (e.g., file:///...)\n   */\n  processImage(fileUri: string): Promise<boolean>;\n}\n\n// Usage example\nconst processPhoto = async (photoUri: string) => {\n  // No Base64 conversion here!\n  await NativeModules.ImageProcessor.processImage(photoUri);\n};"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method to get the device model name to JavaScript.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceModel(Promise promise) {\n        try {\n            String model = Build.MODEL;\n            promise.resolve(model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' and 'react-native-gesture-handler'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, useAnimatedGestureHandler } from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number, startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: x.value }, { translateY: y.value }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Swift Native Module for iOS that exposes a function to trigger a system impact haptic feedback.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n  \n  @objc func triggerImpact(_ style: String) {\n    DispatchQueue.main.async {\n      let styleEnum: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"light\": styleEnum = .light\n        case \"medium\": styleEnum = .medium\n        case \"heavy\": styleEnum = .heavy\n        default: styleEnum = .medium\n      }\n      let generator = UIImpactFeedbackGenerator(style: styleEnum)\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// Bridge Header (HapticModule.m)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Use Expo's 'expo-file-system' to download an image from a URL and log the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + 'downloaded_image.jpg';\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Implement a 'TurboModule' TypeScript specification (New Architecture) for a calculator module to optimize bridge communication.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a pulsing animation effect on a button using 'react-native-reanimated' sequence and repeat modifiers.", "output": "import React, { useEffect } from 'react';\nimport Animated, { useSharedValue, useAnimatedStyle, withRepeat, withSequence, withTiming, Easing } from 'react-native-reanimated';\nimport { View, StyleSheet } from 'react-native';\n\nexport const PulsingButton = () => {\n  const scale = useSharedValue(1);\n\n  useEffect(() => {\n    scale.value = withRepeat(\n      withSequence(\n        withTiming(1.2, { duration: 500, easing: Easing.ease }),\n        withTiming(1, { duration: 500, easing: Easing.ease })\n      ),\n      -1, // Infinite repeat\n      true // Reverse\n    );\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <View style={styles.center}>\n      <Animated.View style={[styles.circle, animatedStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  center: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  circle: { width: 100, height: 100, borderRadius: 50, backgroundColor: 'tomato' },\n});"}
{"instruction": "Expose a native Android UI Component (a simple ImageView) to React Native using 'SimpleViewManager'.", "output": "package com.myapp;\n\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport android.widget.ImageView;\nimport com.bumptech.glide.Glide;\n\npublic class ReactImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTImageView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public ImageView createViewInstance(ThemedReactContext context) {\n        return new ImageView(context);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        Glide.with(view.getContext()).load(src).into(view);\n    }\n}"}
{"instruction": "Optimize a FlatList to reduce bridge traffic and serialization overhead by using 'memo' and 'getItemLayout'.", "output": "import React, { memo, useCallback } from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 50;\n\n// Memoize the item to prevent unnecessary re-renders\nconst ListItem = memo(({ title }: { title: string }) => (\n  <View style={styles.item}>\n    <Text>{title}</Text>\n  </View>\n));\n\nexport const OptimizedList = ({ data }: { data: Array<{ id: string, title: string }> }) => {\n  \n  const renderItem = useCallback(({ item }) => (\n    <ListItem title={item.title} />\n  ), []);\n\n  // Using getItemLayout skips the layout measurement calculation on the native side\n  const getItemLayout = useCallback((_, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  }), []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: ITEM_HEIGHT, justifyContent: 'center', paddingHorizontal: 20 }\n});"}
{"instruction": "Use Reanimated to create a scroll-bound animation where an image fades out as the user scrolls down.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollFade() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 200],\n      [1, 0],\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n      <Animated.Image \n        source={{ uri: 'https://via.placeholder.com/300' }} \n        style={[styles.image, imageStyle]} \n      />\n      <Animated.View style={styles.content} />\n    </Animated.ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: '100%', height: 300 },\n  content: { height: 1000, backgroundColor: '#f0f0f0' }\n});"}
{"instruction": "Implement a background fetch task using Expo's TaskManager to run code when the app is backgrounded.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date();\n    console.log(`Background fetch executed at: ${now.toISOString()}`);\n    // Perform fetch or data sync here\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App component)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // Android only\n    startOnBoot: true, // Android only\n  });\n}"}
{"instruction": "Create a simple Native Module for iOS in Swift that exposes a method to get the device's battery level and expose it to React Native.", "output": "// 1. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 2. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level == -1 {\n      reject(\"ERR_BATTERY\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 3. usage.ts\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nexport const checkBattery = async () => {\n  try {\n    const level = await BatteryModule.getBatteryLevel();\n    console.log(`Battery is at ${level}%`);\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create an Android Native Module in Java to show a native Toast message.", "output": "// 1. ToastModule.java\npackage com.myapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n\n// 2. JS Wrapper\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nexport const showNativeToast = (msg: string) => {\n  ToastModule.show(msg, 0); // 0 for LENGTH_SHORT\n};"}
{"instruction": "Implement a draggable box using `react-native-reanimated` and `react-native-gesture-handler` that returns to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Use Reanimated Layout Animations to animate items appearing and disappearing from a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          onTouchEnd={() => removeItem(item)}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  card: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Using Expo Sensors (Accelerometer), create a component that rotates an image based on the device's tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Image } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltImage() {\n  const [{ x }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(setData);\n    Accelerometer.setUpdateInterval(16);\n    return () => subscription.remove();\n  }, []);\n\n  // Calculate rotation based on X axis tilt\n  const rotation = `${x * 180}deg`;\n\n  return (\n    <View style={styles.container}>\n      <Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={[styles.image, { transform: [{ rotate: rotation }] }]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  image: { width: 100, height: 100 },\n});"}
{"instruction": "Create an Expo Config Plugin to add a specific permission (e.g., CAMERA) to the AndroidManifest.xml automatically during build.", "output": "const { withAndroidManifest, AndroidConfig } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    const permissions = androidManifest.manifest['uses-permission'] || [];\n    \n    if (!permissions.find((p) => p.$['android:name'] === 'android.permission.CAMERA')) {\n      androidManifest.manifest['uses-permission'] = [\n        ...permissions,\n        { $: { 'android:name': 'android.permission.CAMERA' } },\n      ];\n    }\n    \n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Optimize bridge traffic by using `runOnUI` in Reanimated to perform a heavy synchronous calculation on the UI thread instead of the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = 0;\n  // Simulate heavy work on UI thread to avoid blocking JS thread\n  for (let i = 0; i < 1000000; i++) {\n    result += input * i;\n  }\n  console.log('Calculation finished on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // This function is called from JS, but executes logic strictly on UI thread\n  // avoiding serialization of massive intermediate data over the bridge.\n  runOnUI(heavyCalculation)(5);\n};"}
{"instruction": "Wrap a native iOS UIView (e.g., a simple colored view) as a React Native component (Native UI Component).", "output": "// 1. RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\nRCT_EXPORT_MODULE(RNTColorView)\nRCT_EXPORT_VIEW_PROPERTY(color, NSString)\n\n- (UIView *)view {\n  return [[UIView alloc] init];\n}\n\n- (void)setColor:(UIView *)view json:(NSString *)json {\n  // Simple hex parser logic would go here, assuming standard colors for brevity\n  if ([json isEqualToString:@\"red\"]) view.backgroundColor = [UIColor redColor];\n  else view.backgroundColor = [UIColor blueColor];\n}\n@end\n\n// 2. ColorView.tsx\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColorViewProps extends ViewProps {\n  color: string;\n}\n\n// 'RNTColorView' must match the name in RCT_EXPORT_MODULE\nexport const ColorView = requireNativeComponent<ColorViewProps>('RNTColorView');"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) that calculates the square of a number.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Spec file usually named NativeCalculator.ts\nexport interface Spec extends TurboModule {\n  // Define the interface for the C++ / Native implementation\n  getSquare(n: number): number;\n}\n\n// Enforce the module name\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (imageUrl: string) => {\n  try {\n    const filename = imageUrl.split('/').pop();\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      imageUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Implement a Shared Element Transition between two screens using React Native Reanimated 3. The output should show the component code where an image is tagged for transition.", "output": "import React from 'react';\nimport { View, Button } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { useNavigation } from '@react-navigation/native';\n\nexport default function ListScreen() {\n  const navigation = useNavigation();\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Animated.Image\n        source={{ uri: 'https://picsum.photos/200' }}\n        style={{ width: 100, height: 100 }}\n        sharedTransitionTag=\"tag-unique-id\" // The magic key for Reanimated 3\n      />\n      <Button title=\"Go to Detail\" onPress={() => navigation.navigate('Detail')} />\n    </View>\n  );\n}"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method 'getDeviceName' to React Native using a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n   DeviceModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceModule\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           String manufacturer = Build.MANUFACTURER;\n           String model = Build.MODEL;\n           promise.resolve(manufacturer + \" \" + model);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' and 'react-native-gesture-handler'. The box should spring back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, rStyle]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' containing an 'add' function. This is for the Codegen parser.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create an iOS Native Module in Swift using the RCTBridgeModule protocol that creates a simple alert dialog.", "output": "// CalendarModule.swift\nimport Foundation\nimport UIKit\n\n@objc(CalendarModule)\nclass CalendarModule: NSObject {\n\n  @objc(createCalendarEvent:location:)\n  func createCalendarEvent(_ name: String, location: String) -> Void {\n    // In a real app, this would access the UI thread to show an alert or modify UI\n    DispatchQueue.main.async {\n      let alert = UIAlertController(title: \"Event Created\", message: \"Name: \\(name) at \\(location)\", preferredStyle: .alert)\n      alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))\n      UIApplication.shared.keyWindow?.rootViewController?.present(alert, animated: true, completion: nil)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Using the Expo Modules API (Kotlin), create a simple module that reads a value from the device's shared preferences.", "output": "package expo.modules.settings\n\nimport android.content.Context\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass SettingsModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"SettingsModule\")\n\n    Function(\"getTheme\") { \n      val sharedPref = context.getSharedPreferences(\"my_prefs\", Context.MODE_PRIVATE)\n      return@Function sharedPref.getString(\"theme\", \"light\")\n    }\n  }\n  private val context\n    get() = requireNotNull(appContext.reactContext) { \"React Context is null\" }\n}"}
{"instruction": "Perform a heavy calculation on the UI thread using a Reanimated Worklet to prevent blocking the JavaScript bridge.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst handleHeavyTask = () => {\n  runOnUI((input: number) => {\n    'worklet';\n    const result = fibonacci(input);\n    console.log(`Calculation result on UI thread: ${result}`);\n  })(20);\n};"}
{"instruction": "Demonstrate how to install a synchronous JSI (JavaScript Interface) function in C++ to bypass the asynchronous bridge for a high-performance math operation.", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", move(multiply));\n}"}
{"instruction": "Optimize bridge traffic by using 'runOnJS' within a Reanimated gesture handler to only send necessary updates to the JS thread (e.g., when a gesture ends), rather than streaming data.", "output": "import { runOnJS } from 'react-native-reanimated';\nimport { Gesture } from 'react-native-gesture-handler';\n\nconst MyComponent = () => {\n  const handleEnd = (finalPosition: number) => {\n    // This function runs on the JS thread\n    console.log('Gesture ended at:', finalPosition);\n    // Perform JS-side state updates or API calls here\n  };\n\n  const pan = Gesture.Pan()\n    .onUpdate((e) => {\n      'worklet';\n      // Logic remains on UI thread, no bridge traffic\n      console.log(e.translationX);\n    })\n    .onEnd((e) => {\n      'worklet';\n      // Only cross the bridge once at the end\n      runOnJS(handleEnd)(e.translationX);\n    });\n\n  // ... render component\n};"}
{"instruction": "Use 'expo-secure-store' to asynchronously save and retrieve a sensitive user token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nasync function saveToken(key: string, value: string) {\n  await SecureStore.setItemAsync(key, value);\n}\n\nasync function getToken(key: string) {\n  const result = await SecureStore.getItemAsync(key);\n  if (result) {\n    console.log(\"Here's your value \\uD83D\\uDD10\", result);\n  } else {\n    console.log('No values stored under that key.');\n  }\n}"}
{"instruction": "Create a draggable box component using `react-native-reanimated` and `react-native-gesture-handler`. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, useAnimatedGestureHandler } from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number; startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: x.value }, { translateY: y.value }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator`. It should support a synchronous `add` method.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method to add two numbers\n  add(a: number, b: number): number;\n}\n\n// Retrieve the module; 'NativeCalculator' must match the name in the C++/Java/Obj-C implementation\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a basic Expo Module (Kotlin implementation) that exposes a function `getDeviceName` and sends an event `onDeviceShake`. Provide the Kotlin code snippet using the Expo Modules API.", "output": "package expo.modules.settings\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass SettingsModule : Module() {\n  override fun definition() = ModuleDefinition {\n    // Sets the name of the module that JavaScript code will use to refer to the module.\n    Name(\"SettingsModule\")\n\n    // Defines event names that the module can send to JavaScript.\n    Events(\"onDeviceShake\")\n\n    // Defines a function that can be called synchronously or asynchronously.\n    Function(\"getDeviceName\") { \n      return@Function android.os.Build.MODEL\n    }\n  }\n}"}
{"instruction": "Optimize a bridge-heavy operation by directly modifying native view properties using `setNativeProps` to avoid React render cycles (e.g., updating a scroll indicator manually).", "output": "import React, { useRef } from 'react';\nimport { View, Button, TextInput, StyleSheet } from 'react-native';\n\nexport default function DirectManipulation() {\n  const inputRef = useRef<TextInput>(null);\n\n  const forceUpdateText = () => {\n    // Bypasses React state update and bridge serialization overhead for the Virtual DOM comparison\n    // Useful for high-frequency updates like scroll syncing or animations not supported by Reanimated\n    inputRef.current?.setNativeProps({\n      text: 'Updated directly via NativeProps',\n      style: { backgroundColor: '#e0e0e0' }\n    });\n  };\n\n  return (\n    <View style={styles.container}>\n      <TextInput \n        ref={inputRef} \n        style={styles.input} \n        defaultValue=\"Initial Text\" \n      />\n      <Button title=\"Direct Update\" onPress={forceUpdateText} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, justifyContent: 'center' },\n  input: { height: 50, borderWidth: 1, marginBottom: 20, padding: 10 }\n});"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) binding function snippet. The function `install` should bind a global C++ function `nativeMultiply` to the JavaScript runtime.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n    // Create the host function\n    auto multiply = Function::createFromHostFunction(\n        jsiRuntime,\n        PropNameID::forAscii(jsiRuntime, \"nativeMultiply\"),\n        2, // param count\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n                throw JSError(runtime, \"nativeMultiply expects 2 number arguments\");\n            }\n            double result = arguments[0].asNumber() * arguments[1].asNumber();\n            return Value(result);\n        }\n    );\n\n    // Bind it to the global object so JS can call `global.nativeMultiply(2, 3)`\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Use `react-native-reanimated` to create a parallax effect based on the device gyroscope using `useAnimatedSensor`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  // Access the gyroscope sensor\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withTiming(y * 20, { duration: 100 }) },\n        { translateY: withTiming(x * 20, { duration: 100 }) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.card, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  card: { width: 200, height: 200, backgroundColor: '#4c669f', borderRadius: 10 },\n});"}
{"instruction": "Offload a heavy calculation (e.g., Fibonacci) to the UI thread using a Reanimated Worklet to prevent blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function WorkletExample() {\n  const [result, setResult] = useState<number | null>(null);\n\n  // This function is marked as a 'worklet' automatically by the babel plugin when used in runOnUI\n  const heavyTask = (n: number) => {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return 1;\n      return fib(num - 1) + fib(num - 2);\n    };\n    const res = fib(n);\n    console.log(`Calculated on UI thread: ${res}`);\n    return res;\n  };\n\n  const triggerCalculation = () => {\n    runOnUI(() => {\n      const res = heavyTask(30);\n      // Note: Updating JS state from UI thread requires runOnJS in real scenarios,\n      // but purely for offloading logic, this executes on the UI thread.\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={triggerCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Setup a background fetch task using Expo to download data every 15 minutes.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date().toISOString();\n    console.log(`Got background fetch call at date: ${now}`);\n    // Perform fetch here\n    // const data = await fetch('https://api.example.com/updates');\n    \n    // Return result\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App.tsx useEffect)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // android only\n    startOnBoot: true, // android only\n  });\n}"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(item => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          onTouchEnd={() => removeItem(item)}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: '90%', height: 50, backgroundColor: 'teal', marginVertical: 5, borderRadius: 8 }\n});"}
{"instruction": "Create a custom Frame Processor using `react-native-vision-camera` to process camera frames on the UI thread (Worklet).", "output": "import { useFrameProcessor } from 'react-native-vision-camera';\nimport { runOnJS } from 'react-native-reanimated';\n\n// Mock function to simulate a native frame processor plugin\n// In reality, this would be: const scanFaces = VisionCameraProxy.initFrameProcessorPlugin('scanFaces')\nconst scanFaces = (frame: any) => { 'worklet'; return { faces: [] }; };\n\nexport function MyCameraComponent() {\n  const onFacesDetected = (faces: any[]) => {\n    console.log('Faces detected:', faces.length);\n  };\n\n  const frameProcessor = useFrameProcessor((frame) => {\n    'worklet';\n    // Perform heavy image processing on the UI thread (synchronously)\n    const data = scanFaces(frame);\n    \n    // Call back to JS thread with results\n    if (data.faces.length > 0) {\n      runOnJS(onFacesDetected)(data.faces);\n    }\n  }, []);\n\n  return (\n    // <Camera frameProcessor={frameProcessor} ... />\n    null // Placeholder for actual Camera component render\n  );\n}"}
{"instruction": "Create a React Native component using 'react-native-reanimated' (v3) that implements a draggable box using the Pan Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const pressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      pressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.translationX,\n        y: event.translationY,\n      };\n    })\n    .onFinalize(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n      pressed.value = false;\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n      { scale: withSpring(pressed.value ? 1.2 : 1) },\n    ],\n    backgroundColor: pressed.value ? '#FFE04B' : '#B58DF1',\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 100,\n    width: 100,\n    borderRadius: 20,\n    cursor: 'grab',\n  },\n});"}
{"instruction": "Write the Java code for a custom Android Native Module named 'ToastModule' that exposes a method 'show' to display a native Android Toast.", "output": "package com.yourname.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    private static ReactApplicationContext reactContext;\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n        reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        int toastDuration = (duration == 0) ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG;\n        Toast.makeText(getReactApplicationContext(), message, toastDuration).show();\n    }\n}"}
{"instruction": "Demonstrate how to use 'expo-file-system' to download an image from a URL and save it to the local document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download error:', e);\n  }\n  return null;\n};\n\n// Usage\n// downloadImage('https://example.com/logo.png', 'logo.png');"}
{"instruction": "Define a TypeScript specification (Spec) for a TurboModule named 'NativeCalculator' that includes a synchronous method 'add'. This is for the New Architecture (Fabric/TurboModules).", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define a synchronous method\n  add(a: number, b: number): number;\n  \n  // Define an asynchronous method (Promise)\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a Swift file for an iOS Native Module named 'Counter' that uses the React Native bridge to increment a count and resolve a Promise with the new value.", "output": "// Counter.swift\nimport Foundation\n\n@objc(Counter)\nclass Counter: NSObject {\n  private var count = 0\n\n  @objc\n  func increment(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    count += 1\n    resolve(count)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Optimize Bridge traffic by using Reanimated 'runOnUI' to handle heavy calculation logic on the UI thread, avoiding the JS thread entirely for this operation.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyLogicOnUI(input: number) {\n  'worklet';\n  // This runs synchronously on the UI thread\n  let result = 0;\n  for (let i = 0; i < 10000; i++) {\n     result += Math.sqrt(input * i);\n  }\n  console.log('[UI Thread] Calculation complete:', result);\n}\n\n// Trigger from JS component\nconst handlePress = () => {\n  runOnUI(heavyLogicOnUI)(50);\n};"}
{"instruction": "Use 'expo-secure-store' to securely save and retrieve a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nasync function saveToken(key: string, value: string) {\n  await SecureStore.setItemAsync(key, value);\n}\n\nasync function getToken(key: string) {\n  const result = await SecureStore.getItemAsync(key);\n  if (result) {\n    console.log('Token retrieved:', result);\n    return result;\n  } else {\n    console.log('No token found');\n    return null;\n  }\n}\n\n// Usage\n// saveToken('user_auth_token', 'abc-123-xyz');"}
{"instruction": "Create a custom Native UI Component wrapper in Java (Android) called 'SimpleViewManager' to expose a native View to React Native.", "output": "package com.myapp;\n\nimport android.view.View;\nimport androidx.annotation.NonNull;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class SimpleViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"SimpleView\";\n\n    @NonNull\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @NonNull\n    @Override\n    protected View createViewInstance(@NonNull ThemedReactContext reactContext) {\n        return new View(reactContext);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(View view, String color) {\n        view.setBackgroundColor(android.graphics.Color.parseColor(color));\n    }\n}"}
{"instruction": "Implement 'InteractionManager' to defer a heavy data parsing task until after navigation animations are complete to prevent frame drops.", "output": "import React, { useEffect, useState } from 'react';\nimport { InteractionManager, Text, View } from 'react-native';\n\nconst HeavyScreen = () => {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Complex synchronous task that would otherwise freeze the transition\n      performHeavyParsing();\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  const performHeavyParsing = () => {\n    // Simulate heavy work\n    const start = Date.now();\n    while (Date.now() - start < 500) {}\n  };\n\n  if (!isReady) {\n    return <View><Text>Loading...</Text></View>;\n  }\n\n  return <View><Text>Heavy Content Loaded</Text></View>;\n};"}
{"instruction": "Create a Reanimated 'Layout Animation' to animate a list item entering and exiting the screen with a fade and slide effect.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInLeft, FadeOutRight, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [show, setShow] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View\n          entering={FadeInLeft.duration(500)}\n          exiting={FadeOutRight.duration(500)}\n          layout={Layout.springify()}\n          style={styles.box}\n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', marginTop: 50 },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', marginTop: 20 },\n});"}
{"instruction": "Create a simple React Native Reanimated component using TypeScript that fades in a view when the component mounts using `useSharedValue` and `withTiming`.", "output": "import React, { useEffect } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nconst FadeInView = () => {\n  const opacity = useSharedValue(0);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: opacity.value,\n    };\n  });\n\n  useEffect(() => {\n    opacity.value = withTiming(1, { duration: 1000 });\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n  },\n});\n\nexport default FadeInView;"}
{"instruction": "Write the Java code for a basic Android Native Module named 'CalendarModule' that exposes a method `createCalendarEvent` which logs a name and location to the console.", "output": "package com.your app;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.util.Log;\n\npublic class CalendarModule extends ReactContextBaseJavaModule {\n   CalendarModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"CalendarModule\";\n   }\n\n   @ReactMethod\n   public void createCalendarEvent(String name, String location) {\n       Log.d(\"CalendarModule\", \"Create event called with name: \" + name + \" and location: \" + location);\n   }\n}"}
{"instruction": "Write an Expo Config Plugin function in JavaScript that modifies the AndroidManifest.xml to add a specific permission (e.g., READ_CONTACTS).", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withContactsPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    // Add the permission if it doesn't exist\n    const permissionName = 'android.permission.READ_CONTACTS';\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (props) => props.$['android:name'] === permissionName\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': permissionName },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withContactsPermission;"}
{"instruction": "Implement a draggable box using `react-native-reanimated` and `react-native-gesture-handler`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Demonstrate Bridge Optimization by using `InteractionManager` to defer a heavy calculation until after navigation animations or interactions are complete.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nconst HeavyTaskComponent = () => {\n  const [isReady, setIsReady] = useState(false);\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // Defer work until the bridge is idle (e.g., after navigation transition)\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy calculation or network request here\n      const result = performHeavyCalculation();\n      setData(result);\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  const performHeavyCalculation = () => {\n    // Simulating heavy synchronous work\n    return 'Heavy Data Loaded';\n  };\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>{data}</Text>\n    </View>\n  );\n};\n\nexport default HeavyTaskComponent;"}
{"instruction": "Create a TypeScript definition for a TurboModule (New Architecture) named `NativeLocalStorage` that supports `setItem`, `getItem`, and `removeItem`.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  setItem(key: string, value: string): void;\n  getItem(key: string): string | null;\n  removeItem(key: string): void;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeLocalStorage');"}
{"instruction": "Write a Swift class for an iOS Native Module that exposes a method to get the device's battery level using a Promise.", "output": "import Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let batteryLevel = UIDevice.current.batteryLevel\n    \n    if batteryLevel < 0 {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    } else {\n      resolve(batteryLevel * 100)\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use `runOnJS` in Reanimated to call a JavaScript function from the UI thread when an animation value exceeds a threshold.", "output": "import React from 'react';\nimport { Button, Alert } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedReaction, runOnJS, withTiming } from 'react-native-reanimated';\n\nconst TriggerAlert = () => {\n  const progress = useSharedValue(0);\n\n  const showAlert = () => {\n    Alert.alert('Finished', 'Animation reached 100%');\n  };\n\n  useAnimatedReaction(\n    () => {\n      return progress.value;\n    },\n    (currentValue, previousValue) => {\n      if (currentValue === 1 && previousValue !== 1) {\n        // Call JS function from UI thread\n        runOnJS(showAlert)();\n      }\n    }\n  );\n\n  const startAnimation = () => {\n    progress.value = withTiming(1, { duration: 2000 });\n  };\n\n  return <Button title=\"Start\" onPress={startAnimation} />;\n};\n\nexport default TriggerAlert;"}
{"instruction": "Use Expo's `expo-file-system` to download an image from a URL and save it to the local document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url, fileName) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Optimize a FlatList in React Native to reduce bridge traffic and improve performance by implementing `removeClippedSubviews`, `maxToRenderPerBatch`, and `windowSize`.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst OptimizedList = ({ data }) => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: 50, justifyContent: 'center' }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      // Optimization Props\n      removeClippedSubviews={true} // Unmount components off-screen (Android specific mostly)\n      maxToRenderPerBatch={10}     // Render amount per batch to reduce JS frame drops\n      windowSize={5}               // Reduces memory usage by keeping fewer items rendered off-screen\n      initialNumToRender={10}      // Load enough to fill the screen initially\n      getItemLayout={(data, index) => (\n        { length: 50, offset: 50 * index, index } // Skip measurement calculation on the bridge\n      )}\n    />\n  );\n};\n\nexport default OptimizedList;"}
{"instruction": "Create a Swift Native Module for iOS that exposes a method to get the current device battery level. Include the Objective-C interface export.", "output": "// BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// BatteryModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Create a Kotlin Native Module for Android that exposes a method to show a native Toast message.", "output": "// ToastModule.kt\npackage com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n    \n    override fun getConstants(): MutableMap<String, Any> {\n        val constants = HashMap<String, Any>()\n        constants[\"SHORT\"] = 0\n        constants[\"LONG\"] = 1\n        return constants\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n      isPressed.value = false;\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'hotpink' : 'blue',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Use Expo Haptics to trigger different feedback types based on user interaction.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticFeedbackScreen() {\n  const triggerLight = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const triggerHeavy = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n  };\n\n  const triggerSuccess = () => {\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Light Impact\" onPress={triggerLight} />\n      <View style={styles.spacer} />\n      <Button title=\"Heavy Impact\" onPress={triggerHeavy} />\n      <View style={styles.spacer} />\n      <Button title=\"Success Notification\" onPress={triggerSuccess} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  spacer: { height: 20 },\n});"}
{"instruction": "Create a Reanimated Worklet to run logic purely on the UI thread, demonstrating bridge avoidance. The function should format a currency string based on a SharedValue updates.", "output": "import React from 'react';\nimport { Text, Button, View } from 'react-native';\nimport { useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport default function UIThreadLogic() {\n  const price = useSharedValue(0);\n\n  // This function is marked as a worklet automatically by Reanimated babel plugin\n  // It runs entirely on the UI thread, avoiding the JS bridge during animations or high-freq updates\n  const formatCurrencyOnUI = (value: number) => {\n    'worklet';\n    const formatted = '$' + value.toFixed(2);\n    console.log('[UI Thread] Formatted Price:', formatted);\n    // In a real scenario, you might update a TextInput text directly via props\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      price.value = Math.random() * 100;\n      formatCurrencyOnUI(price.value);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Update Price (Check Logs)\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a TypeScript specification for a TurboModule (New Architecture) to optimize bridge communication for a Calculator module.", "output": "// NativeCalculator.ts\nimport type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous execution is a key feature of TurboModules/JSI\n  add(a: number, b: number): number;\n  \n  subtract(a: number, b: number): number;\n  \n  // Asynchronous method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo ImagePicker to select an image from the library and display it.", "output": "import React, { useState } from 'react';\nimport { Button, Image, View, StyleSheet } from 'react-native';\nimport * as ImagePicker from 'expo-image-picker';\n\nexport default function ImagePickerExample() {\n  const [image, setImage] = useState<string | null>(null);\n\n  const pickImage = async () => {\n    // No permissions request is necessary for launching the image library\n    let result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsEditing: true,\n      aspect: [4, 3],\n      quality: 1,\n    });\n\n    if (!result.canceled) {\n      setImage(result.assets[0].uri);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Pick an image from camera roll\" onPress={pickImage} />\n      {image && <Image source={{ uri: image }} style={styles.image} />}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  image: { width: 200, height: 200, marginTop: 20 },\n});"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, FlatList, StyleSheet, TouchableOpacity } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutRight } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, Math.floor(Math.random() * 1000)]);\n  };\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={FadeIn} \n            exiting={SlideOutRight} \n            layout={Layout.springify()} \n            style={styles.card}\n          >\n            <Text>Item {item}</Text>\n            <TouchableOpacity onPress={() => removeItem(item)}>\n              <Text style={styles.delete}>Delete</Text>\n            </TouchableOpacity>\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { \n    padding: 20, \n    marginVertical: 5, \n    backgroundColor: '#f9c2ff', \n    flexDirection: 'row', \n    justifyContent: 'space-between' \n  },\n  delete: { color: 'red', fontWeight: 'bold' }\n});"}
{"instruction": "Setup a React Native Event Emitter listener in TypeScript to handle events sent from a Native Module.", "output": "import { NativeEventEmitter, NativeModules } from 'react-native';\nimport { useEffect } from 'react';\n\n// Assuming 'MyEventModule' is the name of your native module\nconst { MyEventModule } = NativeModules;\n\nexport default function EventListener() {\n  useEffect(() => {\n    const eventEmitter = new NativeEventEmitter(MyEventModule);\n    \n    const subscription = eventEmitter.addListener('onNativeEvent', (event: { status: string, data: any }) => {\n      console.log('Received event from native:', event.status, event.data);\n    });\n\n    return () => {\n      // Clean up subscription on unmount\n      subscription.remove();\n    };\n  }, []);\n\n  return null;\n}"}
{"instruction": "Use Expo SecureStore to securely save and retrieve a user token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nasync function saveToken(key: string, value: string) {\n  try {\n    await SecureStore.setItemAsync(key, value);\n    console.log('Token saved securely');\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n}\n\nasync function getToken(key: string): Promise<string | null> {\n  try {\n    const result = await SecureStore.getItemAsync(key);\n    if (result) {\n      console.log('Token retrieved:', result);\n      return result;\n    } else {\n      console.log('No token stored under this key.');\n      return null;\n    }\n  } catch (error) {\n    console.error('Error retrieving token', error);\n    return null;\n  }\n}\n\n// Usage example\n// saveToken('user_auth_token', 'abc-123-xyz');\n// getToken('user_auth_token');"}
{"instruction": "Create a simple native iOS module in Swift that exposes a method to get the device's battery level and returns it to JavaScript via a Promise. Include the Objective-C bridge export.", "output": "// BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// BatteryModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Implement a basic draggable box using React Native Reanimated 3 and react-native-gesture-handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Native Module for Android using Kotlin that exposes a method to show a native Toast message.", "output": "// ToastModule.kt\npackage com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}\n\n// ToastPackage.kt\npackage com.myapp\n\nimport com.facebook.react.ReactPackage\nimport com.facebook.react.bridge.NativeModule\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.uimanager.ViewManager\n\nclass ToastPackage : ReactPackage {\n    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {\n        return listOf(ToastModule(reactContext))\n    }\n\n    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {\n        return emptyList()\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use the Expo Modules API to create a simple module definition in Swift that allows JavaScript to store and retrieve a string value synchronously.", "output": "import ExpoModulesCore\n\npublic class MyStorageModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyStorage\")\n\n    // Internal storage\n    var storedValue: String = \"\"\n\n    Function(\"setValue\") { (value: String) in\n      storedValue = value\n    }\n\n    Function(\"getValue\") { () -> String in\n      return storedValue\n    }\n  }\n}"}
{"instruction": "Optimize bridge traffic by offloading a heavy Fibonacci calculation to the UI thread using a Reanimated Worklet.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      const res = fibonacci(35); // Heavy calc on UI thread via JSI\n      runOnJS(setResult)(res);   // Send result back to JS thread\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Calculate Fib(35) on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a Reanimated scroll interpolation where an image fades out as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollFade() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 200],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n      <Animated.Image \n        source={{ uri: 'https://via.placeholder.com/300' }} \n        style={[styles.image, imageStyle]} \n      />\n      <Animated.View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n    </Animated.ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: '100%', height: 300, resizeMode: 'cover' }\n});"}
{"instruction": "Use `InteractionManager` to optimize bridge performance by deferring a heavy component mount until after a navigation transition finishes.", "output": "import React, { useState, useEffect } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nconst HeavyComponent = () => {\n  // Simulating a component that is expensive to render\n  return <Text>Heavy Content Loaded</Text>;\n};\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    const task = InteractionManager.runAfterInteractions(() => {\n      // This runs after animations (like navigation transitions) are done\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <HeavyComponent />\n    </View>\n  );\n}"}
{"instruction": "Create a C++ JSI function that adds two numbers synchronously and install it into the Javascript Runtime (JSI concepts).", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n    auto addFunction = Function::createFromHostFunction(\n        jsiRuntime,\n        PropNameID::forAscii(jsiRuntime, \"nativeAdd\"),\n        2, // param count\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            double res = arguments[0].getNumber() + arguments[1].getNumber();\n            return Value(res);\n        }\n    );\n\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeAdd\", addFunction);\n}"}
{"instruction": "Implement a custom Layout Animation using Reanimated to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', gap: 10, marginBottom: 20 },\n  item: { width: 300, height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Create a custom React Hook using Expo Haptics to trigger feedback based on success, warning, or error states.", "output": "import * as Haptics from 'expo-haptics';\nimport { useCallback } from 'react';\n\ntype HapticType = 'success' | 'warning' | 'error' | 'light' | 'medium' | 'heavy';\n\nexport const useHapticFeedback = () => {\n  const trigger = useCallback((type: HapticType = 'medium') => {\n    switch (type) {\n      case 'success':\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n        break;\n      case 'warning':\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n        break;\n      case 'error':\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n        break;\n      case 'light':\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n        break;\n      case 'medium':\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n        break;\n      case 'heavy':\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n        break;\n    }\n  }, []);\n\n  return trigger;\n};\n\n// Usage: const haptic = useHapticFeedback(); haptic('success');"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Java class for an Android Native Module that exposes a method to get the device's battery level to React Native.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create an Objective-C header and implementation for a simple iOS Native Module that logs a string to the Xcode console.", "output": "// CalendarModule.h\n#import <React/RCTBridgeModule.h>\n@interface CalendarModule : NSObject <RCTBridgeModule>\n@end\n\n// CalendarModule.m\n#import \"CalendarModule.h\"\n#import <React/RCTLog.h>\n\n@implementation CalendarModule\n\n// To export a module named CalendarModule\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)\n{\n  RCTLogInfo(@\"Pretending to create an event %@ at %@\", name, location);\n}\n\n@end"}
{"instruction": "Optimize bridge traffic by implementing a NativeEventEmitter pattern in TypeScript to listen for native updates instead of polling.", "output": "import { NativeModules, NativeEventEmitter, EmitterSubscription } from 'react-native';\n\n// Assume 'MyNativeModule' is linked and has sendEvent calls in native code\nconst { MyNativeModule } = NativeModules;\n\nclass NativeEventService {\n  private eventEmitter: NativeEventEmitter;\n  private subscription: EmitterSubscription | null = null;\n\n  constructor() {\n    this.eventEmitter = new NativeEventEmitter(MyNativeModule);\n  }\n\n  public subscribeToDataUpdates(callback: (data: any) => void) {\n    // Clean up existing subscription if any\n    this.unsubscribe();\n\n    this.subscription = this.eventEmitter.addListener('onDataUpdate', (event) => {\n      callback(event);\n    });\n  }\n\n  public unsubscribe() {\n    if (this.subscription) {\n      this.subscription.remove();\n      this.subscription = null;\n    }\n  }\n}\n\nexport const nativeEventService = new NativeEventService();"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={styles.item}\n          onTouchEnd={() => removeItem(item)}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Define a TurboModule specification (TypeScript) for the New Architecture to ensure type safety across the bridge.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature explicitly\n  getString(id: string): Promise<string>;\n  \n  // Synchronous method example\n  getUnsafeObject(key: string): Object;\n}\n\n// Retrieve the module. The name must match the native module name.\nexport default TurboModuleRegistry.getEnforcing<Spec>('MyTurboModule');"}
{"instruction": "Create a parallax effect using the device gyroscope with Reanimated's useAnimatedSensor.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming, interpolate } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  // Access gyroscope data directly on the UI thread\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const x = sensor.sensor.value.x;\n    const y = sensor.sensor.value.y;\n\n    return {\n      transform: [\n        { translateX: withTiming(interpolate(y, [-2, 2], [-20, 20]), { duration: 100 }) },\n        { translateY: withTiming(interpolate(x, [-2, 2], [-20, 20]), { duration: 100 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.card, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  card: { width: 200, height: 200, backgroundColor: '#4c669f', borderRadius: 10 },\n});"}
{"instruction": "Demonstrate bridge optimization by using JSI-based storage (react-native-mmkv) instead of asynchronous AsyncStorage.", "output": "import { MMKV } from 'react-native-mmkv';\nimport { useEffect, useState } from 'react';\n\n// Initialize MMKV (Synchronous, JSI-based, bypasses the bridge)\nexport const storage = new MMKV();\n\nexport const useUserTheme = () => {\n  const [theme, setTheme] = useState(storage.getString('user.theme') || 'light');\n\n  const toggleTheme = () => {\n    const newTheme = theme === 'light' ? 'dark' : 'light';\n    // Synchronous write\n    storage.set('user.theme', newTheme);\n    setTheme(newTheme);\n  };\n\n  return { theme, toggleTheme };\n};\n\n// Note: This avoids the async/await overhead of the traditional bridge."}
{"instruction": "Implement a secure token storage service using Expo SecureStore.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY_TOKEN = 'auth_token';\n\nexport const AuthService = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      // prevent keychain access when device is locked\n      await SecureStore.setItemAsync(KEY_TOKEN, token, {\n        keychainAccessible: SecureStore.WHEN_UNLOCKED,\n      });\n    } catch (e) {\n      console.error('Error saving token', e);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(KEY_TOKEN);\n    } catch (e) {\n      console.error('Error getting token', e);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    try {\n      await SecureStore.deleteItemAsync(KEY_TOKEN);\n    } catch (e) {\n      console.error('Error deleting token', e);\n    }\n  },\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 100,\n    width: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a modern Expo Module (Swift) definition to get the device's system name.", "output": "import ExpoModulesCore\n\npublic class SystemInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"SystemInfo\")\n\n    // Defines a function that can be called from JavaScript\n    Function(\"getSystemName\") { () -> String in\n      return UIDevice.current.systemName\n    }\n\n    // Defines a synchronous property\n    Property(\"model\") {\n      return UIDevice.current.model\n    }\n  }\n}"}
{"instruction": "Create a legacy Native Module for Android (Java) that exposes a Toast method to JavaScript.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Implement a Reanimated ScrollView with a sticky header that scales down as you scroll.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function StickyHeaderScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(scrollY.value, [0, 100], [200, 100], Extrapolate.CLAMP);\n    return { height };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item} />\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    backgroundColor: 'tomato',\n    width: '100%',\n  },\n  item: {\n    height: 100,\n    backgroundColor: '#eee',\n    margin: 10,\n    borderRadius: 8,\n  },\n});"}
{"instruction": "Optimize Bridge performance by creating a Blocking Synchronous Method in an iOS Native Module (Objective-C).", "output": "// CalendarManager.m\n#import \"React/RCTBridgeModule.h\"\n\n@interface RCT_EXTERN_MODULE(CalendarManager, NSObject)\n\n// This macro exposes the method as synchronous, bypassing the async bridge queue.\n// WARNING: Use sparingly as this blocks the JS thread.\nRCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(getCalendarID)\n{\n  return [[NSUUID UUID] UUIDString];\n}\n\n@end"}
{"instruction": "Create a custom Reanimated Layout Animation for a list item entering the screen.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { Layout, FadeInLeft, FadeOutRight } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInLeft.duration(500)}\n          exiting={FadeOutRight.duration(500)}\n          layout={Layout.springify()}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  card: { width: 300, height: 50, backgroundColor: 'teal', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Use Expo's TaskManager and BackgroundFetch to register a simple background task.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  const now = Date.now();\n  console.log(`Got background fetch call at date: ${new Date(now).toISOString()}`);\n  // Perform logic here (e.g., sync data)\n  return BackgroundFetch.BackgroundFetchResult.NewData;\n});\n\n// 2. Register the task (call this in your App component or useEffect)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,   // Android only\n    startOnBoot: true,        // Android only\n  });\n}"}
{"instruction": "Offload a heavy calculation to the UI thread using a Reanimated Worklet.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function will run on the UI thread\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = 0;\n  for (let i = 0; i < input * 1000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished on UI thread:', result);\n  return result;\n}\n\n// Call this from your JS thread (e.g., onPress)\nconst triggerCalculation = () => {\n  runOnUI(heavyCalculation)(5000);\n};"}
{"instruction": "Implement a 'useProxy' hook to interact with a Native Module while handling platform discrepancies safely.", "output": "import { NativeModules, Platform } from 'react-native';\n\nconst { MyCustomModule } = NativeModules;\n\ninterface MyModuleInterface {\n  doSomething: (arg: string) => Promise<boolean>;\n}\n\nexport const useMyNativeModule = (): MyModuleInterface => {\n  const doSomething = async (arg: string): Promise<boolean> => {\n    if (Platform.OS === 'ios') {\n      // iOS specific implementation or method name adjustment\n      return MyCustomModule?.performActionIOS ? MyCustomModule.performActionIOS(arg) : Promise.resolve(false);\n    } else if (Platform.OS === 'android') {\n      // Android specific implementation\n      return MyCustomModule?.performActionAndroid ? MyCustomModule.performActionAndroid(arg) : Promise.resolve(false);\n    }\n    return Promise.resolve(false);\n  };\n\n  return { doSomething };\n};"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, useAnimatedGestureHandler } from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number; startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: x.value }, { translateY: y.value }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should have a method 'add' that takes two numbers and returns a Promise resolving to a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Demonstrate how to create a simple Native Module in Swift (iOS) that exposes a method 'getDeviceName' to JavaScript. Include both the Swift class and the Objective-C bridge file.", "output": "// DeviceInfoModule.swift\nimport Foundation\nimport React\n\n@objc(DeviceInfoModule)\nclass DeviceInfoModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfoModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfoModule, NSObject)\n\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Using Expo's 'expo-haptics', create a function that triggers a 'Light' impact feedback when a user presses a button.", "output": "import * as Haptics from 'expo-haptics';\nimport { Button, View } from 'react-native';\nimport React from 'react';\n\nconst HapticButton = () => {\n  const handlePress = async () => {\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button pressed with haptic feedback');\n  };\n\n  return (\n    <View>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n};\n\nexport default HapticButton;"}
{"instruction": "Implement a performance optimization for a FlatList rendering complex items. Use 'getItemLayout' to skip measurement calculations and 'React.memo' for the list item component.", "output": "import React, { useCallback } from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 80;\n\ninterface ItemProps {\n  title: string;\n}\n\n// Optimization 1: Memoize the Item component to prevent unnecessary re-renders\nconst ListItem = React.memo(({ title }: ItemProps) => (\n  <View style={styles.item}>\n    <Text>{title}</Text>\n  </View>\n));\n\nconst OptimizedList = ({ data }: { data: ItemProps[] }) => {\n  const renderItem = useCallback(({ item }: { item: ItemProps }) => (\n    <ListItem title={item.title} />\n  ), []);\n\n  // Optimization 2: Provide exact layout dimensions to avoid bridge calculation overhead\n  const getItemLayout = useCallback((data: any, index: number) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  }), []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item, index) => index.toString()}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: ITEM_HEIGHT, justifyContent: 'center', padding: 20, borderBottomWidth: 1 },\n});\n\nexport default OptimizedList;"}
{"instruction": "Create an Android Native Module in Kotlin that opens the device's Wi-Fi settings when called from JavaScript.", "output": "package com.myapp\n\nimport android.content.Intent\nimport android.provider.Settings\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass WifiSettingsModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"WifiSettings\"\n    }\n\n    @ReactMethod\n    fun openWifiSettings() {\n        val intent = Intent(Settings.ACTION_WIFI_SETTINGS)\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n        if (intent.resolveActivity(reactApplicationContext.packageManager) != null) {\n            reactApplicationContext.startActivity(intent)\n        }\n    }\n}"}
{"instruction": "Use 'react-native-reanimated' to create a sensor-based animation where a view rotates based on the device's gyroscope data using 'useAnimatedSensor'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nconst GyroscopeView = () => {\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, {\n    interval: 100,\n  });\n\n  const style = useAnimatedStyle(() => {\n    const { x, y } = animatedSensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`) },\n        { rotateY: withTiming(`${y}rad`) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, style]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});\n\nexport default GyroscopeView;"}
{"instruction": "Demonstrate a bridge optimization technique by avoiding base64 serialization. Instead of passing a base64 string of an image from Native to JS, write the file to the cache directory natively and pass the file URI to JS.", "output": "// Pseudo-code logic for a Native Module method (iOS/Swift example)\n\n@objc(saveImage:resolve:reject:)\nfunc saveImage(_ imageInput: UIImage, resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) {\n    // OPTIMIZATION: Avoid converting image to Base64 string (expensive on Bridge).\n    // Instead, save to filesystem and pass the URI.\n    \n    guard let data = imageInput.jpegData(compressionQuality: 0.8) else {\n        reject(\"ERR\", \"Compression failed\", nil)\n        return\n    }\n    \n    let fileName = UUID().uuidString + \".jpg\"\n    let fileURL = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)\n    \n    do {\n        try data.write(to: fileURL)\n        // Return the path string, which is lightweight\n        resolve(fileURL.absoluteString)\n    } catch {\n        reject(\"ERR\", \"Write failed\", error)\n    }\n}"}
{"instruction": "Using 'expo-file-system', write a function to download a PDF from a remote URL and save it to the app's document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadPdf = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.documentDirectory}${fileName}.pdf`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n};"}
{"instruction": "Create a Reanimated Layout Animation where items in a list animate into position when they are mounted (Entering) and animate out when removed (Exiting).", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nconst AnimatedList = () => {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      <View style={styles.list}>\n        {items.map((item) => (\n          <Animated.View\n            key={item}\n            entering={FadeInUp.duration(500)}\n            exiting={FadeOutDown.duration(500)}\n            layout={Layout.springify()}\n            style={styles.card}\n          />\n        ))}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  list: { marginTop: 20, width: '100%', alignItems: 'center' },\n  card: { width: 300, height: 50, backgroundColor: 'teal', marginBottom: 10, borderRadius: 8 },\n});\n\nexport default AnimatedList;"}
{"instruction": "Create a custom Expo Module in Swift to retrieve the device's current battery level. This utilizes the Expo Modules API to interface with native iOS code.", "output": "import ExpoModulesCore\nimport UIKit\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a synchronous function that returns the battery level\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n\n    // Defines an event that can be emitted to JS\n    Events(\"onLowPowerModeChange\")\n\n    OnStartObserving {\n      NotificationCenter.default.addObserver(\n        self,\n        selector: #selector(self.powerModeChanged),\n        name: NSNotification.Name.NSProcessInfoPowerStateDidChange,\n        object: nil\n      )\n    }\n\n    OnStopObserving {\n      NotificationCenter.default.removeObserver(self)\n    }\n  }\n\n  @objc func powerModeChanged() {\n    sendEvent(\"onLowPowerModeChange\", [\n      \"isLowPowerMode\": ProcessInfo.processInfo.isLowPowerModeEnabled\n    ])\n  }\n}"}
{"instruction": "Implement a draggable View using `react-native-reanimated` and `react-native-gesture-handler`. The component should spring back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBall = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.ball, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 100, height: 100, borderRadius: 50, backgroundColor: 'blue' },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeSecureStorage'. This is part of the New Architecture to ensure type safety between JS and Native.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Saves a string to secure storage. Returns a Promise.\n  setItem(key: string, value: string): Promise<void>;\n  \n  // Retrieves a string. Returns a Promise (resolve null if not found).\n  getItem(key: string): Promise<string | null>;\n\n  // Removes an item.\n  removeItem(key: string): Promise<void>;\n  \n  // Example of a synchronous method (JSI powered)\n  isAvailable(): boolean;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeSecureStorage');"}
{"instruction": "Create a legacy Android Native Module (Java) that exposes a method to open the device's specialized Date Settings menu.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class SettingsModule extends ReactContextBaseJavaModule {\n    SettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"SettingsModule\";\n    }\n\n    @ReactMethod\n    public void openDateSettings() {\n        Intent intent = new Intent(Settings.ACTION_DATE_SETTINGS);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (intent.resolveActivity(getReactApplicationContext().getPackageManager()) != null) {\n            getReactApplicationContext().startActivity(intent);\n        }\n    }\n}"}
{"instruction": "Implement a collapsible header using `react-native-reanimated`. The header opacity should fade to 0 as the user scrolls down.", "output": "import React from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 100;\n\nexport const CollapsibleHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, HEADER_HEIGHT],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: HEADER_HEIGHT }}\n      >\n        {/* List Content Placeholder */}\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: HEADER_HEIGHT,\n    backgroundColor: 'tomato',\n    zIndex: 1,\n  }\n});"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function that performs a synchronous addition of two numbers. This demonstrates bypassing the asynchronous bridge for high-performance native logic.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\n// Function to install the binding into the runtime\nvoid installMathBinding(Runtime& runtime) {\n    auto add = Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"nativeAdd\"),\n        2, // argument count\n        [](Runtime& runtime, const Value& thisValue, const Value* arguments, size_t count) -> Value {\n            if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n                throw JSError(runtime, \"nativeAdd expects 2 number arguments\");\n            }\n            double result = arguments[0].asNumber() + arguments[1].asNumber();\n            return Value(result);\n        }\n    );\n\n    // Expose 'nativeAdd' to the global JavaScript object\n    runtime.global().setProperty(runtime, \"nativeAdd\", add);\n}"}
{"instruction": "Use Expo's `expo-camera` to create a component that requests camera permissions and renders a view finder.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function AppCamera() {\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) {\n    return <View />;\n  }\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text style={{ textAlign: 'center' }}>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing=\"back\">\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n});"}
{"instruction": "Optimize a heavy calculation by running it on the UI thread using Reanimated `runOnUI`. This prevents the JavaScript thread from freezing during animations.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nfunction heavyCalculation(n: number) {\n  'worklet'; // Marks function to run on UI thread\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('[UI Thread] Calculation done:', result);\n}\n\nexport const OffloadWork = () => {\n  const handlePress = () => {\n    // Dispatch work to UI thread, leaving JS thread free for React updates\n    runOnUI(heavyCalculation)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />\n    </View>\n  );\n};"}
{"instruction": "Create a legacy iOS Native Module (Objective-C) that allows changing the App Icon programmatically.", "output": "// AppIconModule.m\n#import \"React/RCTBridgeModule.h\"\n#import <UIKit/UIKit.h>\n\n@interface AppIconModule : NSObject <RCTBridgeModule>\n@end\n\n@implementation AppIconModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(changeIcon:(NSString *)iconName)\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSString *name = [iconName length] == 0 ? nil : iconName;\n        if ([[UIApplication sharedApplication] supportsAlternateIcons]) {\n            [[UIApplication sharedApplication] setAlternateIconName:name completionHandler:^(NSError * _Nullable error) {\n                if (error) {\n                    NSLog(@\"Error changing icon: %@\", error);\n                }\n            }];\n        }\n    });\n}\n\n@end"}
{"instruction": "Use `react-native-reanimated` Sensor API to create a parallax effect based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport const ParallaxView = () => {\n  // 1. Hook into the Gyroscope\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  // 2. Map sensor data to styles\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withTiming(y * 20, { duration: 100 }) },\n        { translateY: withTiming(x * 20, { duration: 100 }) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'purple', borderRadius: 20 },\n});"}
{"instruction": "Create a native iOS module using Swift that exposes a method `getDeviceName` to React Native. The method should return the device name via a Promise.", "output": "// 1. DeviceName.m (Objective-C Interface)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceName, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 2. DeviceName.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceName)\nclass DeviceName: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Implement a draggable box component using `react-native-reanimated` (v2/v3) and `react-native-gesture-handler`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Write an Expo Config Plugin to automatically add a custom key `MY_CUSTOM_API_KEY` to the iOS `Info.plist` during the prebuild phase.", "output": "const { withInfoPlist } = require('@expo/config-plugins');\n\nconst withCustomApiKey = (config, { apiKey }) => {\n  return withInfoPlist(config, (config) => {\n    config.modResults['MY_CUSTOM_API_KEY'] = apiKey;\n    return config;\n  });\n};\n\nmodule.exports = withCustomApiKey;"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `Calculator` that includes a synchronous method `add` accepting two numbers.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Create a React Native Android Native Module using Kotlin that opens a specific URL in the system browser.", "output": "package com.yourapp\n\nimport android.content.Intent\nimport android.net.Uri\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass BrowserOpenerModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"BrowserOpener\"\n    }\n\n    @ReactMethod\n    fun openUrl(url: String) {\n        val intent = Intent(Intent.ACTION_VIEW)\n        intent.data = Uri.parse(url)\n        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n        reactApplicationContext.startActivity(intent)\n    }\n}"}
{"instruction": "Use `react-native-reanimated` to offload a heavy Fibonacci calculation to the UI thread using a Worklet to prevent freezing the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport const HeavyCalc = () => {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      const value = fibonacci(35); // Heavy calc on UI thread\n      runOnJS(setResult)(value);   // Update state on JS thread\n    })();\n  };\n\n  return (\n    <View>\n      <Button title=\"Calculate Fib(35)\" onPress={handlePress} />\n      <Text>Result: {result}</Text>\n    </View>\n  );\n};\n"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) function signature that would be used to bind a native C++ function to the JavaScript global object, bypassing the asynchronous bridge.", "output": "// In your C++ installation code (e.g., install.cpp)\n\nvoid install(jsi::Runtime& runtime) {\n  auto multiply = jsi::Function::createFromHostFunction(\n    runtime,\n    jsi::PropNameID::forAscii(runtime, \"multiply\"),\n    2, // Number of arguments\n    [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n      if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n        throw jsi::JSError(runtime, \"multiply expects 2 numbers\");\n      }\n      double res = arguments[0].asNumber() * arguments[1].asNumber();\n      return jsi::Value(res);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"nativeMultiply\", std::move(multiply));\n}"}
{"instruction": "Create a Reanimated component that uses `LayoutAnimations` to fade items in when mounted and slide them out to the right when unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeIn.duration(500)} \n          exiting={SlideOutRight.duration(300)}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  item: { height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Use `expo-file-system` to download a remote image to the device's cache directory and log the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string) => {\n  try {\n    const filename = remoteUrl.split('/').pop();\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Demonstrate bridge optimization by using a `Uint8Array` to pass binary data from JavaScript to a hypothetical Native Module, avoiding the serialization overhead of Base64 strings.", "output": "import { NativeModules } from 'react-native';\n\nconst { DataProcessor } = NativeModules;\n\n// Instead of sending a massive Base64 string over the bridge (expensive serialization),\n// we create a typed array. React Native handles typed arrays more efficiently.\nconst sendBinaryData = () => {\n  const size = 1024 * 10;\n  const buffer = new ArrayBuffer(size);\n  const view = new Uint8Array(buffer);\n  \n  // Fill with dummy data\n  for (let i = 0; i < size; i++) {\n    view[i] = i % 255;\n  }\n\n  // Pass the base64-free binary object directly\n  // Note: This requires the native module to accept a ReadableMap containing the binary or similar structure depending on RN version/library used.\n  DataProcessor.processBinary(view.buffer);\n};"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable box. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a legacy Android Native Module in Java that exposes a method to show a native Toast message. Include the ReactMethod and getName implementation.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    private static ReactApplicationContext reactContext;\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n        reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should have a synchronous method 'add' that takes two numbers and returns a number.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Demonstrate how to create a custom Expo Module using the 'expo-modules-core' API in Swift. Create a module named 'MySettings' with a function 'setTheme' that takes a string argument.", "output": "import ExpoModulesCore\n\npublic class MySettingsModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MySettings\")\n\n    Function(\"setTheme\") { (theme: String) in\n      UserDefaults.standard.set(theme, forKey: \"app_theme\")\n      print(\"Theme set to: \\(theme)\")\n    }\n  }\n}"}
{"instruction": "Use 'react-native-reanimated' to create a Layout Animation. Create a list item component that fades in when mounted and slides out to the right when unmounted.", "output": "import React from 'react';\nimport { Text, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\ninterface ListItemProps {\n  label: string;\n}\n\nexport default function ListItem({ label }: ListItemProps) {\n  return (\n    <Animated.View \n      entering={FadeIn.duration(500)} \n      exiting={SlideOutRight.duration(300)} \n      style={styles.item}\n    >\n      <Text style={styles.text}>{label}</Text>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    padding: 20,\n    backgroundColor: '#f9c2ff',\n    marginVertical: 8,\n    marginHorizontal: 16,\n    borderRadius: 8,\n  },\n  text: {\n    fontSize: 16,\n  }\n});"}
{"instruction": "Implement a bridge optimization strategy using 'react-native-reanimated' worklets. Write a function that performs a heavy calculation on the UI thread to avoid blocking the JS thread during an animation frame.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy calculation function\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(input * i);\n  }\n  return result;\n}\n\nexport const triggerCalculation = () => {\n  runOnUI(() => {\n    'worklet';\n    const start = global.performance.now();\n    const result = heavyCalculation(42);\n    const end = global.performance.now();\n    console.log(`Calculation on UI Thread: ${result} (took ${end - start}ms)`);\n  })();\n};"}
{"instruction": "Create a legacy iOS Native Module header and implementation file (Objective-C) that exports a method 'getDeviceName' which returns the device name to JavaScript via a Promise.", "output": "// DeviceInfo.h\n#import <React/RCTBridgeModule.h>\n@interface DeviceInfo : NSObject <RCTBridgeModule>\n@end\n\n// DeviceInfo.m\n#import \"DeviceInfo.h\"\n#import <UIKit/UIKit.h>\n\n@implementation DeviceInfo\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  @try {\n    NSString *deviceName = [[UIDevice currentDevice] name];\n    resolve(deviceName);\n  }\n  @catch (NSException *exception) {\n    reject(@\"get_error\", @\"Could not get device name\", nil);\n  }\n}\n\n@end"}
{"instruction": "Use 'expo-file-system' to download a file from a URL and save it to the local document directory. Log the URI upon success.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadFile = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress * 100}%`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    if (result) {\n      console.log('Finished downloading to:', result.uri);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Write a Reanimated 'useAnimatedScrollHandler' to interpolate the background color of a header based on the scroll Y offset of a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolateColor } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const backgroundColor = interpolateColor(\n      scrollY.value,\n      [0, 150],\n      ['transparent', 'red']\n    );\n    return { backgroundColor };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 60,\n    zIndex: 1,\n  }\n});"}
{"instruction": "Explain and implement a bridge optimization technique for passing large images between Native and JS. Instead of passing a base64 string (which is slow and memory intensive), pass a file URI.", "output": "// Optimization Explanation: \n// Passing Base64 strings over the React Native bridge requires serialization/deserialization \n// which blocks the JS thread and spikes memory usage. \n// The optimized approach is to save the image to the filesystem on the Native side \n// and pass the 'file://' URI to JS. React Native's Image component can render file URIs directly.\n\n// TypeScript Interface for the Native Module\nimport { NativeModules } from 'react-native';\nconst { ImageProcessor } = NativeModules;\n\ninterface ImageProcessorInterface {\n  // Returns a Promise resolving to a file URI string, NOT base64\n  processImage(imageUri: string): Promise<string>;\n}\n\nexport const processAndDisplay = async (originalUri: string) => {\n  try {\n    // Native module saves result to disk and returns path\n    const newUri = await ImageProcessor.processImage(originalUri);\n    console.log('Optimized Image URI:', newUri);\n    return newUri;\n  } catch (error) {\n    console.error('Processing failed', error);\n  }\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Native Module in Java (Android) that exposes a method to show a native Toast message. Include the ReactMethod annotation and the getName method.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    private static ReactApplicationContext reactContext;\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n        reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        int toastDuration = (duration == 0) ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG;\n        Toast.makeText(getReactApplicationContext(), message, toastDuration).show();\n    }\n}"}
{"instruction": "Write a Native Module in Swift (iOS) that exposes a method `getDeviceName` via a callback. Assume the Objective-C bridging header is already configured.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n\n  @objc\n  func getDeviceName(_ callback: RCTResponseSenderBlock) {\n    let deviceName = UIDevice.current.name\n    callback([NSNull(), deviceName])\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Using Expo Camera, create a component that requests camera permissions and renders the camera view if granted.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function App() {\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) {\n    return <View />;\n  }\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text style={{ textAlign: 'center' }}>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing=\"back\">\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n});"}
{"instruction": "Demonstrate Bridge Optimization by writing a C++ JSI (JavaScript Interface) function that performs a synchronous multiplication. This avoids the asynchronous overhead of the traditional bridge.", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &runtime) {\n    auto multiply = Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"multiply\"),\n        2, // Number of arguments\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n                return Value::undefined();\n            }\n            double res = arguments[0].asNumber() * arguments[1].asNumber();\n            return Value(res);\n        }\n    );\n\n    runtime.global().setProperty(runtime, \"multiply\", multiply);\n}"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list. Create a simple component that adds and removes items.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', gap: 10, marginBottom: 20 },\n  card: { width: 300, height: 50, backgroundColor: '#4CAF50', marginVertical: 5, justifyContent: 'center', alignItems: 'center', borderRadius: 8 },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Create a utility function using `expo-file-system` to download an image from a URL and save it to the app's document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = FileSystem.documentDirectory + filename;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Optimize bridge usage by using Reanimated's `useAnimatedSensor`. Create a component that rotates a View based on the gyroscope data directly on the UI thread without passing data over the bridge every frame.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType } from 'react-native-reanimated';\n\nexport default function GyroscopeBox() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    // Access sensor data synchronously on the UI thread\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: `${x}rad` },\n        { rotateY: `${y}rad` }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});"}
{"instruction": "Setup a Background Fetch task using Expo. Register a task named 'BACKGROUND_SYNC' that logs a message when executed.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst TASK_NAME = 'BACKGROUND_SYNC';\n\n// 1. Define the task\nTaskManager.defineTask(TASK_NAME, async () => {\n  try {\n    const now = new Date();\n    console.log(`Got background fetch call at date: ${now.toISOString()}`);\n    // Perform your background logic here (e.g., API calls)\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App initialization)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(TASK_NAME, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,   // android only,\n    startOnBoot: true,        // android only\n  });\n}"}
{"instruction": "Create a React Hook that subscribes to a Native Event Emitter (e.g., for keyboard or custom native module events) and cleans up the listener on unmount.", "output": "import { useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules, Platform } from 'react-native';\n\n// Assuming a custom native module named 'MyCustomModule'\nconst { MyCustomModule } = NativeModules;\n\nexport const useNativeEvent = (eventName: string, callback: (data: any) => void) => {\n  useEffect(() => {\n    const eventEmitter = new NativeEventEmitter(MyCustomModule);\n    \n    const eventListener = eventEmitter.addListener(eventName, (event) => {\n      callback(event);\n    });\n\n    // Cleanup subscription on unmount\n    return () => {\n      eventListener.remove();\n    };\n  }, [eventName, callback]);\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring \n} from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </GestureDetector>\n  );\n};\n\nconst styles = StyleSheet.create({\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 10,\n  },\n});"}
{"instruction": "Implement a synchronous calculation on the UI thread using a Reanimated Worklet to avoid bridge traffic. Create a function that calculates the factorial of a number entirely on the UI thread when a button is pressed.", "output": "import React from 'react';\nimport { Button, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculation = () => {\n  \n  const calculateFactorial = (n: number) => {\n    'worklet';\n    if (n === 0 || n === 1) return 1;\n    let result = 1;\n    for (let i = 2; i <= n; i++) {\n      result *= i;\n    }\n    console.log(`Factorial of ${n} calculated on UI thread: ${result}`);\n    // Note: To send data back to JS thread, you would use runOnJS\n  };\n\n  const handlePress = () => {\n    // Dispatch job to UI thread avoiding the JS bridge for the loop execution\n    runOnUI(calculateFactorial)(10);\n  };\n\n  return <Button title=\"Calculate on UI Thread\" onPress={handlePress} />;\n};"}
{"instruction": "Create a TypeScript definition for a New Architecture TurboModule named 'NativeMath' that includes a synchronous method 'add'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition for TurboModule\n  add(a: number, b: number): number;\n  \n  // Asynchronous method example\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeMath');"}
{"instruction": "Use `expo-modules-core` to create a JavaScript binding for a native module named 'MySettings' that listens for a custom native event 'onThemeChange'.", "output": "import { requireNativeModule, EventEmitter, Subscription } from 'expo-modules-core';\n\n// 1. Require the native module\nconst MySettingsModule = requireNativeModule('MySettings');\n\n// 2. Create the event emitter\nconst emitter = new EventEmitter(MySettingsModule);\n\n// 3. Export a typed interface\nexport const MySettings = {\n  getTheme: (): string => MySettingsModule.getTheme(),\n  \n  addThemeListener: (listener: (event: { theme: string }) => void): Subscription => {\n    return emitter.addListener('onThemeChange', listener);\n  },\n};"}
{"instruction": "Implement a 'Scroll to Hide' header effect using Reanimated 3 `useAnimatedScrollHandler` to optimize performance by updating styles directly on the native thread.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 60, backgroundColor: 'red', width: '100%' },\n  content: { height: 1000, backgroundColor: '#eee' }\n});"}
{"instruction": "Write the Java code snippet for a React Native Android Module that exposes a method `showToast` to JavaScript. (Legacy Bridge approach).", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a wrapper for a Native UI Component named 'RNCameraView' using `requireNativeComponent` for usage in TypeScript.", "output": "import React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface RNCameraViewProps extends ViewProps {\n  zoomLevel: number;\n  onBarcodeRead?: (event: { nativeEvent: { code: string } }) => void;\n}\n\n// The first argument matches the name returned in the native ViewManager\nconst NativeCameraView = requireNativeComponent<RNCameraViewProps>('RNCameraView');\n\nexport const CameraView: React.FC<RNCameraViewProps> = (props) => {\n  return <NativeCameraView {...props} />;\n};"}
{"instruction": "Utilize `useAnimatedSensor` from Reanimated to create a style that rotates an image based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedSensor, \n  SensorType, \n  useAnimatedStyle, \n  withTiming \n} from 'react-native-reanimated';\n\nexport const GyroImage = () => {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`) },\n        { rotateY: withTiming(`${y}rad`) }\n      ],\n    };\n  });\n\n  return <Animated.Image source={{ uri: 'https://via.placeholder.com/150' }} style={[styles.img, animatedStyle]} />;\n};\n\nconst styles = StyleSheet.create({\n  img: { width: 150, height: 150 }\n});"}
{"instruction": "Implement Layout Animations using Reanimated to animate items entering and exiting a list when a state array changes.", "output": "import React, { useState } from 'react';\nimport { Button, View } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={{ height: 50, backgroundColor: 'orange', margin: 10 }}\n        />\n      ))}\n    </View>\n  );\n};"}
{"instruction": "Securely store and retrieve a user authentication token using `expo-secure-store`.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const TokenService = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n    } catch (e) {\n      console.error('Error saving token', e);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(KEY);\n    } catch (e) {\n      console.error('Error retrieving token', e);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    await SecureStore.deleteItemAsync(KEY);\n  }\n};"}
{"instruction": "Create a custom React Native hook using Reanimated 3 and Expo Haptics that makes a view scale down and trigger haptic feedback when pressed, utilizing the Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nexport const BouncyButton = ({ children, onPress }: { children: React.ReactNode, onPress?: () => void }) => {\n  const scale = useSharedValue(1);\n\n  const tap = Gesture.Tap()\n    .onBegin(() => {\n      scale.value = withSpring(0.9);\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    })\n    .onFinalize(() => {\n      scale.value = withSpring(1);\n      if (onPress) onPress();\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <GestureDetector gesture={tap}>\n      <Animated.View style={[styles.button, animatedStyle]}>\n        {children}\n      </Animated.View>\n    </GestureDetector>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    padding: 20,\n    backgroundColor: '#3498db',\n    borderRadius: 10,\n  },\n});"}
{"instruction": "Write a Java class for an Android Native Module that exposes a method `getDeviceName` to JavaScript using a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n    DeviceInfoModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceInfo\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            promise.resolve(manufacturer + \" \" + model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Implement a Reanimated 3 `useAnimatedScrollHandler` to create a sticky header effect where the header opacity fades out as the user scrolls down.", "output": "import React from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 100;\n\nexport default function ScrollFadeHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, HEADER_HEIGHT], [1, 0], Extrapolation.CLAMP),\n      transform: [\n        { translateY: interpolate(scrollY.value, [0, HEADER_HEIGHT], [0, -HEADER_HEIGHT / 2], Extrapolation.CLAMP) }\n      ]\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Content goes here */}\n          <View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: HEADER_HEIGHT,\n    backgroundColor: 'tomato',\n    zIndex: 1,\n  },\n  content: {\n    paddingTop: HEADER_HEIGHT,\n  }\n});"}
{"instruction": "Create a TypeScript specification for a React Native TurboModule named 'SecureStorage' that includes methods for storing and retrieving strings.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  getConstants: () => {};\n  \n  // Store a value securely\n  setItem(key: string, value: string): Promise<boolean>;\n  \n  // Retrieve a value securely\n  getItem(key: string): Promise<string | null>;\n  \n  // Remove a value\n  removeItem(key: string): Promise<boolean>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('SecureStorage');"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function that installs a synchronous global function `nativeAdd` into the Javascript Runtime to optimize bridge performance for heavy calculations.", "output": "#include <jsi/jsi.h>\n#include <ReactCommon/CallInvoker.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid installNativeAdd(Runtime &jsiRuntime) {\n    auto nativeAdd = Function::createFromHostFunction(\n        jsiRuntime,\n        PropNameID::forAscii(jsiRuntime, \"nativeAdd\"),\n        2, // Number of arguments\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n                throw JSError(runtime, \"nativeAdd expects 2 number arguments\");\n            }\n            \n            double a = arguments[0].asNumber();\n            double b = arguments[1].asNumber();\n            \n            return Value(a + b);\n        }\n    );\n\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeAdd\", move(nativeAdd));\n}"}
{"instruction": "Implement an iOS Native Module in Swift that emits an event 'onVolumeChange' to JavaScript whenever the system volume changes.", "output": "// VolumeModule.swift\nimport Foundation\nimport React\nimport AVFoundation\n\n@objc(VolumeModule)\nclass VolumeModule: RCTEventEmitter {\n  \n  private var observation: NSKeyValueObservation?\n\n  override func supportedEvents() -> [String]! {\n    return [\"onVolumeChange\"]\n  }\n  \n  override func startObserving() {\n    let audioSession = AVAudioSession.sharedInstance()\n    try? audioSession.setActive(true)\n    \n    observation = audioSession.observe(\\ .outputVolume) { [weak self] (session, _) in\n      self?.sendEvent(withName: \"onVolumeChange\", body: [\"volume\": session.outputVolume])\n    }\n  }\n\n  override func stopObserving() {\n    observation?.invalidate()\n    observation = nil\n  }\n  \n  @objc override static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Create an Expo TaskManager task to handle background location updates and log the coordinates.", "output": "import * as TaskManager from 'expo-task-manager';\nimport * as Location from 'expo-location';\n\nconst LOCATION_TASK_NAME = 'background-location-task';\n\n// 1. Define the task\nTaskManager.defineTask(LOCATION_TASK_NAME, ({ data, error }) => {\n  if (error) {\n    console.error(\"Background location error:\", error);\n    return;\n  }\n  if (data) {\n    const { locations } = data as { locations: Location.LocationObject[] };\n    // Process locations here\n    console.log('Received new locations in background:', locations[0].coords);\n  }\n});\n\n// 2. Function to register the task (call this from a component)\nexport const startBackgroundUpdate = async () => {\n  const { status } = await Location.requestBackgroundPermissionsAsync();\n  if (status === 'granted') {\n    await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {\n      accuracy: Location.Accuracy.Balanced,\n      timeInterval: 10000,\n      distanceInterval: 50,\n    });\n  }\n};"}
{"instruction": "Demonstrate how to optimize a large FlatList in React Native by memoizing the renderItem and using keyExtractor to reduce bridge traffic during re-renders.", "output": "import React, { useCallback, memo } from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\n// 1. Memoize the child component to prevent unnecessary re-renders\nconst ListItem = memo(({ title }: { title: string }) => {\n  return (\n    <View style={styles.item}>\n      <Text>{title}</Text>\n    </View>\n  );\n}, (prevProps, nextProps) => prevProps.title === nextProps.title);\n\nexport const OptimizedList = ({ data }: { data: ItemData[] }) => {\n  \n  // 2. Memoize renderItem so the function reference stays stable\n  const renderItem = useCallback(({ item }: { item: ItemData }) => {\n    return <ListItem title={item.title} />;\n  }, []);\n\n  // 3. Simple key extractor\n  const keyExtractor = useCallback((item: ItemData) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true} // Unmounts off-screen views (Android)\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { padding: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Use Reanimated 3 Layout Animations to create a list item that smoothly enters with a fade-in and exits with a slide-out to the left.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutLeft, Layout } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter(item => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Entering animation\n          entering={FadeIn.duration(500)}\n          // Exiting animation\n          exiting={SlideOutLeft.duration(500)}\n          // Layout transition for siblings shifting position\n          layout={Layout.springify()}\n          style={styles.box}\n        >\n           <Button title={`Remove ${item}`} onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n      <Button title=\"Add Item\" onPress={() => setItems(curr => [...curr, Date.now()])} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 50 },\n  box: { marginBottom: 10, backgroundColor: '#ddd', padding: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a helper function to check if a specific Expo module (e.g., Camera) is available at runtime to avoid crashes on unsupported platforms.", "output": "import { requireNativeModule } from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\n/**\n * Safely checks if an Expo module is installed and linked.\n * @param moduleName The name of the native module (e.g., 'ExpoCamera')\n * @returns boolean\n */\nexport function isExpoModuleAvailable(moduleName: string): boolean {\n  try {\n    // On web, native modules work differently or are shimmed\n    if (Platform.OS === 'web') return false;\n\n    const module = requireNativeModule(moduleName);\n    return !!module;\n  } catch (error) {\n    return false;\n  }\n}\n\n// Usage Example:\n// const hasCamera = isExpoModuleAvailable('ExpoCamera');"}
{"instruction": "Create a custom Expo Module definition in TypeScript using 'expo-modules-core'. The module should expose a synchronous function 'getDeviceName' and an asynchronous function 'setValueAsync'.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native module\ninterface MyCustomModuleInterface {\n  getDeviceName(): string;\n  setValueAsync(value: string): Promise<void>;\n}\n\n// Load the native module\nconst MyCustomModule = requireNativeModule<MyCustomModuleInterface>('MyCustomModule');\n\nexport function getDeviceName(): string {\n  return MyCustomModule.getDeviceName();\n}\n\nexport async function setValueAsync(value: string): Promise<void> {\n  return await MyCustomModule.setValueAsync(value);\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. Use the 'Gesture' API to handle the pan interaction and update shared values.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a simple Android Native Module in Java that exposes a method 'getBatteryLevel' via a Promise. Include the required ReactMethod annotation.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            // Mocking battery level for example\n            int batteryLevel = 85;\n            promise.resolve(batteryLevel);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Create an Objective-C implementation for an iOS Native Module that exposes a method 'triggerHaptic' which takes a string argument representing the type.", "output": "#import \"RCTCalendarModule.h\"\n#import <React/RCTLog.h>\n#import <UIKit/UIKit.h>\n\n@implementation HapticModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(triggerHaptic:(NSString *)type)\n{\n  dispatch_async(dispatch_get_main_queue(), ^{\n    if ([type isEqualToString:@\"heavy\"]) {\n      UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleHeavy];\n      [generator impactOccurred];\n    } else {\n       UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight];\n       [generator impactOccurred];\n    }\n  });\n}\n\n@end"}
{"instruction": "Define a TypeScript specification for a React Native TurboModule named 'NativeCalculator'. It should include an 'add' method that takes two numbers and returns a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use a Reanimated Worklet to offload a heavy calculation (Fibonacci) to the UI thread to avoid blocking the JS thread when a button is pressed.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(heavyTask)(10);\n  };\n\n  function heavyTask(n: number) {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return 1;\n      return fib(num - 1) + fib(num - 2);\n    };\n    const result = fib(n);\n    console.log(`Fibonacci result on UI thread: ${result}`);\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a background fetch task registration using 'expo-background-fetch' and 'expo-task-manager'. The task should log the current time.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  const now = new Date().toISOString();\n  console.log(`Got background fetch call at date: ${now}`);\n  // Be sure to return the successful result type!\n  return BackgroundFetch.BackgroundFetchResult.NewData;\n});\n\n// 2. Register the task somewhere in your app initialization\nasync function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // android only,\n    startOnBoot: true, // android only\n  });\n}"}
{"instruction": "Optimize a large list implementation by using Shopify's 'FlashList' instead of the standard 'FlatList' to reduce bridge traffic and improve recycling performance.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ title: `Item ${i}` }));\n\nexport default function OptimizedList() {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => <Text style={styles.item}>{item.title}</Text>}\n        estimatedItemSize={50}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    padding: 10,\n    borderBottomWidth: 1,\n    borderColor: '#ccc',\n  },\n});"}
{"instruction": "Create a parallax effect component using 'useAnimatedSensor' from Reanimated to move an image based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withTiming(y * 20, { duration: 100 }) },\n        { translateY: withTiming(x * 20, { duration: 100 }) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Implement the Java method within an Android Native Module to emit an event 'onStepChange' to JavaScript using the RCTDeviceEventEmitter.", "output": "import com.facebook.react.modules.core.DeviceEventManagerModule;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.bridge.Arguments;\nimport androidx.annotation.Nullable;\n\n// Helper method inside your Native Module class\nprivate void sendEvent(String eventName, @Nullable WritableMap params) {\n    if (getReactApplicationContext().hasActiveCatalystInstance()) {\n        getReactApplicationContext()\n            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n            .emit(eventName, params);\n    }\n}\n\n// Usage example\npublic void onStepDetected(int steps) {\n    WritableMap params = Arguments.createMap();\n    params.putInt(\"steps\", steps);\n    sendEvent(\"onStepChange\", params);\n}"}
{"instruction": "Create a simple iOS Native Module in Swift that exposes a method to get the current device name. Include the Swift class and the required Objective-C export.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  @objc func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejector reject: RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejector:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create an Android Native Module in Kotlin that exposes a method to show a native Toast message.", "output": "// ToastModule.kt\npackage com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that supports adding two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo FileSystem to download an image from a URL and save it to the local document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + filename;\n    const { uri } = await FileSystem.downloadAsync(url, fileUri);\n    console.log('Finished downloading to ', uri);\n    return uri;\n  } catch (error) {\n    console.error('Download failed', error);\n    return null;\n  }\n};\n\n// Usage: downloadImage('https://example.com/image.png', 'myimage.png');"}
{"instruction": "Implement a Reanimated Worklet to offload a heavy calculation (e.g., Fibonacci) to the UI thread to avoid blocking the JS bridge.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst handleHeavyTask = () => {\n  runOnUI((input: number) => {\n    'worklet';\n    const result = fibonacci(input);\n    console.log(`Fibonacci result on UI thread: ${result}`);\n  })(20);\n};"}
{"instruction": "Create an Expo Config Plugin (app.plugin.js) to add a specific permission to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withCustomPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    const permissions = androidManifest.manifest['uses-permission'] || [];\n    \n    if (!permissions.some(p => p.$['android:name'] === 'android.permission.ACCESS_FINE_LOCATION')) {\n      permissions.push({ $: { 'android:name': 'android.permission.ACCESS_FINE_LOCATION' } });\n    }\n    \n    androidManifest.manifest['uses-permission'] = permissions;\n    return config;\n  });\n};\n\nmodule.exports = withCustomPermission;"}
{"instruction": "Use Reanimated Layout Animations to animate the mounting and unmounting of a list item with a fade and slide effect.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [show, setShow] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View \n          entering={FadeInUp.duration(500)} \n          exiting={FadeOutDown.duration(500)} \n          style={styles.card}\n        >\n          <Animated.Text>Animated Card</Animated.Text>\n        </Animated.View>\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 50 },\n  card: { height: 100, backgroundColor: 'tomato', marginTop: 20, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Use Expo SecureStore to safely store and retrieve a user's authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nasync function saveToken(key: string, value: string) {\n  await SecureStore.setItemAsync(key, value);\n}\n\nasync function getToken(key: string) {\n  const result = await SecureStore.getItemAsync(key);\n  if (result) {\n    console.log('Token retrieved:', result);\n    return result;\n  } else {\n    console.log('No token stored under that key.');\n    return null;\n  }\n}\n\n// Usage: saveToken('user_auth_token', 'xyz-123');"}
{"instruction": "Create a bridge optimization pattern using a typed array (Uint8Array) to pass binary data from JS to Native, avoiding base64 serialization overhead.", "output": "// JavaScript Side\nimport { NativeModules } from 'react-native';\nconst { DataProcessor } = NativeModules;\n\nconst sendBinaryData = () => {\n  const data = new Uint8Array([0, 255, 12, 44]);\n  // Convert typed array to string only for the bridge if JSI isn't used, \n  // but modern bridges handle ArrayBuffers better than base64 strings for large data.\n  // Ideally, in a JSI context, you pass the ArrayBuffer directly.\n  // Here is the standard bridge approach passing as string (less optimal) vs direct map:\n  \n  // Pseudo-code for JSI/TurboModule direct buffer access would be preferred here.\n  // However, for standard Native Module:\n  const base64Str = Buffer.from(data).toString('base64'); \n  DataProcessor.processData(base64Str);\n};\n\n// Native Side (Java - Android)\n// @ReactMethod\n// public void processData(String base64Data) {\n//    byte[] data = Base64.decode(base64Data, Base64.DEFAULT);\n//    // Process byte array...\n// }"}
{"instruction": "Create a custom Native Module for Android using Java to display a native Toast message, and provide the TypeScript interface to consume it.", "output": "// Android: ToastModule.java\npackage com.myapp;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.widget.Toast;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n\n// TypeScript: ToastModule.ts\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n    show(message: string, duration: number): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Implement a draggable box component using 'react-native-reanimated' (v3) and 'react-native-gesture-handler' without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, rStyle]} />\n    </GestureDetector>\n  );\n};\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a TypeScript specification for a TurboModule named 'NativeCalculator' to support the React Native New Architecture.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use 'expo-camera' to create a component that requests camera permissions and renders a simple camera view.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function SimpleCamera() {\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) return <View />;\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing=\"back\" />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n});"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's 'runOnUI' to execute a heavy calculation (Fibonacci) on the UI thread, avoiding JS thread blockage.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  // This function is defined as a worklet automatically by Reanimated babel plugin\n  const heavyTask = () => {\n    'worklet';\n    const fib = (n: number): number => {\n      if (n <= 1) return n;\n      return fib(n - 1) + fib(n - 2);\n    };\n    const result = fib(35); // Heavy recursive calc\n    console.log('[UI Thread] Result:', result);\n  };\n\n  const handlePress = () => {\n    // Offload to UI thread to keep JS thread responsive for other events\n    runOnUI(heavyTask)();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native Module for iOS using Swift to trigger Haptic Feedback and expose it to JavaScript.", "output": "// iOS: HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n  \n  @objc(triggerImpact:)\n  func triggerImpact(style: String) {\n    DispatchQueue.main.async {\n      let styleEnum: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n      case \"heavy\": styleEnum = .heavy\n      case \"medium\": styleEnum = .medium\n      default: styleEnum = .light\n      }\n      let generator = UIImpactFeedbackGenerator(style: styleEnum)\n      generator.impactOccurred()\n    }\n  }\n}\n\n// iOS: HapticModule.m (Macro export)\n#import <React/RCTBridgeModule.h>\n@interface RCT_EXTERN_MODULE(HapticModule, NSObject)\nRCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n@end\n\n// TS Interface\nimport { NativeModules } from 'react-native';\nconst { HapticModule } = NativeModules;\nexport const triggerHaptic = (style: 'light' | 'medium' | 'heavy') => HapticModule.triggerImpact(style);"}
{"instruction": "Use 'expo-file-system' to download an image from a URL and save it to the local document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + filename;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Implement a Reanimated Layout Animation to smoothly fade out items when they are removed from a list.", "output": "import React, { useState } from 'react';\nimport { Button, View } from 'react-native';\nimport Animated, { FadeOutLeft, Layout } from 'react-native-reanimated';\n\nexport default function ListDeleter() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          layout={Layout.springify()}\n          exiting={FadeOutLeft.duration(500)}\n          style={{ height: 50, backgroundColor: 'tomato', margin: 5 }}\n        />\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Expose a native Android View (a simple colored FrameLayout) as a UI Component to React Native using Java.", "output": "// Java: ColoredViewManager.java\npackage com.myapp;\nimport android.graphics.Color;\nimport android.widget.FrameLayout;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class ColoredViewManager extends SimpleViewManager<FrameLayout> {\n    public static final String REACT_CLASS = \"ColoredView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public FrameLayout createViewInstance(ThemedReactContext context) {\n        return new FrameLayout(context);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(FrameLayout view, String color) {\n        view.setBackgroundColor(Color.parseColor(color));\n    }\n}\n\n// TypeScript: ColoredView.tsx\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColoredViewProps extends ViewProps {\n  color: string;\n}\n\nexport const ColoredView = requireNativeComponent<ColoredViewProps>('ColoredView');"}
{"instruction": "Create a component that rotates an image based on the device's gyroscope data using 'react-native-reanimated' sensors.", "output": "import React from 'react';\nimport { Image, StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withSpring } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withSpring(`${x}rad`) },\n        { rotateY: withSpring(`${y}rad`) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={[styles.image, animatedStyle]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  image: { width: 100, height: 100 },\n});"}
{"instruction": "Create a basic iOS Native Module in Swift (using the Bridge) that exposes a method to get the device's name. Include the Objective-C interface file.", "output": "// DeviceInfo.swift\nimport Foundation\nimport React\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Create a simple Android Native Module in Java that exposes a method to show a Toast message. Include the ReactPackage implementation.", "output": "// ToastModule.java\npackage com.myapp;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.widget.Toast;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n   ToastModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"ToastModule\";\n   }\n\n   @ReactMethod\n   public void show(String message, int duration) {\n       Toast.makeText(getReactApplicationContext(), message, duration).show();\n   }\n}\n\n// MyAppPackage.java\n// ... (Imports omitted for brevity)\npublic class MyAppPackage implements ReactPackage {\n   @Override\n   public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {\n       List<NativeModule> modules = new ArrayList<>();\n       modules.add(new ToastModule(reactContext));\n       return modules;\n   }\n\n   @Override\n   public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n       return Collections.emptyList();\n   }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TurboModule specification (TypeScript) for a calculator module under the New Architecture. It should have an `add` method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a modern Expo Module (Swift) using the Expo Modules API that exposes a synchronous function to get the system uptime.", "output": "import ExpoModulesCore\n\npublic class MySystemModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MySystemModule\")\n\n    // Synchronous function accessible from JS\n    Function(\"getUptime\") { () -> TimeInterval in\n      return ProcessInfo.processInfo.systemUptime\n    }\n  }\n}"}
{"instruction": "Optimize bridge performance by using `runOnUI` in Reanimated to handle a scroll event and update a shared value without crossing the bridge to the JS thread.", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport default function OptimizedScroll() {\n  const scrollY = useSharedValue(0);\n\n  // This handler runs entirely on the UI thread (Native)\n  // preventing frame drops during heavy JS thread load.\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      scrollY.value = event.contentOffset.y;\n      // Custom logic running on UI thread\n      if (event.contentOffset.y > 100) {\n         // perform UI-only logic here\n      }\n    },\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n      {/* Content */}\n    </Animated.ScrollView>\n  );\n}"}
{"instruction": "Use `InteractionManager` to defer a heavy calculation until after a navigation transition or animation is complete to prevent UI jank.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nconst HeavyScreen = () => {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Schedule the heavy task after animations/transitions finish\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform expensive setup or data fetching here\n      doHeavyCalculation();\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  const doHeavyCalculation = () => {\n    // Simulation of blocking work\n    let result = 0;\n    for(let i = 0; i < 5000000; i++) result += i;\n    console.log('Done', result);\n  };\n\n  if (!isReady) {\n    return <ActivityIndicator />;\n  }\n\n  return (\n    <View>\n      <Text>Heavy Content Loaded</Text>\n    </View>\n  );\n};\n\nexport default HeavyScreen;"}
{"instruction": "Implement a custom Native UI Component Manager (Android/Java) to expose a simple `ImageView` to React Native.", "output": "package com.myapp;\n\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport android.widget.ImageView;\nimport com.squareup.picasso.Picasso;\n\npublic class ReactImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTImageView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public ImageView createViewInstance(ThemedReactContext context) {\n        return new ImageView(context);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        Picasso.get().load(src).into(view);\n    }\n}"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 50 },\n  item: { height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Create a TypeScript wrapper for a Native UI Component named `RCTCustomView` using `requireNativeComponent`.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface CustomViewProps extends ViewProps {\n  color: string;\n  onRegionChange?: (event: any) => void;\n}\n\n// The first argument matches the name returned by the Native ViewManager\nconst RCTCustomView = requireNativeComponent<CustomViewProps>('RCTCustomView');\n\nexport default RCTCustomView;"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeMath' that includes a synchronous method to add two numbers. This leverages the JSI for direct C++ binding.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeMath');"}
{"instruction": "Create a Draggable Box component using 'react-native-reanimated' and 'react-native-gesture-handler' that runs entirely on the UI thread to avoid bridge traffic.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Gesture, GestureDetector, GestureHandlerRootView } from 'react-native-gesture-handler';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      start.value = { x: offset.value.x, y: offset.value.y };\n    })\n    .onUpdate((e) => {\n      offset.value = {\n        x: start.value.x + e.translationX,\n        y: start.value.y + e.translationY,\n      };\n    })\n    .onEnd(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ translateX: offset.value.x }, { translateY: offset.value.y }],\n  }));\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write an Expo Config Plugin to automatically add the 'ACCESS_FINE_LOCATION' permission to the AndroidManifest.xml during the prebuild phase.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withLocationPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (item) => item.$['android:name'] === 'android.permission.ACCESS_FINE_LOCATION'\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': 'android.permission.ACCESS_FINE_LOCATION' },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withLocationPermission;"}
{"instruction": "Implement a Swift (iOS) Native Module method that resolves a Promise with the device's battery level. This demonstrates basic asynchronous bridging.", "output": "@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc(getBatteryLevel:withRejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"ERR_UNAVAILABLE\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n}"}
{"instruction": "Use 'react-native-reanimated' to create a scrolling header that interpolates opacity based on the scroll position of an Animated.ScrollView.", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\nimport { View, StyleSheet, Text } from 'react-native';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Hidden Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 60, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1, justifyContent: 'center', alignItems: 'center' },\n  content: { height: 1000, backgroundColor: '#f0f0f0' }\n});"}
{"instruction": "Implement a Kotlin (Android) Native Module method that shows a system Toast message. This exposes Android-specific UI functionality to JS.", "output": "package com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}"}
{"instruction": "Use 'expo-file-system' to check if a specific directory exists in the document cache, and create it if it does not.", "output": "import * as FileSystem from 'expo-file-system';\n\nasync function ensureDirExists(dirName: string) {\n  const dirUri = FileSystem.documentDirectory + dirName;\n  const dirInfo = await FileSystem.getInfoAsync(dirUri);\n  \n  if (!dirInfo.exists) {\n    await FileSystem.makeDirectoryAsync(dirUri, { intermediates: true });\n    console.log('Directory created:', dirUri);\n  } else {\n    console.log('Directory exists');\n  }\n}"}
{"instruction": "Implement the JavaScript side of a Custom Native UI Component (e.g., a MapView) using 'requireNativeComponent' with TypeScript props definition.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface NativeMapProps extends ViewProps {\n  zoomEnabled?: boolean;\n  region: {\n    latitude: number;\n    longitude: number;\n    latitudeDelta: number;\n    longitudeDelta: number;\n  };\n  onRegionChange?: (event: any) => void;\n}\n\nconst RNTMap = requireNativeComponent<NativeMapProps>('RNTMap');\n\nexport default RNTMap;"}
{"instruction": "Optimize bridge performance by passing a binary buffer (Uint8Array) to a native module method instead of a Base64 string. This snippet shows the JS call site.", "output": "import { NativeModules } from 'react-native';\n\nconst { ImageProcessor } = NativeModules;\n\n// Optimization: Passing binary data directly avoids the CPU cost of Base64 serialization/deserialization on the Bridge.\nconst processImageBuffer = async (imageData: Uint8Array) => {\n  try {\n    // Note: React Native handles ArrayBuffer serialization efficiently in modern versions\n    const result = await ImageProcessor.applyFilter(imageData.buffer);\n    return result;\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create a Reanimated Layout Animation to make a list item slide in from the right when mounted and fade out when unmounted.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, SlideInRight } from 'react-native-reanimated';\n\nconst ListItem = ({ label }: { label: string }) => (\n  <Animated.View \n    entering={SlideInRight.duration(500)} \n    exiting={FadeOut.duration(300)} \n    style={styles.item}\n  >\n    <Text>{label}</Text>\n  </Animated.View>\n);\n\nconst styles = StyleSheet.create({\n  item: { padding: 20, backgroundColor: 'white', borderBottomWidth: 1, borderColor: '#ccc' }\n});\n\nexport default ListItem;"}
{"instruction": "Create a draggable box component using React Native Reanimated (v2/v3) and React Native Gesture Handler. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Create a simple Android Native Module in Java that exposes a method to show a system Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to JavaScript\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    // Method exposed to JavaScript\n    @ReactMethod\n    public void show(String message, int duration) {\n        int toastDuration = (duration == 0) ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG;\n        Toast.makeText(getReactApplicationContext(), message, toastDuration).show();\n    }\n}"}
{"instruction": "Write an Expo Config Plugin to automatically add a 'NSCameraUsageDescription' key to the iOS Info.plist during the prebuild phase.", "output": "const { withInfoPlist } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config, { permissionMessage } = {}) => {\n  return withInfoPlist(config, (config) => {\n    config.modResults.NSCameraUsageDescription = \n      permissionMessage || \"This app needs access to the camera to take photos.\";\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Implement a scroll-based animation using Reanimated where a header's opacity fades out as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [1, 0],\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Fading Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.listItem}>\n            <Text>Item {i + 1}</Text>\n          </View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 60 },\n  header: {\n    position: 'absolute',\n    top: 0, left: 0, right: 0,\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  listItem: { height: 80, borderBottomWidth: 1, justifyContent: 'center', padding: 20 },\n});"}
{"instruction": "Using the modern Expo Modules API (Swift), create a module definition that exposes a synchronous function to get the device model name.", "output": "import ExpoModulesCore\nimport UIKit\n\npublic class DeviceInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    // Sets the name of the module that JavaScript code will use to require it.\n    Name(\"DeviceInfo\")\n\n    // Exposes a synchronous function to JavaScript\n    Function(\"getModelName\") { () -> String in\n      return UIDevice.current.model\n    }\n  }\n}"}
{"instruction": "Demonstrate a Bridge Optimization technique using 'setNativeProps' to update a view's style directly without triggering a React render cycle (useful for high-frequency updates like scrolling tickers, though Reanimated is preferred for animations).", "output": "import React, { useRef } from 'react';\nimport { View, Button, TextInput, StyleSheet } from 'react-native';\n\nexport default function DirectManipulation() {\n  const inputRef = useRef<TextInput>(null);\n\n  const changeColorDirectly = () => {\n    // OPTIMIZATION: Bypasses the React Virtual DOM diffing and bridge serialization overhead\n    // for a simple style update. \n    inputRef.current?.setNativeProps({\n      style: { backgroundColor: '#' + Math.floor(Math.random()*16777215).toString(16) },\n      text: 'Updated via Native Props'\n    });\n  };\n\n  return (\n    <View style={styles.container}>\n      <TextInput \n        ref={inputRef} \n        style={styles.box} \n        defaultValue=\"Original Text\" \n      />\n      <Button title=\"Update Directly\" onPress={changeColorDirectly} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 200, height: 50, borderWidth: 1, marginBottom: 20, padding: 10 }\n});"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) named 'NativeCalculator'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous and asynchronous methods\n  add(a: number, b: number): Promise<number>;\n  \n  // Synchronous method example (New Arch specific capability)\n  multiply(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a Reanimated Worklet to offload a heavy calculation (e.g., Fibonacci) to the UI thread to prevent blocking the JS thread.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function WorkletExample() {\n  \n  // This function is marked as a worklet and runs on the UI thread\n  const heavyTask = () => {\n    'worklet';\n    const fib = (n: number): number => {\n      if (n <= 1) return n;\n      return fib(n - 1) + fib(n - 2);\n    };\n    \n    const result = fib(30);\n    console.log(`[UI Thread] Fib result: ${result}`);\n  };\n\n  const handlePress = () => {\n    // Dispatch execution to the UI thread\n    runOnUI(heavyTask)();\n    Alert.alert('Task started on UI thread');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create an iOS Native Module in Swift that requires an Objective-C bridge file (header) to expose a method 'getBatteryLevel' to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    resolve(level)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (The Bridge)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n\n@end\n*/"}
{"instruction": "Implement Layout Animations using Reanimated 3 to animate a list item appearing and disappearing without manual interpolation logic.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function LayoutAnimationList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      \n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          style={styles.card}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n        >\n          <Text>Item ID: {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', marginBottom: 20, gap: 10 },\n  card: { \n    width: 300, \n    height: 50, \n    backgroundColor: '#ddd', \n    marginBottom: 10, \n    justifyContent: 'center', \n    alignItems: 'center', \n    borderRadius: 8 \n  }\n});"}
{"instruction": "Create a draggable component using React Native Reanimated 3 and Gesture Handler. The component should be a blue square that returns to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a simple Expo Module in Swift (iOS) that exposes a function to get the device's current battery level. This demonstrates modern Expo Native Modules API.", "output": "import ExpoModulesCore\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a basic Native Module in Kotlin for Android that displays a system Toast message. Include the ReactMethod annotation.", "output": "package com.myapp.toast\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Use Reanimated's `runOnUI` to offload a heavy synchronous calculation (like a Fibonacci sequence) to the UI thread to prevent blocking the JS thread during user interactions.", "output": "import { Button } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n  \n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const result = fib(35); // Heavy calc on UI thread\n      console.log('Fibonacci Result calculated on UI thread:', result);\n    })();\n  };\n\n  return <Button title=\"Run Heavy Task\" onPress={handlePress} />;\n};"}
{"instruction": "Create a React Native component that uses `useAnimatedScrollHandler` to interpolate the opacity of a header based on the scroll Y position of an Animated.ScrollView.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, useAnimatedScrollHandler, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: { height: 80, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#f0f0f0' }\n});"}
{"instruction": "Write an Objective-C header and implementation file snippet to create a Native Module that exports a constant `deviceName` to JavaScript.", "output": "// DeviceInfo.h\n#import <React/RCTBridgeModule.h>\n@interface DeviceInfo : NSObject <RCTBridgeModule>\n@end\n\n// DeviceInfo.m\n#import \"DeviceInfo.h\"\n#import <UIKit/UIKit.h>\n\n@implementation DeviceInfo\n\nRCT_EXPORT_MODULE();\n\n- (NSDictionary *)constantsToExport\n{\n  return @{ @\"deviceName\": [[UIDevice currentDevice] name] };\n}\n\n+ (BOOL)requiresMainQueueSetup\n{\n  return YES;\n}\n\n@end"}
{"instruction": "Implement a secure storage utility using `expo-secure-store` to save and retrieve an authentication token asynchronously.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'auth_token';\n\nexport const TokenService = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(KEY);\n    } catch (error) {\n      console.error('Error getting token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    await SecureStore.deleteItemAsync(KEY);\n  }\n};"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list. Create a list component where items slide in from the right and fade out when removed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, FlatList } from 'react-native';\nimport Animated, { SlideInRight, FadeOut } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={{ flex: 1, marginTop: 50 }}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={SlideInRight} \n            exiting={FadeOut} \n            style={{ padding: 20, borderBottomWidth: 1, borderColor: '#ccc' }}\n          >\n            <Text onPress={() => removeItem(item)}>Item {item} (Tap to remove)</Text>\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n};"}
{"instruction": "Create an Expo Config Plugin (app.plugin.js) that modifies the AndroidManifest.xml to add a specific permission (e.g., CAMERA). This is essential for configuring native projects without ejecting.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    // Check if permission already exists to avoid duplicates\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (perm) => perm.$['android:name'] === 'android.permission.CAMERA'\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': 'android.permission.CAMERA' },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Optimize bridge communication by creating a Reanimated component that adjusts padding synchronously with the keyboard height using `useAnimatedKeyboard`, avoiding the asynchronous delay of the standard Keyboard API.", "output": "import React from 'react';\nimport { TextInput, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useAnimatedKeyboard } from 'react-native-reanimated';\n\nexport const KeyboardAwareView = () => {\n  const keyboard = useAnimatedKeyboard();\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    paddingBottom: keyboard.height.value,\n  }));\n\n  return (\n    <Animated.View style={[styles.container, animatedStyle]}>\n      <TextInput \n        style={styles.input} \n        placeholder=\"Type here...\" \n        placeholderTextColor=\"#999\"\n      />\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'flex-end' },\n  input: { height: 50, borderWidth: 1, borderColor: '#ccc', margin: 20, padding: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a draggable box component using React Native Reanimated (v2+) and React Native Gesture Handler. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a Java Native Module for Android (Old Architecture) that exposes a method to get the device's battery level percentage. Include the Java code for the Module class.", "output": "package com.myapp;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    private ReactApplicationContext reactContext;\n\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n        this.reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = reactContext.registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level * 100 / (float)scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Implement a custom Layout Animation using Reanimated. Create a list item component that fades in when mounted and slides out to the left when unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutLeft, Layout } from 'react-native-reanimated';\n\nconst ListItem = ({ id, onDelete }: { id: number, onDelete: (id: number) => void }) => {\n  return (\n    <Animated.View\n      entering={FadeIn.duration(500)}\n      exiting={SlideOutLeft.duration(300)}\n      layout={Layout.springify()}\n      style={styles.item}\n    >\n      <Text style={styles.text}>Item {id}</Text>\n      <Button title=\"Delete\" onPress={() => onDelete(id)} />\n    </Animated.View>\n  );\n};\n\nconst MyList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const handleDelete = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <ListItem key={item} id={item} onDelete={handleDelete} />\n      ))}\n      <Button title=\"Add Item\" onPress={() => setItems([...items, Date.now()])} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    padding: 20,\n    backgroundColor: '#f0f0f0',\n    marginBottom: 10,\n    borderRadius: 8,\n  },\n  text: { fontSize: 18 },\n});\n\nexport default MyList;"}
{"instruction": "Create a Swift Native Module for iOS to trigger system Haptic Feedback. Include the Swift class and the Obj-C exposition macro.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func triggerSelection() {\n    DispatchQueue.main.async {\n      let generator = UISelectionFeedbackGenerator()\n      generator.selectionChanged()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n  RCT_EXTERN_METHOD(triggerSelection)\n@end"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' that includes a synchronous method to add two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method to add two numbers\n  add(a: number, b: number): number;\n  \n  // Asynchronous method example\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Using `expo-file-system`, write a function to download an image from a URL and save it to the app's document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nasync function downloadImage(imageUrl: string, fileName: string): Promise<string | null> {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      imageUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error('Download error:', e);\n    return null;\n  }\n}"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function snippet that installs a global function `nativeAdd` into the Javascript Runtime. This function should sum two numbers synchronously, avoiding the asynchronous bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid installNativeAdd(Runtime& runtime) {\n  auto nativeAdd = Function::createFromHostFunction(\n    runtime,\n    PropNameID::forAscii(runtime, \"nativeAdd\"),\n    2, // Number of arguments\n    [](Runtime& runtime, const Value& thisValue, const Value* arguments, size_t count) -> Value {\n      if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n         throw JSError(runtime, \"nativeAdd expects 2 number arguments\");\n      }\n      \n      double a = arguments[0].asNumber();\n      double b = arguments[1].asNumber();\n      \n      return Value(a + b);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"nativeAdd\", nativeAdd);\n}"}
{"instruction": "Optimize a React Native FlatList rendering complex items. Implement `getItemLayout` for fixed-height items and wrap the render item in `React.memo` to prevent unnecessary re-renders.", "output": "import React, { useCallback } from 'react';\nimport { FlatList, View, Text, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 80;\n\ninterface ItemProps {\n  title: string;\n  id: string;\n}\n\n// Optimization 1: Memoize the list item\nconst ListItem = React.memo(({ title }: ItemProps) => {\n  console.log(`Rendering ${title}`);\n  return (\n    <View style={styles.item}>\n      <Text>{title}</Text>\n    </View>\n  );\n});\n\nconst OptimizedList = ({ data }: { data: ItemProps[] }) => {\n  \n  const renderItem = useCallback(({ item }: { item: ItemProps }) => (\n    <ListItem title={item.title} id={item.id} />\n  ), []);\n\n  const getItemLayout = useCallback((data: any, index: number) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  }), []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      // Optimization 2: Skip measurement calculation for fixed height items\n      getItemLayout={getItemLayout}\n      // Optimization 3: Window size adjustment\n      windowSize={5}\n      initialNumToRender={10}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: ITEM_HEIGHT,\n    justifyContent: 'center',\n    padding: 20,\n    borderBottomWidth: 1,\n    borderColor: '#ccc',\n  }\n});"}
{"instruction": "Create a Reanimated 'Worklet' to offload a heavy calculation (e.g., Fibonacci) to the UI thread to avoid blocking the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Define the heavy function as a worklet\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Trigger from JS thread\nconst handleHeavyCalculation = () => {\n  runOnUI((input: number) => {\n    'worklet';\n    const start = _getAnimationTimestamp();\n    const result = fibonacci(input);\n    const end = _getAnimationTimestamp();\n    console.log(`Fibonacci(${input}) = ${result}. Took ${end - start}ms on UI thread.`);\n  })(35);\n};"}
{"instruction": "Use `expo-haptics` to create a custom hook that provides different feedback types based on user interaction success or failure.", "output": "import * as Haptics from 'expo-haptics';\nimport { useCallback } from 'react';\n\nexport const useFeedback = () => {\n  const success = useCallback(() => {\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  }, []);\n\n  const error = useCallback(() => {\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  }, []);\n\n  const lightTap = useCallback(() => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  }, []);\n\n  return { success, error, lightTap };\n};\n\n// Usage Example:\n// const { success } = useFeedback();\n// <Button onPress={success} title=\"Complete Task\" />"}
{"instruction": "Create a simple Expo Module using the Kotlin API (Expo Modules API) that exposes a function to get the device's model name synchronously.", "output": "import expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceModelModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceModel\")\n\n    // Defines a synchronous function that returns the device model\n    Function(\"getModelName\") {\n      return@Function Build.MODEL\n    }\n  }\n}"}
{"instruction": "Implement a React Native component using `react-native-reanimated` (v3) that creates a pulsing circle effect (scaling up and down continuously).", "output": "import React, { useEffect } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withRepeat, \n  withTiming, \n  Easing \n} from 'react-native-reanimated';\n\nexport const PulsingCircle = () => {\n  const scale = useSharedValue(1);\n\n  useEffect(() => {\n    scale.value = withRepeat(\n      withTiming(1.5, { duration: 1000, easing: Easing.ease }),\n      -1,\n      true\n    );\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.circle, animatedStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  circle: { width: 100, height: 100, borderRadius: 50, backgroundColor: 'blue' },\n});"}
{"instruction": "Write a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator` that supports adding two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a Legacy Native Module in Java (Android) that opens a specific URL in the default browser.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BrowserOpenerModule extends ReactContextBaseJavaModule {\n    BrowserOpenerModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BrowserOpener\";\n    }\n\n    @ReactMethod\n    public void openUrl(String url) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(url));\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (intent.resolveActivity(getReactApplicationContext().getPackageManager()) != null) {\n            getReactApplicationContext().startActivity(intent);\n        }\n    }\n}"}
{"instruction": "Implement a Reanimated `worklet` to format a currency string on the UI thread, preventing frame drops during active gestures.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Defining the worklet\nconst formatCurrencyWorklet = (amount: number) => {\n  'worklet';\n  return '$' + amount.toFixed(2).replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,');\n};\n\n// Usage example inside a gesture handler or animated reaction\nexport const updatePriceLabel = (price: number) => {\n  runOnUI(() => {\n    const formatted = formatCurrencyWorklet(price);\n    console.log('Formatted on UI Thread:', formatted);\n    // logic to update text input props directly via refs would go here\n  })();\n};"}
{"instruction": "Create a draggable box component using `react-native-gesture-handler` and `react-native-reanimated`.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, rStyle]} />\n    </GestureDetector>\n  );\n};\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Write an Objective-C header and implementation for a Legacy iOS Native Module that exposes a method to trigger Haptic Feedback.", "output": "// HapticModule.h\n#import <React/RCTBridgeModule.h>\n#import <UIKit/UIKit.h>\n\n@interface HapticModule : NSObject <RCTBridgeModule>\n@end\n\n// HapticModule.m\n#import \"HapticModule.h\"\n\n@implementation HapticModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(triggerSelection)\n{\n  dispatch_async(dispatch_get_main_queue(), ^{\n    UISelectionFeedbackGenerator *generator = [[UISelectionFeedbackGenerator alloc] init];\n    [generator selectionChanged];\n  });\n}\n\n@end"}
{"instruction": "Demonstrate Bridge Optimization by using a `Uint8Array` to pass binary data to a Native Module, avoiding Base64 string serialization overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { ImageProcessor } = NativeModules;\n\n// Instead of passing a Base64 string which requires expensive serialization/deserialization:\n// const base64String = \"...\"; \n// ImageProcessor.process(base64String);\n\n// Optimization: Pass binary data directly using TypedArrays (supported by the Bridge/JSI)\nconst processImageBuffer = (data: ArrayBuffer) => {\n  const buffer = new Uint8Array(data);\n  // Native side receives this as a byte array/NSData/Blob without string parsing\n  ImageProcessor.processBinaryData(buffer);\n};"}
{"instruction": "Use JSI (JavaScript Interface) in C++ to write a function that performs a high-performance synchronous calculation, bypassing the React Native asynchronous bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\n// Example function to install into the Runtime\nvoid installMathBinding(Runtime& runtime) {\n  auto multiply = Function::createFromHostFunction(\n    runtime,\n    PropNameID::forAscii(runtime, \"multiplyNative\"),\n    2, // Number of arguments\n    [](Runtime& runtime, const Value& thisValue, const Value* arguments, size_t count) -> Value {\n      if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n        return Value::undefined();\n      }\n      double result = arguments[0].asNumber() * arguments[1].asNumber();\n      return Value(result);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"multiplyNative\", multiply);\n}"}
{"instruction": "Create an Expo component that uses `expo-file-system` to read a local file and display the content text.", "output": "import React, { useState, useEffect } from 'react';\nimport { Text, View } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nexport const FileReader = () => {\n  const [content, setContent] = useState<string>('Loading...');\n\n  useEffect(() => {\n    const readFile = async () => {\n      const fileUri = FileSystem.documentDirectory + 'example.txt';\n      try {\n        // Ensure file exists for demo purposes, normally you check info first\n        await FileSystem.writeAsStringAsync(fileUri, 'Hello from Expo FS!');\n        \n        const result = await FileSystem.readAsStringAsync(fileUri);\n        setContent(result);\n      } catch (e) {\n        setContent('Error reading file');\n      }\n    };\n    readFile();\n  }, []);\n\n  return (\n    <View>\n      <Text>File Content: {content}</Text>\n    </View>\n  );\n};"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that creates a draggable square box using the PanGestureHandler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture, GestureHandlerRootView } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 100,\n    width: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a TypeScript definition for a TurboModule (New Architecture) named 'NativeCalculator' that includes a synchronous method 'add' and an asynchronous method 'multiply'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method using the bridge/JSI\n  add(a: number, b: number): number;\n  \n  // Asynchronous method returning a Promise\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a simple Native Module in Android (Kotlin) that exposes a method to get the device battery level.", "output": "package com.myapp.battery\n\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.BatteryManager\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass BatteryModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"BatteryModule\"\n    }\n\n    @ReactMethod\n    fun getBatteryLevel(promise: Promise) {\n        try {\n            val ifilter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)\n            val batteryStatus = reactApplicationContext.registerReceiver(null, ifilter)\n\n            val level = batteryStatus?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1\n            val scale = batteryStatus?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1\n\n            if (level == -1 || scale == -1) {\n                promise.reject(\"BATTERY_ERROR\", \"Could not get battery level\")\n            } else {\n                promise.resolve(level / scale.toFloat())\n            }\n        } catch (e: Exception) {\n            promise.reject(\"BATTERY_ERROR\", e.message)\n        }\n    }\n}"}
{"instruction": "Write an Expo Config Plugin to automatically add the 'ACCESS_FINE_LOCATION' permission to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withLocationPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    const permissions = androidManifest.manifest['uses-permission'] || [];\n    \n    if (!permissions.some(p => p.$['android:name'] === 'android.permission.ACCESS_FINE_LOCATION')) {\n      permissions.push({\n        $: {\n          'android:name': 'android.permission.ACCESS_FINE_LOCATION',\n        },\n      });\n    }\n\n    androidManifest.manifest['uses-permission'] = permissions;\n    return config;\n  });\n};\n\nmodule.exports = withLocationPermission;"}
{"instruction": "Implement a Reanimated 'worklet' to offload a heavy calculation (Fibonacci sequence) to the UI thread to avoid blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      // This runs on the UI thread\n      const heavyResult = fibonacci(35);\n      \n      // Call back to JS thread to update state\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Not calculated'}</Text>\n      <Button title=\"Calculate Fib(35) on UI Thread\" onPress={handleCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Create an iOS Native Module (Swift) that exports a constant value 'systemName' to JavaScript.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc\n  func constantsToExport() -> [AnyHashable : Any]! {\n    return [\n      \"systemName\": UIDevice.current.systemName\n    ]\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// DeviceInfo.m (Objective-C Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n// @end"}
{"instruction": "Use 'expo-haptics' to trigger a notification feedback when an error occurs in a function.", "output": "import * as Haptics from 'expo-haptics';\n\nasync function performRiskyOperation() {\n  try {\n    // Simulate operation\n    throw new Error(\"Operation failed\");\n  } catch (error) {\n    console.error(error);\n    // Trigger error haptic feedback\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  }\n}"}
{"instruction": "Optimize bridge traffic by creating a custom hook that uses React Native's 'LayoutAnimation' for a simple list item deletion, avoiding the overhead of complex animation libraries for simple layout changes.", "output": "import { useState, useCallback } from 'react';\nimport { LayoutAnimation, UIManager, Platform } from 'react-native';\n\nif (Platform.OS === 'android') {\n  if (UIManager.setLayoutAnimationEnabledExperimental) {\n    UIManager.setLayoutAnimationEnabledExperimental(true);\n  }\n}\n\nexport const useListRemover = (initialItems: string[]) => {\n  const [items, setItems] = useState(initialItems);\n\n  const removeItem = useCallback((indexToRemove: number) => {\n    // Configure animation before state update\n    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);\n    \n    setItems((currentItems) => \n      currentItems.filter((_, index) => index !== indexToRemove)\n    );\n  }, []);\n\n  return { items, removeItem };\n};"}
{"instruction": "Implement a JSI-style synchronous native method binding in C++ (Pseudo-code for the `install` function) to expose a function `global.multiply(a, b)`.", "output": "void install(facebook::jsi::Runtime& jsiRuntime) {\n  auto multiply = facebook::jsi::Function::createFromHostFunction(\n    jsiRuntime,\n    facebook::jsi::PropNameID::forAscii(jsiRuntime, \"multiply\"),\n    2, // param count\n    [](facebook::jsi::Runtime& runtime,\n       const facebook::jsi::Value& thisValue,\n       const facebook::jsi::Value* arguments,\n       size_t count) -> facebook::jsi::Value {\n      \n      double res = arguments[0].asNumber() * arguments[1].asNumber();\n      return facebook::jsi::Value(res);\n    }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", std::move(multiply));\n}"}
{"instruction": "Create a React Native component that subscribes to a native event 'onVolumeChange' emitted by a Native Module.", "output": "import React, { useEffect, useState } from 'react';\nimport { NativeEventEmitter, NativeModules, Text, View } from 'react-native';\n\nconst { VolumeModule } = NativeModules;\n\n// Guard against missing module\nconst volumeEmitter = VolumeModule \n  ? new NativeEventEmitter(VolumeModule) \n  : null;\n\nexport default function VolumeMonitor() {\n  const [volume, setVolume] = useState(0);\n\n  useEffect(() => {\n    if (!volumeEmitter) return;\n\n    const subscription = volumeEmitter.addListener('onVolumeChange', (event) => {\n      setVolume(event.newVolume);\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  return (\n    <View>\n      <Text>Current Volume: {volume}</Text>\n    </View>\n  );\n}"}
{"instruction": "Create a simple Native Module in Swift for iOS that exposes a method to get the device's battery level and returns it to JavaScript via a Promise.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. BatteryModule.ts (JavaScript Usage)\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nexport const getBatteryPercentage = async (): Promise<number> => {\n  return await BatteryModule.getBatteryLevel();\n};"}
{"instruction": "Create a Native Module in Kotlin for Android that opens a specific URL in the default browser.", "output": "// 1. LinkModule.kt\npackage com.myapp\n\nimport android.content.Intent\nimport android.net.Uri\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass LinkModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName() = \"LinkModule\"\n\n    @ReactMethod\n    fun openUrl(url: String) {\n        val intent = Intent(Intent.ACTION_VIEW)\n        intent.data = Uri.parse(url)\n        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n        reactApplicationContext.startActivity(intent)\n    }\n}\n\n// 2. LinkPackage.kt (Registering the module)\n// ... Standard ReactPackage implementation returning LinkModule ...\n\n// 3. usage.ts\nimport { NativeModules } from 'react-native';\nconst { LinkModule } = NativeModules;\n\nLinkModule.openUrl('https://reactnative.dev');"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a modern Expo Module (using expo-modules-core) that returns the device name synchronously.", "output": "// 1. index.ts (Entry point)\nimport { requireNativeModule } from 'expo-modules-core';\n\nconst DeviceNameModule = requireNativeModule('DeviceName');\n\nexport function getDeviceName(): string {\n  return DeviceNameModule.getDeviceName();\n}\n\n// 2. DeviceNameModule.swift (iOS implementation)\nimport ExpoModulesCore\nimport UIKit\n\npublic class DeviceNameModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceName\")\n\n    Function(\"getDeviceName\") {\n      return UIDevice.current.name\n    }\n  }\n}\n\n// 3. DeviceNameModule.kt (Android implementation)\npackage expo.modules.devicename\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass DeviceNameModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceName\")\n\n    Function(\"getDeviceName\") {\n      return android.os.Build.MODEL\n    }\n  }\n}"}
{"instruction": "Demonstrate how to offload a heavy synchronous calculation to the UI thread using Reanimated Worklets to prevent freezing the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculationWorklet() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      'worklet';\n      // Simulating heavy work on UI thread\n      let sum = 0;\n      for (let i = 0; i < 100000000; i++) {\n        sum += i;\n      }\n      \n      // Update state back on JS thread\n      runOnJS(setResult)(sum);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Calc\" onPress={handleCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Implement a scroll-driven animation where an image header fades out and scales down as the user scrolls up, using Reanimated.", "output": "import React from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\nconst HEADER_HEIGHT = 200;\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(scrollY.value, [0, HEADER_HEIGHT], [1, 0], Extrapolate.CLAMP);\n    const scale = interpolate(scrollY.value, [-100, 0], [1.2, 1], Extrapolate.CLAMP);\n    return { opacity, transform: [{ scale }] };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.Image \n        source={{ uri: 'https://via.placeholder.com/400' }}\n        style={[styles.header, headerStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n         <View style={{ height: 1000, backgroundColor: '#fff', marginTop: HEADER_HEIGHT }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { position: 'absolute', top: 0, left: 0, width, height: HEADER_HEIGHT, zIndex: 1 },\n});"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function snippet to expose a synchronous 'multiply' function directly to the Javascript Runtime, bypassing the asynchronous bridge.", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n        if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n             return Value::undefined();\n        }\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", std::move(multiply));\n}\n\n// Usage in JS (assuming binding is installed):\n// global.multiply(10, 5); // Returns 50 synchronously"}
{"instruction": "Create a Reanimated Parallax effect using the device Gyroscope sensor.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withSpring, interpolate } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    const transX = withSpring(interpolate(y, [-1, 1], [-20, 20]));\n    const transY = withSpring(interpolate(x, [-1, 1], [-20, 20]));\n\n    return {\n      transform: [{ translateX: transX }, { translateY: transY }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.card, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  card: { width: 200, height: 300, backgroundColor: 'tomato', borderRadius: 10 },\n});"}
{"instruction": "Define a TurboModule specification (New Architecture) in TypeScript for a Calculator module.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous methods\n  add(a: number, b: number): number;\n  \n  // Define asynchronous methods\n  multiply(a: number, b: number): Promise<number>;\n  \n  // Define void methods\n  logOperation(message: string): void;\n}\n\n// Enforce the module name\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a custom Native UI Component (Android) that wraps a standard Android TextView and exposes it to React Native.", "output": "// 1. CustomTextViewManager.java\npackage com.myapp;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport android.widget.TextView;\nimport android.graphics.Color;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"CustomTextView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        return new TextView(reactContext);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n    \n    @ReactProp(name = \"textColor\", customType = \"Color\")\n    public void setTextColor(TextView view, Integer color) {\n        view.setTextColor(color != null ? color : Color.BLACK);\n    }\n}\n\n// 2. CustomTextView.tsx (JS Interface)\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface CustomTextViewProps extends ViewProps {\n  text: string;\n  textColor?: string;\n}\n\nexport const CustomTextView = requireNativeComponent<CustomTextViewProps>('CustomTextView');"}
{"instruction": "Create a simple Android Native Module in Java that exposes a method to get the device's battery level using promises.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level * 100 / (float)scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Implement a drag-and-drop interaction using React Native Reanimated (v3) and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Create an Expo Config Plugin to automatically add the `ACCESS_FINE_LOCATION` permission to the Android Manifest.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withLocationPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n\n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (perm) => perm.$['android:name'] === 'android.permission.ACCESS_FINE_LOCATION'\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': 'android.permission.ACCESS_FINE_LOCATION' },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withLocationPermission;"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `Calculator` with an `add` method.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Create an iOS Native Module in Swift that provides a method to trigger a haptic feedback impact.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc(triggerImpact:)\n  func triggerImpact(style: String) -> Void {\n    DispatchQueue.main.async {\n      let impactStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"light\": impactStyle = .light\n        case \"medium\": impactStyle = .medium\n        case \"heavy\": impactStyle = .heavy\n        default: impactStyle = .medium\n      }\n      let generator = UIImpactFeedbackGenerator(style: impactStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Implement a Reanimated scroll handler that interpolates the opacity of a header based on the vertical scroll offset.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    height: 80,\n    backgroundColor: 'red',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  content: { height: 1000, backgroundColor: '#f0f0f0', marginTop: 80 },\n});"}
{"instruction": "Register a background fetch task using `expo-background-fetch` and `expo-task-manager`.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date().toISOString();\n    console.log(`Got background fetch call at date: ${now}`);\n    // Perform your background logic here (e.g., API call)\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App component or useEffect)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // android only,\n    startOnBoot: true, // android only\n  });\n}"}
{"instruction": "Demonstrate bridge optimization by invoking a Javascript callback from the UI thread safely using Reanimated's `runOnJS`.", "output": "import React from 'react';\nimport { Button, Alert } from 'react-native';\nimport { useSharedValue, withTiming, runOnJS } from 'react-native-reanimated';\n\nexport default function ThreadSafetyExample() {\n  const progress = useSharedValue(0);\n\n  const handleAnimationComplete = (finished: boolean) => {\n    // This function runs on the JS thread\n    Alert.alert('Animation Finished', `Completed: ${finished}`);\n  };\n\n  const startAnimation = () => {\n    progress.value = withTiming(1, { duration: 1000 }, (finished) => {\n      // This callback runs on the UI thread.\n      // We must bridge back to JS to trigger side effects like Alerts or State updates.\n      if (finished) {\n        runOnJS(handleAnimationComplete)(finished);\n      }\n    });\n  };\n\n  return <Button title=\"Start\" onPress={startAnimation} />;\n}"}
{"instruction": "Create a simple Native UI Component wrapper for Android (Java) that exposes a custom TextView to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomTextView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        TextView textView = new TextView(reactContext);\n        textView.setTextColor(Color.BLACK);\n        return textView;\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Create a basic Android Native Module in Java to retrieve the device battery level using the React Native Bridge.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using `react-native-reanimated` v3 and `react-native-gesture-handler`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeCalculator' for the New Architecture.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): number;\n  readonly constants: {\n    PI: number;\n  };\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a modern Expo Module in Kotlin that exposes a synchronous function to get the device model name.", "output": "package expo.modules.deviceinfo\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceInfoModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getModel\") {\n      return@Function Build.MODEL\n    }\n  }\n}"}
{"instruction": "Write the C++ JSI code to install a global function 'multiply' directly into the JavaScript runtime to bypass the bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid installBinding(Runtime& runtime) {\n    auto multiply = Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"multiply\"),\n        2,\n        [](Runtime& rt, const Value& thisValue, const Value* args, size_t count) -> Value {\n            if (count < 2 || !args[0].isNumber() || !args[1].isNumber()) {\n                throw JSError(rt, \"multiply expects 2 number arguments\");\n            }\n            double result = args[0].asNumber() * args[1].asNumber();\n            return Value(result);\n        }\n    );\n\n    runtime.global().setProperty(runtime, \"multiply\", multiply);\n}"}
{"instruction": "Implement a high-performance list using Shopify's `FlashList` to optimize rendering of a large dataset.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => <Text style={styles.item}>{item.title}</Text>}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    padding: 10,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});\n\nexport default MyList;"}
{"instruction": "Create the Objective-C implementation file (.m) to expose a Swift class 'CalendarModule' to React Native.", "output": "#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(CalendarModule, NSObject)\n\n// Expose a method that takes a string and a date (as number)\nRCT_EXTERN_METHOD(createEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)\n\n// Expose a method with a callback\nRCT_EXTERN_METHOD(findEvents:(RCTResponseSenderBlock)callback)\n\n@end"}
{"instruction": "Use Reanimated Worklets to execute a heavy calculation on the UI thread without blocking the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Define a worklet\nfunction heavyCalculation(input) {\n  'worklet';\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(input * i);\n  }\n  console.log('Calculation done on UI thread:', result);\n  return result;\n}\n\n// Trigger from JS thread\nconst triggerCalculation = () => {\n  runOnUI(heavyCalculation)(42);\n};"}
{"instruction": "Create a Reanimated component that rotates an image based on the device gyroscope sensor data.", "output": "import React from 'react';\nimport { StyleSheet, Image } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`, { duration: 50 }) },\n        { rotateY: withTiming(`${y}rad`, { duration: 50 }) },\n      ],\n    };\n  });\n\n  return (\n    <Animated.Image\n      source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n      style={[styles.image, animatedStyle]}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: 100, height: 100 },\n});"}
{"instruction": "Implement a Custom ViewManager in Android (Java) to expose a native `TextView` to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        return new TextView(reactContext);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n\n    @ReactProp(name = \"color\", customType = \"Color\")\n    public void setColor(TextView view, Integer color) {\n        view.setTextColor(color != null ? color : Color.BLACK);\n    }\n}"}
{"instruction": "Create a simple Native Module in Android (Java) that exposes a method to get the device's battery level to React Native.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Spring back to center on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create an Expo Config Plugin to automatically add the 'ACCESS_FINE_LOCATION' permission to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withLocationPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    const permissions = androidManifest.manifest['uses-permission'] || [];\n    \n    if (!permissions.some(p => p.$['android:name'] === 'android.permission.ACCESS_FINE_LOCATION')) {\n      permissions.push({\n        $: {\n          'android:name': 'android.permission.ACCESS_FINE_LOCATION',\n        },\n      });\n    }\n    \n    androidManifest.manifest['uses-permission'] = permissions;\n    return config;\n  });\n};\n\nmodule.exports = withLocationPermission;"}
{"instruction": "Implement a Swift Native Module for iOS that triggers a UIImpactFeedbackGenerator haptic response.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc(triggerImpact:)\n  func triggerImpact(style: String) {\n    let impactStyle: UIImpactFeedbackGenerator.FeedbackStyle\n    \n    switch style {\n    case \"light\": impactStyle = .light\n    case \"medium\": impactStyle = .medium\n    case \"heavy\": impactStyle = .heavy\n    default: impactStyle = .medium\n    }\n    \n    DispatchQueue.main.async {\n      let generator = UIImpactFeedbackGenerator(style: impactStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Use Reanimated's `runOnUI` to perform a synchronous heavy calculation on the UI thread to avoid blocking the JS thread (Bridge optimization example).", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A heavy synchronous function\nfunction heavyCalculation(n: number) {\n  'worklet';\n  if (n <= 1) return n;\n  return heavyCalculation(n - 1) + heavyCalculation(n - 2);\n}\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const start = Date.now();\n      const result = heavyCalculation(30); // Runs on UI thread\n      const end = Date.now();\n      console.log(`Fibonacci(30) = ${result}, Time: ${end - start}ms`);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Calc on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a custom Native UI Component in Android (Kotlin) that exposes a simple TextView to React Native.", "output": "package com.myapp\n\nimport android.graphics.Color\nimport android.widget.TextView\nimport com.facebook.react.uimanager.SimpleViewManager\nimport com.facebook.react.uimanager.ThemedReactContext\nimport com.facebook.react.uimanager.annotations.ReactProp\n\nclass CustomTextViewManager : SimpleViewManager<TextView>() {\n    override fun getName() = \"RCTCustomTextView\"\n\n    override fun createViewInstance(reactContext: ThemedReactContext): TextView {\n        return TextView(reactContext).apply {\n            setTextColor(Color.BLACK)\n        }\n    }\n\n    @ReactProp(name = \"text\")\n    fun setText(view: TextView, text: String?) {\n        view.text = text ?: \"\"\n    }\n}\n// Usage in JS: requireNativeComponent('RCTCustomTextView')"}
{"instruction": "Create an animated list item using Reanimated Layout Animations that fades out and slides upward when deleted.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text } from 'react-native';\nimport Animated, { FadeOut, SlideInLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (id: number) => {\n    setItems((current) => current.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={SlideInLeft}\n          exiting={FadeOut.duration(500)}\n          layout={Layout.springify()}\n          style={{ margin: 10, padding: 20, backgroundColor: '#ddd', flexDirection: 'row', justifyContent: 'space-between' }}\n        >\n          <Text>Item {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Use Expo FileSystem to download an image and check its info, demonstrating async bridge usage.", "output": "import * as FileSystem from 'expo-file-system';\n\ninterface DownloadResult {\n  uri: string;\n  status: number;\n}\n\nexport const downloadImage = async (remoteUrl: string): Promise<string | null> => {\n  const filename = remoteUrl.split('/').pop();\n  const localUri = FileSystem.documentDirectory + (filename || 'image.jpg');\n\n  try {\n    const downloadRes = await FileSystem.downloadAsync(remoteUrl, localUri);\n    \n    if (downloadRes.status === 200) {\n      const info = await FileSystem.getInfoAsync(downloadRes.uri);\n      console.log('File info:', info);\n      return downloadRes.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error('Download failed', e);\n    return null;\n  }\n};"}
{"instruction": "Create a C++ JSI (JavaScript Interface) binding snippet to expose a synchronous host function 'nativeMultiply' to the JS Runtime (Bridge optimization).", "output": "// Inside a JSI Module installation function (C++)\nvoid install(jsi::Runtime& runtime) {\n  auto multiply = jsi::Function::createFromHostFunction(\n    runtime,\n    jsi::PropNameID::forAscii(runtime, \"nativeMultiply\"),\n    2, // Number of arguments\n    [](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* args, size_t count) -> jsi::Value {\n      if (count < 2 || !args[0].isNumber() || !args[1].isNumber()) {\n        throw jsi::JSError(rt, \"nativeMultiply expects 2 numbers\");\n      }\n      double result = args[0].asNumber() * args[1].asNumber();\n      return jsi::Value(result);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"nativeMultiply\", std::move(multiply));\n}\n// Usage in JS: global.nativeMultiply(5, 5) -> returns 25 synchronously"}
{"instruction": "Implement a component that rotates an image based on device gyroscope data using Reanimated's `useAnimatedSensor`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const gyroscope = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = gyroscope.sensor.value;\n    // Limit rotation for visual stability\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`, { duration: 100 }) },\n        { rotateY: withTiming(`${y}rad`, { duration: 100 }) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 200, height: 200, backgroundColor: 'tomato' },\n});"}
{"instruction": "Create a simple Native Module in Android (Java) that exposes a method to get the device model, and provide the TypeScript interface to consume it.", "output": "// android/app/src/main/java/com/yourapp/DeviceModule.java\npackage com.yourapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getModel(Promise promise) {\n        try {\n            promise.resolve(Build.MODEL);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}\n\n// DeviceModule.ts\nimport { NativeModules } from 'react-native';\n\nconst { DeviceModule } = NativeModules;\n\ninterface DeviceModuleInterface {\n  getModel(): Promise<string>;\n}\n\nexport default DeviceModule as DeviceModuleInterface;"}
{"instruction": "Implement a draggable square using 'react-native-reanimated' and 'react-native-gesture-handler'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Spring back to center\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use 'expo-secure-store' to create a helper function that securely saves a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nexport async function saveUserToken(token: string): Promise<void> {\n  try {\n    // Ideally, check for availability first\n    const isAvailable = await SecureStore.isAvailableAsync();\n    if (isAvailable) {\n      await SecureStore.setItemAsync('user_auth_token', token, {\n        keychainAccessible: SecureStore.AFTER_FIRST_UNLOCK,\n      });\n      console.log('Token saved successfully');\n    } else {\n      console.warn('SecureStore is not available on this device');\n    }\n  } catch (error) {\n    console.error('Error saving token:', error);\n    throw error;\n  }\n}"}
{"instruction": "Create an iOS Native Module (Objective-C) that triggers a native Alert dialog.", "output": "// AlertModule.h\n#import <React/RCTBridgeModule.h>\n@interface AlertModule : NSObject <RCTBridgeModule>\n@end\n\n// AlertModule.m\n#import \"AlertModule.h\"\n#import <UIKit/UIKit.h>\n\n@implementation AlertModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(showAlert:(NSString *)title message:(NSString *)message)\n{\n  dispatch_async(dispatch_get_main_queue(), ^{\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:title\n                                                                   message:message\n                                                            preferredStyle:UIAlertControllerStyleAlert];\n    \n    UIAlertAction *ok = [UIAlertAction actionWithTitle:@\"OK\" style:UIAlertActionStyleDefault handler:nil];\n    [alert addAction:ok];\n    \n    UIViewController *rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;\n    [rootViewController presentViewController:alert animated:YES completion:nil];\n  });\n}\n\n@end"}
{"instruction": "Demonstrate bridge optimization by moving a heavy synchronous calculation to the UI thread using a Reanimated Worklet.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// This function is completely isolated from the JS thread\n// and runs on the UI thread.\nfunction heavyCalculationWorklet(input: number) {\n  'worklet';\n  console.log('Running on UI Thread');\n  let result = 0;\n  // Simulate heavy work\n  for (let i = 0; i < input * 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished:', result);\n}\n\nexport default function WorkletExample() {\n  const handlePress = () => {\n    // Call the worklet from the JS thread without blocking the JS bridge\n    runOnUI(heavyCalculationWorklet)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a scroll-based header animation (Parallax) using Reanimated 3.", "output": "import React from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolate } from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          translateY: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75]\n          ),\n        },\n        {\n          scale: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [2, 1, 1]\n          ),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.imageContainer, imageStyle]}>\n        <Animated.Image\n          source={{ uri: 'https://via.placeholder.com/600x400' }}\n          style={styles.image}\n        />\n      </Animated.View>\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: IMG_HEIGHT }}\n      >\n        <View style={styles.content}>\n          {/* Content goes here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  imageContainer: { position: 'absolute', top: 0, left: 0, width: width, zIndex: 1 },\n  image: { flex: 1, width: null, height: null, resizeMode: 'cover' },\n  content: { height: 1000, backgroundColor: 'white' },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator'.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Specifying the interface for the TurboModule\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  \n  // Using typed arrays is more efficient for bridge transfer\n  calculateMean(data: Array<number>): number;\n}\n\n// Enforcing the module load\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Use Expo Camera to create a component that requests permission and shows a camera preview.", "output": "import React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, Button } from 'react-native';\nimport { Camera, CameraType } from 'expo-camera';\n\nexport default function SimpleCamera() {\n  const [type, setType] = useState(CameraType.back);\n  const [permission, requestPermission] = Camera.useCameraPermissions();\n\n  if (!permission) {\n    return <View />;\n  }\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text style={{ textAlign: 'center' }}>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  function toggleCameraType() {\n    setType(current => (current === CameraType.back ? CameraType.front : CameraType.back));\n  }\n\n  return (\n    <View style={styles.container}>\n      <Camera style={styles.camera} type={type}>\n        <View style={styles.buttonContainer}>\n          <Button title=\"Flip Camera\" onPress={toggleCameraType} />\n        </View>\n      </Camera>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: { flex: 1, flexDirection: 'row', backgroundColor: 'transparent', margin: 64, justifyContent: 'center', alignItems: 'flex-end' },\n});"}
{"instruction": "Implement a Native UI Component in Android (Java) called 'ColorView' that accepts a color prop and expose it to JS.", "output": "// 1. ViewManager (ColorViewManager.java)\npackage com.yourapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class ColorViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"ColorView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        return new View(context);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(View view, String color) {\n        view.setBackgroundColor(Color.parseColor(color));\n    }\n}\n\n// 2. JavaScript Interface (ColorView.tsx)\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColorViewProps extends ViewProps {\n  color: string;\n}\n\nexport const ColorView = requireNativeComponent<ColorViewProps>('ColorView');"}
{"instruction": "Use 'expo-task-manager' and 'expo-background-fetch' to register a background task that logs a timestamp.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task in global scope\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date();\n    console.log(`Background fetch executed at: ${now.toISOString()}`);\n    // You must return the result\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task within a component or hook\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // Android only\n    startOnBoot: true, // Android only\n  });\n}\n\nexport async function unregisterBackgroundFetchAsync() {\n  return BackgroundFetch.unregisterTaskAsync(BACKGROUND_FETCH_TASK);\n}"}
{"instruction": "Create a draggable box component using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      // Return to original position\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Native Module in Swift (iOS) that exposes a method `getDeviceName` to React Native. Include the Objective-C bridge macro.", "output": "// DeviceInfoModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfoModule)\nclass DeviceInfoModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    if !deviceName.isEmpty {\n      resolve(deviceName)\n    } else {\n      reject(\"NO_NAME\", \"Could not get device name\", nil)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfoModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfoModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Implement a Native Module in Kotlin (Android) that exposes a `showToast` method to React Native.", "output": "package com.myapp.toastmodule\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Optimize a FlatList in React Native to prevent blank areas during fast scrolling by implementing `getItemLayout` and tuning `initialNumToRender`.", "output": "import React, { useCallback } from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 80;\n\nexport const OptimizedList = ({ data }) => {\n  \n  const renderItem = useCallback(({ item }) => (\n    <View style={styles.item}>\n      <Text>{item.title}</Text>\n    </View>\n  ), []);\n\n  // Optimization: Skip measurement calculation by providing fixed layout\n  const getItemLayout = useCallback((data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  }), []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: ITEM_HEIGHT,\n    justifyContent: 'center',\n    padding: 20,\n    borderBottomWidth: 1,\n  }\n});"}
{"instruction": "Use Expo's `expo-haptics` to trigger different feedback types based on user actions (Selection, Success, Error).", "output": "import * as Haptics from 'expo-haptics';\nimport { Button, View, StyleSheet } from 'react-native';\n\nexport default function HapticFeedbackExample() {\n  \n  const handleSelection = () => {\n    // Light feedback for UI selection\n    Haptics.selectionAsync();\n  };\n\n  const handleSuccess = () => {\n    // Notification feedback for success\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  };\n\n  const handleError = () => {\n    // Notification feedback for error\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Selection\" onPress={handleSelection} />\n      <Button title=\"Success\" onPress={handleSuccess} />\n      <Button title=\"Error\" onPress={handleError} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'space-around', alignItems: 'center' }\n});"}
{"instruction": "Define a TurboModule specification in TypeScript for the New Architecture to ensure type safety between Native and JS.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the interface for the native module\n  getBatteryLevel(): Promise<number>;\n  addListener(eventName: string): void;\n  removeListeners(count: number): void;\n}\n\n// Loads the module if available, otherwise returns null\nexport default TurboModuleRegistry.get<Spec>('BatteryTurboModule') as Spec | null;"}
{"instruction": "Use `runOnUI` from Reanimated to offload a heavy synchronous calculation to the UI thread to avoid freezing the JS Bridge.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  \n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      // This runs on the UI thread, keeping the JS thread free for React updates\n      const heavyMath = () => {\n        let result = 0;\n        for (let i = 0; i < 10000000; i++) {\n          result += Math.sqrt(i);\n        }\n        console.log('Calculation done on UI thread:', result);\n      };\n      \n      heavyMath();\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom hook that uses `expo-sensors` (Accelerometer) to detect if the phone is being shaken.", "output": "import { useState, useEffect } from 'react';\nimport { Accelerometer } from 'expo-sensors';\n\nexport const useShakeDetector = (threshold = 1.5) => {\n  const [isShaking, setIsShaking] = useState(false);\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n\n    const subscription = Accelerometer.addListener(data => {\n      const { x, y, z } = data;\n      // Calculate total acceleration magnitude\n      const acceleration = Math.sqrt(x * x + y * y + z * z);\n      \n      // If acceleration exceeds threshold (approx 1G + movement)\n      if (acceleration >= threshold) {\n        setIsShaking(true);\n        // Reset state after a short delay\n        setTimeout(() => setIsShaking(false), 1000);\n      }\n    });\n\n    return () => subscription && subscription.remove();\n  }, [threshold]);\n\n  return isShaking;\n};"}
{"instruction": "Implement Reanimated Layout Animations to animate a list item appearing (SlideInRight) and disappearing (FadeOutLeft).", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { SlideInRight, FadeOutLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={SlideInRight.duration(500)}\n          exiting={FadeOutLeft.duration(300)}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Button title={`Remove ${item}`} onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { marginVertical: 10, padding: 20, backgroundColor: '#f0f0f0', borderRadius: 8 }\n});"}
{"instruction": "Create a native event emitter in iOS (Swift) to send continuous updates to React Native (e.g., a timer).", "output": "// TimerModule.swift\nimport Foundation\n\n@objc(TimerModule)\nclass TimerModule: RCTEventEmitter {\n  \n  var timer: Timer?\n  var hasListeners = false\n\n  @objc\n  override func startObserving() {\n    hasListeners = true\n    // Start a 1-second timer\n    timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in\n      if (self.hasListeners) {\n        self.sendEvent(withName: \"onTick\", body: [\"timestamp\": Date().timeIntervalSince1970])\n      }\n    }\n  }\n\n  @objc\n  override func stopObserving() {\n    hasListeners = false\n    timer?.invalidate()\n  }\n\n  @objc\n  override func supportedEvents() -> [String]! {\n    return [\"onTick\"]\n  }\n  \n  @objc\n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Create a Swift Native Module for iOS named 'CalendarModule' that exposes a method to create a calendar event. Include the Objective-C bridge export.", "output": "// CalendarModule.swift\nimport Foundation\nimport React\n\n@objc(CalendarModule)\nclass CalendarModule: NSObject {\n  \n  @objc(createCalendarEvent:location:)\n  func createCalendarEvent(_ name: String, location: String) -> Void {\n    print(\"Pretending to create an event \" + name + \" at \" + location)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// CalendarModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(CalendarModule, NSObject)\n\nRCT_EXTERN_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)\n\n@end"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create an Android Native Module in Java that exposes a Toast method to React Native.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    private static ReactApplicationContext reactContext;\n\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n        reactContext = context;\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Use 'expo-haptics' to trigger different feedback types based on user interaction.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticFeedback() {\n  return (\n    <View style={styles.container}>\n      <Button\n        title=\"Light Impact\"\n        onPress={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}\n      />\n      <Button\n        title=\"Success Notification\"\n        onPress={() => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success)}\n      />\n      <Button\n        title=\"Selection Change\"\n        onPress={() => Haptics.selectionAsync()}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'space-evenly', alignItems: 'center' }\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that adds two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) binding function to expose a synchronous 'multiply' method to the JS runtime, bypassing the bridge.", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n        if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n            return Value::undefined();\n        }\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", move(multiply));\n}"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems([...items, Date.now()]);\n  const removeItem = () => setItems(items.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn.duration(500)}\n          exiting={FadeOut.duration(500)}\n          layout={Layout.springify()}\n          style={styles.item}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: 200, height: 50, backgroundColor: 'tomato', margin: 5, justifyContent: 'center', alignItems: 'center' },\n  text: { color: 'white' }\n});"}
{"instruction": "Create a native UI component wrapper for an iOS UILabel using Objective-C.", "output": "// RNTLabelManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTLabelManager : RCTViewManager\n@end\n\n@implementation RNTLabelManager\n\nRCT_EXPORT_MODULE(RNTLabel)\n\n- (UIView *)view\n{\n  UILabel *label = [[UILabel alloc] init];\n  label.textAlignment = NSTextAlignmentCenter;\n  return label;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(text, NSString)\n\n@end"}
{"instruction": "Use 'expo-camera' to create a component that displays the camera preview.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function SimpleCamera() {\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) return <View />;\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing=\"back\">\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n});"}
{"instruction": "Create a custom Reanimated hook 'useShake' that shakes a view when triggered.", "output": "import { useEffect } from 'react';\nimport { useSharedValue, useAnimatedStyle, withSequence, withTiming, withRepeat } from 'react-native-reanimated';\n\nexport const useShake = (trigger) => {\n  const rotation = useSharedValue(0);\n\n  useEffect(() => {\n    if (trigger) {\n      rotation.value = withSequence(\n        withTiming(-10, { duration: 50 }),\n        withRepeat(withTiming(10, { duration: 100 }), 6, true),\n        withTiming(0, { duration: 50 })\n      );\n    }\n  }, [trigger, rotation]);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ rotateZ: `${rotation.value}deg` }],\n    };\n  });\n\n  return animatedStyle;\n};"}
{"instruction": "Create a Swift Native Module for iOS that exposes a method `getDeviceName` which resolves a Promise with the device name. Include the Objective-C interface bridge.", "output": "// DeviceModule.swift\nimport Foundation\nimport React\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n  @objc\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v2/v3) and `react-native-gesture-handler`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create an Android Native Module using Java that opens the specific Application Settings screen for the current app.", "output": "// OpenSettingsModule.java\npackage com.myapp;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class OpenSettingsModule extends ReactContextBaseJavaModule {\n    OpenSettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"OpenSettings\";\n    }\n\n    @ReactMethod\n    public void open() {\n        Activity currentActivity = getCurrentActivity();\n        if (currentActivity == null) return;\n\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        Uri uri = Uri.fromParts(\"package\", currentActivity.getPackageName(), null);\n        intent.setData(uri);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        currentActivity.startActivity(intent);\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator` that includes an `add` method.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the app's document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nasync function downloadImage(imageUrl: string, fileName: string) {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      imageUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n}"}
{"instruction": "Optimize Bridge performance by offloading a heavy calculation (e.g., Fibonacci) to a Reanimated Worklet, preventing JS thread blocking.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function runs entirely on the UI thread\nfunction heavyCalculationWorklet(n: number) {\n  'worklet';\n  const fib = (num: number): number => {\n    if (num <= 1) return 1;\n    return fib(num - 1) + fib(num - 2);\n  };\n  \n  const result = fib(n);\n  console.log(`[UI Thread] Fib result for ${n}: ${result}`);\n}\n\n// Call from JS thread\nexport function triggerCalculation() {\n  runOnUI(heavyCalculationWorklet)(30);\n}"}
{"instruction": "Create a custom hook using `expo-sensors` (Accelerometer) to detect a shake motion.", "output": "import { useState, useEffect } from 'react';\nimport { Accelerometer } from 'expo-sensors';\n\nexport const useShakeDetector = (threshold = 1.2) => {\n  const [isShaking, setShaking] = useState(false);\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(data => {\n      const { x, y, z } = data;\n      const acceleration = Math.sqrt(x * x + y * y + z * z);\n      if (acceleration >= threshold) {\n        setShaking(true);\n        setTimeout(() => setShaking(false), 1000);\n      }\n    });\n\n    return () => subscription.remove();\n  }, [threshold]);\n\n  return isShaking;\n};"}
{"instruction": "Implement a scroll-driven header animation (opacity fade-out) using `react-native-reanimated`.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [1, 0], Extrapolate.CLAMP),\n      transform: [\n        { translateY: interpolate(scrollY.value, [0, 100], [0, -50], Extrapolate.CLAMP) }\n      ]\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 100, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, marginTop: 100, backgroundColor: '#eee' }\n});"}
{"instruction": "Create an iOS View Manager (Objective-C) to expose a native `UIView` with a configurable background color property to React Native.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end"}
{"instruction": "Use `expo-secure-store` to safely store and retrieve a user's session token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_session_token';\n\nexport const saveToken = async (token: string) => {\n  try {\n    await SecureStore.setItemAsync(KEY, token);\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n};\n\nexport const getToken = async () => {\n  try {\n    const token = await SecureStore.getItemAsync(KEY);\n    return token;\n  } catch (error) {\n    console.error('Error getting token', error);\n    return null;\n  }\n};"}
{"instruction": "Create a basic iOS Native Module using Swift that exposes a method `getDeviceName` which resolves a Promise with the device name. Include the Objective-C bridging header exposure.", "output": "// DeviceModule.swift\nimport Foundation\nimport React\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v2/v3) and `react-native-gesture-handler`. The animation must run entirely on the UI thread to avoid bridge traffic.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Create an Android Native Module in Java that creates a Toast message. This demonstrates a simple 'Fire and Forget' method over the bridge.", "output": "// ToastModule.java\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Use Expo's `expo-file-system` to download an image to the local cache and then display it. This task focuses on handling binary data logic outside the React Native bridge.", "output": "import React, { useEffect, useState } from 'react';\nimport { Image, View, Text } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nexport default function ImageDownloader() {\n  const [localUri, setLocalUri] = useState<string | null>(null);\n\n  useEffect(() => {\n    const downloadImage = async () => {\n      const remoteUrl = 'https://example.com/image.png';\n      const fileUri = FileSystem.cacheDirectory + 'example.png';\n      \n      try {\n        const { uri } = await FileSystem.downloadAsync(remoteUrl, fileUri);\n        setLocalUri(uri);\n      } catch (e) {\n        console.error(e);\n      }\n    };\n\n    downloadImage();\n  }, []);\n\n  return (\n    <View>\n      {localUri ? <Image source={{ uri: localUri }} style={{ width: 100, height: 100 }} /> : <Text>Loading...</Text>}\n    </View>\n  );\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture). This is a bridge optimization task ensuring type safety and C++ generation.", "output": "// NativeCalculator.ts\nimport type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use `runOnUI` from `react-native-reanimated` to offload a heavy synchronous calculation (like Fibonacci) to the UI thread to prevent the JS thread (Bridge) from dropping frames.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport default function HeavyCalculation() {\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const start = Date.now();\n      const result = fibonacci(35);\n      const end = Date.now();\n      console.log(`Fibonacci(35) = ${result}, Time: ${end - start}ms`);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a Background Fetch task using Expo to run code when the app is minimized. This requires defining the task string and registering it.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  const now = new Date();\n  console.log(`Got background fetch call at date: ${now.toISOString()}`);\n  // Perform your background logic here (e.g., sync data)\n  return BackgroundFetch.BackgroundFetchResult.NewData;\n});\n\n// 2. Register the task (usually in App.js or a useEffect)\nasync function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // android only,\n    startOnBoot: true, // android only\n  });\n}"}
{"instruction": "Create a Native UI Component (iOS) wrapper. Create the Objective-C Manager to expose a basic `UIView` that accepts a `color` prop.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// Usage in JS:\n// import { requireNativeComponent } from 'react-native';\n// export const ColorView = requireNativeComponent('RNTColorView');"}
{"instruction": "Optimize bridge communication by implementing a batched state update in a functional component. Instead of triggering multiple bridge passes for separate state updates, combine them.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text } from 'react-native';\n\nexport default function BatchedUpdates() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n  const [active, setActive] = useState(false);\n\n  const handlePress = () => {\n    // React Native (React 18+) automatically batches these updates\n    // into a single re-render and a single bridge transaction for UI updates\n    // where applicable, reducing bridge overhead compared to older versions.\n    setCount(c => c + 1);\n    setText('Updated');\n    setActive(a => !a);\n  };\n\n  return (\n    <View>\n      <Text>{count} - {text} - {active ? 'Active' : 'Inactive'}</Text>\n      <Button title=\"Update All\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Use the Expo Sensors API (Magnetometer) to rotate an image based on device orientation. This demonstrates subscribing to native event streams.", "output": "import React, { useState, useEffect } from 'react';\nimport { Image, View, StyleSheet } from 'react-native';\nimport { Magnetometer } from 'expo-sensors';\n\nexport default function Compass() {\n  const [magnetometer, setMagnetometer] = useState(0);\n\n  useEffect(() => {\n    Magnetometer.setUpdateInterval(100);\n    const subscription = Magnetometer.addListener(data => {\n      let angle = Math.atan2(data.y, data.x) * (180 / Math.PI);\n      angle = angle - 90;\n      if (angle < 0) angle += 360;\n      setMagnetometer(angle);\n    });\n\n    return () => subscription && subscription.remove();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Image \n        source={require('./compass_needle.png')} \n        style={{ \n          width: 200, \n          height: 200, \n          transform: [{ rotate: `${360 - magnetometer}deg` }] \n        }} \n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Create a React Native functional component using `react-native-reanimated` and `react-native-gesture-handler` to implement a draggable box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a native Android Java module for React Native that exposes a method `getDeviceName` which returns the device model name via a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                promise.resolve(model);\n            } else {\n                promise.resolve(manufacturer + \" \" + model);\n            }\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Using Expo's `expo-file-system`, create a TypeScript function that downloads an image from a URL and saves it to the app's document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, fileName: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.documentDirectory}${fileName}`;\n    const downloadRes = await FileSystem.downloadAsync(url, fileUri);\n    \n    if (downloadRes.status === 200) {\n      return downloadRes.uri;\n    }\n    return null;\n  } catch (error) {\n    console.error('Download failed:', error);\n    return null;\n  }\n};"}
{"instruction": "Define a TypeScript specification for a React Native TurboModule (New Architecture) named `Calculator` that includes a synchronous method `add(a: number, b: number): number`.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Create a Swift Native Module for iOS that exposes a method `triggerHaptic` which uses `UIImpactFeedbackGenerator` to create a heavy impact vibration.", "output": "@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc(triggerHaptic)\n  func triggerHaptic() {\n    DispatchQueue.main.async {\n      let generator = UIImpactFeedbackGenerator(style: .heavy)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Implement a bridge optimization technique in TypeScript where a large JavaScript object is passed to a Native Module as a JSON string instead of a raw object to reduce serialization overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { DataProcessor } = NativeModules;\n\n// Optimization: Serializing in JS is often faster than the Bridge recursively serializing deep objects.\n// This reduces the 'toll' on the bridge for very large datasets.\nexport const processLargeDataset = (largeData: Record<string, any>) => {\n  const jsonString = JSON.stringify(largeData);\n  // The Native Module expects a String, not a ReadableMap\n  DataProcessor.processDataString(jsonString);\n};"}
{"instruction": "Use `react-native-reanimated` to offload a heavy Fibonacci calculation to the UI thread using a worklet to prevent blocking the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nconst heavyCalculation = () => {\n  'worklet';\n  const fib = (n: number): number => {\n    if (n <= 1) return n;\n    return fib(n - 1) + fib(n - 2);\n  };\n  \n  const result = fib(35); // Heavy computation\n  console.log('Calculation done on UI thread:', result);\n};\n\nexport const triggerCalculation = () => {\n  runOnUI(heavyCalculation)();\n};"}
{"instruction": "Create a custom Android ViewManager in Java to expose a simple `TextView` with a configurable `text` property to React Native.", "output": "package com.myapp;\n\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class MyTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"MyTextView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public TextView createViewInstance(ThemedReactContext context) {\n        return new TextView(context);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Using `react-native-reanimated`, create an animated scroll handler that interpolates the opacity of a header based on the vertical scroll offset (Y-axis).", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 60, width: '100%', backgroundColor: 'red', position: 'absolute', top: 0, zIndex: 1 },\n});"}
{"instruction": "Write a TypeScript function using `expo-local-authentication` to check if hardware biometrics are supported and currently enrolled on the device.", "output": "import * as LocalAuthentication from 'expo-local-authentication';\n\nexport const checkBiometrics = async (): Promise<boolean> => {\n  const hasHardware = await LocalAuthentication.hasHardwareAsync();\n  const isEnrolled = await LocalAuthentication.isEnrolledAsync();\n  \n  return hasHardware && isEnrolled;\n};"}
{"instruction": "Create a simple Native Module in Swift (iOS) that exposes a method to get the device's battery level and exports it to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a React Native TurboModule specification in TypeScript. This interface defines a synchronous method to calculate a hash, intended to be implemented in C++ for JSI performance.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // JSI allows synchronous return values without blocking the main thread if logic is fast\n  fastHash(input: string): string;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('FastHasher');"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v2/v3) and `react-native-gesture-handler`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring, \n  useAnimatedGestureHandler \n} from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number, startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = translateX.value;\n      ctx.startY = translateY.value;\n    },\n    onActive: (event, ctx) => {\n      translateX.value = ctx.startX + event.translationX;\n      translateY.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      // Spring back to center\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Kotlin class for an Android Native Module that opens a specific URL in the system browser.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BrowserOpenerModule extends ReactContextBaseJavaModule {\n\n    BrowserOpenerModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BrowserOpener\";\n    }\n\n    @ReactMethod\n    public void openUrl(String url) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(url));\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (intent.resolveActivity(getReactApplicationContext().getPackageManager()) != null) {\n            getReactApplicationContext().startActivity(intent);\n        }\n    }\n}"}
{"instruction": "Use the modern Expo Modules API (Swift) to create a module that returns the device name synchronously.", "output": "import ExpoModulesCore\nimport UIKit\n\npublic class DeviceInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getDeviceName\") { () -> String in\n      return UIDevice.current.name\n    }\n  }\n}"}
{"instruction": "Demonstrate Bridge Optimization using Reanimated's `runOnJS`. Create a Worklet that tracks a shared value on the UI thread and only invokes a JavaScript callback when a specific threshold is crossed, preventing a flood of events over the bridge.", "output": "import React from 'react';\nimport { Button, Alert } from 'react-native';\nimport { useSharedValue, runOnJS, useAnimatedReaction } from 'react-native-reanimated';\n\nexport default function ThresholdMonitor() {\n  const progress = useSharedValue(0);\n\n  const triggerAlert = () => {\n    Alert.alert('Threshold Reached', 'The animation crossed 100!');\n  };\n\n  // Running logic on the UI thread\n  useAnimatedReaction(\n    () => {\n      return progress.value;\n    },\n    (currentValue, previousValue) => {\n      if (currentValue > 100 && (previousValue ?? 0) <= 100) {\n        // Only cross the bridge when necessary\n        runOnJS(triggerAlert)();\n      }\n    }\n  );\n\n  return (\n    <Button \n      title=\"Increment Value\" \n      onPress={() => { progress.value += 10; }} \n    />\n  );\n}"}
{"instruction": "Create a custom Native UI Component in Objective-C (iOS) that renders a `UIView` with a configurable background color property, exposing it to React Native.", "output": "// 1. RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\n// Expose the 'color' property\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// 2. Usage in JavaScript\n// import { requireNativeComponent } from 'react-native';\n// export const ColorView = requireNativeComponent('RNTColorView');"}
{"instruction": "Implement a Reanimated Layout Animation to animate items entering and exiting a list. Use `Layout.springify()` for layout changes.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()} // Handles position changes of surrounding items\n          style={styles.card}\n        >\n          <Text onPress={() => removeItem(item)}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20 },\n  card: { padding: 20, marginVertical: 5, backgroundColor: '#ddd', borderRadius: 8 }\n});"}
{"instruction": "Use `expo-haptics` to trigger different feedback styles based on user interaction in a TypeScript function.", "output": "import * as Haptics from 'expo-haptics';\n\nexport const triggerFeedback = async (type: 'success' | 'error' | 'selection') => {\n  switch (type) {\n    case 'success':\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      break;\n    case 'error':\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n      break;\n    case 'selection':\n      await Haptics.selectionAsync();\n      break;\n  }\n};"}
{"instruction": "Implement a Reanimated scroll interpolation. Change the background color of a header based on the scroll position of an `Animated.ScrollView`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  useAnimatedScrollHandler, \n  interpolateColor \n} from 'react-native-reanimated';\n\nexport default function ScrollInterpolation() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const backgroundColor = interpolateColor(\n      scrollY.value,\n      [0, 150],\n      ['transparent', 'red']\n    );\n    return { backgroundColor };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ height: 1000 }}\n      >\n        {/* Content goes here */}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { \n    position: 'absolute', \n    top: 0, \n    left: 0, \n    right: 0, \n    height: 80, \n    zIndex: 1 \n  }\n});"}
{"instruction": "Create a simple Expo Module definition in Kotlin that exposes a synchronous function to get the device's battery level.", "output": "import expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.content.Context\nimport android.os.BatteryManager\n\nclass BatteryModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    Function(\"getBatteryLevel\") { ->\n      val context = appContext.reactContext ?: return@Function -1\n      val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n      return@Function batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onFinalize(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript interface for a TurboModule (JSI-backed Native Module) named 'NativeCalculator' to optimize bridge communication.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n  divide(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a Native Module in Java (Android) that exposes a method to show a Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Use Reanimated's `useAnimatedSensor` to create a style that moves an element based on the device's gyroscope data (Parallax effect).", "output": "import React from 'react';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\nimport { StyleSheet, View } from 'react-native';\n\nexport default function ParallaxView() {\n  const gyroscope = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = gyroscope.sensor.value;\n    return {\n      transform: [\n        { translateX: withTiming(y * 20) },\n        { translateY: withTiming(x * 20) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' }\n});"}
{"instruction": "Create a Native Module header in Objective-C (iOS) that exports a method to change the app icon.", "output": "// CalendarModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(IconModule, NSObject)\n\nRCT_EXTERN_METHOD(changeIcon:(NSString *)iconName\n                 resolver:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Implement a 'worklet' in Reanimated to perform a heavy calculation on the UI thread to avoid freezing the JS Bridge.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyCalculation(input: number) {\n  'worklet';\n  // Simulating heavy work on UI thread\n  let result = 0;\n  for (let i = 0; i < input * 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished on UI thread:', result);\n}\n\nexport const triggerHeavyTask = () => {\n  runOnUI(heavyCalculation)(50);\n};"}
{"instruction": "Optimize bridge traffic by using `useAnimatedScrollHandler` to filter scroll events on the UI thread and only invoking a JS callback when a specific threshold is reached.", "output": "import { runOnJS, useAnimatedScrollHandler } from 'react-native-reanimated';\n\ninterface Props {\n  onThresholdReached: () => void;\n}\n\nexport const useOptimizedScroll = ({ onThresholdReached }: Props) => {\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    // Logic runs purely on UI thread\n    if (event.contentOffset.y > 200) {\n      // Only cross the bridge when necessary\n      runOnJS(onThresholdReached)();\n    }\n  });\n\n  return scrollHandler;\n};"}
{"instruction": "Expose a native Android `ImageView` as a Native UI Component using `SimpleViewManager`.", "output": "package com.myapp;\n\nimport android.widget.ImageView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class ReactImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTImageView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public ImageView createViewInstance(ThemedReactContext context) {\n        return new ImageView(context);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        // Implementation to load image from URL would go here\n    }\n}"}
{"instruction": "Use `expo-file-system` to download a file and log the URI, ensuring directory existence.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadFile = async (url: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.documentDirectory}${fileName}`;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a draggable box component using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write the Java code for a simple Android Native Module named 'ToastModule' that exposes a method 'showToast' to React Native.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to React Native\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    // Method exposed to JS\n    @ReactMethod\n    public void showToast(String message) {\n        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n    }\n}"}
{"instruction": "Create a TypeScript interface for a TurboModule (New Architecture) named 'NativeCalculator' that supports a synchronous 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition for New Architecture\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 3 scroll handler that interpolates the opacity of a header based on the scroll position of an Animated.ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, useAnimatedScrollHandler, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: {\n    height: 60,\n    backgroundColor: 'red',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n});"}
{"instruction": "Use 'expo-file-system' to download an image to the local cache directory and log the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'downloaded_image.jpg';\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result) {\n      console.log('Finished downloading to:', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Demonstrate how to run a synchronous function on the UI thread using a Reanimated Worklet to avoid the JS bridge.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is marked as a worklet automatically by the Babel plugin\n// or can be explicitly marked with 'worklet';\nfunction heavyCalculationUI(input: number) {\n  'worklet';\n  console.log('[UI Thread] Calculating:', input);\n  // Perform expensive UI-synchronous logic here\n  return input * 2;\n}\n\nexport const triggerWorklet = () => {\n  // Call from JS thread, executes on UI thread\n  runOnUI(heavyCalculationUI)(42);\n};"}
{"instruction": "Create a Swift file for an iOS Native Module that exposes a method to get the device name. Include the Objective-C bridge macro.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m (Objective-C Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n// RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n// @end"}
{"instruction": "Optimize a list rendering scenario by using Shopify's FlashList to render a grid of items efficiently.", "output": "import React from 'react';\nimport { View, Text } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={{ height: 100, padding: 20, borderBottomWidth: 1 }}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={100}\n        keyExtractor={(item) => item.id}\n        numColumns={2}\n      />\n    </View>\n  );\n};\nexport default MyList;"}
{"instruction": "Use 'expo-sensors' (Accelerometer) to drive a Reanimated SharedValue, converting the imperative listener to a declarative animation value.", "output": "import React, { useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function SensorAnimation() {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(data => {\n      x.value = withSpring(data.x * 200);\n      y.value = withSpring(data.y * 200);\n    });\n    Accelerometer.setUpdateInterval(16);\n\n    return () => subscription && subscription.remove();\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: x.value }, { translateY: -y.value }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.ball, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 50, height: 50, borderRadius: 25, backgroundColor: 'tomato' },\n});"}
{"instruction": "Demonstrate high-performance synchronous storage access using 'react-native-mmkv' (which uses JSI) to bypass the async bridge overhead of AsyncStorage.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize the storage instance\nexport const storage = new MMKV();\n\n// Function to save user object synchronously\nexport const saveUser = (user: { id: string; name: string }) => {\n  storage.set('user.id', user.id);\n  storage.set('user.name', user.name);\n  console.log('User saved synchronously via JSI');\n};\n\n// Function to retrieve user object synchronously\nexport const getUser = () => {\n  const id = storage.getString('user.id');\n  const name = storage.getString('user.name');\n  \n  if (id && name) {\n    return { id, name };\n  }\n  return null;\n};"}
{"instruction": "Create a simple Native Module for Android using Java that exposes a 'showToast' method to React Native.", "output": "// android/app/src/main/java/com/yourapp/ToastModule.java\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message) {\n        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n    }\n}\n\n// Usage in JS:\n// import { NativeModules } from 'react-native';\n// NativeModules.ToastModule.showToast('Hello from Native!');"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' and 'react-native-gesture-handler' without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Swift Native Module for iOS that gets the device battery level.", "output": "// ios/BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level == -1 {\n      reject(\"ERR_BATTERY\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// ios/BatteryModule.m\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n// RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n// @end"}
{"instruction": "Use Expo FileSystem to download an image from a URL and log the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + 'downloaded_image.jpg';\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) to enable codegen for a Calculator module.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('CalculatorModule') as Spec | null;"}
{"instruction": "Create a Reanimated Parallax ScrollView effect where the header image zooms in when pulling down.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const rImgStyle = useAnimatedStyle(() => {\n    return {\n      height: interpolate(\n        scrollY.value,\n        [-100, 0],\n        [IMG_HEIGHT + 100, IMG_HEIGHT],\n        Extrapolate.CLAMP\n      ),\n      top: interpolate(scrollY.value, [-100, 0], [-100, 0], Extrapolate.CLAMP),\n    };\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n      <Animated.Image\n        source={{ uri: 'https://placekitten.com/800/600' }}\n        style={[styles.image, rImgStyle]}\n      />\n      <Animated.View style={styles.content}>\n        {/* List Content */}\n      </Animated.View>\n    </Animated.ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: '100%', position: 'absolute' },\n  content: { marginTop: IMG_HEIGHT, height: 1000, backgroundColor: 'white' }\n});"}
{"instruction": "Optimize Bridge communication by creating a Synchronous Native Method in Android (Java) for blocking operations.", "output": "// In your Java Module\n@ReactMethod(isBlockingSynchronousMethod = true)\npublic String getDeviceIDSync() {\n    // Warning: This blocks the JS thread. Use only for quick, essential data.\n    return android.provider.Settings.Secure.getString(\n        getReactApplicationContext().getContentResolver(),\n        android.provider.Settings.Secure.ANDROID_ID\n    );\n}\n\n// Usage in JS:\n// const deviceId = NativeModules.MyModule.getDeviceIDSync();\n// console.log(deviceId); // Immediate result, no await"}
{"instruction": "Use Expo Sensors (Accelerometer) to update a shared value in Reanimated without passing data through the JS bridge repeatedly.", "output": "import React, { useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function SensorBall() {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(data => {\n      // While the listener is in JS, assigning to sharedValue triggers UI update\n      // via the Reanimated worklet runtime, minimizing render overhead.\n      x.value = withSpring(data.x * 200);\n      y.value = withSpring(data.y * -200);\n    });\n    Accelerometer.setUpdateInterval(16); \n    return () => subscription && subscription.remove();\n  }, []);\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: x.value }, { translateY: y.value }]\n  }));\n\n  return <View style={styles.container}><Animated.View style={[styles.ball, rStyle]} /></View>;\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 50, height: 50, borderRadius: 25, backgroundColor: 'red' }\n});"}
{"instruction": "Implement Layout Animations using Reanimated to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems([...items, Date.now()]);\n  const removeItem = (id: number) => setItems(items.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={styles.item}\n          onTouchEnd={() => removeItem(item)}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: '90%', height: 50, backgroundColor: 'orange', marginVertical: 5, borderRadius: 8 }\n});"}
{"instruction": "Set up an iOS Native Module with `RCTEventEmitter` to send periodic events to JavaScript.", "output": "// ios/EventModule.swift\nimport Foundation\n\n@objc(EventModule)\nclass EventModule: RCTEventEmitter {\n  \n  @objc override func supportedEvents() -> [String]! {\n    return [\"onTicker\"]\n  }\n\n  @objc func startTicker() {\n    Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in\n      self.sendEvent(withName: \"onTicker\", body: [\"timestamp\": Date().timeIntervalSince1970])\n    }\n  }\n  \n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// Usage in JS:\n// import { NativeEventEmitter, NativeModules } from 'react-native';\n// const eventEmitter = new NativeEventEmitter(NativeModules.EventModule);\n// NativeModules.EventModule.startTicker();\n// eventEmitter.addListener('onTicker', (event) => console.log(event));"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' to implement a draggable square box that springs back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a custom Native Module for Android (Java) and the accompanying JavaScript interface to show a native Toast message.", "output": "// android/app/src/main/java/com/yourapp/ToastModule.java\n/*\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n   public ToastModule(ReactApplicationContext reactContext) {\n       super(reactContext);\n   }\n   @Override\n   public String getName() {\n       return \"ToastModule\";\n   }\n   @ReactMethod\n   public void show(String message) {\n       Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n   }\n}\n*/\n\n// ToastModule.ts\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n  show(message: string): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Implement a 'react-native-reanimated' scroll effect where a header image fades out and scales down as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View, Image } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 150], [1, 0], Extrapolation.CLAMP),\n      transform: [\n        { scale: interpolate(scrollY.value, [-100, 0], [1.5, 1], Extrapolation.CLAMP) },\n        { translateY: interpolate(scrollY.value, [0, 150], [0, -50], Extrapolation.CLAMP) }\n      ],\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.Image \n        source={{ uri: 'https://via.placeholder.com/300' }} \n        style={[styles.header, headerStyle]} \n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Long content here */}\n          <View style={{height: 1000, backgroundColor: '#f0f0f0'}} />\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 200, width: '100%', position: 'absolute', top: 0, zIndex: 1 },\n  content: { marginTop: 200, padding: 20 },\n});"}
{"instruction": "Use Expo's 'expo-file-system' to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate Bridge Optimization by using 'runOnUI' and 'runOnJS' in Reanimated to perform a heavy calculation on the UI thread and report the result back to the JS thread without blocking the bridge.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  \n  const handleResult = (result: number) => {\n    // This runs on the JS thread\n    Alert.alert('Calculation Complete', `Result: ${result}`);\n  };\n\n  const performHeavyTask = () => {\n    // This function is executed on the UI thread\n    'worklet';\n    let result = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 10000000; i++) {\n      result += i;\n    }\n    // Call back to JS thread\n    runOnJS(handleResult)(result);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={() => runOnUI(performHeavyTask)()} />\n    </View>\n  );\n}"}
{"instruction": "Create a Native Module interface for iOS (Objective-C) that emits an event to JavaScript every second, demonstrating the usage of RCTEventEmitter.", "output": "// ios/TimerModule.h\n/*\n#import <React/RCTBridgeModule.h>\n#import <React/RCTEventEmitter.h>\n\n@interface TimerModule : RCTEventEmitter <RCTBridgeModule>\n@end\n*/\n\n// ios/TimerModule.m\n/*\n#import \"TimerModule.h\"\n\n@implementation TimerModule\n\nRCT_EXPORT_MODULE();\n\n- (NSArray<NSString *> *)supportedEvents {\n  return @[@\"onTick\"];\n}\n\nRCT_EXPORT_METHOD(startTimer) {\n  [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n      [self sendEventWithName:@\"onTick\" body:@{@\"timestamp\": @([NSDate date].timeIntervalSince1970)}];\n  }];\n}\n@end\n*/\n\n// TimerComponent.tsx\nimport React, { useEffect } from 'react';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\nconst { TimerModule } = NativeModules;\nconst timerEvents = new NativeEventEmitter(TimerModule);\n\nexport const useNativeTimer = () => {\n  useEffect(() => {\n    TimerModule.startTimer();\n    const subscription = timerEvents.addListener('onTick', (data) => {\n      console.log('Tick:', data.timestamp);\n    });\n    return () => subscription.remove();\n  }, []);\n};"}
{"instruction": "Use 'expo-haptics' to create a custom hook that triggers different feedback types based on user interaction success or failure.", "output": "import * as Haptics from 'expo-haptics';\nimport { useCallback } from 'react';\n\nexport const useFeedback = () => {\n  const success = useCallback(async () => {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  }, []);\n\n  const error = useCallback(async () => {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  }, []);\n\n  const selection = useCallback(async () => {\n    await Haptics.selectionAsync();\n  }, []);\n\n  return { success, error, selection };\n};\n\n// Usage: const { success } = useFeedback(); success();"}
{"instruction": "Implement a Reanimated 'Entering' and 'Exiting' layout animation for a list of items where items slide in from the right and fade out when removed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { SlideInRight, FadeOut } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={SlideInRight.duration(500)} \n          exiting={FadeOut.duration(300)}\n          style={styles.item}\n        >\n          <Text onPress={() => removeItem(item)}>Item {item} (Tap to remove)</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: { padding: 20, backgroundColor: '#ddd', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a simplified wrapper for a Native UI Component (iOS) called 'RNCustomView' that accepts a 'color' prop from JavaScript.", "output": "// ios/RNCustomViewManager.m\n/*\n#import <React/RCTViewManager.h>\n@interface RNCustomViewManager : RCTViewManager\n@end\n\n@implementation RNCustomViewManager\nRCT_EXPORT_MODULE(RNCustomView)\nRCT_EXPORT_VIEW_PROPERTY(color, NSString)\n- (UIView *)view {\n  return [[UIView alloc] init];\n}\n@end\n*/\n\n// RNCustomView.tsx\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface RNCustomViewProps extends ViewProps {\n  color: string;\n}\n\n// 'RNCustomView' string must match the name in RCT_EXPORT_MODULE\nconst RNCustomViewNative = requireNativeComponent<RNCustomViewProps>('RNCustomView');\n\nexport const CustomView = (props: RNCustomViewProps) => {\n  return <RNCustomViewNative {...props} />;\n};"}
{"instruction": "Use 'expo-sensors' (Gyroscope) and Reanimated to create a view that tilts based on the device's physical orientation.", "output": "import React, { useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function GyroView() {\n  const rotateX = useSharedValue(0);\n  const rotateY = useSharedValue(0);\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(16);\n    const subscription = Gyroscope.addListener((data) => {\n      // data.x, data.y, data.z are rotation rates in rad/s\n      rotateX.value = withSpring(data.y * 2); // Tilt vertical\n      rotateY.value = withSpring(data.x * 2); // Tilt horizontal\n    });\n    return () => subscription.remove();\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { rotateX: `${rotateX.value}rad` },\n      { rotateY: `${rotateY.value}rad` }\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center', perspective: 1000 },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', borderRadius: 10 },\n});"}
{"instruction": "Create a modern Expo Module (Kotlin) that exposes a function to get the device's battery level synchronously.", "output": "package expo.modules.batterylevel\n\nimport android.content.Context\nimport android.os.BatteryManager\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass BatteryLevelModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"BatteryLevel\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { \n      val context = appContext.reactContext ?: return@Function -1\n      val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n      return@Function batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and Gesture Handler without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a legacy Android Native Module in Java that exposes a method to show a Toast message, bridging it to JavaScript.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        // Toasts must be shown on the UI thread\n        android.widget.Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a legacy iOS Native Module in Objective-C that triggers the system's impact haptic feedback.", "output": "// HapticModule.h\n#import <React/RCTBridgeModule.h>\n@interface HapticModule : NSObject <RCTBridgeModule>\n@end\n\n// HapticModule.m\n#import \"HapticModule.h\"\n#import <UIKit/UIKit.h>\n\n@implementation HapticModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(triggerImpact)\n{\n  dispatch_async(dispatch_get_main_queue(), ^{\n    UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleMedium];\n    [generator prepare];\n    [generator impactOccurred];\n  });\n}\n\n@end"}
{"instruction": "Optimize bridge traffic by creating a Reanimated Worklet that performs a heavy calculation (Fibonacci) on the UI thread to avoid blocking the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Define the heavy function as a worklet\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport const handleHeavyCalculation = () => {\n  runOnUI((input: number) => {\n    'worklet';\n    const start = _getAnimationTimestamp();\n    const result = fibonacci(input);\n    const end = _getAnimationTimestamp();\n    console.log(`Fibonacci(${input}) = ${result}. Calculated in ${end - start}ms on UI Thread.`);\n  })(30);\n};"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) function signature to expose a synchronous 'multiply' function directly to the JS runtime (HostObject pattern).", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nclass MathHostObject : public HostObject {\npublic:\n  Value get(Runtime& runtime, const PropNameID& name) override {\n    auto methodName = name.utf8(runtime);\n\n    if (methodName == \"multiply\") {\n      return Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"multiply\"),\n        2, // argument count\n        [](Runtime& runtime, const Value& thisValue, const Value* arguments, size_t count) -> Value {\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n        }\n      );\n    }\n    return Value::undefined();\n  }\n};"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a Native UI Component for Android (Java) that exposes a simple `ImageView` to React Native using `SimpleViewManager`.", "output": "package com.myapp;\n\nimport com.facebook.drawee.backends.pipeline.Fresco;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport com.facebook.react.views.image.ReactImageView;\n\npublic class CustomImageManager extends SimpleViewManager<ReactImageView> {\n    public static final String REACT_CLASS = \"RCTCustomImage\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public ReactImageView createViewInstance(ThemedReactContext context) {\n        return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), null, null);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ReactImageView view, String src) {\n        view.setSource(com.facebook.react.bridge.Arguments.createArray()); // Simplified for example, normally requires Uri parsing\n    }\n}"}
{"instruction": "Use Reanimated's `useAnimatedSensor` to create a view that rotates based on the device gyroscope data without bridge communication per frame.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nexport default function GyroscopeView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`, { duration: 50 }) },\n        { rotateY: withTiming(`${y}rad`, { duration: 50 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});"}
{"instruction": "Implement a layout animation using Reanimated for a list item that fades in when mounted and slides out to the left when unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Button } from 'react-native';\nimport Animated, { Entering, Exiting } from 'react-native-reanimated';\n\nconst ListItem = () => (\n  <Animated.View\n    entering={Entering.FadeIn.duration(500)}\n    exiting={Exiting.SlideOutLeft.duration(300)}\n    style={{ height: 50, backgroundColor: 'green', margin: 10 }}\n  />\n);\n\nexport default function ListExample() {\n  const [show, setShow] = useState(true);\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && <ListItem />}\n    </View>\n  );\n}"}
{"instruction": "Create a simple Expo Module in Kotlin (Android) that exposes a synchronous function named 'getDeviceName'.", "output": "import expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceInfoModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Exposes a synchronous function to JavaScript\n    Function(\"getDeviceName\") {\n      return@Function \"${Build.MANUFACTURER} ${Build.MODEL}\"\n    }\n  }\n}"}
{"instruction": "Implement a draggable square using 'react-native-reanimated' and 'react-native-gesture-handler' in TypeScript.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: start.value.x + e.translationX,\n        y: start.value.y + e.translationY,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript Specification (Spec) for a TurboModule named 'NativeCalculator' that includes an 'add' method returning a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a legacy Native Module in iOS (Swift) that exposes a method 'getBatteryLevel' via a Promise/Resolver.", "output": "// CalendarModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc(getBatteryLevel:withRejecter:)\n  func getBatteryLevel(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n}\n\n// BatteryModule.m (Objective-C Interface)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n// RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve withRejecter:(RCTPromiseRejectBlock)reject)\n// @end"}
{"instruction": "Use Reanimated's 'useAnimatedSensor' to create a parallax effect on an image based on the device gyroscope.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming, InterpolationMode, interpolate } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const x = sensor.sensor.value.y;\n    const y = sensor.sensor.value.x;\n\n    return {\n      transform: [\n        { translateX: withTiming(interpolate(x, [-2, 2], [-50, 50], InterpolationMode.CLAMP)) },\n        { translateY: withTiming(interpolate(y, [-2, 2], [-50, 50], InterpolationMode.CLAMP)) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image \n        source={{ uri: 'https://via.placeholder.com/300' }} \n        style={[styles.image, animatedStyle]} \n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  image: { width: 300, height: 300 },\n});"}
{"instruction": "Write a C++ JSI function snippet that installs a global function 'nativeMultiply' into the JavaScript Runtime.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid installNativeMultiply(Runtime& runtime) {\n  auto func = Function::createFromHostFunction(\n      runtime,\n      PropNameID::forAscii(runtime, \"nativeMultiply\"),\n      2, // param count\n      [](Runtime& rt, const Value& thisValue, const Value* args, size_t count) -> Value {\n        if (count < 2 || !args[0].isNumber() || !args[1].isNumber()) {\n            return Value::undefined();\n        }\n        double result = args[0].asNumber() * args[1].asNumber();\n        return Value(result);\n      }\n  );\n\n  runtime.global().setProperty(runtime, \"nativeMultiply\", func);\n}"}
{"instruction": "Implement a Reanimated Layout Animation where items in a list fade in and slide up when entering, and shrink when exiting.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInDown, ZoomOut } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeInDown.duration(500)} \n          exiting={ZoomOut.duration(300)}\n          style={styles.box} \n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  box: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Demonstrate bridge optimization by offloading a heavy Fibonacci calculation to the UI thread using a Reanimated Worklet.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// Pure JS function (Worklet)\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport default function HeavyCalc() {\n  const handlePress = () => {\n    runOnUI(() => {\n      // This runs on the UI thread, not blocking the JS thread\n      const start = Date.now();\n      const result = fibonacci(35);\n      const end = Date.now();\n      console.log(`Fib(35) = ${result} took ${end - start}ms on UI thread`);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Calculation\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a Legacy Native Module in Java (Android) that opens a specific URL in the browser.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BrowserLinkModule extends ReactContextBaseJavaModule {\n    BrowserLinkModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BrowserLink\";\n    }\n\n    @ReactMethod\n    public void openUrl(String url) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(url));\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (intent.resolveActivity(getReactApplicationContext().getPackageManager()) != null) {\n            getReactApplicationContext().startActivity(intent);\n        }\n    }\n}"}
{"instruction": "Use 'expo-haptics' to trigger different feedback styles based on user interaction type.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticFeedbackExample() {\n  return (\n    <View style={styles.container}>\n      <Button \n        title=\"Light Impact\"\n        onPress={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}\n      />\n      <View style={{ height: 20 }} />\n      <Button \n        title=\"Success Notification\"\n        onPress={() => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success)}\n      />\n      <View style={{ height: 20 }} />\n      <Button \n        title=\"Selection Change\"\n        onPress={() => Haptics.selectionAsync()}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Create a Swift Native Module for iOS that exposes a method to retrieve the device's battery level and returns it via a callback.", "output": "// DeviceModule.swift\nimport Foundation\nimport React\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n\n  @objc(getBatteryLevel:)\n  func getBatteryLevel(_ callback: RCTResponseSenderBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    callback([NSNull(), level])\n  }\n}\n\n// DeviceModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel: (RCTResponseSenderBlock)callback)\n@end"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create an Android Native Module using Kotlin that gets the device model name and returns it via a Promise.", "output": "// DeviceInfoModule.kt\npackage com.myapp\n\nimport android.os.Build\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass DeviceInfoModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"DeviceInfo\"\n    }\n\n    @ReactMethod\n    fun getModel(promise: Promise) {\n        try {\n            val model = Build.MODEL\n            promise.resolve(model)\n        } catch (e: Exception) {\n            promise.reject(\"Error\", e)\n        }\n    }\n}"}
{"instruction": "Use Expo FileSystem to download an image from a URL and save it to the app's cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Implement a bridge optimization pattern by batching analytics events in TypeScript to reduce the frequency of passing data over the React Native bridge.", "output": "import { NativeModules } from 'react-native';\n\nconst { AnalyticsModule } = NativeModules;\n\nclass AnalyticsBatcher {\n  private queue: any[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private readonly BATCH_INTERVAL = 5000;\n\n  logEvent(eventName: string, params: object) {\n    this.queue.push({ eventName, params, timestamp: Date.now() });\n\n    if (!this.timer) {\n      this.timer = setTimeout(this.flush, this.BATCH_INTERVAL);\n    }\n  }\n\n  private flush = () => {\n    if (this.queue.length > 0) {\n      // Send entire array over the bridge once\n      AnalyticsModule.trackBatch(this.queue);\n      this.queue = [];\n    }\n    this.timer = null;\n  };\n}\n\nexport const analytics = new AnalyticsBatcher();"}
{"instruction": "Create a C++ JSI (JavaScript Interface) binding function to perform a synchronous math operation, bypassing the asynchronous bridge.", "output": "// cpp-adapter.cpp\n#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // Number of arguments\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n             throw JSError(runtime, \"Two number arguments required\");\n          }\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Create a Reanimated scroll handler that interpolates the opacity of a header based on the scroll Y position.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: { height: 80, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#eee', marginTop: 80 },\n});"}
{"instruction": "Use `expo-sensors` (Accelerometer) to rotate a View based on the device's tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltView() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(setData);\n    Accelerometer.setUpdateInterval(100);\n    return () => subscription && subscription.remove();\n  }, []);\n\n  // Simple calculation for rotation based on X-axis tilt\n  const rotation = `${x * 90}deg`;\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: rotation }] }]}>\n        <Text>Tilt Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'coral', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement the TypeScript side of a Native Module that listens for a custom 'onVolumeChange' event sent from native code.", "output": "import { useEffect } from 'react';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\nconst { VolumeModule } = NativeModules;\n\nexport const useVolumeListener = (callback: (volume: number) => void) => {\n  useEffect(() => {\n    const eventEmitter = new NativeEventEmitter(VolumeModule);\n    \n    const subscription = eventEmitter.addListener('onVolumeChange', (event) => {\n      callback(event.volume);\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [callback]);\n};"}
{"instruction": "Create a custom Reanimated Worklet to run logic purely on the UI thread, such as clamping a value within a range.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// Define the worklet\nconst clampWorklet = (value: number, min: number, max: number) => {\n  'worklet';\n  return Math.min(Math.max(value, min), max);\n};\n\nexport const triggerUIClamp = (val: number) => {\n  runOnUI((v) => {\n    'worklet';\n    const clamped = clampWorklet(v, 0, 100);\n    console.log('Clamped value on UI thread:', clamped);\n  })(val);\n};"}
{"instruction": "Create a simple Native Module in Swift (iOS) that exposes a method to get the device's current battery level and returns it to React Native via a Promise.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n\n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// DeviceInfo.m (Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a Native Module in Java (Android) that exposes a method to show a native Android Toast message.", "output": "// ToastModule.java\npackage com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        android.widget.Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use `expo-haptics` to create a custom button component that triggers different haptic feedback types based on a prop.", "output": "import React from 'react';\nimport { TouchableOpacity, Text, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\ntype FeedbackType = 'light' | 'medium' | 'heavy' | 'success' | 'error';\n\ninterface HapticButtonProps {\n  type: FeedbackType;\n  label: string;\n  onPress?: () => void;\n}\n\nexport const HapticButton: React.FC<HapticButtonProps> = ({ type, label, onPress }) => {\n  const handlePress = async () => {\n    switch (type) {\n      case 'light':\n        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n        break;\n      case 'medium':\n        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n        break;\n      case 'heavy':\n        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n        break;\n      case 'success':\n        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n        break;\n      case 'error':\n        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n        break;\n    }\n    onPress?.();\n  };\n\n  return (\n    <TouchableOpacity style={styles.button} onPress={handlePress}>\n      <Text style={styles.text}>{label}</Text>\n    </TouchableOpacity>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: { padding: 15, backgroundColor: '#ddd', borderRadius: 8, margin: 5 },\n  text: { fontSize: 16, fontWeight: 'bold' },\n});"}
{"instruction": "Demonstrate Bridge Optimization by performing a heavy calculation (Fibonacci) on the UI thread using a Reanimated Worklet, preventing the JS thread from freezing.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcWorklet() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(calculateFibonacci)(35);\n  };\n\n  function updateResult(val: number) {\n    setResult(val);\n  }\n\n  // This function runs entirely on the UI thread\n  function calculateFibonacci(n: number) {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return num;\n      return fib(num - 1) + fib(num - 2);\n    };\n    const res = fib(n);\n    \n    // Call back to JS thread to update React state\n    runOnJS(updateResult)(res);\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Waiting...'}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a component using `expo-sensors` (Accelerometer) that rotates an image based on the device tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { Image, StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltImage() {\n  const [data, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(setData);\n    return () => subscription && subscription.remove();\n  }, []);\n\n  // Calculate rotation based on X axis tilt\n  const rotation = `${data.x * 90}deg`;\n\n  return (\n    <View style={styles.container}>\n      <Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={[styles.image, { transform: [{ rotate: rotation }] }]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  image: { width: 100, height: 100 },\n});"}
{"instruction": "Implement Layout Animations using Reanimated to animate items entering and exiting a list without manually calculating positions.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutLeft } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((i) => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn}\n          exiting={SlideOutLeft}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { \n    backgroundColor: '#f9c2ff', \n    padding: 20, \n    marginVertical: 8, \n    flexDirection: 'row', \n    justifyContent: 'space-between', \n    alignItems: 'center',\n    borderRadius: 8\n  },\n});"}
{"instruction": "Define a TurboModule specification (TypeScript Interface) for the New Architecture to expose a synchronous string reversal method.", "output": "// NativeStringTools.ts\nimport type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method example\n  reverseString(input: string): string;\n  \n  // Asynchronous method example\n  getDeviceName(): Promise<string>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('StringTools') as Spec | null;"}
{"instruction": "Create a wrapper for a custom Native UI Component (e.g., a native MapView or VideoView) using `requireNativeComponent`.", "output": "import React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\n// Define props expected by the native view\ninterface CustomMapViewProps extends ViewProps {\n  zoomEnabled?: boolean;\n  region?: {\n    latitude: number;\n    longitude: number;\n    latitudeDelta: number;\n    longitudeDelta: number;\n  };\n  onRegionChange?: (event: any) => void;\n}\n\n// 'RNCustomMap' must match the name returned in the native ViewManager\nconst RNCustomMap = requireNativeComponent<CustomMapViewProps>('RNCustomMap');\n\nexport const CustomMapView: React.FC<CustomMapViewProps> = (props) => {\n  return <RNCustomMap {...props} />;\n};"}
{"instruction": "Demonstrate optimizing bridge traffic by using `react-native-mmkv` (JSI) for synchronous storage instead of `AsyncStorage` (Bridge).", "output": "import React, { useState, useEffect } from 'react';\nimport { Text, Button, View } from 'react-native';\nimport { MMKV } from 'react-native-mmkv';\n\n// MMKV uses JSI to bind C++ directly to JS, bypassing the async bridge entirely.\nconst storage = new MMKV();\n\nexport default function StorageOptimization() {\n  const [username, setUsername] = useState<string>('');\n\n  useEffect(() => {\n    // Synchronous read (Instant, no await needed)\n    const storedUser = storage.getString('user.name');\n    if (storedUser) setUsername(storedUser);\n  }, []);\n\n  const handleSave = () => {\n    const newUser = 'User_' + Math.floor(Math.random() * 1000);\n    // Synchronous write (Instant)\n    storage.set('user.name', newUser);\n    setUsername(newUser);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Current User: {username}</Text>\n      <Button title=\"Update User (Sync JSI)\" onPress={handleSave} />\n    </View>\n  );\n}"}
{"instruction": "Create a simple Native Module in iOS (Swift) that exposes a method to get the device's battery level and a TypeScript interface to access it from React Native.", "output": "// 1. ios/BatteryModule.swift\nimport Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. ios/BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. src/BatteryModule.ts\nimport { NativeModules } from 'react-native';\n\ninterface BatteryModuleInterface {\n  getBatteryLevel(): Promise<number>;\n}\n\nconst { BatteryModule } = NativeModules;\n\nexport default BatteryModule as BatteryModuleInterface;"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position when released with a spring animation.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use Expo FileSystem to download an image from a URL and save it to the local cache directory, returning the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string): Promise<string | null> => {\n  try {\n    const filename = remoteUrl.split('/').pop() || 'downloaded_image.jpg';\n    const fileUri = FileSystem.cacheDirectory + filename;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Download progress: ${progress * 100}%`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Create a Reanimated Worklet to perform a heavy synchronous calculation on the UI thread to avoid blocking the JS Bridge during an animation.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function WorkletExample() {\n  \n  const heavyCalculation = () => {\n    'worklet'; // Marks this function to run on the UI thread\n    let result = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 10000000; i++) {\n      result += Math.sqrt(i);\n    }\n    console.log('Calculation done on UI thread:', result);\n  };\n\n  const handlePress = () => {\n    // Trigger the function on the UI thread, bypassing the JS bridge for the execution\n    runOnUI(heavyCalculation)();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a Native Module in Android (Kotlin) that shows a native Toast message, including the ReactPackage setup.", "output": "// 1. android/.../ToastModule.kt\npackage com.yourapp\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName(): String = \"ToastModule\"\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}\n\n// 2. android/.../MyAppPackage.kt\npackage com.yourapp\nimport com.facebook.react.ReactPackage\nimport com.facebook.react.bridge.NativeModule\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.uimanager.ViewManager\n\nclass MyAppPackage : ReactPackage {\n    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {\n        return listOf(ToastModule(reactContext))\n    }\n\n    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {\n        return emptyList()\n    }\n}\n\n// 3. Usage in JS\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n// ToastModule.show('Hello Native!', 0);"}
{"instruction": "Create a React Native component that uses Expo Haptics to provide feedback when a user selects an item from a list.", "output": "import React from 'react';\nimport { FlatList, Text, TouchableOpacity, StyleSheet, View } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nconst DATA = Array.from({ length: 10 }).map((_, i) => ({ id: String(i), title: `Item ${i + 1}` }));\n\nexport default function HapticList() {\n  const handlePress = (item: string) => {\n    // Trigger medium weight haptic feedback\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    console.log(`Selected ${item}`);\n  };\n\n  return (\n    <FlatList\n      data={DATA}\n      keyExtractor={(item) => item.id}\n      renderItem={({ item }) => (\n        <TouchableOpacity \n          style={styles.item} \n          onPress={() => handlePress(item.title)}\n        >\n          <Text style={styles.text}>{item.title}</Text>\n        </TouchableOpacity>\n      )}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { padding: 20, borderBottomWidth: 1, borderBottomColor: '#ccc' },\n  text: { fontSize: 18 },\n});"}
{"instruction": "Optimize Bridge performance by using `InteractionManager` to defer a heavy state update until after navigation transitions or animations are complete.", "output": "import React, { useState, useEffect } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n  const [data, setData] = useState<number[]>([]);\n\n  useEffect(() => {\n    // Defer heavy task until animations (like navigation push) are finished\n    const interactionPromise = InteractionManager.runAfterInteractions(() => {\n      // Simulate heavy data processing\n      const heavyData = Array.from({ length: 5000 }, (_, i) => i);\n      setData(heavyData);\n      setIsReady(true);\n    });\n\n    // Cleanup subscription\n    return () => interactionPromise.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" style={{ marginTop: 50 }} />;\n  }\n\n  return (\n    <View style={{ flex: 1, padding: 20 }}>\n      <Text>Loaded {data.length} items without stuttering the transition!</Text>\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native UI Component for iOS (Swift) that renders a UIView with a specific background color, and expose it to React Native as `ColorView`.", "output": "// 1. ios/ColorView.swift\nimport UIKit\n\nclass ColorView: UIView {\n  @objc var colorHex: String = \"\" {\n    didSet {\n      self.backgroundColor = hexStringToUIColor(hex: colorHex)\n    }\n  }\n\n  func hexStringToUIColor(hex: String) -> UIColor {\n    // Simplified hex parser\n    return UIColor.red // Placeholder logic\n  }\n}\n\n// 2. ios/ColorViewManager.swift\n@objc(ColorViewManager)\nclass ColorViewManager: RCTViewManager {\n  override func view() -> UIView! {\n    return ColorView()\n  }\n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 3. src/ColorView.tsx\nimport React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColorViewProps extends ViewProps {\n  colorHex: string;\n}\n\nconst NativeColorView = requireNativeComponent<ColorViewProps>('ColorView');\n\nexport const ColorView: React.FC<ColorViewProps> = (props) => {\n  return <NativeColorView {...props} />;\n};"}
{"instruction": "Implement a parallax scroll header using Reanimated 3, where an image scales up when scrolling down (negative offset) and translates up when scrolling up.", "output": "import React from 'react';\nimport { StyleSheet, View, Dimensions } from 'react-native';\nimport Animated, { \n  useAnimatedRef, \n  useAnimatedScrollHandler, \n  useSharedValue, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n  const scrollRef = useAnimatedRef<Animated.ScrollView>();\n\n  const scrollHandler = useAnimatedScrollHandler(event => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          translateY: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75]\n          ),\n        },\n        {\n          scale: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [2, 1, 1],\n            Extrapolation.CLAMP\n          ),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.ScrollView ref={scrollRef} onScroll={scrollHandler} scrollEventThrottle={16}>\n        <Animated.Image\n          source={{ uri: 'https://picsum.photos/800/600' }}\n          style={[styles.image, imageStyle]}\n        />\n        <View style={styles.content}>\n          <Animated.Text>Scroll Content Here...</Animated.Text>\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: width, position: 'absolute', top: 0, left: 0 },\n  content: { paddingTop: IMG_HEIGHT, padding: 20, minHeight: 1000, backgroundColor: 'white' },\n});"}
{"instruction": "Use Expo Sensors (Accelerometer) to rotate a View based on the device's tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, Text, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function SensorRotate() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0, z: 0 });\n  const [subscription, setSubscription] = useState<any>(null);\n\n  const _subscribe = () => {\n    setSubscription(\n      Accelerometer.addListener(accelerometerData => {\n        setData(accelerometerData);\n      })\n    );\n    Accelerometer.setUpdateInterval(100);\n  };\n\n  const _unsubscribe = () => {\n    subscription && subscription.remove();\n    setSubscription(null);\n  };\n\n  useEffect(() => {\n    _subscribe();\n    return () => _unsubscribe();\n  }, []);\n\n  // Calculate rotation based on X axis tilt\n  const rotation = `${x * 90}deg`;\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: rotation }] }]}>\n        <Text>Rotate Me!</Text>\n      </View>\n      <Text style={{ marginTop: 20 }}>x: {x.toFixed(2)} y: {y.toFixed(2)}</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'coral', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Create a draggable square using React Native Reanimated and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeMath' that includes an 'add' function.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeMath');"}
{"instruction": "Write a basic Android Native Module in Kotlin that exposes a method to show a Toast message.", "output": "package com.myapp.toastmodule\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Implement an iOS Native Module in Objective-C that gets the device name and returns it via a Promise.", "output": "#import \"RCTDeviceModule.h\"\n#import <UIKit/UIKit.h>\n\n@implementation RCTDeviceModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  @try {\n    NSString *deviceName = [[UIDevice currentDevice] name];\n    resolve(deviceName);\n  } @catch (NSException *exception) {\n    reject(@\"no_device_name\", @\"There was no device name\", nil);\n  }\n}\n\n@end"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + filename;\n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Optimize list performance by replacing FlatList with Shopify's FlashList to reduce the JS-Native bridge overhead during scrolling.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ title: `Item ${i}` }));\n\nconst MyOptimizedList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => <Text style={styles.item}>{item.title}</Text>}\n        // estimatedItemSize is crucial for FlashList performance optimizations\n        estimatedItemSize={50}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    padding: 10,\n    borderBottomWidth: 1,\n    borderColor: '#ccc',\n    justifyContent: 'center'\n  }\n});\n\nexport default MyOptimizedList;"}
{"instruction": "Use Reanimated's `useAnimatedSensor` to rotate a View based on the device's gyroscope data (UI thread only).", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withTiming } from 'react-native-reanimated';\n\nexport default function GyroscopeView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    // Access sensor data directly on the UI thread\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { rotateX: withTiming(`${x}rad`) },\n        { rotateY: withTiming(`${y}rad`) }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});"}
{"instruction": "Offload a heavy synchronous calculation to the UI thread using a Reanimated Worklet to prevent blocking the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is marked as a worklet and runs on the UI thread\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = 0;\n  for (let i = 0; i < input * 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // Call the worklet from the JS thread\n  runOnUI(heavyCalculation)(50);\n};"}
{"instruction": "Implement a bi-directional event emitter in a Swift Native Module (iOS) to send updates to JavaScript.", "output": "// CalendarModule.swift\nimport Foundation\nimport React\n\n@objc(CalendarModule)\nclass CalendarModule: RCTEventEmitter {\n\n  // Return supported events\n  override func supportedEvents() -> [String]! {\n    return [\"onCalendarEventCreated\"]\n  }\n\n  @objc(createEvent:location:)\n  func createEvent(_ name: String, location: String) -> Void {\n    // Perform native logic...\n    \n    // Send event to JavaScript\n    self.sendEvent(withName: \"onCalendarEventCreated\", body: [\"name\": name, \"location\": location])\n  }\n\n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use Expo Haptics to provide physical feedback when a user presses a button.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Trigger a light impact haptic feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button pressed with haptic feedback');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a simple Native Module in Swift (iOS) that exposes a method 'increment' which takes a number and returns a promise resolving with the number + 1. Include the Objective-C interface bridging.", "output": "// 1. Counter.swift\nimport Foundation\n\n@objc(Counter)\nclass Counter: NSObject {\n  @objc(increment:resolve:rejecter:)\n  func increment(_ count: Int, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {\n    resolve(count + 1)\n  }\n}\n\n// 2. Counter.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(Counter, NSObject)\n  RCT_EXTERN_METHOD(increment:(NSInteger)count\n                    resolve:(RCTPromiseResolveBlock)resolve\n                    rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a Native Module in Android (Java) named 'DeviceModule' that exposes a method 'getDeviceName' which returns the Android model name via a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n   DeviceModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceModule\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           promise.resolve(Build.MODEL);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Using 'react-native-reanimated' v3, create a component with a box that scales up from 1 to 1.5 when a button is pressed, using a spring animation.", "output": "import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function ScalingBox() {\n  const scale = useSharedValue(1);\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePress = () => {\n    scale.value = withSpring(Math.random() > 0.5 ? 1.5 : 1);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n      <Button title=\"Animate\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', marginBottom: 20 },\n});"}
{"instruction": "Demonstrate bridge optimization by creating a Reanimated 'Worklet'. Write a function that runs entirely on the UI thread to calculate a value based on scroll offset, preventing JS thread blocking.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is defined on the JS thread but executed on the UI thread\nfunction heavyCalculationOnUI(value: number) {\n  'worklet';\n  const result = Math.pow(value, 3) / 2;\n  console.log('Calculated on UI thread:', result);\n}\n\n// Usage example inside a component or event handler\nconst triggerCalculation = () => {\n  runOnUI(heavyCalculationOnUI)(10);\n};"}
{"instruction": "Use the modern 'Expo Modules API' (Kotlin) to define a module that returns a synchronous 'hello' string. This avoids the async bridge for simple data.", "output": "package expo.modules.mymodule\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass MyModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"MyModule\")\n\n    // Synchronous function, no Promise needed\n    Function(\"hello\") {\n      return@Function \"Hello from Kotlin!\"\n    }\n  }\n}"}
{"instruction": "Implement a 'GestureDetector' using 'react-native-gesture-handler' and Reanimated to create a draggable circle.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle } from 'react-native-reanimated';\n\nexport default function DraggableCircle() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const pan = Gesture.Pan()\n    .onChange((event) => {\n      translateX.value += event.changeX;\n      translateY.value += event.changeY;\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <GestureDetector gesture={pan}>\n      <Animated.View style={[styles.circle, rStyle]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  circle: { width: 80, height: 80, borderRadius: 40, backgroundColor: 'tomato' }\n});"}
{"instruction": "Create a Native UI Component wrapper in iOS (Objective-C) for a simple UIView with a configurable background color property.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\n// Expose the 'color' prop to JavaScript\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end"}
{"instruction": "Use 'expo-file-system' to download an image to the local cache directory and log the local URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'my-image.jpg';\n    const { uri } = await FileSystem.downloadAsync(remoteUrl, fileUri);\n    console.log('Finished downloading to ', uri);\n    return uri;\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Optimize performance using Reanimated 'useDerivedValue'. Create a derived value that updates a text label based on a shared value (scroll position) without triggering React state updates (re-renders).", "output": "import { useSharedValue, useDerivedValue, runOnJS } from 'react-native-reanimated';\nimport { TextInput } from 'react-native-gesture-handler';\n\n// Assuming 'scrollOffset' is a shared value linked to a scroll view\nconst DisplayScrollValue = ({ scrollOffset }) => {\n  // Ref for a TextInput to update without React render\n  const inputRef = React.useRef(null);\n\n  useDerivedValue(() => {\n    const text = `Scroll: ${Math.round(scrollOffset.value)}`;\n    // Update Native Prop directly from UI thread logic\n    // (Note: In Reanimated 3, specific TextInput adapters might be needed, \n    // or use AnimatedTextInput with 'text' prop for direct manipulation)\n    if (inputRef.current) {\n       inputRef.current.setNativeProps({ text });\n    }\n  });\n\n  return <TextInput ref={inputRef} editable={false} />;\n};"}
{"instruction": "Define a background task using 'expo-task-manager' and 'expo-background-fetch' to run code when the app is minimized.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst TASK_NAME = 'BACKGROUND_FETCH_TASK';\n\n// 1. Define the task\nTaskManager.defineTask(TASK_NAME, async () => {\n  try {\n    const now = Date.now();\n    console.log(`Got background fetch call at date: ${new Date(now).toISOString()}`);\n    // Return result\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App.tsx useEffect)\nasync function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(TASK_NAME, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,\n    startOnBoot: true,\n  });\n}"}
{"instruction": "Create a simple Native Module in Swift (iOS) that exposes a method to get the device's battery level and returns it via a Promise to the JavaScript side.", "output": "// 1. ios/BatteryModule.swift\nimport Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. ios/BatteryModule.m (Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. usage.ts\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nexport const checkBattery = async () => {\n  try {\n    const level = await BatteryModule.getBatteryLevel();\n    console.log(`Battery Level: ${level}%`);\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Implement a draggable box using React Native Reanimated (v2/v3) and React Native Gesture Handler. The animation must run entirely on the UI thread to optimize bridge usage.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      // Running on UI thread automatically\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Create an Android Native Module in Kotlin that shows a native Toast message.", "output": "// 1. android/app/src/main/java/com/yourapp/ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}\n\n// 2. Register in ReactPackage (omitted for brevity)\n\n// 3. Usage in TS\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nexport const showToast = (msg: string) => {\n  ToastModule.show(msg, 0); // 0 for short, 1 for long\n};"}
{"instruction": "Use Expo Haptics to trigger different feedback types based on user interaction success or failure.", "output": "import * as Haptics from 'expo-haptics';\nimport { Button, View, StyleSheet } from 'react-native';\n\nexport default function HapticFeedbackExample() {\n  const onSuccess = async () => {\n    // Light impact for general success\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  };\n\n  const onError = async () => {\n    // Heavy vibration for errors\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  };\n\n  const onSelection = async () => {\n    // Tiny tick for scroll selection\n    await Haptics.selectionAsync();\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Success\" onPress={onSuccess} />\n      <Button title=\"Error\" onPress={onError} />\n      <Button title=\"Selection\" onPress={onSelection} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'space-evenly', alignItems: 'center' }\n});"}
{"instruction": "Demonstrate Bridge Optimization using Reanimated 'worklets'. Create a function that calculates a value on the UI thread synchronously, avoiding the asynchronous bridge delay.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A standard JS function\nfunction handlePress() {\n  // Dispatch a job to the UI thread\n  runOnUI(heavyCalculation)(100);\n}\n\n// This function is marked as a worklet automatically by the babel plugin\n// It runs synchronously on the UI thread\nfunction heavyCalculation(input: number) {\n  'worklet';\n  const result = Math.pow(input, 2);\n  console.log('Calculated on UI thread:', result);\n  // Note: console.log in worklets prints to the JS console via a special binding\n}"}
{"instruction": "Define a TurboModule specification (TypeScript) for the New Architecture (Fabric/TurboModules) to ensure type safety and lazy loading of native modules.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\n// Define the interface specification\nexport interface Spec extends TurboModule {\n  // Returns a promise\n  getString(id: string): Promise<string>;\n  \n  // Synchronous number return (only possible with JSI/TurboModules)\n  getUnsafeNumber(): number;\n  \n  // Void method\n  logMessage(message: string): void;\n}\n\n// Enforce the module name matching the native side\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeSecureStorage');"}
{"instruction": "Create a Reanimated ScrollView that interpolates the background color of a header based on the scroll position on the UI thread.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  useSharedValue, \n  interpolateColor \n} from 'react-native-reanimated';\n\nexport default function ScrollHeaderColor() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const backgroundColor = interpolateColor(\n      scrollY.value,\n      [0, 150],\n      ['transparent', 'red']\n    );\n    return { backgroundColor };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0, left: 0, right: 0,\n    height: 80,\n    zIndex: 1,\n  }\n});"}
{"instruction": "Use `expo-file-system` to download a large image and pass the URI to an `Image` component. This avoids passing base64 strings over the bridge, optimizing performance.", "output": "import React, { useEffect, useState } from 'react';\nimport { Image, View, Text } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nexport default function OptimizedImageLoader() {\n  const [imageUri, setImageUri] = useState<string | null>(null);\n\n  useEffect(() => {\n    const downloadImage = async () => {\n      const remoteUrl = 'https://example.com/large-image.png';\n      const localPath = `${FileSystem.cacheDirectory}large-image.png`;\n\n      // Download directly to file system\n      const { uri } = await FileSystem.downloadAsync(remoteUrl, localPath);\n      \n      // Set URI state (lightweight string) rather than base64 data\n      setImageUri(uri);\n    };\n\n    downloadImage();\n  }, []);\n\n  if (!imageUri) return <Text>Loading...</Text>;\n\n  return (\n    <View>\n      <Image source={{ uri: imageUri }} style={{ width: 300, height: 300 }} />\n    </View>\n  );\n}"}
{"instruction": "Implement a Native Event Emitter in iOS (Swift) to send continuous updates (e.g., accelerometer data) to JavaScript.", "output": "// 1. Swift: SensorModule.swift\nimport React\n\n@objc(SensorModule)\nclass SensorModule: RCTEventEmitter {\n  \n  // Required to support events\n  override func supportedEvents() -> [String]! {\n    return [\"onSensorChange\"]\n  }\n\n  @objc\n  func startUpdates() {\n    // Simulate sensor data\n    Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in\n      self.sendEvent(withName: \"onSensorChange\", body: [\"val\": Float.random(in: 0...10)])\n    }\n  }\n}\n\n// 2. TypeScript Usage\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\nconst { SensorModule } = NativeModules;\nconst sensorEmitter = new NativeEventEmitter(SensorModule);\n\nexport const subscribeToSensor = () => {\n  SensorModule.startUpdates();\n  \n  const subscription = sensorEmitter.addListener('onSensorChange', (event) => {\n    console.log('Sensor value:', event.val);\n  });\n  \n  return subscription;\n};"}
{"instruction": "Create a Reanimated Layout Animation to smoothly animate an item entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      \n      <View style={styles.list}>\n        {items.map((item) => (\n          <Animated.View \n            key={item} \n            style={styles.card}\n            entering={FadeInUp.duration(500)}\n            exiting={FadeOutDown.duration(500)}\n            layout={Layout.springify()}\n          />\n        ))}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  list: { marginTop: 20 },\n  card: { width: 300, height: 50, backgroundColor: 'orange', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a modern Expo Module using the 'expo-modules-core' API (Swift) that exposes a synchronous function to get the device name and an asynchronous function to get the battery level.", "output": "import ExpoModulesCore\n\npublic class DeviceInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Synchronous function accessible via DeviceInfo.getDeviceName()\n    Function(\"getDeviceName\") { () -> String in\n      return UIDevice.current.name\n    }\n\n    // Asynchronous function accessible via await DeviceInfo.getBatteryLevelAsync()\n    AsyncFunction(\"getBatteryLevelAsync\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The box should spring back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method to add two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n}\n\n// Enforce the module name matching the native implementation\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Demonstrate how to offload a heavy calculation to the UI thread using a Reanimated Worklet to prevent blocking the JS thread (Bridge optimization).", "output": "import React, { useEffect } from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  \n  // This function is marked as a worklet and runs on the UI thread\n  function heavyTask(input: number) {\n    'worklet';\n    console.log('Running on UI Thread');\n    let result = 0;\n    // Simulate heavy synchronous work\n    for (let i = 0; i < input * 1000000; i++) {\n      result += Math.sqrt(i);\n    }\n    console.log('Result:', result);\n  }\n\n  const handlePress = () => {\n    // Trigger the worklet from the JS thread without blocking JS interactions\n    runOnUI(heavyTask)(50);\n  };\n\n  return (\n    <View>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Android Native Module in Kotlin that displays a native Toast message.", "output": "package com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(private val reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        // Toasts must run on the UI thread\n        android.os.Handler(android.os.Looper.getMainLooper()).post {\n            Toast.makeText(reactContext, message, if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG).show()\n        }\n    }\n}"}
{"instruction": "Create a Reanimated Layout Animation that triggers a custom 'entering' animation (fade + scale) when an item is added to a list.", "output": "import React, { useState } from 'react';\nimport { View, Button } from 'react-native';\nimport Animated, { FadeIn, ScaleIn } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, Date.now()]);\n  };\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Combine FadeIn and ScaleIn for the entering animation\n          entering={FadeIn.duration(500).withInitialValues({ opacity: 0 }).springify().damping(12)}\n          style={{ \n            height: 50, \n            backgroundColor: 'tomato', \n            margin: 10, \n            borderRadius: 8 \n          }}\n        />\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Implement an optimized Bridge data transfer by creating a helper function that converts a base64 string to an ArrayBuffer on the JS side before passing it to a Native Module (to avoid double serialization overhead if the module supports binary).", "output": "import { NativeModules } from 'react-native';\nimport { Buffer } from 'buffer'; // Requires 'buffer' polyfill or package\n\nconst { ImageProcessor } = NativeModules;\n\n/**\n * Optimization: Instead of passing a huge Base64 string across the bridge,\n * we convert it to an ArrayBuffer (binary). React Native's bridge handles\n * binary data more efficiently than large strings in some configurations.\n */\nexport const processImageOptimized = async (base64String: string) => {\n  // Convert Base64 to binary buffer\n  const buffer = Buffer.from(base64String, 'base64');\n  \n  // Pass the buffer directly to the native module\n  // The Native Module method signature must accept a String (auto-converted) or specific binary type depending on platform\n  return await ImageProcessor.processImageBuffer(buffer.toString('base64')); \n  // Note: Standard bridge often converts back to base64 or string, \n  // but JSI/TurboModules allow direct ArrayBuffer access.\n  // This snippet demonstrates the JS-side preparation.\n};"}
{"instruction": "Create a Native UI Component manager for iOS (Objective-C header/implementation) to expose a simple UIView changing background color.", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  UIView *view = [[UIView alloc] init];\n  view.backgroundColor = [UIColor redColor];\n  return view;\n}\n\n// Expose a property to React Native\nRCT_EXPORT_VIEW_PROPERTY(color, NSString)\n\n@end"}
{"instruction": "Set up a background task using 'expo-task-manager' and 'expo-background-fetch' to run logic when the app is minimized.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst TASK_NAME = 'BACKGROUND_SYNC_TASK';\n\n// 1. Define the task\nTaskManager.defineTask(TASK_NAME, async () => {\n  try {\n    const now = new Date();\n    console.log(`Background task running at: ${now.toISOString()}`);\n    // Perform fetch or database sync here\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (usually in useEffect or App entry)\nexport async function registerBackgroundTask() {\n  return BackgroundFetch.registerTaskAsync(TASK_NAME, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,   // Android only\n    startOnBoot: true,        // Android only\n  });\n}"}
{"instruction": "Use 'react-native-reanimated' to create a scroll handler that synchronizes a shared value with the scroll offset (Y-axis) for parallax effects.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ParallaxScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      height: 300,\n      transform: [\n        {\n          translateY: interpolate(scrollY.value, [-300, 0, 300], [150, 0, -100], Extrapolation.CLAMP),\n        },\n        {\n          scale: interpolate(scrollY.value, [-300, 0], [2, 1], Extrapolation.CLAMP),\n        }\n      ],\n    };\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.View style={styles.content} />\n    </Animated.ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { width: '100%', backgroundColor: 'purple' },\n  content: { height: 1000, backgroundColor: '#f0f0f0' },\n});"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable square box. The box should use spring physics to return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a modern Expo Module API definition (Swift) to create a native module named 'MySettings' that exposes a function 'getTheme' returning a string, and an event 'onChangeTheme'.", "output": "import ExpoModulesCore\n\npublic class MySettingsModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MySettings\")\n\n    // Defines event names that the module can send to JavaScript.\n    Events(\"onChangeTheme\")\n\n    // Defines a synchronous function that runs on the native thread.\n    Function(\"getTheme\") { () -> String in\n      return \"dark\" // Logic to retrieve actual system theme would go here\n    }\n\n    // Example of a function to trigger the event\n    Function(\"setTheme\") { (newTheme: String) in\n      self.sendEvent(\"onChangeTheme\", [\n        \"theme\": newTheme\n      ])\n    }\n  }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should include a method 'add' that takes two numbers and returns a Promise resolving to a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a 'react-native-reanimated' scroll handler to animate a header's opacity based on the vertical scroll position of an Animated.ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 80, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#f0f0f0' },\n});"}
{"instruction": "Write a legacy Android Native Module (Java) method to get the device's battery level and expose it to React Native via a Promise.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Demonstrate how to offload a heavy synchronous calculation (e.g., Fibonacci) to the UI thread using Reanimated's 'runOnUI' to avoid freezing the JavaScript bridge/thread.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  \n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n) => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const result = fib(35); // Heavy calc running on UI thread\n      console.log('Fibonacci Result:', result);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom iOS Native UI Component (Objective-C) wrapper for a simple UIView that exposes a color property to React Native.", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// Usage in JS:\n// import { requireNativeComponent } from 'react-native';\n// export const ColorView = requireNativeComponent('RNTColorView');"}
{"instruction": "Using Expo's 'expo-task-manager' and 'expo-background-fetch', configure a background task that runs every 15 minutes.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  try {\n    const now = new Date();\n    console.log(`Got background fetch call at date: ${now.toISOString()}`);\n    // Perform your background logic here (e.g. sync data)\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App.tsx useEffect)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // Android only\n    startOnBoot: true, // Android only\n  });\n}"}
{"instruction": "Implement a layout animation using Reanimated 3 where items in a list fade in when mounted and slide out to the right when unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Button } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn.duration(500)}\n          exiting={SlideOutRight.duration(500)}\n          layout={Layout.springify()}\n          style={{ height: 50, backgroundColor: 'orange', margin: 10 }}\n        />\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Optimize bridge communication by creating a Reanimated 'useAnimatedSensor' hook to drive a parallax effect based on the device gyroscope, bypassing the JS thread completely.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(y * 20) }, // Rotate device Y -> move image X\n        { translateY: withSpring(x * 20) }, // Rotate device X -> move image Y\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.card, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  card: { width: 200, height: 200, backgroundColor: '#444', borderRadius: 10 },\n});"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable square box. The box should follow the user's finger during the pan gesture and spring back to its original position (0,0) when released. Use the Reanimated v3 API.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a native Android module in Java (Old Architecture) that exposes a method `getBatteryLevel` to React Native. The method should return a Promise resolving with the battery percentage (integer) or rejecting with an error.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            if (batteryStatus != null) {\n                int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n                int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n                int batteryPct = (int) ((level / (float) scale) * 100);\n                promise.resolve(batteryPct);\n            } else {\n                promise.reject(\"BATTERY_UNAVAILABLE\", \"Could not fetch battery status\");\n            }\n        } catch (Exception e) {\n            promise.reject(\"ERROR\", e.getMessage());\n        }\n    }\n}"}
{"instruction": "Create a TypeScript interface for a TurboModule (New Architecture) named 'NativeCalculator'. It should include a synchronous method `add` that takes two numbers and returns a number.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Using 'readonly' ensures strict typing for the TurboModule spec\n  readonly add: (a: number, b: number) => number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Using Expo SDK, create a function that requests camera permissions and, if granted, takes a picture using a `CameraView` reference and saves it to the app's cache directory.", "output": "import { CameraView } from 'expo-camera';\nimport { useRef } from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { useCameraPermissions } from 'expo-camera';\n\nexport const CameraComponent = () => {\n  const [permission, requestPermission] = useCameraPermissions();\n  const cameraRef = useRef<CameraView>(null);\n\n  const takePicture = async () => {\n    if (!permission?.granted) {\n      const response = await requestPermission();\n      if (!response.granted) return;\n    }\n\n    if (cameraRef.current) {\n      try {\n        const photo = await cameraRef.current.takePictureAsync();\n        Alert.alert('Success', `Photo saved to: ${photo?.uri}`);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n\n  return (\n    <View style={{ flex: 1 }}>\n      <CameraView style={{ flex: 1 }} ref={cameraRef} />\n      <Button title=\"Snap\" onPress={takePicture} />\n    </View>\n  );\n};"}
{"instruction": "Write a Swift class for an iOS Native Module that exposes a method `openSettings` which opens the iOS Settings app. Include the Objective-C bridging macro required to expose the method.", "output": "// SettingsModule.swift\nimport Foundation\nimport React\n\n@objc(SettingsModule)\nclass SettingsModule: NSObject {\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n\n  @objc\n  func openSettings() {\n    DispatchQueue.main.async {\n      if let url = URL(string: UIApplication.openSettingsURLString) {\n        if UIApplication.shared.canOpenURL(url) {\n          UIApplication.shared.open(url, options: [:], completionHandler: nil)\n        }\n      }\n    }\n  }\n}\n\n// SettingsModule.m (Objective-C Header)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(SettingsModule, NSObject)\n  RCT_EXTERN_METHOD(openSettings)\n@end\n*/"}
{"instruction": "Implement a 'worklet' using `react-native-reanimated` to offload a heavy calculation (e.g., Fibonacci) to the UI thread to avoid blocking the JS bridge.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      'worklet';\n      // Recursive fibonacci running on UI thread\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const value = fib(30); // Heavy calc\n      \n      // Return result to JS thread\n      runOnJS(setResult)(value);\n    })();\n  };\n\n  return (\n    <View>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handleCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Create an Expo background task using `expo-task-manager` and `expo-background-fetch` that logs a message every time the OS triggers the fetch.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_FETCH_TASK = 'background-fetch-task';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_FETCH_TASK, async () => {\n  const now = new Date().toISOString();\n  console.log(`Got background fetch call at date: ${now}`);\n  // Be sure to return the successful result type!\n  return BackgroundFetch.BackgroundFetchResult.NewData;\n});\n\n// 2. Register the task (call this in your App.tsx useEffect)\nexport async function registerBackgroundFetchAsync() {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_FETCH_TASK, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false,   // android only,\n    startOnBoot: true,        // android only\n  });\n}"}
{"instruction": "Use `react-native-reanimated` to create an Animated ScrollView where the header opacity interpolates from 0 to 1 based on the vertical scroll offset (0 to 100px).", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Fading Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, padding: 20 }}>\n          <Text>Scroll content...</Text>\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write a Kotlin class extending `SimpleViewManager` to expose a standard Android `TextView` as a React Native component named `RCTCustomTextView`. Include a prop `@ReactProp` to set the text.", "output": "package com.myapp\n\nimport android.widget.TextView\nimport com.facebook.react.uimanager.SimpleViewManager\nimport com.facebook.react.uimanager.ThemedReactContext\nimport com.facebook.react.uimanager.annotations.ReactProp\n\nclass CustomTextViewManager : SimpleViewManager<TextView>() {\n\n    override fun getName(): String {\n        return \"RCTCustomTextView\"\n    }\n\n    override fun createViewInstance(reactContext: ThemedReactContext): TextView {\n        return TextView(reactContext)\n    }\n\n    @ReactProp(name = \"text\")\n    fun setText(view: TextView, text: String?) {\n        view.text = text ?: \"\"\n    }\n}"}
{"instruction": "Create a custom React Native hook `useOrientation` that listens to orientation changes using `expo-screen-orientation` and returns the current orientation string.", "output": "import { useState, useEffect } from 'react';\nimport * as ScreenOrientation from 'expo-screen-orientation';\n\nexport function useOrientation() {\n  const [orientation, setOrientation] = useState<ScreenOrientation.Orientation>(ScreenOrientation.Orientation.UNKNOWN);\n\n  useEffect(() => {\n    // Get initial\n    const getInitialOrientation = async () => {\n      const current = await ScreenOrientation.getOrientationAsync();\n      setOrientation(current);\n    };\n    getInitialOrientation();\n\n    // Subscribe to updates\n    const subscription = ScreenOrientation.addOrientationChangeListener((evt) => {\n      setOrientation(evt.orientationInfo.orientation);\n    });\n\n    return () => {\n      ScreenOrientation.removeOrientationChangeListener(subscription);\n    };\n  }, []);\n\n  return orientation;\n}"}
{"instruction": "Create a basic iOS Native Module in Swift for React Native that exposes a method to get the device's battery level. Include the Objective-C interface bridge.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Implement a draggable box component using `react-native-reanimated` (v3) and `react-native-gesture-handler`. The box should snap back to the origin when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `RTNCalculator` that includes a synchronous `add` method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method example\n  add(a: number, b: number): number;\n\n  // Asynchronous method example\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('RTNCalculator') as Spec | null;"}
{"instruction": "Create a custom Expo Module using the Expo Modules API (Kotlin) that exposes a function to set a generic string preference and send an event to JavaScript.", "output": "package expo.modules.settings\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass SettingsModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"SettingsModule\")\n\n    // Defines event names that the module can send to JavaScript.\n    Events(\"onChangeTheme\")\n\n    // Function to save a setting and emit an event\n    Function(\"setTheme\") { themeName: String ->\n      // Logic to save preference would go here...\n      \n      // Send event to JS\n      sendEvent(\"onChangeTheme\", mapOf(\n        \"theme\" to themeName\n      ))\n      \n      return@Function \"Theme set to $themeName\"\n    }\n  }\n}"}
{"instruction": "Optimize a heavy calculation in React Native by offloading it to the UI thread using a Reanimated Worklet to prevent blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function WorkletExample() {\n  const [result, setResult] = useState<number | null>(null);\n\n  // This function runs entirely on the UI thread\n  const heavyCalculation = (input: number) => {\n    'worklet';\n    let sum = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 5000000; i++) {\n      sum += i * input;\n    }\n    return sum;\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const calculatedValue = heavyCalculation(2);\n      // Update state back on the JS thread\n      // Note: runOnJS is implicitly handled for state setters in newer Reanimated versions,\n      // but explicit usage is safer for general functions.\n      // runOnJS(setResult)(calculatedValue);\n      console.log('Result calculated on UI thread:', calculatedValue);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Write an Expo Config Plugin to automatically add a specific permission (`android.permission.RECORD_AUDIO`) to the `AndroidManifest.xml` during the prebuild phase.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withRecordAudioPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    // Ensure permissions array exists\n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const permissionName = 'android.permission.RECORD_AUDIO';\n    \n    // Check if permission already exists\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (perm) => perm.$['android:name'] === permissionName\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: {\n          'android:name': permissionName,\n        },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withRecordAudioPermission;"}
{"instruction": "Implement a Reanimated `useAnimatedScrollHandler` to create a parallax header effect where an image scales up when scrolling down (pull-to-refresh direction) and translates up when scrolling up.", "output": "import React from 'react';\nimport { Dimensions, StyleSheet, View } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  useSharedValue, \n  interpolate,\n  Extrapolation\n} from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          translateY: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75]\n          ),\n        },\n        {\n          scale: interpolate(\n            scrollY.value,\n            [-IMG_HEIGHT, 0, IMG_HEIGHT],\n            [2, 1, 1],\n            Extrapolation.CLAMP\n          ),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/600x400' }}\n        style={[styles.image, imageStyle]}\n      />\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: IMG_HEIGHT }}\n      >\n        <View style={styles.content}>\n          {/* List content goes here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: width,\n    resizeMode: 'cover',\n  },\n  content: {\n    height: 1000,\n    backgroundColor: 'white',\n  }\n});"}
{"instruction": "Create a Java Native Module for Android that opens a specific URL in the default browser using an Intent.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BrowserOpenerModule extends ReactContextBaseJavaModule {\n\n    BrowserOpenerModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BrowserOpener\";\n    }\n\n    @ReactMethod\n    public void openUrl(String url) {\n        try {\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setData(Uri.parse(url));\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            getReactApplicationContext().startActivity(intent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"}
{"instruction": "Create a custom Reanimated Layout Animation (Keyframe) to make an item slide in from the right with a wobble effect upon mounting.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { Keyframe } from 'react-native-reanimated';\n\nexport default function WobbleEntry() {\n  const [show, setShow] = useState(false);\n\n  const enteringAnimation = new Keyframe({\n    0: {\n      transform: [{ translateX: 200 }, { rotate: '0deg' }],\n      opacity: 0,\n    },\n    50: {\n      transform: [{ translateX: -20 }, { rotate: '-5deg' }],\n      opacity: 1,\n    },\n    75: {\n      transform: [{ translateX: 10 }, { rotate: '5deg' }],\n    },\n    100: {\n      transform: [{ translateX: 0 }, { rotate: '0deg' }],\n      opacity: 1,\n    },\n  }).duration(800);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View \n          entering={enteringAnimation} \n          style={styles.box} \n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'tomato',\n    marginTop: 20,\n    borderRadius: 10,\n  },\n});"}
{"instruction": "Implement a Bridge Optimization technique by using `InteractionManager` to defer a heavy task until after animations/transitions are complete.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // Defer the heavy task until navigation transitions or interactions are done\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy calculation or network request here\n      const heavyData = performHeavyCalculation();\n      setData(heavyData);\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  const performHeavyCalculation = () => {\n    // Simulate expensive operation\n    return new Array(1000).fill('Item').map((item, i) => `${item} ${i}`);\n  };\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n        <Text>Rendering transitions...</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, padding: 20 }}>\n      <Text>Heavy Data Loaded: {data?.length} items</Text>\n    </View>\n  );\n}"}
{"instruction": "Create a custom Expo Module using the modern 'expo-modules-core' API (TypeScript) that exposes a synchronous function to get the device model name. This demonstrates the modern alternative to legacy Native Modules.", "output": "import { Module } from 'expo-modules-core';\n\nexport default class DeviceModelModule extends Module {\n  public definition() {\n    // Sets the name of the module that JavaScript code will use to refer to the module.\n    this.name('DeviceModel');\n\n    // Defines a synchronous function that runs on the native thread and returns a value immediately.\n    this.function('getModel', (): string => {\n      // In a real scenario, you would access native device APIs here.\n      // For this example, we return a static string simulating native retrieval.\n      return 'iPhone 15 Pro Max (Simulated)';\n    });\n  }\n}"}
{"instruction": "Implement a draggable View using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The box should follow the finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a legacy Android Native Module (Java) that exposes a method to show a Toast message. This demonstrates bridging native Android UI components to JS.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Module Name exposed to JS\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    // Method exposed to JS\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a legacy iOS Native Module (Swift) that exposes a method to trigger a haptic feedback impact. Includes the objective-c bridge export.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func triggerImpact(_ style: String) {\n    DispatchQueue.main.async {\n      let feedbackStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"heavy\": feedbackStyle = .heavy\n        case \"medium\": feedbackStyle = .medium\n        default: feedbackStyle = .light\n      }\n      let generator = UIImpactFeedbackGenerator(style: feedbackStyle)\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Optimize Bridge performance by offloading a heavy calculation (Fibonacci) to the UI thread using a Reanimated Worklet. This avoids blocking the JS thread (Bridge Optimization/JSI usage).", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet'; // Marks this function to run on the UI thread (JSI context)\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      const heavyResult = fibonacci(35); // Heavy work on UI thread\n      runOnJS(setResult)(heavyResult);   // Call back to JS thread to update state\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Task\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Implement a 'Sticky Header' effect using Reanimated 3. The header's opacity should interpolate based on the ScrollView's vertical offset.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function StickyHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP);\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {Array.from({ length: 50 }).map((_, i) => (\n            <Text key={i} style={styles.item}>Item {i}</Text>\n          ))}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { position: 'absolute', top: 0, left: 0, right: 0, height: 80, backgroundColor: 'red', zIndex: 1, justifyContent: 'center', alignItems: 'center', paddingTop: 30 },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  content: { paddingTop: 80, paddingHorizontal: 20 },\n  item: { padding: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Demonstrate Bridge Optimization by passing binary data (Uint8Array) instead of Base64 strings to a hypothetical Native Module. Base64 adds 33% overhead and CPU cost; modern RN supports ArrayBuffers.", "output": "import { NativeModules } from 'react-native';\n\nconst { ImageProcessor } = NativeModules;\n\n/**\n * Sends binary data directly to native side without Base64 serialization.\n * React Native automatically converts Uint8Array to native byte arrays/Data.\n */\nexport const processImageBuffer = async (imageUrl: string) => {\n  try {\n    // 1. Fetch data as an ArrayBuffer (binary)\n    const response = await fetch(imageUrl);\n    const buffer = await response.arrayBuffer();\n    \n    // 2. Wrap in Uint8Array\n    const uint8Data = new Uint8Array(buffer);\n\n    // 3. Pass directly to native module\n    // Native side (Java/Obj-C) receives this as byte[] or NSData, avoiding string parsing.\n    const result = await ImageProcessor.applyFilter(uint8Data);\n    console.log('Processed size:', result);\n  } catch (e) {\n    console.error('Bridge transfer failed', e);\n  }\n};"}
{"instruction": "Use Expo Sensors (Accelerometer) to rotate a View based on device tilt. Shows integration of Expo managed workflow packages.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, Text, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltSensor() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  // Simple calculation to visualize tilt\n  const tilt = Math.round(x * 100);\n\n  return (\n    <View style={styles.container}>\n      <Text>Tilt your phone!</Text>\n      <View style={[styles.ball, { transform: [{ rotate: `${tilt}deg` }] }]}>\n        <Text style={{ color: 'white' }}>UP</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 100, height: 100, backgroundColor: 'purple', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list. This replaces the old LayoutAnimation API.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeInUp} \n          exiting={FadeOutDown} \n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  buttons: { flexDirection: 'row', justifyContent: 'space-around', marginBottom: 20 },\n  card: { height: 50, backgroundColor: '#e0e0e0', marginBottom: 10, justifyContent: 'center', paddingLeft: 10, borderRadius: 8 }\n});"}
{"instruction": "Create an Android Native UI Component (ViewManager) in Java to expose a simple 'CustomView' that can be used in JSX. This allows rendering native Android views inside React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"RCTCustomView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        View view = new View(context);\n        view.setBackgroundColor(Color.RED); // Default color\n        return view;\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(View view, String color) {\n        view.setBackgroundColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Create a Native Module for iOS using Swift to retrieve the device's battery level and expose it to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    resolve(level)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. Usage in JavaScript\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nconst checkBattery = async () => {\n  const level = await BatteryModule.getBatteryLevel();\n  console.log(`Battery Level: ${level * 100}%`);\n};"}
{"instruction": "Implement a simple Android Native Module using Java to display a native Toast message.", "output": "// 1. ToastModule.java\npackage com.myapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message) {\n        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n    }\n}\n\n// 2. CustomPackage.java (Register the module)\n// ... inside createNativeModules list: modules.add(new ToastModule(reactContext));\n\n// 3. Usage in JavaScript\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nToastModule.show('Hello from Java!');"}
{"instruction": "Create a draggable box using React Native Reanimated (v3) and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Optimize Bridge traffic by using 'react-native-mmkv' (JSI) for synchronous storage instead of the asynchronous AsyncStorage.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize MMKV (creates a JSI binding directly to C++, bypassing the async bridge)\nexport const storage = new MMKV();\n\n// Usage Example\nconst UserProfile = () => {\n  // Synchronous Write (High Performance)\n  const saveUser = (username: string) => {\n    storage.set('user.name', username);\n  };\n\n  // Synchronous Read\n  const getUser = () => {\n    const username = storage.getString('user.name');\n    return username ?? 'Guest';\n  };\n\n  return { saveUser, getUser };\n};"}
{"instruction": "Use Expo Sensors to rotate a View based on the device's accelerometer data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function SensorRotate() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  const rotation = Math.atan2(y, x) * (180 / Math.PI);\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: `${rotation}deg` }] }]}>\n        <Text>Rotate Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'coral', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement a Reanimated Layout Animation to smoothly animate items entering and leaving a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((i) => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn}\n          exiting={FadeOut}\n          layout={Layout.springify()}\n          onTouchEnd={() => removeItem(item)}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { height: 50, backgroundColor: '#4CAF50', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Use `InteractionManager` to optimize bridge performance by deferring a heavy calculation until after navigation or animations complete.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function HeavyScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Schedule the heavy task after animations/transitions finish\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy calculation or network request here\n      doHeavyWork();\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  const doHeavyWork = () => {\n    // Simulate blocking work\n    let result = 0;\n    for (let i = 0; i < 5000000; i++) result += i;\n    console.log('Heavy work done', result);\n  };\n\n  if (!isReady) return <ActivityIndicator size=\"large\" />;\n\n  return (\n    <View><Text>Heavy Content Loaded</Text></View>\n  );\n}"}
{"instruction": "Create an Expo Config Plugin to modify the AndroidManifest.xml to add the VIBRATE permission.", "output": "// plugin/withVibratePermission.js\nconst { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withVibratePermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    // Ensure permissions array exists\n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (perm) => perm.$['android:name'] === 'android.permission.VIBRATE'\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': 'android.permission.VIBRATE' },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withVibratePermission;"}
{"instruction": "Use Reanimated 'runOnUI' (Worklets) to execute logic on the UI thread, bypassing the JS thread entirely.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function WorkletExample() {\n  // This function is defined in JS but marked as 'worklet' automatically by the babel plugin\n  // when passed to runOnUI or used in hooks.\n  const uiThreadFunction = (name: string) => {\n    'worklet';\n    console.log(`Hello ${name} from the UI Thread!`);\n    // You can perform synchronous UI calculations here without freezing the JS bridge\n  };\n\n  const handlePress = () => {\n    runOnUI(uiThreadFunction)('Developer');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run on UI\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Use `expo-file-system` to download an image from a remote URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n};\n\n// Usage: downloadImage('https://example.com/logo.png', 'logo.png');"}
{"instruction": "Create a simple Android Native Module in Java that exposes a method to get the device's battery level asynchronously using a Promise.", "output": "package com.myapp;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a modern Expo Module API definition in Kotlin that exposes a synchronous function to generate a random UUID.", "output": "package expo.modules.uuidgenerator\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport java.util.UUID\n\nclass UuidGeneratorModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"UuidGenerator\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"generate\") { \n      return@Function UUID.randomUUID().toString()\n    }\n  }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'RTNCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('RTNCalculator');"}
{"instruction": "Demonstrate how to optimize a React Native FlatList to reduce bridge traffic and improve scroll performance using 'getItemLayout' and 'removeClippedSubviews'.", "output": "import React from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 50;\n\nconst OptimizedList = ({ data }) => {\n  const renderItem = ({ item }) => (\n    <View style={styles.item}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  // Optimization: Skip measurement calculation by providing fixed dimensions\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      getItemLayout={getItemLayout}\n      // Optimization: Unmount components off-screen to save memory\n      removeClippedSubviews={true}\n      // Optimization: Render fewer items initially\n      initialNumToRender={10}\n      // Optimization: Tune how far ahead to render\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: ITEM_HEIGHT, justifyContent: 'center', paddingHorizontal: 20 },\n});\n\nexport default OptimizedList;"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) binding function that performs a synchronous heavy calculation (e.g., multiplier) and installs it into the global JavaScript runtime.", "output": "#include <jsi/jsi.h>\n#include <ReactCommon/CallInvoker.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid install(Runtime &runtime) {\n    auto multiplier = Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"nativeMultiplier\"),\n        2, // param count\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            if (count < 2) return Value::undefined();\n            \n            double a = arguments[0].asNumber();\n            double b = arguments[1].asNumber();\n            \n            // Perform synchronous calculation without bridge serialization overhead\n            return Value(a * b);\n        }\n    );\n\n    runtime.global().setProperty(runtime, \"nativeMultiplier\", move(multiplier));\n}"}
{"instruction": "Create an iOS Native Module in Swift that emits an event to JavaScript when a screenshot is taken.", "output": "// ScreenshotDetector.swift\nimport Foundation\nimport React\n\n@objc(ScreenshotDetector)\nclass ScreenshotDetector: RCTEventEmitter {\n\n  override init() {\n    super.init()\n    NotificationCenter.default.addObserver(\n      self,\n      selector: #selector(detectScreenshot),\n      name: UIApplication.userDidTakeScreenshotNotification,\n      object: nil\n    )\n  }\n\n  @objc func detectScreenshot() {\n    sendEvent(withName: \"onScreenshotTaken\", body: [\"timestamp\": Date().timeIntervalSince1970])\n  }\n\n  override func supportedEvents() -> [String]! {\n    return [\"onScreenshotTaken\"]\n  }\n  \n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use Reanimated 3 to create a layout animation where items in a list fade out and slide left when removed.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, SlideOutLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = () => {\n    setItems((current) => current.slice(0, -1));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          style={styles.box}\n          // Layout animation for position adjustments of siblings\n          layout={Layout.springify()}\n          // Exiting animation\n          exiting={SlideOutLeft.duration(300).withCallback((finished) => {\n             'worklet';\n             // Optional callback logic\n          })}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  box: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Create a custom Expo Config Plugin to add a specific permission (e.g., CAMERA) to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const hasPermission = androidManifest.manifest['uses-permission'].some(\n      (perm) => perm.$['android:name'] === 'android.permission.CAMERA'\n    );\n\n    if (!hasPermission) {\n      androidManifest.manifest['uses-permission'].push({\n        $: { 'android:name': 'android.permission.CAMERA' },\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Implement a performance optimization hook that batches state updates to prevent excessive bridge passes when receiving high-frequency data (e.g., WebSocket messages).", "output": "import { useState, useEffect, useRef } from 'react';\n\nexport function useBatchedSocketData(socket, batchTimeMs = 50) {\n  const [data, setData] = useState([]);\n  const bufferRef = useRef([]);\n\n  useEffect(() => {\n    const handleMessage = (message) => {\n      // Push to a ref instead of triggering a state update immediately\n      bufferRef.current.push(message);\n    };\n\n    socket.on('message', handleMessage);\n\n    // Flush buffer to state at a fixed interval\n    const intervalId = setInterval(() => {\n      if (bufferRef.current.length > 0) {\n        setData((prev) => [...prev, ...bufferRef.current]);\n        bufferRef.current = [];\n      }\n    }, batchTimeMs);\n\n    return () => {\n      socket.off('message', handleMessage);\n      clearInterval(intervalId);\n    };\n  }, [socket, batchTimeMs]);\n\n  return data;\n}"}
{"instruction": "Create a modern Expo Module (Swift) that exposes a native function to get the device model name synchronously.", "output": "import ExpoModulesCore\n\npublic class DeviceModelModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceModel\")\n\n    // Exposes a synchronous function to JavaScript\n    Function(\"getModelName\") {\n      return UIDevice.current.model\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler without sending touch events across the bridge.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' that adds two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n}\n\n// Load the module, defaulting to null if not available\nexport default TurboModuleRegistry.get<Spec>('Calculator') as Spec | null;"}
{"instruction": "Create a basic Android Native Module in Kotlin that exposes a method to show a Toast message.", "output": "package com.yourapp\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport android.widget.Toast\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Use a Reanimated Worklet to offload a heavy Fibonacci calculation to the UI thread to prevent blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const heavyResult = fib(35); // Expensive calculation\n      \n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Calculating...'}</Text>\n      <Button title=\"Run Heavy Task\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Implement a C++ JSI binding function (concept) to install a global function 'nativeMultiply' into the JavaScript Runtime.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid installNativeMultiply(Runtime &runtime) {\n    auto multiply = Function::createFromHostFunction(\n        runtime,\n        PropNameID::forAscii(runtime, \"nativeMultiply\"),\n        2, // Number of arguments\n        [](Runtime &rt, const Value &thisValue, const Value *args, size_t count) -> Value {\n            if (count < 2 || !args[0].isNumber() || !args[1].isNumber()) {\n                throw JSError(rt, \"Two numbers expected\");\n            }\n            double result = args[0].asNumber() * args[1].asNumber();\n            return Value(result);\n        }\n    );\n\n    runtime.global().setProperty(runtime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Create a custom iOS Native UI Component (View Manager) in Objective-C to expose a generic UIView with a settable background color.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\n// Expose the backgroundColor prop (React Native handles the conversion automatically)\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end"}
{"instruction": "Optimize a scroll animation by binding scroll events directly to a shared value using Reanimated's useAnimatedScrollHandler to avoid bridge traffic.", "output": "import React from 'react';\nimport Animated, { useSharedValue, useAnimatedStyle, useAnimatedScrollHandler, interpolate, Extrapolation } from 'react-native-reanimated';\nimport { StyleSheet, View } from 'react-native';\n\nexport default function ScrollAnimation() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [1, 0], Extrapolation.CLAMP),\n      transform: [\n        { translateY: interpolate(scrollY.value, [0, 100], [0, -50], Extrapolation.CLAMP) }\n      ]\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 100, backgroundColor: 'tomato', width: '100%' }\n});"}
{"instruction": "Use InteractionManager to defer a heavy task until after an animation or transition is complete to keep the JS thread free for UI updates.", "output": "import React, { useEffect, useState } from 'react';\nimport { InteractionManager, Text, View, ActivityIndicator } from 'react-native';\n\nexport default function DeferredTask() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Schedule expensive task after interactions/animations allow\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy data loading or processing here\n      console.log('Animation complete, running heavy task...');\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>Heavy content loaded!</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a Reanimated Layout Animation to animate a list item when it is mounted and unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20 },\n  item: { height: 50, backgroundColor: 'teal', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a basic Native Module in Swift (iOS) that exposes a method to get the device's battery level using a Promise.", "output": "// CalendarModule.swift\nimport Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc(getBatteryLevel:withRejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// BatteryModule.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve withRejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a Native Module in Kotlin (Android) that exposes a method to get the Android Model name.", "output": "// DeviceModule.kt\npackage com.yourapp\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport com.facebook.react.bridge.Promise\nimport android.os.Build\n\nclass DeviceModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"DeviceModule\"\n    }\n\n    @ReactMethod\n    fun getModel(promise: Promise) {\n        try {\n            val model = Build.MODEL\n            promise.resolve(model)\n        } catch (e: Exception) {\n            promise.reject(\"Error\", e)\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use the Expo Modules API (Swift) to create a simple native module that returns a synchronous 'Hello World' string.", "output": "import ExpoModulesCore\n\npublic class MyModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyModule\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"hello\") { (name: String) in\n      return \"Hello \\(name)!\"\n    }\n  }\n}"}
{"instruction": "Implement an optimized ScrollView header animation using Reanimated that interpolates opacity based on scroll offset.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute', top: 0, left: 0, right: 0, height: 60,\n    backgroundColor: 'white', justifyContent: 'center', alignItems: 'center', zIndex: 1, elevation: 2\n  }\n});"}
{"instruction": "Bridge Optimization: Demonstrate how to use Reanimated's `runOnUI` to execute logic on the UI thread, bypassing the JS bridge completely for a heavy calculation triggered by a gesture.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyUICalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  let result = 0;\n  for(let i=0; i < 1000; i++) {\n     result += input * i;\n  }\n  console.log('Calculated on UI thread:', result);\n}\n\n// Usage inside a component or gesture callback\nconst handlePress = () => {\n  // This call does not block the JS thread and does not require bridge serialization for the logic inside heavyUICalculation\n  runOnUI(heavyUICalculation)(5);\n};"}
{"instruction": "Create a Custom Native ViewManager in Java (Android) to expose a simple TextView to React Native.", "output": "package com.myapp;\n\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport android.widget.TextView;\nimport android.graphics.Color;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        return new TextView(reactContext);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n    \n    @ReactProp(name = \"color\")\n    public void setColor(TextView view, String color) {\n        view.setTextColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Use Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { Entering, Exiting, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={Entering.FadeIn.duration(500)} \n          exiting={Exiting.FadeOut.duration(500)}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { marginTop: 50, padding: 20 },\n  item: { height: 50, width: '100%', backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) binding function to install a synchronous global function. (Concept code for cpp-adapter.cpp).", "output": "#include <jsi/jsi.h>\n#include \"example.h\"\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // Number of arguments\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          if(!arguments[0].isNumber() || !arguments[1].isNumber()) {\n              return Value::undefined();\n          }\n          double res = arguments[0].getNumber() * arguments[1].getNumber();\n          return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", move(multiply));\n}"}
{"instruction": "Create a strictly typed TypeScript interface for a Native Module that includes a method returning a Promise.", "output": "import { NativeModules } from 'react-native';\n\ninterface CalendarModuleInterface {\n  /**\n   * Creates a calendar event.\n   * @param name Name of the event\n   * @param location Location string\n   * @returns Promise resolving to the event ID\n   */\n  createCalendarEvent(name: string, location: string): Promise<string>;\n  \n  /**\n   * Constants exported by the native module\n   */\n  DEFAULT_EVENT_NAME: string;\n}\n\nconst { CalendarModule } = NativeModules;\n\nexport default CalendarModule as CalendarModuleInterface;"}
{"instruction": "Create a custom React Native hook using Expo Haptics and Reanimated to create a button that scales down and triggers impact feedback when pressed.", "output": "import React from 'react';\nimport { Pressable, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport const HapticButton = ({ onPress, children }: { onPress: () => void, children: React.ReactNode }) => {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    scale.value = withSpring(0.9);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[styles.button, animatedStyle]}\n    >\n      {children}\n    </AnimatedPressable>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    padding: 16,\n    backgroundColor: '#007AFF',\n    borderRadius: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});"}
{"instruction": "Write the Java code for a simple Android Native Module that exposes a method to get the current battery level via a Promise.", "output": "package com.yourapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    public BatteryModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            if (batteryStatus == null) {\n                promise.reject(\"BATTERY_UNAVAILABLE\", \"Battery status is null\");\n                return;\n            }\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"ERR_BATTERY\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated (v3) and React Native Gesture Handler. The box should snap back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (Fabric/New Architecture) named 'Calculator' that includes a synchronous method 'add'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method execution is a key benefit of TurboModules/JSI\n  add(a: number, b: number): number;\n  \n  // Async method example\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Create an Objective-C header and implementation for an iOS Native Module that exports a constant 'environment' to JavaScript.", "output": "// CalendarModule.h\n#import <React/RCTBridgeModule.h>\n@interface EnvironmentModule : NSObject <RCTBridgeModule>\n@end\n\n// CalendarModule.m\n#import \"EnvironmentModule.h\"\n\n@implementation EnvironmentModule\n\nRCT_EXPORT_MODULE();\n\n- (NSDictionary *)constantsToExport\n{\n  #if DEBUG\n    return @{ @\"env\": @\"development\" };\n  #else\n    return @{ @\"env\": @\"production\" };\n  #endif\n}\n\n+ (BOOL)requiresMainQueueSetup\n{\n  return YES;\n}\n\n@end"}
{"instruction": "Use Reanimated to optimize bridge traffic by running a heavy calculation synchronously on the UI thread using `runOnUI`, rather than passing data back to the JS thread.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A computationally expensive function\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = input;\n  for (let i = 0; i < 10000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('[UI Thread] Result:', result);\n}\n\nexport const HeavyWorkletExample = () => {\n  const handlePress = () => {\n    // Instead of calculating in JS or sending a bridge message,\n    // we execute directly on the UI thread (JSI context)\n    runOnUI(heavyCalculation)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};\n"}
{"instruction": "Implement an Expo TaskManager task to handle background location updates.", "output": "import * as TaskManager from 'expo-task-manager';\nimport * as Location from 'expo-location';\n\nconst LOCATION_TASK_NAME = 'background-location-task';\n\n// 1. Define the task in global scope\nTaskManager.defineTask(LOCATION_TASK_NAME, ({ data, error }) => {\n  if (error) {\n    console.error('Background location error:', error);\n    return;\n  }\n  if (data) {\n    const { locations } = data as { locations: Location.LocationObject[] };\n    console.log('Received new locations in background:', locations);\n    // Perform API calls or local storage updates here\n  }\n});\n\n// 2. Function to register the task (call this from a component)\nexport const startBackgroundUpdate = async () => {\n  const { status } = await Location.requestBackgroundPermissionsAsync();\n  if (status === 'granted') {\n    await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {\n      accuracy: Location.Accuracy.Balanced,\n      distanceInterval: 50,\n      deferredUpdatesInterval: 1000 * 60, // 1 minute\n    });\n  }\n};"}
{"instruction": "Create a Reanimated ScrollView that interpolates the opacity of a header based on the scroll Y position.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  useSharedValue, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nexport const ParallaxHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Long content here */}\n          <View style={{ height: 1000 }} />\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 80,\n    backgroundColor: 'blue',\n    zIndex: 1,\n  },\n  content: { paddingTop: 100 },\n});"}
{"instruction": "Write a Native Module code snippet for Android (Java) to send an event 'onStepCount' to JavaScript using the DeviceEventManagerModule.", "output": "private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {\n    if (reactContext.hasActiveCatalystInstance()) {\n        reactContext\n            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n            .emit(eventName, params);\n    }\n}\n\n// Example usage within the module\npublic void onSensorChanged(SensorEvent event) {\n    WritableMap params = Arguments.createMap();\n    params.putInt(\"steps\", (int) event.values[0]);\n    sendEvent(getReactApplicationContext(), \"onStepCount\", params);\n}"}
{"instruction": "Use Expo SecureStore to create a simple hook for storing and retrieving an authentication token securely.", "output": "import * as SecureStore from 'expo-secure-store';\nimport { useState, useEffect } from 'react';\n\nexport const useAuthToken = () => {\n  const [token, setToken] = useState<string | null>(null);\n\n  useEffect(() => {\n    const loadToken = async () => {\n      const stored = await SecureStore.getItemAsync('user_auth_token');\n      if (stored) setToken(stored);\n    };\n    loadToken();\n  }, []);\n\n  const saveToken = async (newToken: string) => {\n    await SecureStore.setItemAsync('user_auth_token', newToken);\n    setToken(newToken);\n  };\n\n  const removeToken = async () => {\n    await SecureStore.deleteItemAsync('user_auth_token');\n    setToken(null);\n  };\n\n  return { token, saveToken, removeToken };\n};"}
{"instruction": "Create a Native Module in iOS (Swift) that exposes a method to get the device's battery level and returns it via a Promise to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport React\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n\n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1 {\n      reject(\"ERR_BATTERY\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. Usage in TypeScript\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nasync function checkBattery() {\n  try {\n    const level = await BatteryModule.getBatteryLevel();\n    console.log(`Battery Level: ${level}%`);\n  } catch (e) {\n    console.error(e);\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a simple Android Native Module using Kotlin that displays a Toast message when called from JavaScript.", "output": "// 1. ToastModule.kt\npackage com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName() = \"ToastModule\"\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n}\n\n// 2. MyAppPackage.kt (Registering the module)\n// ... inside createNativeModules list:\n// modules.add(ToastModule(reactContext))\n\n// 3. Usage in TypeScript\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nexport const showToast = () => {\n  ToastModule.show('Hello from Native!', 0); // 0 for LENGTH_SHORT\n};"}
{"instruction": "Use the Expo Modules API to create a modern native module that returns the device's name synchronously. Provide the Swift implementation and the TypeScript definition.", "output": "// 1. ios/MyDeviceModule.swift\nimport ExpoModulesCore\nimport UIKit\n\npublic class MyDeviceModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyDeviceModule\")\n\n    Function(\"getDeviceName\") {\n      return UIDevice.current.name\n    }\n  }\n}\n\n// 2. index.ts\nimport { requireNativeModule } from 'expo-modules-core';\n\ninterface MyDeviceModuleInterface {\n  getDeviceName(): string;\n}\n\nconst MyDeviceModule = requireNativeModule<MyDeviceModuleInterface>('MyDeviceModule');\n\nexport function getDeviceName(): string {\n  return MyDeviceModule.getDeviceName();\n}"}
{"instruction": "Optimize bridge performance by offloading a heavy calculation (Fibonacci) to the UI thread using a Reanimated Worklet, preventing the JS thread from freezing.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleUpdateResult = (val: number) => {\n    setResult(val);\n  };\n\n  const triggerCalculation = () => {\n    runOnUI(() => {\n      // This runs on the UI thread, leaving JS thread free for touches/updates\n      const heavyResult = fibonacci(35);\n      runOnJS(handleUpdateResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={triggerCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Define a TurboModule specification (TypeScript) for the New Architecture to access the App Version. This file is used by Codegen to generate native scaffolding.", "output": "// NativeAppVersion.ts\nimport type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  getAppVersion(): string;\n  getBuildNumber(): string;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeAppVersion');"}
{"instruction": "Implement an iOS Native Module (Swift) that acts as an EventEmitter to send a 'ShakeEvent' to JavaScript when the device is shaken.", "output": "// 1. ShakeModule.swift\nimport React\nimport UIKit\n\n@objc(ShakeModule)\nclass ShakeModule: RCTEventEmitter {\n  \n  override func supportedEvents() -> [String]! {\n    return [\"onShake\"]\n  }\n  \n  override func startObserving() {\n    NotificationCenter.default.addObserver(self, selector: #selector(emitShakeEvent), name: UIDevice.orientationDidChangeNotification, object: nil)\n  }\n\n  override func stopObserving() {\n    NotificationCenter.default.removeObserver(self)\n  }\n\n  @objc func emitShakeEvent() {\n    // Simplified logic: emitting on orientation change for demo purposes\n    // In a real app, you would override UIWindow motionEnded\n    sendEvent(withName: \"onShake\", body: [\"shaken\": true])\n  }\n  \n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. JS Usage\nimport { NativeEventEmitter, NativeModules } from 'react-native';\nconst { ShakeModule } = NativeModules;\nconst shakeEmitter = new NativeEventEmitter(ShakeModule);\n\n// Usage\nconst subscription = shakeEmitter.addListener('onShake', (event) => console.log(event));"}
{"instruction": "Replace a standard FlatList with Shopify's FlashList to optimize rendering performance for a large list of items.", "output": "import React from 'react';\nimport { Text, View, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 2000 }, (_, i) => ({ title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50} // Crucial for FlashList performance\n        keyExtractor={(item, index) => index.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderColor: '#ccc',\n  },\n});\n\nexport default MyList;"}
{"instruction": "Implement a basic C++ JSI (JavaScript Interface) binding setup in a `cpp-adapter.cpp` file to expose a synchronous C++ function `multiply(a, b)` to JavaScript. (Conceptual JSI setup).", "output": "#include <jni.h>\n#include <jsi/jsi.h>\n#include \"MyJSIModule.h\"\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid install(Runtime &jsiRuntime) {\n    auto multiply = Function::createFromHostFunction(\n        jsiRuntime,\n        PropNameID::forAscii(jsiRuntime, \"multiply\"),\n        2, // param count\n        [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n            double res = arguments[0].asNumber() * arguments[1].asNumber();\n            return Value(res);\n        }\n    );\n\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", move(multiply));\n}\n\n// Note: This function 'install' is usually called from the JNI OnLoad (Android) or Bridge setup (iOS)."}
{"instruction": "Create a React Native component that uses `expo-camera` to show a camera preview and capture a photo when a button is pressed.", "output": "import { CameraView, useCameraPermissions } from 'expo-camera';\nimport { useState, useRef } from 'react';\nimport { Button, StyleSheet, Text, View } from 'react-native';\n\nexport default function App() {\n  const [permission, requestPermission] = useCameraPermissions();\n  const cameraRef = useRef<CameraView>(null);\n\n  if (!permission) return <View />;\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  const takePicture = async () => {\n    if (cameraRef.current) {\n      const photo = await cameraRef.current.takePictureAsync();\n      console.log(photo?.uri);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} ref={cameraRef}>\n        <View style={styles.buttonContainer}>\n          <Button title=\"Snap\" onPress={takePicture} />\n        </View>\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: { flex: 1, flexDirection: 'row', backgroundColor: 'transparent', margin: 64, justifyContent: 'center', alignItems: 'flex-end' },\n});"}
{"instruction": "Create a basic iOS Native Module in Swift that exposes a method to get the device name. Include the Objective-C bridge macro.", "output": "// DeviceInfo.swift\nimport Foundation\nimport React\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n\n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a custom Expo Module using the `expo-modules-core` API that returns a synchronous 'Hello' string.", "output": "import { Module } from 'expo-modules-core';\n\nexport default class MyCustomModule extends Module {\n  // Each module class must define a public name\n  public name() {\n    return 'MyCustomModule';\n  }\n\n  // Defines the definition of the module\n  public definition() {\n    // Sets the function to be exported to the JavaScript world\n    this.Function('hello', () => {\n      return 'Hello from Expo Native Module!';\n    });\n  }\n}"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) that includes a method to add two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('MathTurboModule') as Spec | null;"}
{"instruction": "Create an Android Native Module in Java that opens a URL in the default browser.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class LinkOpenerModule extends ReactContextBaseJavaModule {\n    LinkOpenerModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"LinkOpener\";\n    }\n\n    @ReactMethod\n    public void openURL(String url) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(url));\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (intent.resolveActivity(getReactApplicationContext().getPackageManager()) != null) {\n            getReactApplicationContext().startActivity(intent);\n        }\n    }\n}"}
{"instruction": "Use Reanimated `runOnUI` to offload a heavy synchronous calculation (e.g., Fibonacci) to the UI thread to prevent blocking the JS thread.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nconst heavyCalculation = (n: number): number => {\n  'worklet';\n  if (n <= 1) return n;\n  return heavyCalculation(n - 1) + heavyCalculation(n - 2);\n};\n\nexport default function WorkletExample() {\n  const handlePress = () => {\n    runOnUI(() => {\n      const result = heavyCalculation(35);\n      console.log('Fibonacci result calculated on UI thread:', result);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Implement a C++ JSI (JavaScript Interface) binding function to expose a synchronous C++ method to JavaScript. (Focus on the install function).", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"multiply\"),\n      2, // Number of arguments\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n        if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n            return Value::undefined();\n        }\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"multiply\", move(multiply));\n}"}
{"instruction": "Use `react-native-reanimated` Layout Animations to animate a list item when it is mounted and unmounted.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutRight } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [show, setShow] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle Item\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View \n          entering={FadeIn.duration(500)} \n          exiting={SlideOutRight.duration(300)} \n          layout={Layout.springify()}\n          style={styles.box} \n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', paddingTop: 50 },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', marginTop: 20, borderRadius: 10 }\n});"}
{"instruction": "Create a native UI component wrapper for Android (Java) to expose a simple CustomView to React Native.", "output": "package com.myapp;\n\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport android.view.View;\nimport android.graphics.Color;\n\npublic class CustomViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"RCTCustomView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        View view = new View(context);\n        view.setBackgroundColor(Color.RED); // Simple red box\n        return view;\n    }\n}"}
{"instruction": "Use the Expo Battery API to get the current battery level asynchronously.", "output": "import { useState, useEffect } from 'react';\nimport { Text, View } from 'react-native';\nimport * as Battery from 'expo-battery';\n\nexport default function BatteryLevel() {\n  const [batteryLevel, setBatteryLevel] = useState<number | null>(null);\n\n  useEffect(() => {\n    const fetchBattery = async () => {\n      const level = await Battery.getBatteryLevelAsync();\n      setBatteryLevel(level);\n    };\n\n    fetchBattery();\n    \n    const subscription = Battery.addBatteryLevelListener(({ batteryLevel }) => {\n      setBatteryLevel(batteryLevel);\n    });\n\n    return () => subscription && subscription.remove();\n  }, []);\n\n  return (\n    <View>\n      <Text>Current Battery Level: {batteryLevel ? (batteryLevel * 100).toFixed(0) + '%' : 'Loading...'}</Text>\n    </View>\n  );\n}"}
