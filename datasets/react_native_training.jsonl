{"instruction": "Create a custom Expo Module using the Expo Modules API (Swift) to expose a function that returns the device's system name, and provide the TypeScript usage code.", "output": "// 1. iOS Implementation (MyModule.swift)\nimport ExpoModulesCore\n\npublic class MyModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyModule\")\n\n    Function(\"getSystemName\") { () -> String in\n      return UIDevice.current.systemName\n    }\n  }\n}\n\n// 2. TypeScript Usage (MyModule.ts)\nimport { requireNativeModule } from 'expo-modules-core';\n\ninterface MyModuleInterface {\n  getSystemName(): string;\n}\n\nconst MyModule = requireNativeModule<MyModuleInterface>('MyModule');\n\nexport function getDeviceSystemName(): string {\n  return MyModule.getSystemName();\n}"}
{"instruction": "Implement a Reanimated 3 component where a box fades in when mounted and slides out to the right when unmounted using Layout Animations.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nexport default function AnimatedBox() {\n  const [visible, setVisible] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setVisible(!visible)} />\n      {visible && (\n        <Animated.View\n          entering={FadeIn.duration(500)}\n          exiting={SlideOutRight.duration(500)}\n          style={styles.box}\n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', marginTop: 20 },\n});"}
{"instruction": "Create a draggable View using `react-native-gesture-handler` and `react-native-reanimated` that snaps back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n    })\n    .onFinalize(() => {\n      start.value = { x: 0, y: 0 };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ translateX: offset.value.x }, { translateY: offset.value.y }],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Android Native Module (Java) that creates a method `showToast` to display a native Android Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Write a legacy iOS Native Module (Objective-C) header and implementation that exposes a method to resolve a Promise with the app bundle identifier.", "output": "// AppInfoModule.h\n#import <React/RCTBridgeModule.h>\n@interface AppInfoModule : NSObject <RCTBridgeModule>\n@end\n\n// AppInfoModule.m\n#import \"AppInfoModule.h\"\n\n@implementation AppInfoModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getBundleId:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSString *bundleId = [[NSBundle mainBundle] bundleIdentifier];\n  if (bundleId) {\n    resolve(bundleId);\n  } else {\n    reject(@\"no_bundle_id\", @\"Cannot get bundle identifier\", nil);\n  }\n}\n\n@end"}
{"instruction": "Use Reanimated `runOnUI` to perform a heavy calculation (Fibonacci) on the UI thread to avoid blocking the JS thread, and update the state back on the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalc() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      const value = fibonacci(30); // Heavy calc on UI thread\n      runOnJS(setResult)(value);   // Update React state on JS thread\n    })();\n  };\n\n  return (\n    <View>\n      <Button title=\"Calculate Fib(30)\" onPress={handleCalculation} />\n      <Text>Result: {result}</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a hook using `expo-file-system` to download a remote image to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\nimport { useState } from 'react';\n\nexport const useImageDownloader = () => {\n  const [localUri, setLocalUri] = useState<string | null>(null);\n\n  const downloadImage = async (remoteUrl: string, fileName: string) => {\n    try {\n      const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n      const { uri } = await FileSystem.downloadAsync(remoteUrl, fileUri);\n      setLocalUri(uri);\n    } catch (error) {\n      console.error('Download failed', error);\n    }\n  };\n\n  return { localUri, downloadImage };\n};"}
{"instruction": "Bridge Optimization: Create a TypeScript utility class that batches analytics events and sends them to a native module every 2 seconds (or when 10 events accumulate) to reduce bridge traffic.", "output": "import { NativeModules } from 'react-native';\nconst { AnalyticsModule } = NativeModules;\n\nclass BatchAnalytics {\n  private queue: any[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private readonly BATCH_SIZE = 10;\n  private readonly INTERVAL = 2000;\n\n  logEvent(event: string, data: object) {\n    this.queue.push({ event, data, timestamp: Date.now() });\n\n    if (this.queue.length >= this.BATCH_SIZE) {\n      this.flush();\n    } else if (!this.timer) {\n      this.timer = setTimeout(() => this.flush(), this.INTERVAL);\n    }\n  }\n\n  private flush() {\n    if (this.queue.length === 0) return;\n    \n    const batch = [...this.queue];\n    this.queue = [];\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n\n    // Single bridge call for multiple events\n    AnalyticsModule.trackBatch(batch);\n  }\n}\n\nexport const Analytics = new BatchAnalytics();"}
{"instruction": "Create a Reanimated component that applies a parallax effect to an image based on the device gyroscope sensor data.", "output": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, { useAnimatedSensor, useAnimatedStyle, SensorType, withSpring } from 'react-native-reanimated';\n\nexport default function ParallaxImage() {\n  // Access gyroscope on the UI thread directly\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, { interval: 10 });\n\n  const style = useAnimatedStyle(() => {\n    const { x, y } = animatedSensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(y * 20) }, // Tilt horizontal moves image X\n        { translateY: withSpring(x * 20) }  // Tilt vertical moves image Y\n      ],\n    };\n  });\n\n  return <Animated.Image source={{ uri: 'https://via.placeholder.com/300' }} style={[styles.img, style]} />;\n}\n\nconst styles = StyleSheet.create({\n  img: { width: 300, height: 300, borderRadius: 10 },\n});"}
{"instruction": "Provide the C++ JSI (JavaScript Interface) implementation stub for a Host Function `multiply` that accepts two numbers and returns their product.", "output": "jsi::Function::createFromHostFunction(\n  runtime,\n  jsi::PropNameID::forAscii(runtime, \"multiply\"),\n  2, // Number of arguments\n  [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n    if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n      throw jsi::JSError(runtime, \"multiply expects 2 number arguments\");\n    }\n\n    double result = arguments[0].asNumber() * arguments[1].asNumber();\n    return jsi::Value(result);\n  }\n);"}
{"instruction": "Create a simple Expo Module using the modern Swift API (Expo Modules API) that exposes a function to get the device model name synchronously.", "output": "import ExpoModulesCore\n\npublic class DeviceInfoModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"DeviceInfo\")\n\n    // Expose a synchronous function to JavaScript\n    Function(\"getDeviceModel\") {\n      return UIDevice.current.model\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should spring back to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Native Module in Java (Android) that exposes a method to show a Toast message. Include the ReactMethod annotation.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a TypeScript interface specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method to add two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Use Reanimated's `runOnUI` to offload a heavy synchronous calculation (e.g., Fibonacci) to the UI thread to prevent blocking the JS thread (Bridge optimization technique).", "output": "import { Button, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n) => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      // Calculate fib(35) on UI thread\n      const result = fib(35);\n      console.log(`Calculation result: ${result}`);\n    })();\n  };\n\n  return <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />;\n}"}
{"instruction": "Create a legacy Native Module in Objective-C (iOS) that exports a method to trigger a standard vibration.", "output": "#import \"RCTBridgeModule.h\"\n#import <AudioToolbox/AudioToolbox.h>\n\n@interface VibrationModule : NSObject <RCTBridgeModule>\n@end\n\n@implementation VibrationModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(vibrate) {\n  AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n}\n\n@end"}
{"instruction": "Implement a Reanimated Layout Animation where items in a list Fade In Up when added and Fade Out Down when removed.", "output": "import React, { useState } from 'react';\nimport { View, Button } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          style={{ height: 50, backgroundColor: 'tomato', margin: 5 }}\n        />\n      ))}\n    </View>\n  );\n}"}
{"instruction": "Optimize bridge traffic by using `useAnimatedProps` with Reanimated and `react-native-svg` to animate a circle's radius directly on the UI thread without React re-renders.", "output": "import React, { useEffect } from 'react';\nimport Svg, { Circle } from 'react-native-svg';\nimport Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming } from 'react-native-reanimated';\n\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport default function PulseCircle() {\n  const r = useSharedValue(10);\n\n  useEffect(() => {\n    r.value = withRepeat(withTiming(50, { duration: 1000 }), -1, true);\n  }, []);\n\n  const animatedProps = useAnimatedProps(() => ({\n    r: r.value,\n  }));\n\n  return (\n    <Svg height=\"200\" width=\"200\">\n      <AnimatedCircle cx=\"100\" cy=\"100\" fill=\"purple\" animatedProps={animatedProps} />\n    </Svg>\n  );\n}"}
{"instruction": "Use Expo Sensors (Accelerometer) combined with Reanimated to rotate an image based on device tilt. This demonstrates bridging sensor data to UI thread animations.", "output": "import React, { useEffect } from 'react';\nimport { Image, StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function TiltImage() {\n  const tilt = useSharedValue(0);\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(({ x }) => {\n      // Update shared value directly from sensor callback\n      tilt.value = x;\n    });\n    Accelerometer.setUpdateInterval(16);\n    return () => subscription.remove();\n  }, []);\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ rotate: `${tilt.value * 90}deg` }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image \n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }} \n        style={[styles.img, rStyle]} \n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  img: { width: 100, height: 100 }\n});"}
{"instruction": "Implement a custom Frame Callback using Reanimated's `useFrameCallback` to create a JS-thread independent animation loop (e.g., for a game loop or high-frequency update).", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, useFrameCallback } from 'react-native-reanimated';\n\nexport default function GameLoop() {\n  const x = useSharedValue(0);\n\n  // Runs on every frame on the UI thread\n  useFrameCallback((frameInfo) => {\n    if (!frameInfo.timeSincePreviousFrame) return;\n    // Move 100 pixels per second\n    const delta = (frameInfo.timeSincePreviousFrame / 1000) * 100;\n    x.value = (x.value + delta) % 300;\n  });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: x.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, rStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  box: { width: 50, height: 50, backgroundColor: 'green' }\n});"}
{"instruction": "Create a modern Expo Native Module (Swift) that exposes a function to get the device's battery level.", "output": "import ExpoModulesCore\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeCalculator' to support the New Architecture (Fabric/TurboModules).", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a legacy Android Native Module (Java) that opens the device's specific application settings.", "output": "package com.myapp;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class OpenSettingsModule extends ReactContextBaseJavaModule {\n    OpenSettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"OpenSettings\";\n    }\n\n    @ReactMethod\n    public void open() {\n        Activity currentActivity = getCurrentActivity();\n        if (currentActivity == null) return;\n\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.setData(Uri.parse(\"package:\" + getReactApplicationContext().getPackageName()));\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);\n        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n        \n        currentActivity.startActivity(intent);\n    }\n}"}
{"instruction": "Use Reanimated to create a scroll header that interpolates opacity and height based on the scroll offset.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 200;\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(scrollY.value, [0, HEADER_HEIGHT], [HEADER_HEIGHT, 50], Extrapolation.CLAMP);\n    const opacity = interpolate(scrollY.value, [0, HEADER_HEIGHT / 2], [1, 0], Extrapolation.CLAMP);\n    return { height, opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.text}>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.listItem}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', overflow: 'hidden' },\n  text: { color: 'white', fontSize: 24, fontWeight: 'bold' },\n  listItem: { height: 100, borderBottomWidth: 1, justifyContent: 'center', padding: 20 }\n});"}
{"instruction": "Implement a C++ JSI binding function (conceptually) to expose a synchronous 'fibonacci' function to the JavaScript runtime, bypassing the async bridge.", "output": "// Inside a cpp-adapter.cpp or similar JSI setup file\n\nvoid install(jsi::Runtime& runtime) {\n  auto fibonacci = jsi::Function::createFromHostFunction(\n    runtime,\n    jsi::PropNameID::forAscii(runtime, \"fibonacci\"),\n    1, // argument count\n    [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n      double n = arguments[0].asNumber();\n      // Simple iterative logic for demo\n      if (n <= 1) return n;\n      double a = 0, b = 1, c;\n      for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n      }\n      return jsi::Value(b);\n    }\n  );\n\n  runtime.global().setProperty(runtime, \"fibonacci\", std::move(fibonacci));\n}"}
{"instruction": "Create an Objective-C ViewManager to wrap a native MKMapView for use in React Native.", "output": "#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  MKMapView *map = [[MKMapView alloc] init];\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\nRCT_EXPORT_VIEW_PROPERTY(scrollEnabled, BOOL)\n\n@end"}
{"instruction": "Use Expo FileSystem to download an image to the local cache directory and display it.", "output": "import React, { useEffect, useState } from 'react';\nimport { Image, View } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nexport default function CachedImage({ sourceUrl }: { sourceUrl: string }) {\n  const [localUri, setLocalUri] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fileName = sourceUrl.split('/').pop();\n    const fileUri = FileSystem.cacheDirectory + fileName;\n\n    FileSystem.getInfoAsync(fileUri).then((info) => {\n      if (info.exists) {\n        setLocalUri(fileUri);\n      } else {\n        FileSystem.downloadAsync(sourceUrl, fileUri)\n          .then(({ uri }) => setLocalUri(uri))\n          .catch(e => console.error(e));\n      }\n    });\n  }, [sourceUrl]);\n\n  if (!localUri) return <View style={{ width: 100, height: 100, backgroundColor: '#eee' }} />;\n  return <Image source={{ uri: localUri }} style={{ width: 100, height: 100 }} />;\n}"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [Date.now(), ...prev]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          entering={FadeInUp} \n          exiting={FadeOutDown} \n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, marginTop: 50 },\n  card: { flexDirection: 'row', justifyContent: 'space-between', padding: 20, marginVertical: 5, backgroundColor: '#f9c2ff', borderRadius: 8 }\n});"}
{"instruction": "Optimize a React Native FlatList to reduce bridge traffic and improve performance using 'getItemLayout', 'initialNumToRender', and memoized render items.", "output": "import React, { useCallback, memo } from 'react';\nimport { FlatList, View, Text, StyleSheet } from 'react-native';\n\nconst ITEM_HEIGHT = 80;\n\n// Memoized Item to prevent re-renders if props don't change\nconst ListItem = memo(({ title }: { title: string }) => (\n  <View style={styles.item}>\n    <Text>{title}</Text>\n  </View>\n));\n\nexport default function OptimizedList() {\n  // Generate large data\n  const data = Array.from({ length: 1000 }).map((_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\n  const renderItem = useCallback(({ item }: { item: { title: string } }) => (\n    <ListItem title={item.title} />\n  ), []);\n\n  const getItemLayout = useCallback((_: any, index: number) => (\n    { length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index }\n  ), []);\n\n  const keyExtractor = useCallback((item: { id: string }) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { height: ITEM_HEIGHT, justifyContent: 'center', paddingHorizontal: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Create a React Native component using 'react-native-reanimated' and 'react-native-gesture-handler' that implements a draggable box. The animation logic must run on the UI thread to optimize bridge usage.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      // Logic runs on UI thread, bypassing the bridge for 60fps\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift file for a minimal Expo Module (using the Expo Modules API) that exposes a synchronous function 'getDeviceName' and an asynchronous function 'setValueAsync'.", "output": "import ExpoModulesCore\n\npublic class MyDeviceModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyDeviceModule\")\n\n    // Synchronous function (faster, blocks JS thread slightly but good for simple data)\n    Function(\"getDeviceName\") { () -> String in\n      return UIDevice.current.name\n    }\n\n    // Asynchronous function (Promise-based in JS)\n    AsyncFunction(\"setValueAsync\") { (value: String) in\n      UserDefaults.standard.set(value, forKey: \"my_custom_value\")\n    }\n  }\n}"}
{"instruction": "Create a native Android Java module that exposes a method to show a Toast message. Include the required `getName` and `@ReactMethod` annotations.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule named 'NativeCalculator'. This is part of the New Architecture to ensure type safety and lazy loading of native modules.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous method for high performance\n  add(a: number, b: number): number;\n  \n  // Define async method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 'Layout Animation' to automatically animate items when they are added to or removed from a list, using `Entering` and `Exiting` modifiers.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutLeft } from 'react-native-reanimated';\n\nexport default function ListAnimator() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add\" onPress={addItem} />\n      <Button title=\"Remove\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn.duration(500)}\n          exiting={SlideOutLeft.duration(300)}\n          layout={Layout.springify()}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  item: { width: '90%', height: 50, backgroundColor: 'tomato', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's `runOnUI` to perform a heavy calculation on the UI thread preventing the JS thread from freezing during an animation.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that would block the JS thread if run there\nfunction heavyCalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(input + i);\n  }\n  console.log('Calculation done on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // We call this from JS, but execution happens on the UI thread\n  // This keeps the Bridge free for other React updates\n  runOnUI(heavyCalculation)(42);\n};"}
{"instruction": "Create a custom iOS Native UI Component (View Manager) in Objective-C to expose a simple 'RNTMap' view to JavaScript.", "output": "// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\n// Expose a property to change zoom enabled status\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end"}
{"instruction": "Write a React Native component that uses `useAnimatedScrollHandler` from Reanimated to drive a header's opacity based on scroll position directly on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [0, 1], 'clamp'),\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <Text key={i} style={styles.item}>Item {i}</Text>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 60, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1, justifyContent: 'center', alignItems: 'center' },\n  item: { padding: 20, borderBottomWidth: 1, borderBottomColor: '#ccc' },\n});"}
{"instruction": "Implement an Android Native Module method in Java that sends an event to JavaScript using `DeviceEventManagerModule`. This is useful for push notifications or hardware updates.", "output": "private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {\n    reactContext\n        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n        .emit(eventName, params);\n}\n\n@ReactMethod\npublic void triggerHardwareUpdate() {\n    WritableMap params = Arguments.createMap();\n    params.putString(\"status\", \"active\");\n    params.putDouble(\"battery\", 0.95);\n    sendEvent(getReactApplicationContext(), \"HardwareUpdate\", params);\n}"}
{"instruction": "Use the Expo FileSystem API to download a file to the local cache directory. This demonstrates utilizing the Expo ecosystem for native capabilities without writing native code.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'downloaded_image.jpg';\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    console.log('Finished downloading to ', result?.uri);\n    return result?.uri;\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should follow the user's finger and spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Demonstrate how to create a custom Expo Module definition in TypeScript. Create a module named 'MySettings' that has a synchronous function 'getTheme' and an asynchronous function 'setValueAsync'.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native module\ninterface MySettingsModule {\n  getTheme(): string;\n  setValueAsync(key: string, value: string): Promise<void>;\n}\n\n// Require the native module\n// This assumes the native iOS (Swift) and Android (Kotlin) code is already linked via the Expo Modules API\nconst MySettings = requireNativeModule<MySettingsModule>('MySettings');\n\n// Usage wrapper\nexport const getAppTheme = (): string => {\n  return MySettings.getTheme();\n};\n\nexport const setAppSetting = async (key: string, value: string) => {\n  await MySettings.setValueAsync(key, value);\n};"}
{"instruction": "Implement a high-performance synchronous storage solution using 'react-native-mmkv' to demonstrate Bridge Optimization via JSI (JavaScript Interface), replacing the asynchronous AsyncStorage pattern.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Create a new instance. \n// This bypasses the React Native Bridge by using C++ JSI bindings directly.\nexport const storage = new MMKV({\n  id: 'user-storage',\n  encryptionKey: 'secure-key-example'\n});\n\n// Helper functions\nexport const getUserSession = (): string | undefined => {\n  // Synchronous read (much faster than await AsyncStorage.getItem())\n  return storage.getString('user.session_token');\n};\n\nexport const saveUserSession = (token: string) => {\n  // Synchronous write\n  storage.set('user.session_token', token);\n};\n\nexport const clearSession = () => {\n  storage.delete('user.session_token');\n};"}
{"instruction": "Use React Native Reanimated to run a heavy calculation on the UI thread (using a Worklet) to prevent blocking the JavaScript thread during an animation.", "output": "import React from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n  const result = useSharedValue(0);\n\n  // This function is marked as a 'worklet' to run on the UI thread\n  const heavyTask = (input: number) => {\n    'worklet';\n    let sum = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 5000000; i++) {\n      sum += i * input;\n    }\n    console.log('Calculation done on UI thread');\n    return sum;\n  };\n\n  const handlePress = () => {\n    runOnUI(() => {\n      const calcResult = heavyTask(2);\n      result.value = calcResult;\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};\n"}
{"instruction": "Create a typed interface for a Custom Native UI Component named 'RNCameraView' using `requireNativeComponent`.", "output": "import { requireNativeComponent, ViewProps, HostComponent } from 'react-native';\n\n// Define props expected by the native view\ninterface RNCameraViewProps extends ViewProps {\n  zoomLevel: number;\n  isOn: boolean;\n  onBarcodeScanned?: (event: { nativeEvent: { data: string } }) => void;\n}\n\n// Register the component\n// 'RNCameraView' must match the name returned by the native ViewManager\nconst RNCameraView: HostComponent<RNCameraViewProps> = requireNativeComponent('RNCameraView');\n\nexport default RNCameraView;"}
{"instruction": "Use the Expo FileSystem API to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string, fileName: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Download progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Set up a `NativeEventEmitter` to listen for a specific event sent from a Native Module (e.g., 'HardwareVolumeEvent'). Include cleanup logic.", "output": "import { useEffect } from 'react';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\n// Assume 'VolumeModule' is exposed natively\nconst { VolumeModule } = NativeModules;\n\nexport const useVolumeListener = (callback: (volume: number) => void) => {\n  useEffect(() => {\n    if (!VolumeModule) return;\n\n    const eventEmitter = new NativeEventEmitter(VolumeModule);\n    \n    // Subscribe to the event\n    const subscription = eventEmitter.addListener('HardwareVolumeEvent', (event) => {\n      callback(event.volume);\n    });\n\n    // Cleanup subscription on unmount\n    return () => {\n      subscription.remove();\n    };\n  }, [callback]);\n};"}
{"instruction": "Implement Reanimated Layout Animations to automatically animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport const AnimatedList = () => {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text onPress={() => removeItem(item)}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20 },\n  card: { height: 50, backgroundColor: '#ddd', marginVertical: 5, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Configure a Background Fetch task using Expo's TaskManager and BackgroundFetch APIs to run a periodic job.", "output": "import * as BackgroundFetch from 'expo-background-fetch';\nimport * as TaskManager from 'expo-task-manager';\n\nconst BACKGROUND_TASK_NAME = 'MY_BACKGROUND_TASK';\n\n// 1. Define the task\nTaskManager.defineTask(BACKGROUND_TASK_NAME, async () => {\n  try {\n    const now = new Date();\n    console.log(`Background task running at: ${now.toISOString()}`);\n    // Perform fetch or logic here\n    return BackgroundFetch.BackgroundFetchResult.NewData;\n  } catch (error) {\n    return BackgroundFetch.BackgroundFetchResult.Failed;\n  }\n});\n\n// 2. Register the task (call this in your App initialization)\nexport const registerBackgroundTask = async () => {\n  return BackgroundFetch.registerTaskAsync(BACKGROUND_TASK_NAME, {\n    minimumInterval: 60 * 15, // 15 minutes\n    stopOnTerminate: false, // Android only\n    startOnBoot: true, // Android only\n  });\n};"}
{"instruction": "Optimize a FlatList to reduce bridge traffic and frame drops by implementing `getItemLayout`, `initialNumToRender`, and `maxToRenderPerBatch`.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst ITEM_HEIGHT = 60;\n\ninterface Item { id: string; title: string; }\n\nexport const OptimizedList = ({ data }: { data: Item[] }) => {\n  \n  // Optimizes rendering by skipping measurement calculations on the bridge\n  const getItemLayout = (data: any, index: number) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  const renderItem = ({ item }: { item: Item }) => (\n    <View style={{ height: ITEM_HEIGHT, justifyContent: 'center' }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={(item) => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10} // Render enough to fill the screen initially\n      maxToRenderPerBatch={10} // Limit items rendered per batch to keep JS thread free\n      windowSize={5} // Reduce memory usage by keeping fewer items in memory outside viewport\n      removeClippedSubviews={true} // Unmount views off-screen (Android)\n    />\n  );\n};"}
{"instruction": "Create a React Native Reanimated component using TypeScript that implements a draggable box using `react-native-gesture-handler` and `react-native-reanimated`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nconst DraggableBox = () => {\n  const pressed = useSharedValue<boolean>(false);\n  const offset = useSharedValue<{ x: number; y: number }>({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      pressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.changeX + offset.value.x,\n        y: event.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      pressed.value = false;\n      // Return to origin on release\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n      { scale: withSpring(pressed.value ? 1.2 : 1) },\n    ],\n    backgroundColor: pressed.value ? '#FFE04B' : '#B58DF1',\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.ball, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  ball: { width: 100, height: 100, borderRadius: 50 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a native iOS module (Swift) and the corresponding TypeScript interface to expose a method that returns the device's battery level via a Promise.", "output": "// 1. iOS Swift Code (BatteryModule.swift)\n/*\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level >= 0 {\n      resolve(level)\n    } else {\n      reject(\"BATTERY_ERROR\", \"Unable to determine battery level\", nil)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n*/\n\n// 2. TypeScript Interface (BatteryModule.ts)\nimport { NativeModules } from 'react-native';\n\ninterface BatteryModuleInterface {\n  getBatteryLevel(): Promise<number>;\n}\n\nconst { BatteryModule } = NativeModules;\n\nexport default BatteryModule as BatteryModuleInterface;"}
{"instruction": "Demonstrate bridge optimization by passing a large dataset from JavaScript to a Native Module as a JSON string rather than a JS Object to avoid costly serialization overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { DataProcessor } = NativeModules;\n\n// Inefficient way (Bridge has to serialize deep objects individually)\n// const sendDataInefficiently = (data: ComplexObject[]) => {\n//   DataProcessor.processArray(data);\n// };\n\n// Optimized way\n// By stringifying in JS, we pass a single string across the bridge.\n// The Native side (Java/Obj-C) then parses this string once.\n// This is often faster for large datasets than the RN Bridge serialization.\nconst sendDataOptimized = async (data: any[]) => {\n  try {\n    const jsonString = JSON.stringify(data);\n    const result = await DataProcessor.processJSONString(jsonString);\n    console.log('Processed:', result);\n  } catch (error) {\n    console.error('Bridge error', error);\n  }\n};\n\nexport { sendDataOptimized };"}
{"instruction": "Create an Expo component using `expo-haptics` to trigger different haptic feedback styles based on user interaction.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nconst HapticFeedbackDemo = () => {\n  const triggerSelection = () => {\n    // Light feedback for selection changes\n    Haptics.selectionAsync();\n  };\n\n  const triggerSuccess = () => {\n    // Success notification pattern\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  };\n\n  const triggerImpact = () => {\n    // Heavy physical impact feel\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Selection (Light)\" onPress={triggerSelection} />\n      <View style={styles.spacer} />\n      <Button title=\"Success (Notification)\" onPress={triggerSuccess} />\n      <View style={styles.spacer} />\n      <Button title=\"Heavy Impact\" onPress={triggerImpact} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  spacer: { height: 20 },\n});\n\nexport default HapticFeedbackDemo;"}
{"instruction": "Define a TypeScript specification for a Fabric TurboModule (New Architecture) that includes a method to get a string and a method to calculate a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\n// The interface must extend TurboModule\nexport interface Spec extends TurboModule {\n  // Method returning a simple string\n  getConstants: () => { const1: string };\n  \n  // Method to get a simple string\n  getString(id: string): string;\n\n  // Method performing a calculation\n  addNumbers(a: number, b: number): number;\n}\n\n// Load the module, enforcing the Spec. \n// 'NativeCalculator' is the name used in the C++/Java/Obj-C implementation.\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Implement a Reanimated 'Worklet' to offload a heavy synchronous calculation (like Fibonacci) to the UI thread to prevent blocking the JS thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nconst HeavyCalculationComponent = () => {\n  const [result, setResult] = useState<number | null>(null);\n\n  // This function is marked as a 'worklet' automatically when passed to runOnUI\n  // or defined with 'worklet' directive.\n  const calculateFibonacci = (n: number) => {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return num;\n      return fib(num - 1) + fib(num - 2);\n    };\n    \n    const res = fib(n);\n    \n    // Call back to JS thread to update React state\n    runOnJS(setResult)(res);\n  };\n\n  const handlePress = () => {\n    // Offload to UI thread\n    runOnUI(calculateFibonacci)(35);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Calculating...'}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};\n\nexport default HeavyCalculationComponent;"}
{"instruction": "Write a Native Module for Android (Java) that exposes a method to show a Toast message, and consume it in React Native.", "output": "// 1. Android Java Code (ToastModule.java)\n/*\npackage com.myapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// 2. JavaScript Usage\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\nexport const showToast = (message: string) => {\n  // 0 = SHORT, 1 = LONG (standard Android Toast constants)\n  ToastModule.show(message, 0);\n};"}
{"instruction": "Use Expo's `expo-file-system` to download an image to the local document directory and log the URI.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (imageUrl: string) => {\n  try {\n    const filename = imageUrl.split('/').pop() || 'downloaded.jpg';\n    const fileUri = FileSystem.documentDirectory + filename;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      imageUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n};\n\n// Usage Example\n// downloadImage('https://example.com/image.png');"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on the scroll Y position.", "output": "import React from 'react';\nimport { View, StyleSheet, Text } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nconst ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      \n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={styles.scrollContent}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0, left: 0, right: 0,\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  scrollContent: { paddingTop: 60 },\n  item: { height: 100, borderBottomWidth: 1, justifyContent: 'center', padding: 20 }\n});\n\nexport default ScrollHeader;"}
{"instruction": "Setup a `NativeEventEmitter` in TypeScript to listen for events sent from a Native Module (e.g., a pedometer step counter).", "output": "import { NativeModules, NativeEventEmitter, EmitterSubscription } from 'react-native';\nimport { useEffect } from 'react';\n\n// Assume PedometerModule is linked natively\nconst { PedometerModule } = NativeModules;\n\nconst pedometerEvents = new NativeEventEmitter(PedometerModule);\n\nexport const useStepCounter = () => {\n  useEffect(() => {\n    // Subscribe to event\n    const subscription: EmitterSubscription = pedometerEvents.addListener(\n      'onStepCount',\n      (event: { steps: number }) => {\n        console.log('Steps detected:', event.steps);\n      }\n    );\n\n    // Start the native service if required\n    PedometerModule.startPedometerUpdates();\n\n    return () => {\n      // Cleanup\n      PedometerModule.stopPedometerUpdates();\n      subscription.remove();\n    };\n  }, []);\n};"}
{"instruction": "Create a Swift Native Module (iOS) named 'Counter' that exposes a method 'increment' and 'getCount' to React Native.", "output": "// Counter.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(Counter, NSObject)\nRCT_EXTERN_METHOD(increment)\nRCT_EXTERN_METHOD(getCount: (RCTResponseSenderBlock)callback)\n@end\n\n// Counter.swift\nimport Foundation\n\n@objc(Counter)\nclass Counter: NSObject {\n  private var count = 0\n\n  @objc\n  func increment() {\n    count += 1\n  }\n\n  @objc\n  func getCount(_ callback: RCTResponseSenderBlock) {\n    callback([count])\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Implement a Reanimated 3 scroll handler to animate a header's opacity based on the scroll Y position on the UI thread.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      opacity: interpolate(scrollY.value, [0, 100], [1, 0], Extrapolation.CLAMP),\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 60, backgroundColor: 'red', width: '100%' },\n  content: { height: 1000, backgroundColor: '#eee' }\n});"}
{"instruction": "Create an Android Native Module (Java) to retrieve the device battery level.", "output": "package com.myapp;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n   BatteryModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"BatteryModule\";\n   }\n\n   @ReactMethod\n   public void getBatteryLevel(Promise promise) {\n       try {\n           IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n           Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n           int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n           int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n           float batteryPct = level * 100 / (float)scale;\n           promise.resolve(batteryPct);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeLocalStorage'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  setItem(key: string, value: string): Promise<void>;\n  getItem(key: string): Promise<string | null>;\n  removeItem(key: string): Promise<void>;\n  clear(): Promise<void>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeLocalStorage');"}
{"instruction": "Use Expo FileSystem to download an image from a URL and save it to the app's cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    const downloadRes = await FileSystem.downloadAsync(url, fileUri);\n    \n    if (downloadRes.status === 200) {\n      console.log('Finished downloading to ', downloadRes.uri);\n      return downloadRes.uri;\n    } else {\n      console.error('Download failed');\n      return null;\n    }\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Implement a draggable box using Reanimated 3 and React Native Gesture Handler without triggering JS thread re-renders.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const pan = Gesture.Pan()\n    .onChange((event) => {\n      translateX.value += event.changeX;\n      translateY.value += event.changeY;\n    })\n    .onFinalize(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 10 },\n});"}
{"instruction": "Create an Expo component that uses the Accelerometer sensor to rotate a View based on device tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltView() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    const subscription = Accelerometer.addListener(setData);\n    Accelerometer.setUpdateInterval(100);\n    return () => subscription.remove();\n  }, []);\n\n  const rotation = Math.atan2(y, x) * (180 / Math.PI);\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: `${rotation}deg` }] }]}>\n        <Text>Tilt Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'coral', justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Setup a custom Native UI Component (iOS) named 'RNTMap' to be used in JS via `requireNativeComponent`.", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end\n\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nmodule.exports = requireNativeComponent('RNTMap');"}
{"instruction": "Optimize Bridge communication by using `runOnJS` in Reanimated to only trigger a state update when a threshold is crossed, preventing a flood of events across the bridge.", "output": "import React, { useState } from 'react';\nimport { Text, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedReaction, runOnJS } from 'react-native-reanimated';\n\nexport default function BridgeOptimizer() {\n  const [status, setStatus] = useState('Idle');\n  const progress = useSharedValue(0);\n\n  const handleThreshold = (isActive: boolean) => {\n    // This function runs on the JS thread, but is only called when necessary\n    setStatus(isActive ? 'Active' : 'Idle');\n  };\n\n  useAnimatedReaction(\n    () => progress.value > 0.5, // Worklet: runs on UI thread\n    (isAboveThreshold, previous) => {\n      if (isAboveThreshold !== previous) {\n        // Only cross the bridge when the boolean value changes\n        runOnJS(handleThreshold)(isAboveThreshold);\n      }\n    },\n    [progress]\n  );\n\n  return (\n    <View>\n      <Text>Status: {status}</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a Reanimated Layout Animation for a list item that slides in from the right and fades out upon removal.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { SlideInRight, FadeOut } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={SlideInRight.duration(500)}\n          exiting={FadeOut.duration(300)}\n          style={styles.item}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  item: { height: 50, backgroundColor: 'teal', marginBottom: 10, borderRadius: 8 }\n});"}
{"instruction": "Create a custom React Native hook using Expo's `expo-sensors` and `react-native-reanimated` to animate a View based on the device's accelerometer data. The animation should run on the UI thread to minimize bridge traffic.", "output": "import { useState, useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring, SensorType, useAnimatedSensor } from 'react-native-reanimated';\n\nexport default function AccelerometerAnimation() {\n  // Reanimated 2+ offers useAnimatedSensor which runs directly on the UI thread\n  // bypassing the bridge for every sensor update.\n  const sensor = useAnimatedSensor(SensorType.ACCELEROMETER, { interval: 10 });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const { x, y } = sensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(x * 100) },\n        { translateY: withSpring(y * 100) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a native iOS Swift module (header and implementation) that exposes a method `getDeviceName` to React Native. Then show the TypeScript interface to consume it.", "output": "// DeviceInfo.swift\nimport Foundation\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m (Objective-C Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// DeviceInfo.ts (React Native Usage)\nimport { NativeModules } from 'react-native';\n\nconst { DeviceInfo } = NativeModules;\n\ninterface DeviceInfoInterface {\n  getDeviceName(): Promise<string>;\n}\n\nexport const DeviceInfoModule = DeviceInfo as DeviceInfoInterface;"}
{"instruction": "Implement a draggable box using `react-native-reanimated` and `react-native-gesture-handler`. The solution must run entirely on the UI thread using worklets.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      'worklet'; // Explicitly marking for clarity, though auto-detected\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      'worklet';\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Create a native Android Kotlin module that creates a simple Toast message. Provide the Kotlin code and the React Native TypeScript wrapper.", "output": "// ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName() = \"ToastModule\"\n\n    @ReactMethod\n    fun show(message: String, duration: Int) {\n        Toast.makeText(reactApplicationContext, message, duration).show()\n    }\n\n    override fun getConstants(): MutableMap<String, Any> = hashMapOf(\n        \"SHORT\" to Toast.LENGTH_SHORT,\n        \"LONG\" to Toast.LENGTH_LONG\n    )\n}\n\n// ToastModule.ts\nimport { NativeModules } from 'react-native';\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n  SHORT: number;\n  LONG: number;\n}\n\nconst { ToastModule } = NativeModules;\nexport default ToastModule as ToastInterface;"}
{"instruction": "Demonstrate bridge optimization by implementing a layout animation for a list item removal using `react-native-reanimated` Layout Animations (Entering/Exiting). This avoids imperatively calculating layout on the JS thread.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, Layout, SlideOutRight } from 'react-native-reanimated';\n\nexport default function ListRemover() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (id: number) => {\n    setItems((current) => current.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Animation logic runs on UI thread\n          entering={FadeIn}\n          exiting={SlideOutRight}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item {item}</Text>\n          <Button title=\"Remove\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 50 },\n  card: { \n    height: 50, \n    backgroundColor: '#ddd', \n    marginBottom: 10, \n    flexDirection: 'row', \n    justifyContent: 'space-between', \n    alignItems: 'center', \n    paddingHorizontal: 10 \n  },\n});"}
{"instruction": "Use Expo's `expo-file-system` to download an image from a URL and save it to the local cache directory. Handle the asynchronous nature properly.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string): Promise<string | null> => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Define a TurboModule Specification (New Architecture) in TypeScript for a calculator module that adds two numbers. This is for the codegen to generate C++ bindings.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Using typed definitions allows Codegen to create C++ bindings\n  // reducing bridge overhead compared to legacy modules.\n  add(a: number, b: number): Promise<number>;\n  \n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a high-performance list using `FlashList` (by Shopify) instead of `FlatList` to optimize bridge serialization for large datasets. Include estimated item size.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        // Critical for performance: minimizes layout measurement passes across the bridge\n        estimatedItemSize={50}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    padding: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});\n\nexport default MyList;"}
{"instruction": "Implement a `runOnUI` function using Reanimated to perform a heavy calculation on the UI thread and update a shared value, blocking the JS thread as little as possible.", "output": "import React from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { useSharedValue, runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculation() {\n  const result = useSharedValue(0);\n\n  // This function is defined in JS but will run entirely on the UI thread (C++)\n  const heavyTask = () => {\n    'worklet';\n    let sum = 0;\n    // Simulate heavy work\n    for (let i = 0; i < 10000000; i++) {\n      sum += i;\n    }\n    result.value = sum;\n    console.log('Calculation done on UI thread:', sum);\n  };\n\n  const handlePress = () => {\n    // Offload to UI thread to keep JS thread responsive for other logic\n    runOnUI(heavyTask)();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native UI Component manager for iOS (Objective-C) to expose a native `UIView` with a specific background color property to React Native.", "output": "// RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\n// Expose the 'color' prop. \n// When JS changes this prop, the setter on the native view is called.\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// ColorView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTColorView'\nmodule.exports = requireNativeComponent('RNTColorView');"}
{"instruction": "Create a custom React Native hook using Expo APIs (expo-file-system and expo-sharing) to download an image from a URL to the local cache and immediately invoke the system share dialog.", "output": "import * as FileSystem from 'expo-file-system';\nimport * as Sharing from 'expo-sharing';\nimport { useState } from 'react';\nimport { Alert } from 'react-native';\n\nexport const useDownloadAndShare = () => {\n  const [loading, setLoading] = useState(false);\n\n  const downloadAndShare = async (url: string, fileName: string) => {\n    try {\n      setLoading(true);\n      const result = await FileSystem.downloadAsync(\n        url,\n        FileSystem.cacheDirectory + fileName\n      );\n\n      if (!(await Sharing.isAvailableAsync())) {\n        Alert.alert('Error', 'Sharing is not available on this device');\n        return;\n      }\n\n      await Sharing.shareAsync(result.uri);\n    } catch (error) {\n      console.error(error);\n      Alert.alert('Error', 'Failed to download or share file');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return { downloadAndShare, loading };\n};"}
{"instruction": "Implement a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a basic Android Native Module in Java that exposes a method to get the device's battery level. Include the ReactMethod annotation and the Promise handling.", "output": "package com.myapp;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n            \n            int level = batteryStatus != null ? batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) : -1;\n            int scale = batteryStatus != null ? batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1) : -1;\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Demonstrate Bridge Optimization by creating a Swift Native Module method that accepts an array of strings to process in a single batch, rather than calling the native method multiple times from JavaScript.", "output": "@objc(DataProcessor)\nclass DataProcessor: NSObject {\n  \n  @objc\n  func processBatch(_ data: [String], resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    // Optimization: Processing N items in one bridge call instead of N calls\n    let processedData = data.map { $0.uppercased() }\n    \n    // Simulate heavy work or DB insertion here\n    \n    resolve(processedData)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a synchronous method 'add'.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous execution is a key feature of JSI/TurboModules\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Use React Native Reanimated to offload a heavy calculation (e.g., Fibonacci) to the UI thread using a worklet to prevent blocking the JavaScript thread.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n  \n  // This function is marked as a worklet to run on the UI thread\n  const heavyWorklet = (n: number) => {\n    'worklet';\n    const fib = (num: number): number => {\n      if (num <= 1) return 1;\n      return fib(num - 1) + fib(num - 2);\n    };\n    const result = fib(n);\n    console.log(`Fibonacci result on UI Thread: ${result}`);\n  };\n\n  const handlePress = () => {\n    // Dispatch work to UI thread\n    runOnUI(heavyWorklet)(35);\n  };\n\n  return (\n    <View>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handlePress} />\n    </View>\n  );\n};"}
{"instruction": "Implement a parallax scroll effect using Reanimated 3, where a header image translates at half the speed of the scroll view.", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate } from 'react-native-reanimated';\nimport { StyleSheet, View, Dimensions } from 'react-native';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport const ParallaxHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75]),\n        },\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [2, 1, 1]),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/600x400' }}\n        style={[styles.image, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Content goes here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: width, height: IMG_HEIGHT, position: 'absolute' },\n  content: { paddingTop: IMG_HEIGHT, height: 1000, backgroundColor: 'white' },\n});"}
{"instruction": "Create a C++ JSI binding setup (conceptual code) to expose a synchronous global function 'nativeMultiply' to JavaScript. This avoids the asynchronous bridge.", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\n\nvoid install(Runtime &jsiRuntime) {\n  auto multiply = Function::createFromHostFunction(\n      jsiRuntime,\n      PropNameID::forAscii(jsiRuntime, \"nativeMultiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          if (count < 2) return Value::undefined();\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n      }\n  );\n\n  jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", multiply);\n}"}
{"instruction": "Use Expo Sensors (Accelerometer) to create a custom hook that returns the device's current tilt (x, y, z) with a configurable update interval.", "output": "import { useState, useEffect } from 'react';\nimport { Accelerometer } from 'expo-sensors';\n\ninterface AccelerometerData {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport const useDeviceTilt = (interval: number = 100) => {\n  const [data, setData] = useState<AccelerometerData>({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(interval);\n\n    const subscription = Accelerometer.addListener(accelerometerData => {\n      setData(accelerometerData);\n    });\n\n    return () => subscription && subscription.remove();\n  }, [interval]);\n\n  return data;\n};\n"}
{"instruction": "Write an iOS Native Module (Swift) to trigger Haptic Feedback using UIImpactFeedbackGenerator, exposed to React Native.", "output": "import Foundation\nimport UIKit\n\n@objc(HapticFeedback)\nclass HapticFeedback: NSObject {\n\n  @objc\n  func trigger(_ style: String) {\n    DispatchQueue.main.async {\n      let feedbackStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      \n      switch style {\n      case \"light\": feedbackStyle = .light\n      case \"medium\": feedbackStyle = .medium\n      case \"heavy\": feedbackStyle = .heavy\n      default: feedbackStyle = .medium\n      }\n      \n      let generator = UIImpactFeedbackGenerator(style: feedbackStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Create a custom Expo Native Module in Swift that exposes a function to get the device's system name. Include the TypeScript definition.", "output": "// 1. ios/MyDeviceModule.swift\nimport ExpoModulesCore\n\npublic class MyDeviceModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MyDevice\")\n\n    Function(\"getSystemName\") { () -> String in\n      return UIDevice.current.systemName\n    }\n  }\n}\n\n// 2. index.ts\nimport { requireNativeModule } from 'expo-modules-core';\n\n// It loads the native module object from the JSI or falls back to the bridge\nconst MyDevice = requireNativeModule('MyDevice');\n\nexport function getSystemName(): string {\n  return MyDevice.getSystemName();\n}"}
{"instruction": "Implement a drag-and-drop interaction using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.changeX + offset.value.x,\n        y: event.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      // Return to origin on release\n      offset.value = withSpring({ x: 0, y: 0 });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native/Libraries/TurboModule/RCTExport';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the arithmetic method\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  getConstants(): {|\n    const1: boolean;\n  |};\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a simple Android Native Module in Kotlin that exposes a 'showToast' method to React Native.", "output": "package com.myapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String, duration: Int) {\n        val toastDuration = if (duration == 0) Toast.LENGTH_SHORT else Toast.LENGTH_LONG\n        Toast.makeText(reactApplicationContext, message, toastDuration).show()\n    }\n}"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's 'runOnJS' to call a JavaScript function from the UI thread only when an animation finishes, preventing excessive bridge traffic.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport Animated, { useSharedValue, withTiming, runOnJS } from 'react-native-reanimated';\n\nexport default function OptimizationExample() {\n  const opacity = useSharedValue(0);\n\n  // This function runs on the JavaScript thread\n  const onAnimationFinished = (finished: boolean) => {\n    if (finished) {\n      console.log('Animation finished! JS thread notified.');\n      // Perform JS-heavy logic here (e.g., API calls, state updates)\n    }\n  };\n\n  const startFade = () => {\n    opacity.value = withTiming(1, { duration: 1000 }, (finished) => {\n      // 'finished' callback runs on UI thread.\n      // We invoke runOnJS to cross the bridge explicitly only once.\n      if (finished) {\n        runOnJS(onAnimationFinished)(true);\n      }\n    });\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Animated.View style={{ opacity, width: 100, height: 100, backgroundColor: 'red' }} />\n      <Button title=\"Fade In\" onPress={startFade} />\n    </View>\n  );\n}"}
{"instruction": "Implement an iOS Native Module header and implementation in Objective-C that exports a method to resolve a promise with a random number.", "output": "// RCTRandomNumber.h\n#import <React/RCTBridgeModule.h>\n@interface RCTRandomNumber : NSObject <RCTBridgeModule>\n@end\n\n// RCTRandomNumber.m\n#import \"RCTRandomNumber.h\"\n\n@implementation RCTRandomNumber\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(generate:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSNumber *randomNumber = @(arc4random_uniform(100));\n  resolve(randomNumber);\n}\n\n@end"}
{"instruction": "Use Reanimated to create a sensor-based animation where an image moves based on the device's gyroscope data.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function GyroScopeParallax() {\n  // Initialize the gyroscope sensor\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, {\n    interval: 10, // Update every 10ms\n  });\n\n  const style = useAnimatedStyle(() => {\n    const { x, y } = animatedSensor.sensor.value;\n    return {\n      transform: [\n        { translateX: withSpring(y * 50) }, // Map rotation Y to translation X\n        { translateY: withSpring(x * 50) }, // Map rotation X to translation Y\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, style]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Write a utility function using Expo FileSystem to download an image to the local cache, optimizing performance by avoiding passing base64 strings over the bridge.", "output": "import * as FileSystem from 'expo-file-system';\n\n/**\n * Downloads a file directly to the native file system.\n * This avoids serializing the file data across the JS bridge (base64),\n * which significantly reduces memory usage and frame drops.\n */\nexport const cacheImage = async (remoteUrl: string, fileName: string): Promise<string> => {\n  const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n  \n  try {\n    const { uri } = await FileSystem.downloadAsync(\n      remoteUrl,\n      fileUri\n    );\n    return uri; // Return the local file URI to be used in <Image source={{ uri }} />\n  } catch (e) {\n    console.error('Download failed', e);\n    throw e;\n  }\n};"}
{"instruction": "Implement a Reanimated Layout Animation to automatically animate list items appearing and disappearing without complex state management.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      \n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          // Enter animation: Fades in and moves up\n          entering={FadeInUp}\n          // Exit animation: Fades out and moves down\n          exiting={FadeOutDown}\n          // Layout transition: Smoothly moves other items when one is removed\n          layout={Layout.springify()}\n          style={styles.card}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', marginBottom: 20, gap: 10 },\n  card: { width: 300, height: 50, backgroundColor: '#4CAF50', marginVertical: 5, borderRadius: 8 },\n});"}
{"instruction": "Register a custom Native View Manager in Android (Java) to expose a simple TextView to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        TextView textView = new TextView(reactContext);\n        textView.setTextColor(Color.BLACK);\n        return textView;\n    }\n\n    // Expose a property 'text' to JS\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Create a React Native Native Module interface in TypeScript and the corresponding Android Java code to show a native Toast message. This demonstrates the basic Bridge architecture.", "output": "// 1. ToastModule.ts\nimport { NativeModules } from 'react-native';\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\nconst { ToastModule } = NativeModules;\nexport default ToastModule as ToastInterface;\n\n// 2. ToastModule.java (Android)\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler. The box should use spring physics when released to return to its original position.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use the modern Expo Modules API (Kotlin) to create a simple native function that returns the device name synchronously. This avoids the asynchronous nature of the legacy bridge.", "output": "// 1. DeviceNameModule.kt (android/src/main/java/...)\npackage expo.modules.devicename\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\nimport android.os.Build\n\nclass DeviceNameModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceName\")\n\n    // Synchronous function accessible from JS\n    Function(\"getDeviceName\") {\n      return@Function \"${Build.MANUFACTURER} ${Build.MODEL}\"\n    }\n  }\n}\n\n// 2. index.ts (JavaScript usage)\nimport { requireNativeModule } from 'expo-modules-core';\n\nconst DeviceName = requireNativeModule('DeviceName');\n\nexport function getDeviceName(): string {\n  return DeviceName.getDeviceName();\n}"}
{"instruction": "Optimize Bridge performance by offloading a heavy calculation (e.g., Fibonacci) to the UI thread using a Reanimated Worklet, preventing the JS thread from dropping frames.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcOptimization() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      // Calculate heavy task on UI thread\n      const value = fib(35);\n      \n      // Return result to JS thread\n      runOnJS(setResult)(value);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Task (UI Thread)\" onPress={handleCalculation} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom iOS Native UI Component (a simple colored View) and expose it to React Native using `requireNativeComponent`.", "output": "// 1. RNTColorViewManager.m (iOS)\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\nRCT_EXPORT_MODULE(RNTColorView)\nRCT_EXPORT_VIEW_PROPERTY(color, NSString)\n\n- (UIView *)view {\n  return [[UIView alloc] init];\n}\n@end\n\n// 2. ColorView.tsx (React Native)\nimport React from 'react';\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface NativeProps extends ViewProps {\n  color: string;\n}\n\nconst RNTColorView = requireNativeComponent<NativeProps>('RNTColorView');\n\nexport const ColorView = (props: NativeProps) => {\n  return <RNTColorView {...props} style={props.style} />;\n};"}
{"instruction": "Implement a Reanimated ScrollView where the header image scales up (parallax effect) when the user scrolls down (pulls down).", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedRef, useAnimatedScrollHandler, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxHeader() {\n  const scrollRef = useAnimatedRef<Animated.ScrollView>();\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler(event => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0], [2, 1], Extrapolation.CLAMP),\n        },\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0], [-IMG_HEIGHT / 2, 0], Extrapolation.CLAMP),\n        }\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.ScrollView ref={scrollRef} onScroll={scrollHandler} scrollEventThrottle={16}>\n        <Animated.Image \n          source={{ uri: 'https://via.placeholder.com/300' }} \n          style={[styles.image, imageStyle]} \n        />\n        <View style={{ height: 1000, backgroundColor: 'white' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: '100%', resizeMode: 'cover' },\n});"}
{"instruction": "Use the Expo SecureStore API to securely save and retrieve an authentication token, demonstrating how to handle sensitive data in React Native.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const AuthService = {\n  async saveToken(token: string) {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n      console.log('Token saved securely');\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  async getToken(): Promise<string | null> {\n    try {\n      return await SecureStore.getItemAsync(KEY);\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  async deleteToken() {\n    try {\n      await SecureStore.deleteItemAsync(KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  }\n};"}
{"instruction": "Define a TurboModule specification (New Architecture) in TypeScript. This is the first step in creating a C++ backed module that uses JSI.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Spec file: NativeCalculator.ts\nexport interface Spec extends TurboModule {\n  // Define synchronous methods supported by JSI\n  add(a: number, b: number): number;\n  \n  // Define async methods\n  promiseAdd(a: number, b: number): Promise<number>;\n}\n\n// Get the module. \n// 'Calculator' must match the name in the C++/Java/Obj-C implementation.\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Implement a Reanimated Layout Animation to automatically animate list items appearing and disappearing without manually managing interpolation values.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<number[]>([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter(i => i !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp.duration(500)}\n          exiting={FadeOutDown.duration(500)}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item ID: {item}</Text>\n          <Button title=\"Remove\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  card: { padding: 20, marginVertical: 10, backgroundColor: '#f0f0f0', borderRadius: 8 }\n});"}
{"instruction": "Utilize `InteractionManager` to optimize bridge traffic by deferring a heavy state update until after a navigation animation or interaction completes.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function HeavyScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Defer execution until animations/interactions are done\n    // This prevents frame drops during screen transitions\n    const interactionPromise = InteractionManager.runAfterInteractions(() => {\n      setIsReady(true);\n      // Perform heavy data fetching or complex rendering prep here\n    });\n\n    return () => interactionPromise.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n        <Text>Waiting for bridge/animations...</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Text>Heavy UI Loaded Safely</Text>\n    </View>\n  );\n}"}
{"instruction": "Create a Native Module in iOS using Swift that exposes a method to get the device's real name, handling the Objective-C bridging.", "output": "// 1. DeviceName.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceName)\nclass DeviceName: NSObject {\n  @objc func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    let name = UIDevice.current.name\n    resolve(name)\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. DeviceName.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceName, NSObject)\nRCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// 3. Usage in TypeScript\nimport { NativeModules } from 'react-native';\nconst { DeviceName } = NativeModules;\n\nexport const getDeviceName = async (): Promise<string> => {\n  return await DeviceName.getDeviceName();\n};"}
{"instruction": "Implement a draggable box using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Native Module in Android using Java that opens the specific application settings page.", "output": "// 1. OpenSettingsModule.java\npackage com.myapp;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Settings;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class OpenSettingsModule extends ReactContextBaseJavaModule {\n    OpenSettingsModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"OpenSettings\";\n    }\n\n    @ReactMethod\n    public void open() {\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        Uri uri = Uri.fromParts(\"package\", getReactApplicationContext().getPackageName(), null);\n        intent.setData(uri);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        getReactApplicationContext().startActivity(intent);\n    }\n}\n\n// 2. Usage in JS\nimport { NativeModules } from 'react-native';\nconst { OpenSettings } = NativeModules;\n\n// Call OpenSettings.open() to trigger."}
{"instruction": "Define a TurboModule specification (TypeScript) for the New Architecture to create a synchronous calculator module.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition\n  add(a: number, b: number): number;\n  \n  // Asynchronous method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a custom Expo Module using the modern Expo Modules API (Kotlin) that returns a simple string value synchronously.", "output": "// AsyncFunction is standard, but Function allows synchronous return in Expo Modules API\npackage expo.modules.custom\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass CustomModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"CustomModule\")\n\n    // Defines a synchronous function\n    Function(\"hello\") { name: String ->\n      \"Hello, $name!\"\n    }\n  }\n}\n\n// JavaScript Usage:\n// import { requireNativeModule } from 'expo-modules-core';\n// const CustomModule = requireNativeModule('CustomModule');\n// console.log(CustomModule.hello('World')); // Output: \"Hello, World!\""}
{"instruction": "Implement a C++ JSI (JavaScript Interface) installer function to expose a high-performance native method `nativeMultiply` directly to the JS runtime, bypassing the bridge.", "output": "// cpp-adapter.cpp\n#include <jni.h>\n#include <jsi/jsi.h>\n#include \"example.h\"\n\nusing namespace facebook;\n\nvoid install(jsi::Runtime& jsiRuntime) {\n    auto nativeMultiply = jsi::Function::createFromHostFunction(\n        jsiRuntime,\n        jsi::PropNameID::forAscii(jsiRuntime, \"nativeMultiply\"),\n        2, // argument count\n        [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n            double a = arguments[0].asNumber();\n            double b = arguments[1].asNumber();\n            return jsi::Value(a * b);\n        }\n    );\n\n    jsiRuntime.global().setProperty(jsiRuntime, \"nativeMultiply\", std::move(nativeMultiply));\n}"}
{"instruction": "Use Reanimated Worklets to offload a heavy calculation (Fibonacci) to the UI thread to prevent blocking the JavaScript thread.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyTask() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const handleCalculation = () => {\n    runOnUI(() => {\n      // This runs on the UI thread (separate from JS thread)\n      const heavyResult = fibonacci(35);\n      \n      // Pass result back to JS thread to update state\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View>\n      <Button title=\"Run Heavy Task\" onPress={handleCalculation} />\n      <Text>Result: {result}</Text>\n    </View>\n  );\n}"}
{"instruction": "Wrap a native iOS UIView (e.g., a colored view) into a React Native component using RCTViewManager.", "output": "// 1. RNTColorViewManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTColorViewManager : RCTViewManager\n@end\n\n@implementation RNTColorViewManager\n\nRCT_EXPORT_MODULE(RNTColorView)\n\n- (UIView *)view\n{\n  return [[UIView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(backgroundColor, UIColor)\n\n@end\n\n// 2. ColorView.tsx\nimport { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface ColorViewProps extends ViewProps {\n  backgroundColor?: string;\n}\n\nconst RNTColorView = requireNativeComponent<ColorViewProps>('RNTColorView');\n\nexport default RNTColorView;"}
{"instruction": "Implement a scroll-driven animation using Reanimated where a header's opacity changes based on the ScrollView's offset.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { height: 60, backgroundColor: 'red', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  content: { height: 1000, backgroundColor: '#eee' }\n});"}
{"instruction": "Optimize a FlatList by implementing `getItemLayout` to skip measurement calculations, reducing bridge traffic during scroll.", "output": "import React from 'react';\nimport { FlatList, Text, View } from 'react-native';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\nconst ITEM_HEIGHT = 50;\n\nconst OptimizedList = () => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: ITEM_HEIGHT, justifyContent: 'center' }}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n\n  // Optimization: Allows RN to calculate layout without measuring every item\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n\n  return (\n    <FlatList\n      data={DATA}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nexport default OptimizedList;"}
{"instruction": "Create a basic iOS Native Module using Swift that exposes a method `getDeviceName` to React Native. The method should return the device name via a Promise. Include the Objective-C bridging header export.", "output": "// DeviceModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceModule)\nclass DeviceModule: NSObject {\n  \n  @objc(getDeviceName:rejecter:)\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceModule.m (Objective-C Export)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a simple Android Native Module using Kotlin that exposes a `showToast` method. This method takes a string message and displays a short Android Toast.", "output": "// ToastModule.kt\npackage com.yourapp\n\nimport android.widget.Toast\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass ToastModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"ToastModule\"\n    }\n\n    @ReactMethod\n    fun showToast(message: String) {\n        val toast = Toast.makeText(reactApplicationContext, message, Toast.LENGTH_SHORT)\n        toast.show()\n    }\n}"}
{"instruction": "Implement a draggable box component using `react-native-reanimated` (v3) and `react-native-gesture-handler`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const pan = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Use `expo-secure-store` to create a TypeScript utility object with methods to safely save, retrieve, and delete a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst TOKEN_KEY = 'user_auth_token';\n\nexport const AuthStorage = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(TOKEN_KEY, token);\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    try {\n      await SecureStore.deleteItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  },\n};"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named `NativeCalculator`. It should support a synchronous `add` method.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // TurboModules allow synchronous execution if defined in the spec\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Demonstrate bridge optimization by using Reanimated's `runOnUI` to execute a heavy calculation synchronously on the UI thread without blocking the JS thread, triggered by a button press.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nfunction heavyCalculationUI(input: number) {\n  'worklet';\n  // This runs on the UI thread via JSI, bypassing the async bridge\n  const result = Math.pow(input, 50); \n  console.log('Calculation result on UI Thread:', result);\n}\n\nexport default function BridgeOptimizationExample() {\n  const handlePress = () => {\n    // Dispatch work to UI thread immediately\n    runOnUI(heavyCalculationUI)(100);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy UI Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a Reanimated component that uses Layout Animations to fade and slide in a list item when it mounts (`Entering`).", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInLeft, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState<string[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, `Item ${prev.length + 1}`]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <View style={styles.list}>\n        {items.map((item, index) => (\n          <Animated.View \n            key={index} \n            entering={FadeInLeft.delay(index * 100).springify()} \n            layout={Layout.springify()}\n            style={styles.card}\n          >\n            <Text style={styles.text}>{item}</Text>\n          </Animated.View>\n        ))}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  list: { marginTop: 20 },\n  card: { height: 50, backgroundColor: '#4CAF50', marginBottom: 10, justifyContent: 'center', paddingLeft: 15, borderRadius: 8 },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write an Expo component using `expo-camera` (modern `CameraView`) to display a camera preview and a button to toggle the facing mode.", "output": "import { CameraView, useCameraPermissions, CameraType } from 'expo-camera';\nimport { useState } from 'react';\nimport { Button, StyleSheet, Text, View, TouchableOpacity } from 'react-native';\n\nexport default function App() {\n  const [facing, setFacing] = useState<CameraType>('back');\n  const [permission, requestPermission] = useCameraPermissions();\n\n  if (!permission) return <View />;\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  function toggleCameraFacing() {\n    setFacing(current => (current === 'back' ? 'front' : 'back'));\n  }\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} facing={facing}>\n        <View style={styles.buttonContainer}>\n          <TouchableOpacity style={styles.button} onPress={toggleCameraFacing}>\n            <Text style={styles.text}>Flip Camera</Text>\n          </TouchableOpacity>\n        </View>\n      </CameraView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: { flex: 1, flexDirection: 'row', backgroundColor: 'transparent', margin: 64 },\n  button: { flex: 1, alignSelf: 'flex-end', alignItems: 'center' },\n  text: { fontSize: 24, fontWeight: 'bold', color: 'white' },\n});"}
{"instruction": "Expose a native iOS `UIView` (colored red) as a component named `RNTMap` using the Bridge architecture (requireNativeComponent).", "output": "// RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  UIView *view = [[UIView alloc] init];\n  view.backgroundColor = [UIColor redColor];\n  return view;\n}\n\n@end\n\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nmodule.exports = requireNativeComponent('RNTMap');"}
{"instruction": "Optimize a large list rendering using `FlashList` (from Shopify) to improve performance over `FlatList`. Create a simple component rendering 1000 items.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nexport default function OptimizedList() {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});"}
{"instruction": "Create a draggable box component using 'react-native-reanimated' and 'react-native-gesture-handler' that runs on the UI thread to optimize bridge usage.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      // Runs on UI thread, no bridge crossing per frame\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      // Spring back to start\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a basic Android Native Module in Java that exposes a method to show a native Toast message.", "output": "package com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to React Native: NativeModules.ToastModule\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Create a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes an 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the function signature\n  add(a: number, b: number): Promise<number>;\n}\n\n// Load the module; 'NativeCalculator' must match the native name\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Use Expo's 'expo-file-system' to create a function that writes a text string to a file in the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const saveFile = async (filename: string, content: string): Promise<void> => {\n  const fileUri = FileSystem.documentDirectory + filename;\n  try {\n    await FileSystem.writeAsStringAsync(fileUri, content, {\n      encoding: FileSystem.EncodingType.UTF8,\n    });\n    console.log('File saved to:', fileUri);\n  } catch (error) {\n    console.error('Error saving file:', error);\n  }\n};"}
{"instruction": "Implement a Reanimated 'worklet' to offload a heavy calculation (e.g., Fibonacci) to the UI thread, ensuring the JS thread remains responsive.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  // This function is defined in JS but marked as worklet to run on UI thread\n  const heavyTask = () => {\n    'worklet';\n    const fib = (n) => {\n      if (n <= 1) return n;\n      return fib(n - 1) + fib(n - 2);\n    };\n    const result = fib(35); // Heavy calculation\n    console.log(`Calculation finished on UI thread: ${result}`);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button \n        title=\"Run Heavy Task on UI Thread\"\n        onPress={() => runOnUI(heavyTask)()} \n      />\n    </View>\n  );\n}"}
{"instruction": "Create a simple iOS Native Module in Swift (with Obj-C bridging header assumed) that exposes a function to get the device name.", "output": "// DeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfo)\nclass DeviceInfo: NSObject {\n  \n  @objc\n  func getDeviceName(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// DeviceInfo.m (Obj-C Export)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(DeviceInfo, NSObject)\n// RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n// @end"}
{"instruction": "Use 'react-native-reanimated' `useAnimatedProps` to animate the radius of an SVG Circle directly on the UI thread (requires react-native-svg).", "output": "import React, { useEffect } from 'react';\nimport Svg, { Circle } from 'react-native-svg';\nimport Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming } from 'react-native-reanimated';\n\n// Create an animated component from the SVG Circle\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport default function PulsingCircle() {\n  const r = useSharedValue(10);\n\n  useEffect(() => {\n    // Animate radius from 10 to 50 repeatedly\n    r.value = withRepeat(withTiming(50, { duration: 1000 }), -1, true);\n  }, []);\n\n  // Map shared value to props. Runs on UI thread.\n  const animatedProps = useAnimatedProps(() => ({\n    r: r.value,\n  }));\n\n  return (\n    <Svg height=\"200\" width=\"200\">\n      <AnimatedCircle \n        cx=\"100\" \n        cy=\"100\" \n        fill=\"red\" \n        animatedProps={animatedProps} \n      />\n    </Svg>\n  );\n}"}
{"instruction": "Implement an Expo 'BarCodeScanner' component to scan QR codes using 'expo-camera'.", "output": "import React, { useState, useEffect } from 'react';\nimport { Text, View, StyleSheet, Button } from 'react-native';\nimport { CameraView, Camera } from 'expo-camera';\n\nexport default function QRScanner() {\n  const [hasPermission, setHasPermission] = useState<boolean | null>(null);\n  const [scanned, setScanned] = useState(false);\n\n  useEffect(() => {\n    (async () => {\n      const { status } = await Camera.requestCameraPermissionsAsync();\n      setHasPermission(status === 'granted');\n    })();\n  }, []);\n\n  const handleBarCodeScanned = ({ type, data }: { type: string; data: string }) => {\n    setScanned(true);\n    alert(`Bar code with type ${type} and data ${data} has been scanned!`);\n  };\n\n  if (hasPermission === null) return <Text>Requesting for camera permission</Text>;\n  if (hasPermission === false) return <Text>No access to camera</Text>;\n\n  return (\n    <View style={StyleSheet.absoluteFillObject}>\n      <CameraView\n        onBarcodeScanned={scanned ? undefined : handleBarCodeScanned}\n        barcodeScannerSettings={{ barcodeTypes: ['qr'] }}\n        style={StyleSheet.absoluteFillObject}\n      />\n      {scanned && <Button title={'Tap to Scan Again'} onPress={() => setScanned(false)} />}\n    </View>\n  );\n}"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on scroll position.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100], // Input range\n      [0, 1],   // Output range\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#f0f0f0' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { height: 80, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', position: 'absolute', top: 0, left: 0, right: 0, zIndex: 1 },\n  headerText: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Use 'expo-haptics' to trigger a tactile feedback when a user presses a button.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Triggers a light impact feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Haptic feedback triggered');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that creates a draggable box. Use the 'react-native-gesture-handler' library to handle the Pan gesture and update the X and Y coordinates of the box smoothly on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Spring back to center on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a native Android Java module for React Native that exposes a method 'getDeviceName' which returns the device model name via a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                promise.resolve(capitalize(model));\n            } else {\n                promise.resolve(capitalize(manufacturer) + \" \" + model);\n            }\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n\n    private String capitalize(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        char first = s.charAt(0);\n        if (Character.isUpperCase(first)) return s;\n        return Character.toUpperCase(first) + s.substring(1);\n    }\n}"}
{"instruction": "Using Expo, create a function that requests biometric authentication (FaceID/TouchID) using 'expo-local-authentication' and returns a boolean indicating success.", "output": "import * as LocalAuthentication from 'expo-local-authentication';\n\nexport const authenticateUser = async (): Promise<boolean> => {\n  try {\n    const hasHardware = await LocalAuthentication.hasHardwareAsync();\n    if (!hasHardware) return false;\n\n    const isEnrolled = await LocalAuthentication.isEnrolledAsync();\n    if (!isEnrolled) return false;\n\n    const result = await LocalAuthentication.authenticateAsync({\n      promptMessage: 'Authenticate to continue',\n      fallbackLabel: 'Use Passcode',\n    });\n\n    return result.success;\n  } catch (error) {\n    console.error('Biometric Auth Error:', error);\n    return false;\n  }\n};"}
{"instruction": "Implement a 'Collapsible Header' using 'react-native-reanimated'. The header should fade out and translate upwards as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nconst CollapsibleHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const translateY = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, -100],\n      Extrapolation.CLAMP\n    );\n    \n    const opacity = interpolate(\n      scrollY.value,\n      [0, 80],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n\n    return {\n      transform: [{ translateY }],\n      opacity,\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>My Header</Text>\n      </Animated.View>\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={styles.scrollContent}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}>\n            <Text>Item {i + 1}</Text>\n          </View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 100,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontSize: 20, fontWeight: 'bold' },\n  scrollContent: { paddingTop: 100 },\n  item: { height: 80, borderBottomWidth: 1, borderColor: '#ccc', justifyContent: 'center', padding: 20 },\n});\n\nexport default CollapsibleHeader;"}
{"instruction": "Demonstrate bridge optimization by using 'react-native-mmkv' (which uses JSI) instead of 'AsyncStorage' to synchronously read and write a user object.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize MMKV instance\nexport const storage = new MMKV();\n\ninterface User {\n  id: string;\n  name: string;\n  preferences: { theme: 'dark' | 'light' };\n}\n\n// JSI allows synchronous execution, avoiding the async bridge serialization overhead\nexport const saveUser = (user: User) => {\n  storage.set('user_session', JSON.stringify(user));\n};\n\nexport const getUser = (): User | null => {\n  const userJson = storage.getString('user_session');\n  if (userJson) {\n    return JSON.parse(userJson);\n  }\n  return null;\n};\n\nexport const deleteUser = () => {\n  storage.delete('user_session');\n};"}
{"instruction": "Create a simple Native Module in Swift (iOS) that creates a system alert dialog. Include the Objective-C bridge macro export.", "output": "// AlertModule.swift\nimport Foundation\nimport UIKit\n\n@objc(AlertModule)\nclass AlertModule: NSObject {\n  \n  @objc(showAlert:message:)\n  func showAlert(_ title: String, message: String) {\n    DispatchQueue.main.async {\n      let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)\n      alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))\n      \n      if let rootVC = UIApplication.shared.windows.first?.rootViewController {\n        rootVC.present(alert, animated: true, completion: nil)\n      }\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// AlertModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(AlertModule, NSObject)\n  RCT_EXTERN_METHOD(showAlert:(NSString *)title message:(NSString *)message)\n@end"}
{"instruction": "Optimize a large list rendering in React Native using 'FlashList' (by Shopify) to minimize blank cells and improve JS thread performance compared to FlatList.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 2000 }).map((_, i) => ({\n  id: i.toString(),\n  title: `Item ${i}`,\n}));\n\nconst MyOptimizedList = () => {\n  return (\n    <View style={styles.container}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        // estimatedItemSize is crucial for FlashList performance optimization\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, width: '100%' },\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderColor: '#eee',\n  },\n});\n\nexport default MyOptimizedList;"}
{"instruction": "Use Expo's 'expo-haptics' and 'react-native-reanimated' to create a button that scales down when pressed and triggers a haptic feedback.", "output": "import React from 'react';\nimport { Pressable, StyleSheet, Text } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nconst HapticButton = () => {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ scale: scale.value }],\n    };\n  });\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1);\n  };\n\n  return (\n    <AnimatedPressable\n      style={[styles.button, animatedStyle]}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n    >\n      <Text style={styles.text}>Press Me</Text>\n    </AnimatedPressable>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    backgroundColor: '#6200ee',\n    paddingVertical: 15,\n    paddingHorizontal: 30,\n    borderRadius: 8,\n  },\n  text: { color: 'white', fontWeight: 'bold', fontSize: 16 },\n});\n\nexport default HapticButton;"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list when a 'Delete' button is pressed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet, TouchableOpacity } from 'react-native';\nimport Animated, { FadeInUp, FadeOutLeft, Layout } from 'react-native-reanimated';\n\nconst LayoutAnimationExample = () => {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (idToRemove: number) => {\n    setItems((current) => current.filter((id) => id !== idToRemove));\n  };\n\n  const addItem = () => {\n    const newId = items.length > 0 ? Math.max(...items) + 1 : 1;\n    setItems((current) => [newId, ...current]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutLeft}\n          layout={Layout.springify()}\n          style={styles.card}\n        >\n          <Text>Item {item}</Text>\n          <TouchableOpacity onPress={() => removeItem(item)}>\n            <Text style={styles.deleteText}>Delete</Text>\n          </TouchableOpacity>\n        </Animated.View>\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, paddingTop: 50 },\n  card: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    padding: 20,\n    backgroundColor: 'white',\n    marginBottom: 10,\n    borderRadius: 8,\n    elevation: 2,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n  },\n  deleteText: { color: 'red' },\n});\n\nexport default LayoutAnimationExample;"}
{"instruction": "Create a TurboModule specification (TypeScript interface) for the New Architecture to expose a calculator with a 'add' method. This demonstrates Type-Safe Native Modules.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\n// The interface must extend TurboModule\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n  \n  // Synchronous method example (JSI)\n  multiply(a: number, b: number): number;\n}\n\n// Load the module, defaulting to null if not linked\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method to get the device model name via a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n\n    DeviceInfoModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceInfo\";\n    }\n\n    @ReactMethod\n    public void getModel(Promise promise) {\n        try {\n            String model = Build.MODEL;\n            promise.resolve(model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Implement a draggable box using 'react-native-reanimated' (v3) and 'react-native-gesture-handler'. The logic must run on the UI thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write an Expo Config Plugin to automatically add the 'android.permission.CAMERA' permission to the AndroidManifest.xml.", "output": "const { withAndroidManifest } = require('@expo/config-plugins');\n\nconst withCameraPermission = (config) => {\n  return withAndroidManifest(config, async (config) => {\n    const androidManifest = config.modResults;\n    \n    if (!androidManifest.manifest['uses-permission']) {\n      androidManifest.manifest['uses-permission'] = [];\n    }\n\n    const permissions = androidManifest.manifest['uses-permission'];\n    const hasCamera = permissions.some(p => p.$['android:name'] === 'android.permission.CAMERA');\n\n    if (!hasCamera) {\n      permissions.push({\n        $: { 'android:name': 'android.permission.CAMERA' }\n      });\n    }\n\n    return config;\n  });\n};\n\nmodule.exports = withCameraPermission;"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) named 'NativeCalculator' that includes a synchronous 'add' method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method execution via JSI\n  add(a: number, b: number): number;\n  \n  // Async method\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a Reanimated scroll handler that interpolates the header opacity based on scroll position, ensuring no bridge traffic during scrolling.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: { \n    position: 'absolute', top: 0, left: 0, right: 0, \n    height: 60, backgroundColor: 'white', elevation: 5, \n    zIndex: 1, justifyContent: 'center', alignItems: 'center' \n  }\n});"}
{"instruction": "Create an iOS Native Module (Swift) setup that exposes a method to open the device Settings app.", "output": "// CalendarManager.swift\nimport Foundation\nimport React\n\n@objc(SettingsModule)\nclass SettingsModule: NSObject {\n\n  @objc\n  func openSettings() {\n    DispatchQueue.main.async {\n      if let url = URL(string: UIApplication.openSettingsURLString) {\n        if UIApplication.shared.canOpenURL(url) {\n          UIApplication.shared.open(url, options: [:], completionHandler: nil)\n        }\n      }\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// SettingsModule.m (Objective-C Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(SettingsModule, NSObject)\n// RCT_EXTERN_METHOD(openSettings)\n// @end"}
{"instruction": "Use `expo-file-system` to download an image to the local cache and read it as a Base64 string.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadAndReadImage = async (remoteUrl: string): Promise<string | null> => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'temp_image.jpg';\n    \n    const downloadRes = await FileSystem.downloadAsync(remoteUrl, fileUri);\n    \n    if (downloadRes.status === 200) {\n      const base64 = await FileSystem.readAsStringAsync(downloadRes.uri, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n      return base64;\n    }\n    return null;\n  } catch (error) {\n    console.error('Download failed', error);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate Bridge Optimization by calling a JavaScript function from the UI thread using Reanimated's `runOnJS` only when a gesture ends.", "output": "import { runOnJS } from 'react-native-reanimated';\nimport { Gesture } from 'react-native-gesture-handler';\n\nexport const useEndGesture = (onFinished: () => void) => {\n  // This function lives in the JS thread\n  const handleFinish = () => {\n    console.log('Gesture finished, heavy JS logic here');\n    onFinished();\n  };\n\n  // The gesture handler runs on the UI thread to prevent lag\n  const gesture = Gesture.Pan()\n    .onEnd(() => {\n      'worklet';\n      // Cross the bridge only once at the end\n      runOnJS(handleFinish)();\n    });\n\n  return gesture;\n};"}
{"instruction": "Create a secure storage helper using `expo-secure-store` to save and retrieve a user token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const TokenService = {\n  saveToken: async (token: string): Promise<void> => {\n    await SecureStore.setItemAsync(KEY, token, {\n      keychainAccessible: SecureStore.WHEN_UNLOCKED,\n    });\n  },\n\n  getToken: async (): Promise<string | null> => {\n    return await SecureStore.getItemAsync(KEY);\n  },\n\n  deleteToken: async (): Promise<void> => {\n    await SecureStore.deleteItemAsync(KEY);\n  }\n};"}
{"instruction": "Implement an Android Native Module method that sends a 'Progress' event to JavaScript repeatedly using `DeviceEventManagerModule`.", "output": "private void sendEvent(ReactContext reactContext, String eventName, WritableMap params) {\n    reactContext\n        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n        .emit(eventName, params);\n}\n\n@ReactMethod\npublic void startProgress() {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            for (int i = 0; i <= 100; i += 10) {\n                try {\n                    Thread.sleep(500);\n                    WritableMap params = Arguments.createMap();\n                    params.putInt(\"progress\", i);\n                    sendEvent(getReactApplicationContext(), \"onProgress\", params);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }).start();\n}"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport const DraggableBox = () => {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that includes a method to add numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the method signature\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  multiply(a: number, b: number): number;\n}\n\n// Retrieve the module, enforcing the Spec\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator') as Spec | null;"}
{"instruction": "Create a minimal Expo Module definition (using the Expo Modules API) in TypeScript that exposes a synchronous function to get the device model name.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// 1. Define the interface for the events and methods\ninterface DeviceInfoModule {\n  getDeviceModel(): string;\n}\n\n// 2. Import the native module\n// This assumes you have created the native code (Swift/Kotlin) registered as 'DeviceInfo'\nconst DeviceInfo = requireNativeModule<DeviceInfoModule>('DeviceInfo');\n\n// 3. Export a wrapper function\nexport function getModel(): string {\n  return DeviceInfo.getDeviceModel();\n}"}
{"instruction": "Implement a 'runOnUI' worklet using Reanimated to perform a heavy calculation on the UI thread to avoid blocking the JS thread.", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport const HeavyCalculationComponent = () => {\n\n  // This function is marked as a worklet automatically by Reanimated babel plugin\n  // when used inside runOnUI, or can be explicitly marked with 'worklet';\n  const heavyTask = (input: number) => {\n    'worklet';\n    let result = 0;\n    // Simulate heavy synchronous work on the UI thread\n    for (let i = 0; i < input * 1000000; i++) {\n      result += Math.sqrt(i);\n    }\n    console.log('Calculation done on UI thread:', result);\n  };\n\n  const handlePress = () => {\n    // Dispatch work to UI thread\n    runOnUI(heavyTask)(5);\n    Alert.alert('Task dispatched', 'Check console logs');\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Task on UI\" onPress={handlePress} />\n    </View>\n  );\n};\n"}
{"instruction": "Write a Java class for a legacy Android Native Module that exposes a method to show a Toast message.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to JavaScript\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    // Method exposed to JavaScript\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Optimize a FlatList rendering by using `memo` and `useCallback` to prevent unnecessary bridge traffic and re-renders of list items.", "output": "import React, { useCallback, memo } from 'react';\nimport { FlatList, Text, View, StyleSheet, ListRenderItem } from 'react-native';\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\n// 1. Memoize the child component to prevent re-renders if props haven't changed\nconst ListItem = memo(({ title, onPress }: { title: string; onPress: () => void }) => {\n  console.log(`Rendering ${title}`);\n  return (\n    <View style={styles.item}>\n      <Text onPress={onPress}>{title}</Text>\n    </View>\n  );\n});\n\nexport const OptimizedList = ({ data }: { data: ItemData[] }) => {\n  \n  // 2. Use useCallback to ensure the function reference remains stable across renders\n  const handlePress = useCallback((item: ItemData) => {\n    console.log('Pressed', item.id);\n  }, []);\n\n  // 3. RenderItem function logic\n  const renderItem: ListRenderItem<ItemData> = useCallback(({ item }) => (\n    <ListItem \n      title={item.title} \n      onPress={() => handlePress(item)} // Passing a stable function reference if possible, or wrapping ListItem logic\n    />\n  ), [handlePress]);\n\n  const keyExtractor = useCallback((item: ItemData) => item.id, []);\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      // Optimization props\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n    />\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { padding: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});"}
{"instruction": "Create a Swift Native Module (iOS) that resolves a Promise with the system version.", "output": "@objc(SystemInfo)\nclass SystemInfo: NSObject {\n\n  // Required to expose to React Native\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n\n  // Exposed method with Promise (Resolver/Rejecter)\n  @objc(getSystemVersion:rejecter:)\n  func getSystemVersion(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    let version = UIDevice.current.systemVersion\n    if !version.isEmpty {\n      resolve(version)\n    } else {\n      let error = NSError(domain: \"SystemInfo\", code: 200, userInfo: nil)\n      reject(\"NO_VERSION\", \"Could not get system version\", error)\n    }\n  }\n}"}
{"instruction": "Use Reanimated's `useAnimatedScrollHandler` to create a collapsing header effect based on scroll position.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport const CollapsingHeader = () => {\n  const scrollY = useSharedValue(0);\n  const HEADER_HEIGHT = 200;\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(\n      scrollY.value,\n      [0, HEADER_HEIGHT],\n      [HEADER_HEIGHT, 50],\n      Extrapolation.CLAMP\n    );\n    \n    const opacity = interpolate(\n      scrollY.value,\n      [0, HEADER_HEIGHT / 2],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n\n    return { height, opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: 10 }}\n      >\n        {/* Content placeholders */}\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.listItem} />\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { width: '100%', backgroundColor: 'tomato', position: 'absolute', top: 0, zIndex: 1 },\n  listItem: { height: 100, backgroundColor: '#eee', margin: 10, borderRadius: 8 }\n});"}
{"instruction": "Bridge Optimization: Create a JavaScript helper that passes large data to a native module as a JSON string instead of a JS Object to avoid costly serialization over the bridge.", "output": "import { NativeModules } from 'react-native';\n\nconst { LargeDataModule } = NativeModules;\n\n/**\n * Sends large datasets to native side.\n * Optimization: Serialization of large nested objects over the Bridge is expensive.\n * JSON.stringify() in V8/Hermes is often faster than the Bridge's object traversal.\n * \n * @param data - Complex object to send\n */\nexport const processLargeData = async (data: Record<string, any>) => {\n  try {\n    // Convert to string in JS thread\n    const jsonString = JSON.stringify(data);\n    \n    // Pass a single string across the bridge rather than a deep map\n    const result = await LargeDataModule.processDataString(jsonString);\n    \n    return JSON.parse(result);\n  } catch (error) {\n    console.error('Bridge transfer failed', error);\n    throw error;\n  }\n};"}
{"instruction": "Use Expo FileSystem to download a file and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (remoteUrl: string, fileName: string) => {\n  try {\n    const fileUri = `${FileSystem.cacheDirectory}${fileName}`;\n\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress * 100}%`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a basic iOS Native Module using Swift and the classic Bridge that exports a method to get the device name. Provide both the Swift implementation and the Objective-C bridge header.", "output": "// DeviceInfoModule.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(DeviceInfoModule, NSObject)\n  RCT_EXTERN_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n\n// DeviceInfoModule.swift\nimport Foundation\nimport UIKit\n\n@objc(DeviceInfoModule)\nclass DeviceInfoModule: NSObject {\n  \n  @objc\n  func getDeviceName(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    let deviceName = UIDevice.current.name\n    resolve(deviceName)\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Create a draggable box component using `react-native-reanimated` (v3) and `react-native-gesture-handler`. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' that includes a method to add two numbers.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('Calculator') as Spec | null;"}
{"instruction": "Write an Android Native Module in Kotlin that opens a specific URL in the system's default browser.", "output": "package com.myapp.modules\n\nimport android.content.Intent\nimport android.net.Uri\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass BrowserLinkModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"BrowserLinkModule\"\n    }\n\n    @ReactMethod\n    fun openLink(url: String) {\n        val intent = Intent(Intent.ACTION_VIEW)\n        intent.data = Uri.parse(url)\n        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n        reactApplicationContext.startActivity(intent)\n    }\n}"}
{"instruction": "Demonstrate how to offload a heavy synchronous calculation to the UI thread using Reanimated 'worklets' to prevent the JavaScript thread (and the Bridge) from freezing.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A heavy function defined as a worklet\nfunction heavyCalculation(input: number) {\n  'worklet';\n  let result = input;\n  for (let i = 0; i < 10000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation finished on UI thread:', result);\n}\n\nexport default function HeavyTaskComponent() {\n  const handlePress = () => {\n    // Execute on UI thread, bypassing the JS thread entirely for the loop\n    runOnUI(heavyCalculation)(5);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a native module using the modern Expo Modules API (Swift) that exposes a function to get the current battery level.", "output": "import ExpoModulesCore\n\npublic class BatteryModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"BatteryModule\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getBatteryLevel\") { () -> Float in\n      UIDevice.current.isBatteryMonitoringEnabled = true\n      return UIDevice.current.batteryLevel\n    }\n  }\n}"}
{"instruction": "Implement a Reanimated Layout Animation to animate items appearing and disappearing in a list, replacing the need for complex LayoutAnimation bridge calls.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          style={styles.item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  buttons: { flexDirection: 'row', gap: 10, marginBottom: 20 },\n  item: { width: 300, height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nasync function downloadImage(remoteUrl: string, fileName: string) {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {},\n      (downloadProgress) => {\n        const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n        console.log(`Progress: ${progress}`);\n      }\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}"}
{"instruction": "Optimize a long list using `@shopify/flash-list` instead of `FlatList` to improve performance on the bridge by recycling views more efficiently.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }).map((_, i) => ({ id: i, title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id.toString()}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, justifyContent: 'center', padding: 10, borderBottomWidth: 1, borderColor: '#ccc' },\n});\n\nexport default MyList;"}
{"instruction": "Demonstrate the usage of `react-native-mmkv` to store and retrieve data synchronously using JSI, bypassing the asynchronous bridge calls typical of `AsyncStorage`.", "output": "import { MMKV } from 'react-native-mmkv';\n\n// Initialize the storage (JSI binding happens here)\nexport const storage = new MMKV();\n\n// Synchronous set\nexport const saveUser = (user: { id: string; name: string }) => {\n  storage.set('user.id', user.id);\n  storage.set('user.name', user.name);\n  storage.set('user.isLoggedIn', true);\n};\n\n// Synchronous get\nexport const getUser = () => {\n  const id = storage.getString('user.id');\n  const name = storage.getString('user.name');\n  const isLoggedIn = storage.getBoolean('user.isLoggedIn');\n\n  if (isLoggedIn && id && name) {\n    return { id, name };\n  }\n  return null;\n};"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: isPressed.value ? 1.2 : 1 },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Write a Native Module in Java (Android) to expose a method `getBatteryLevel` to React Native.", "output": "package com.myapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n\n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n\n            float batteryPct = level / (float) scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create a minimal Expo Module using the Expo Modules API (Kotlin) that returns the device name synchronously.", "output": "package expo.modules.devicename\n\nimport android.os.Build\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass DeviceNameModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"DeviceName\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getDeviceName\") {\n      return@Function Build.MODEL\n    }\n  }\n}"}
{"instruction": "Implement a Reanimated 'Scroll to Top' button that smoothly fades in only after the user scrolls down 100 pixels.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, useAnimatedStyle, withTiming, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollToTopExample() {\n  const scrollY = useSharedValue(0);\n  const listRef = React.useRef(null);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const buttonStyle = useAnimatedStyle(() => {\n    return {\n      opacity: withTiming(scrollY.value > 100 ? 1 : 0),\n      transform: [\n        { scale: interpolate(scrollY.value, [0, 100], [0, 1], Extrapolation.CLAMP) }\n      ]\n    };\n  });\n\n  const scrollToTop = () => {\n    listRef.current?.scrollTo({ y: 0, animated: true });\n  };\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.ScrollView\n        ref={listRef}\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n      >\n        {Array.from({ length: 50 }).map((_, i) => (\n          <View key={i} style={styles.item} />\n        ))}\n      </Animated.ScrollView>\n\n      <Animated.View style={[styles.floatingBtn, buttonStyle]}>\n        <Button title=\"Top\" onPress={scrollToTop} />\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { height: 50, margin: 10, backgroundColor: '#ddd' },\n  floatingBtn: { position: 'absolute', bottom: 20, right: 20 },\n});"}
{"instruction": "Demonstrate Bridge Optimization by avoiding passing a Base64 string over the bridge. Instead, write a function that saves data to a file and passes the URI.", "output": "// Optimization Strategy: Avoid serializing large Base64 strings across the JSON bridge.\n// Instead, write to the filesystem on the native side and pass the file path (string) to JS.\n\n// 1. Native Module Method (Pseudocode/Java)\n/*\n@ReactMethod\npublic void processLargeImage(String inputUri, Promise promise) {\n    // Perform heavy image processing in native code...\n    File outputFile = new File(getReactApplicationContext().getCacheDir(), \"processed.jpg\");\n    // Save bitmap to outputFile...\n    \n    // Return ONLY the path, not the base64 data\n    promise.resolve(\"file://\" + outputFile.getAbsolutePath());\n}\n*/\n\n// 2. React Native Usage\nimport { NativeModules, Image } from 'react-native';\nconst { ImageProcessor } = NativeModules;\n\nasync function handleImage(originalUri: string) {\n  try {\n    // Good: Passing small strings (URIs)\n    const newUri = await ImageProcessor.processLargeImage(originalUri);\n    \n    // Display using URI, bypassing JS thread heavy lifting\n    return <Image source={{ uri: newUri }} style={{ width: 100, height: 100 }} />;\n  } catch (e) {\n    console.error(e);\n  }\n}"}
{"instruction": "Create a custom Native UI Component (ViewManager) in Java to expose a native Android TextView to React Native.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class CustomTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RCTCustomText\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        return new TextView(reactContext);\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(TextView view, String color) {\n        view.setTextColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Use Reanimated `useAnimatedSensor` to create a 3D rotation effect on an image based on the device gyroscope.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedSensor, SensorType, useAnimatedStyle, withTiming } from 'react-native-reanimated';\n\nexport default function GyroImage() {\n  const animatedSensor = useAnimatedSensor(SensorType.GYROSCOPE, { interval: 10 });\n\n  const style = useAnimatedStyle(() => {\n    const pitch = animatedSensor.sensor.value.x;\n    const roll = animatedSensor.sensor.value.y;\n\n    return {\n      transform: [\n        { perspective: 1000 },\n        { rotateX: withTiming(`${pitch * 20}deg`, { duration: 50 }) },\n        { rotateY: withTiming(`${roll * 20}deg`, { duration: 50 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={[styles.image, style]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  image: { width: 200, height: 200 },\n});"}
{"instruction": "Implement a Swift (iOS) Native Module that exposes a method to trigger Haptic Feedback.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func trigger(_ type: String) {\n    DispatchQueue.main.async {\n      let generator = UIImpactFeedbackGenerator(style: .medium)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Objective-C Bridge)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(HapticModule, NSObject)\nRCT_EXTERN_METHOD(trigger:(NSString *)type)\n@end\n*/"}
{"instruction": "Using Expo's `expo-file-system`, download a file from a URL and save it locally.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadFile = async (url: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return null;\n};"}
{"instruction": "Create a JSI (JavaScript Interface) setup snippet in C++ to demonstrate how to bind a synchronous C++ function to the global JavaScript object (Bridge Optimization).", "output": "#include <jsi/jsi.h>\n\nusing namespace facebook::jsi;\nusing namespace std;\n\n// This function would be called from your Native Module's install/initialize method\nvoid installJSIBindings(Runtime &runtime) {\n  \n  // Define a C++ function\n  auto multiply = Function::createFromHostFunction(\n      runtime,\n      PropNameID::forAscii(runtime, \"multiply\"),\n      2, // param count\n      [](Runtime &runtime, const Value &thisValue, const Value *arguments, size_t count) -> Value {\n          double res = arguments[0].asNumber() * arguments[1].asNumber();\n          return Value(res);\n      }\n  );\n\n  // Bind it to the global object so JS can call global.multiply(2, 4)\n  runtime.global().setProperty(runtime, \"multiply\", move(multiply));\n}"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should include a synchronous method `add(a: number, b: number): number`.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Synchronous method definition\n  add(a: number, b: number): number;\n}\n\n// Load the module, enforcing the Spec\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a legacy Android Native Module in Java that exposes a method to show a Toast message, and provide the JavaScript wrapper.", "output": "// Android: ToastModule.java\n/*\npackage com.yourapp;\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// JavaScript: ToastModule.ts\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Implement a scroll-based animation using Reanimated where a header's opacity decreases as the user scrolls down a ScrollView.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useSharedValue, useAnimatedStyle, interpolate, Extrapolation } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [1, 0],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Fading Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, padding: 20 }}>\n          <Text>Scroll content...</Text>\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Demonstrate how to optimize a heavy calculation by running it on the UI thread using Reanimated's `runOnUI`, completely bypassing the React Native Bridge.", "output": "import React from 'react';\nimport { Button, View } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that runs purely in the JS context (if called normally) \n// or on the UI thread (if called via runOnUI).\nfunction heavyCalculation(input: number) {\n  'worklet';\n  // Simulate work\n  let result = input;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation result on UI thread:', result);\n}\n\nexport default function HeavyTaskComponent() {\n  const handlePress = () => {\n    // Dispatch work to UI thread to avoid freezing JS thread (Bridge optimization)\n    runOnUI(heavyCalculation)(50);\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center' }}>\n      <Button title=\"Run Heavy Worklet\" onPress={handlePress} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Native UI Component wrapper for a hypothetical iOS 'RNTMap' view using `requireNativeComponent`.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface NativeMapProps extends ViewProps {\n  zoomEnabled?: boolean;\n  region?: {\n    latitude: number;\n    longitude: number;\n    latitudeDelta: number;\n    longitudeDelta: number;\n  };\n  onRegionChange?: (event: any) => void;\n}\n\n// 'RNTMap' refers to the name registered in the Objective-C/Swift ViewManager\nconst RNTMap = requireNativeComponent<NativeMapProps>('RNTMap');\n\nexport default RNTMap;"}
{"instruction": "Use the Expo Modules API (TypeScript/JavaScript side) to implement a class-based module definition for a Battery module, including a listener for level changes.", "output": "import { EventEmitter, Subscription } from 'expo-modules-core';\nimport ExpoBatteryModule from './ExpoBatteryModule'; // The Native Module binding\n\nconst emitter = new EventEmitter(ExpoBatteryModule);\n\nexport function getBatteryLevel(): number {\n  return ExpoBatteryModule.getBatteryLevel();\n}\n\nexport function addBatteryLevelListener(listener: (event: { level: number }) => void): Subscription {\n  return emitter.addListener('onBatteryLevelChange', listener);\n}\n\n// Usage example:\n// useEffect(() => {\n//   const sub = addBatteryLevelListener(({ level }) => console.log(level));\n//   return () => sub.remove();\n// }, []);"}
{"instruction": "Implement a layout animation using Reanimated's `Entering` and `Exiting` modifiers for a list item to animate mounting and unmounting.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown } from 'react-native-reanimated';\n\nexport default function LayoutAnimationExample() {\n  const [show, setShow] = useState(true);\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Toggle\" onPress={() => setShow(!show)} />\n      {show && (\n        <Animated.View \n          entering={FadeInUp.duration(500)} \n          exiting={FadeOutDown.duration(500)} \n          style={styles.box} \n        />\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', marginTop: 100 },\n  box: { width: 100, height: 100, backgroundColor: 'green', marginTop: 20, borderRadius: 10 }\n});"}
{"instruction": "Use `InteractionManager` to defer a heavy operation until after animations/transitions are complete to ensure UI smoothness.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function DeferredRender() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Schedule the heavy task after animations/transitions finish\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Perform heavy setup or data processing here\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>Heavy content loaded smoothly!</Text>\n    </View>\n  );\n}"}
{"instruction": "Implement a custom Expo hook `useCameraPermissions` that requests camera permissions on mount.", "output": "import { useEffect, useState } from 'react';\nimport { Camera, PermissionResponse } from 'expo-camera';\n\nexport function useCameraPermissions() {\n  const [permission, setPermission] = useState<PermissionResponse | null>(null);\n\n  useEffect(() => {\n    (async () => {\n      const response = await Camera.requestCameraPermissionsAsync();\n      setPermission(response);\n    })();\n  }, []);\n\n  return {\n    granted: permission?.granted ?? false,\n    canAskAgain: permission?.canAskAgain ?? true,\n    status: permission?.status,\n  };\n}"}
{"instruction": "Create a React Native component using `react-native-reanimated` and `react-native-gesture-handler` that implements a draggable square box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a native Android module (Java) for React Native to expose a method `getDeviceName` that returns the Android model name via a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n   DeviceInfoModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceInfo\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           String model = Build.MODEL;\n           promise.resolve(model);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Demonstrate how to offload a heavy calculation (e.g., Fibonacci sequence) to the UI thread using a Reanimated Worklet to prevent blocking the JavaScript bridge.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculationWorklet() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      'worklet';\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      // Heavy calculation on UI thread\n      const value = fib(35);\n\n      runOnJS(setResult)(value);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result ?? 'Not calculated'}</Text>\n      <Button title=\"Run Heavy Task on UI Thread\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Expo Hook using `expo-sensors` to rotate a view based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\nimport Animated, { useAnimatedStyle, useSharedValue, withTiming } from 'react-native-reanimated';\n\nexport default function GyroRotator() {\n  const rotation = useSharedValue(0);\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n    const subscription = Gyroscope.addListener(data => {\n      // Simple integration of z-axis rotation\n      rotation.value = withTiming(rotation.value + data.z, { duration: 100 });\n    });\n\n    return () => subscription.remove();\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ rotateZ: `${rotation.value}rad` }],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]}>\n        <Text style={styles.text}>Rotate Me</Text>\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n  text: { color: 'white', fontWeight: 'bold' }\n});"}
{"instruction": "Write the TypeScript specification for a TurboModule (New Architecture) named `RTNCalculator` that defines an `add` method returning a Promise<number>.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('RTNCalculator');"}
{"instruction": "Implement a bridge optimization pattern where multiple small data events are batched into a single bridge call to reduce overhead.", "output": "import { NativeModules } from 'react-native';\n\nconst { AnalyticsModule } = NativeModules;\n\n// Optimization: Batching Bridge Calls\n// Instead of calling the Native Module every time an event occurs, \n// we queue them and send them in a single JSON array.\n\nclass AnalyticsBatcher {\n  private queue: any[] = [];\n  private timer: NodeJS.Timeout | null = null;\n  private readonly BATCH_DELAY = 1000;\n\n  logEvent(eventName: string, data: object) {\n    this.queue.push({ eventName, timestamp: Date.now(), data });\n\n    if (!this.timer) {\n      this.timer = setTimeout(this.flush, this.BATCH_DELAY);\n    }\n  }\n\n  flush = () => {\n    if (this.queue.length === 0) return;\n\n    // Send one large payload over the bridge instead of N small ones\n    AnalyticsModule.trackEventsBatch(this.queue);\n    \n    this.queue = [];\n    this.timer = null;\n  };\n}\n\nexport const analytics = new AnalyticsBatcher();"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport const downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n    return null;\n  } catch (e) {\n    console.error('Download error:', e);\n    return null;\n  }\n};"}
{"instruction": "Create a native iOS module (Swift) that exposes a method `changeIcon` to programmatically change the app icon (requires `Info.plist` configuration).", "output": "// CalendarModule.swift\nimport Foundation\nimport React\n\n@objc(AppIconModule)\nclass AppIconModule: NSObject {\n\n  @objc(changeIcon:resolver:rejecter:)\n  func changeIcon(_ iconName: String?, resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    DispatchQueue.main.async {\n      if UIApplication.shared.supportsAlternateIcons {\n        UIApplication.shared.setAlternateIconName(iconName) { error in\n          if let error = error {\n            reject(\"ICON_CHANGE_ERROR\", error.localizedDescription, error)\n          } else {\n            resolve(\"Icon changed successfully\")\n          }\n        }\n      } else {\n        reject(\"NOT_SUPPORTED\", \"Alternate icons not supported\", nil)\n      }\n    }\n  }\n  \n  @objc static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Use `react-native-reanimated` to create a scroll handler that interpolates the background color of a Header based on the scroll position.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolateColor } from 'react-native-reanimated';\n\nexport default function ScrollHeaderColor() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const backgroundColor = interpolateColor(\n      scrollY.value,\n      [0, 150],\n      ['transparent', 'rgba(0,0,0,0.8)']\n    );\n    return { backgroundColor };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ height: 1000 }}\n      >\n        {/* Content goes here */}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 80,\n    zIndex: 1,\n  },\n});"}
{"instruction": "Use `expo-secure-store` to securely save, retrieve, and delete a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const AuthManager = {\n  saveToken: async (token: string) => {\n    try {\n      await SecureStore.setItemAsync(KEY, token);\n      console.log('Token saved securely');\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async () => {\n    try {\n      const token = await SecureStore.getItemAsync(KEY);\n      return token;\n    } catch (error) {\n      console.error('Error retrieving token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async () => {\n    try {\n      await SecureStore.deleteItemAsync(KEY);\n      console.log('Token deleted');\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  }\n};"}
{"instruction": "Create a React Native Reanimated component that implements a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated'. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator'. It should have a method 'add' that takes two numbers and returns a Promise resolving to a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Write a legacy Android Native Module in Java that exposes a method 'getDeviceName' to React Native via a Promise.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n   DeviceModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"DeviceModule\";\n   }\n\n   @ReactMethod\n   public void getDeviceName(Promise promise) {\n       try {\n           String manufacturer = Build.MANUFACTURER;\n           String model = Build.MODEL;\n           promise.resolve(manufacturer + \" \" + model);\n       } catch (Exception e) {\n           promise.reject(\"Error\", e);\n       }\n   }\n}"}
{"instruction": "Create a custom Expo Module using the Expo Modules API in Swift. The module should be named 'MySettings' and expose a synchronous function 'getTheme' that returns a string.", "output": "import ExpoModulesCore\n\npublic class MySettingsModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"MySettings\")\n\n    // Defines a synchronous function that can be called from JavaScript\n    Function(\"getTheme\") { () -> String in\n      // In a real app, retrieve this from UserDefaults or system settings\n      return \"dark\"\n    }\n  }\n}"}
{"instruction": "Implement a bridge optimization technique in JavaScript where multiple analytics events are batched into a single Native Module call to reduce the overhead of passing data across the bridge.", "output": "import { NativeModules } from 'react-native';\n\nconst { AnalyticsModule } = NativeModules;\n\nconst BATCH_SIZE = 10;\nconst FLUSH_INTERVAL = 5000;\nlet eventQueue: any[] = [];\nlet timer: NodeJS.Timeout | null = null;\n\nconst flushEvents = () => {\n  if (eventQueue.length > 0) {\n    // Send array of events in one bridge call\n    AnalyticsModule.trackEvents(eventQueue);\n    eventQueue = [];\n  }\n  if (timer) {\n    clearTimeout(timer);\n    timer = null;\n  }\n};\n\nexport const logEvent = (eventName: string, params: object) => {\n  eventQueue.push({ name: eventName, timestamp: Date.now(), params });\n\n  if (eventQueue.length >= BATCH_SIZE) {\n    flushEvents();\n  } else if (!timer) {\n    // Ensure events are sent eventually even if batch size isn't met\n    timer = setTimeout(flushEvents, FLUSH_INTERVAL);\n  }\n};"}
{"instruction": "Create an Objective-C header and implementation for a legacy iOS Native Module named 'CalendarManager' that exposes a method 'addEvent' taking a name (string) and location (string).", "output": "// CalendarManager.h\n#import <React/RCTBridgeModule.h>\n@interface CalendarManager : NSObject <RCTBridgeModule>\n@end\n\n// CalendarManager.m\n#import \"CalendarManager.h\"\n#import <React/RCTLog.h>\n\n@implementation CalendarManager\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)\n{\n  RCTLogInfo(@\"Pretending to create an event %@ at %@\", name, location);\n}\n\n@end"}
{"instruction": "Use 'react-native-reanimated' to create a ScrollView where the opacity of a header image interpolates based on the scroll Y offset.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, interpolate, useAnimatedScrollHandler, Extrapolate } from 'react-native-reanimated';\n\nexport default function ParallaxHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 200],\n      [1, 0],\n      Extrapolate.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/300' }}\n        style={[styles.headerImage, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {/* Long content here */}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  headerImage: { width: '100%', height: 200, position: 'absolute', top: 0 },\n  content: { paddingTop: 200, height: 1000, backgroundColor: 'white' }\n});"}
{"instruction": "Write a C++ JSI (JavaScript Interface) function snippet that exposes a synchronous 'multiply' function to the JavaScript runtime. This bypasses the asynchronous bridge.", "output": "// Inside your JSI installation function (e.g., install(Runtime &jsiRuntime))\n\nauto multiply = jsi::Function::createFromHostFunction(\n    jsiRuntime,\n    jsi::PropNameID::forAscii(jsiRuntime, \"multiply\"),\n    2, // param count\n    [](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {\n        if (count < 2 || !arguments[0].isNumber() || !arguments[1].isNumber()) {\n            return jsi::Value::undefined();\n        }\n        double res = arguments[0].asNumber() * arguments[1].asNumber();\n        return jsi::Value(res);\n    }\n);\n\njsiRuntime.global().setProperty(jsiRuntime, \"multiply\", std::move(multiply));"}
{"instruction": "Create a React Native component that uses 'expo-haptics' to trigger a tactile feedback when a user presses a button.", "output": "import React from 'react';\nimport { StyleSheet, View, Button } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Trigger a light impact feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button pressed with haptics');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});"}
{"instruction": "Implement a 'Layout Animation' using Reanimated 3 to animate a list item when it is mounted (entering) and unmounted (exiting) from the DOM.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  const addItem = () => {\n    setItems((prev) => [...prev, prev.length + 1]);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      <View style={styles.list}>\n        {items.map((item) => (\n          <Animated.View\n            key={item}\n            entering={FadeInUp}\n            exiting={FadeOutDown}\n            layout={Layout.springify()}\n            style={styles.card}\n          />\n        ))}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  list: { marginTop: 20, width: '100%', alignItems: 'center' },\n  card: { width: 300, height: 50, backgroundColor: 'tomato', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Create a React Native component using `react-native-reanimated` and `react-native-gesture-handler` that implements a draggable box. The box should return to its original position with a spring animation when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 20,\n  },\n});"}
{"instruction": "Write a Swift class for a React Native iOS Native Module named `CounterModule`. It should expose a method `increment` that takes a promise, resolves with the new count, and emits an event to JavaScript.", "output": "// CounterModule.swift\nimport Foundation\nimport React\n\n@objc(CounterModule)\nclass CounterModule: RCTEventEmitter {\n  private var count = 0\n  \n  override func supportedEvents() -> [String]! {\n    return [\"onCountChanged\"]\n  }\n\n  @objc\n  func increment(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    count += 1\n    sendEvent(withName: \"onCountChanged\", body: [\"count\": count])\n    resolve(count)\n  }\n\n  @objc\n  override static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Define a TypeScript Interface Specification for a TurboModule (New Architecture) named `NativeCalculator`. It should include a method `add` that accepts two numbers and returns a number.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.get<Spec>('NativeCalculator');"}
{"instruction": "Create a React Native component using `expo-sensors` to rotate an image based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Image } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroImage() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n  const [subscription, setSubscription] = useState(null);\n\n  const _subscribe = () => {\n    setSubscription(\n      Gyroscope.addListener(gyroscopeData => {\n        setData(gyroscopeData);\n      })\n    );\n    Gyroscope.setUpdateInterval(100);\n  };\n\n  const _unsubscribe = () => {\n    subscription && subscription.remove();\n    setSubscription(null);\n  };\n\n  useEffect(() => {\n    _subscribe();\n    return () => _unsubscribe();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Image\n        source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}\n        style={{\n          width: 100,\n          height: 100,\n          transform: [{ rotate: `${z}rad` }],\n        }}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement a Kotlin class for an Android Native Module named `DeviceModule`. It should expose a method `getDeviceName` that returns the Android model name via a Promise.", "output": "package com.myapp\n\nimport android.os.Build\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass DeviceModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"DeviceModule\"\n    }\n\n    @ReactMethod\n    fun getDeviceName(promise: Promise) {\n        try {\n            val manufacturer = Build.MANUFACTURER\n            val model = Build.MODEL\n            promise.resolve(\"$manufacturer $model\")\n        } catch (e: Exception) {\n            promise.reject(\"ERROR\", e)\n        }\n    }\n}"}
{"instruction": "Optimize bridge traffic by offloading a heavy calculation (Fibonacci) to the UI thread using a Reanimated Worklet (`runOnUI`).", "output": "import React from 'react';\nimport { Button, View, Alert } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  \n  const handleResult = (result: number) => {\n    Alert.alert(`Result: ${result}`);\n  };\n\n  const fibonacci = (n: number): number => {\n    'worklet';\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  };\n\n  const runHeavyTask = () => {\n    runOnUI(() => {\n      const result = fibonacci(30); // Heavy calc on UI thread\n      runOnJS(handleResult)(result); // Call back to JS thread\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Button title=\"Run Heavy Task\" onPress={runHeavyTask} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Android ViewManager in Java to expose a native `TextView` that sets its text color to red.", "output": "package com.myapp;\n\nimport android.graphics.Color;\nimport android.widget.TextView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class RedTextViewManager extends SimpleViewManager<TextView> {\n    public static final String REACT_CLASS = \"RedTextView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected TextView createViewInstance(ThemedReactContext reactContext) {\n        TextView textView = new TextView(reactContext);\n        textView.setTextColor(Color.RED);\n        return textView;\n    }\n\n    @ReactProp(name = \"text\")\n    public void setText(TextView view, String text) {\n        view.setText(text);\n    }\n}"}
{"instruction": "Use `react-native-reanimated` to create an animated scroll header. The header height should interpolate based on the scroll Y position.", "output": "import React from 'react';\nimport { View, StyleSheet, Text } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolate } from 'react-native-reanimated';\n\nexport default function ScrollHeader() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const height = interpolate(\n      scrollY.value,\n      [0, 100],\n      [200, 80],\n      Extrapolate.CLAMP\n    );\n    return { height };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.text}>Header</Text>\n      </Animated.View>\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={styles.content}>\n          {Array.from({ length: 20 }).map((_, i) => (\n            <View key={i} style={styles.item} />\n          ))}\n        </View>\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n  text: { color: 'white', fontWeight: 'bold' },\n  content: { padding: 20 },\n  item: { height: 50, backgroundColor: '#ddd', marginBottom: 10, borderRadius: 8 },\n});"}
{"instruction": "Demonstrate bridge optimization using `InteractionManager` to defer a heavy rendering task until after a navigation transition is complete.", "output": "import React, { useState, useEffect } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Complex logic or state update runs only after animations/transitions finish\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Heavy UI Rendered</Text>\n      {/* Expensive components go here */}\n    </View>\n  );\n}"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + 'downloaded_image.jpg';\n    \n    const { uri } = await FileSystem.downloadAsync(\n      url,\n      fileUri\n    );\n    \n    console.log('Finished downloading to ', uri);\n    return uri;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\n// Usage Example:\n// downloadImage('https://example.com/image.jpg');"}
{"instruction": "Create a basic Android Native Module in Java that exposes a method to get the device's battery level to React Native.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.BatteryManager;\n\npublic class BatteryModule extends ReactContextBaseJavaModule {\n    BatteryModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"BatteryModule\";\n    }\n\n    @ReactMethod\n    public void getBatteryLevel(Promise promise) {\n        try {\n            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n            Intent batteryStatus = getReactApplicationContext().registerReceiver(null, ifilter);\n            \n            int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);\n            int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);\n            \n            float batteryPct = level / (float)scale;\n            promise.resolve(batteryPct);\n        } catch (Exception e) {\n            promise.reject(\"BATTERY_ERROR\", e);\n        }\n    }\n}"}
{"instruction": "Create a React Native Reanimated 3 component that creates a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated' without triggering re-renders on the JS thread.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift Native Module (iOS) that triggers the system haptic feedback generator when called from JavaScript.", "output": "// HapticModule.swift\nimport Foundation\nimport UIKit\n\n@objc(HapticModule)\nclass HapticModule: NSObject {\n\n  @objc\n  func triggerImpact(_ style: String) {\n    DispatchQueue.main.async {\n      let feedbackStyle: UIImpactFeedbackGenerator.FeedbackStyle\n      switch style {\n        case \"light\": feedbackStyle = .light\n        case \"medium\": feedbackStyle = .medium\n        case \"heavy\": feedbackStyle = .heavy\n        default: feedbackStyle = .medium\n      }\n      let generator = UIImpactFeedbackGenerator(style: feedbackStyle)\n      generator.prepare()\n      generator.impactOccurred()\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// HapticModule.m (Bridge)\n// #import <React/RCTBridgeModule.h>\n// @interface RCT_EXTERN_MODULE(HapticModule, NSObject)\n// RCT_EXTERN_METHOD(triggerImpact:(NSString *)style)\n// @end"}
{"instruction": "Define a TurboModule Registry specification in TypeScript for a Calculator module. This is part of the New Architecture (Fabric/TurboModules) setup.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('CalculatorModule');"}
{"instruction": "Use the Expo Modules API (Kotlin) to create a simple Native View that renders a colored box, configurable via props.", "output": "package expo.modules.colorview\n\nimport android.content.Context\nimport android.graphics.Color\nimport android.view.View\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass ColorViewModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"ColorView\")\n\n    ViewManager {\n      View { context: Context ->\n        View(context)\n      }\n\n      Prop(\"color\") { view: View, color: String ->\n        view.setBackgroundColor(Color.parseColor(color))\n      }\n    }\n  }\n}"}
{"instruction": "Implement a bridge optimization strategy using `InteractionManager` to defer a heavy calculation until after a navigation transition or animation completes.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function OptimizedScreen() {\n  const [isReady, setIsReady] = useState(false);\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // Defer heavy work until interactions (like navigation animations) are done\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Simulate heavy synchronous calculation or bridge call\n      const heavyResult = performHeavyCalculation();\n      setData(heavyResult);\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return <ActivityIndicator size=\"large\" />;\n  }\n\n  return (\n    <View>\n      <Text>Data Loaded: {data}</Text>\n    </View>\n  );\n}\n\nfunction performHeavyCalculation() {\n  // Expensive loop\n  let result = 0;\n  for(let i = 0; i < 5000000; i++) { result += i; }\n  return result;\n}"}
{"instruction": "Create a Reanimated Worklet to perform a calculation on the UI thread, bypassing the JS bridge entirely for high-frequency updates.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is defined in JS but executed on the UI thread\nfunction heavyUIThreadCalculation(input: number) {\n  'worklet';\n  console.log('[UI Thread] Calculating square root');\n  return Math.sqrt(input);\n}\n\nexport const triggerCalculation = () => {\n  runOnUI((value) => {\n    'worklet';\n    const result = heavyUIThreadCalculation(value);\n    console.log('[UI Thread] Result:', result);\n  })(144);\n};"}
{"instruction": "Expose a native iOS UI Component (an Objective-C `UIView` wrapper) to React Native using `RCTViewManager`.", "output": "// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\n// Expose a property\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end"}
{"instruction": "Use `expo-file-system` to download a file from a remote URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nexport async function downloadImage(remoteUrl: string, fileName: string) {\n  const fileUri = FileSystem.cacheDirectory + fileName;\n  \n  try {\n    const downloadResumable = FileSystem.createDownloadResumable(\n      remoteUrl,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n    \n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download failed', e);\n  }\n  return null;\n}"}
{"instruction": "Create a custom React Hook that tracks the keyboard height using Reanimated to ensure smooth layout transitions (avoiding the bridge lag of standard Keyboard listeners).", "output": "import { useEffect } from 'react';\nimport { Keyboard, Platform } from 'react-native';\nimport { useSharedValue } from 'react-native-reanimated';\n\nexport function useAnimatedKeyboard() {\n  const keyboardHeight = useSharedValue(0);\n\n  useEffect(() => {\n    // Note: In modern Reanimated (v3+), useAnimatedKeyboard() is built-in.\n    // This demonstrates the manual bridge logic if the built-in hook wasn't available.\n    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';\n    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';\n\n    const onShow = Keyboard.addListener(showEvent, (e) => {\n      keyboardHeight.value = e.endCoordinates.height;\n    });\n\n    const onHide = Keyboard.addListener(hideEvent, () => {\n      keyboardHeight.value = 0;\n    });\n\n    return () => {\n      onShow.remove();\n      onHide.remove();\n    };\n  }, []);\n\n  return keyboardHeight;\n}"}
{"instruction": "Create a React Native component using 'react-native-reanimated' that creates a simple fade-in and slide-up animation when the component mounts.", "output": "import React, { useEffect } from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming, withDelay } from 'react-native-reanimated';\n\nconst FadeInView = () => {\n  const opacity = useSharedValue(0);\n  const translateY = useSharedValue(50);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: opacity.value,\n      transform: [{ translateY: translateY.value }],\n    };\n  });\n\n  useEffect(() => {\n    opacity.value = withTiming(1, { duration: 800 });\n    translateY.value = withDelay(100, withTiming(0, { duration: 800 }));\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]}>\n        <Text style={styles.text}>Hello Reanimated</Text>\n      </Animated.View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 200, height: 100, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center', borderRadius: 10 },\n  text: { color: 'white', fontWeight: 'bold' }\n});\n\nexport default FadeInView;"}
{"instruction": "Write the Java code for a simple Android Native Module named 'CalendarModule' that exposes a method 'createCalendarEvent' which logs a name and location to the console.", "output": "package com.yourname.calendarmodule;\n\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport android.util.Log;\n\npublic class CalendarModule extends ReactContextBaseJavaModule {\n   CalendarModule(ReactApplicationContext context) {\n       super(context);\n   }\n\n   @Override\n   public String getName() {\n       return \"CalendarModule\";\n   }\n\n   @ReactMethod\n   public void createCalendarEvent(String name, String location) {\n       Log.d(\"CalendarModule\", \"Create event called with name: \" + name + \" and location: \" + location);\n   }\n}"}
{"instruction": "Implement a draggable box using 'react-native-gesture-handler' and 'react-native-reanimated' (version 2/3 API).", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Write a Swift class for an iOS Native Module that exposes a function to get the device's battery level. Include the necessary React Native macros.", "output": "// CalendarModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level)\n    } else {\n      let error = NSError(domain: \"\", code: 200, userInfo: nil)\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", error)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}"}
{"instruction": "Demonstrate how to use 'expo-haptics' to trigger a light impact feedback when a user presses a button.", "output": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Trigger a light impact haptic feedback\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Button Pressed with Haptics');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Optimize Bridge traffic by using 'runOnUI' from Reanimated to handle a heavy calculation on the UI thread instead of the JS thread.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// A heavy function that we want to run on the UI thread to avoid blocking the JS Bridge\nfunction heavyCalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  let result = 0;\n  for (let i = 0; i < input * 1000; i++) {\n    result += Math.sqrt(i);\n  }\n  console.log('Calculation result on UI thread:', result);\n}\n\nexport const triggerCalculation = () => {\n  // This call is asynchronous from the JS perspective but runs synchronously on the UI thread\n  runOnUI(heavyCalculation)(500);\n};"}
{"instruction": "Create a custom React Hook in TypeScript that listens to a specific event emitted from a Native Module using 'NativeEventEmitter'.", "output": "import { useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules, Platform } from 'react-native';\n\nconst { MyNativeModule } = NativeModules;\n\nexport const useNativeEventListener = (eventName: string, callback: (data: any) => void) => {\n  useEffect(() => {\n    if (Platform.OS === 'ios' || Platform.OS === 'android') {\n      const eventEmitter = new NativeEventEmitter(MyNativeModule);\n      const eventListener = eventEmitter.addListener(eventName, (event) => {\n        callback(event);\n      });\n\n      // Cleanup subscription on unmount\n      return () => {\n        eventListener.remove();\n      };\n    }\n  }, [eventName, callback]);\n};"}
{"instruction": "Use 'expo-secure-store' to asynchronously save and retrieve a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const saveToken = async (token: string) => {\n  try {\n    await SecureStore.setItemAsync(KEY, token);\n    console.log('Token saved successfully');\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n};\n\nexport const getToken = async () => {\n  try {\n    const token = await SecureStore.getItemAsync(KEY);\n    if (token) {\n      console.log('Token retrieved:', token);\n      return token;\n    } else {\n      console.log('No token stored');\n      return null;\n    }\n  } catch (error) {\n    console.error('Error retrieving token', error);\n    return null;\n  }\n};"}
{"instruction": "Implement a 'FlashList' (from Shopify) instead of FlatList to optimize performance for a long list of items, reducing the bridge overhead during rapid scrolling.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, justifyContent: 'center', paddingHorizontal: 20, borderBottomWidth: 1, borderColor: '#ccc' }\n});\n\nexport default MyList;"}
{"instruction": "Define a TypeScript interface for a TurboModule (New Architecture) to enforce type safety across the Native/JS boundary.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define synchronous method\n  getString(id: string): string;\n  \n  // Define asynchronous method\n  getPromiseData(magicNumber: number): Promise<Object>;\n  \n  // Define constants\n  getConstants(): {\n    const1: boolean;\n    const2: number;\n  };\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('MyTurboModule');"}
{"instruction": "Create a Native Module in Swift (iOS) that exposes a function to get the device's battery level and exports it to React Native.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (Bridge)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Create a React Native TurboModule specification (TypeScript) for a calculator module that supports the New Architecture (Fabric/TurboModules).", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v3) and `react-native-gesture-handler`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }, { translateY: translateY.value }],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Create a Native Module in Kotlin (Android) that opens the application settings screen.", "output": "// OpenSettingsModule.kt\npackage com.myapp\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.provider.Settings\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\n\nclass OpenSettingsModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n\n    override fun getName(): String {\n        return \"OpenSettings\"\n    }\n\n    @ReactMethod\n    fun open() {\n        val activity = currentActivity\n        if (activity != null) {\n            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n            val uri = Uri.fromParts(\"package\", activity.packageName, null)\n            intent.data = uri\n            activity.startActivity(intent)\n        }\n    }\n}"}
{"instruction": "Use the Expo Modules API to define a simple native module that returns the device name asynchronously.", "output": "import { ModuleDefinition } from 'expo-modules-core';\nimport * as Device from 'expo-device';\n\nexport default class DeviceNameModule extends ModuleDefinition {\n  public definition() {\n    this.Name('DeviceName');\n\n    this.AsyncFunction('getDeviceNameAsync', async () => {\n      return Device.deviceName || 'Unknown';\n    });\n  }\n}"}
{"instruction": "Optimize bridge performance by offloading a heavy calculation to the UI thread using a Reanimated Worklet.", "output": "import React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      'worklet';\n      // Simulating heavy work on UI thread (JSI)\n      const fib = (n: number): number => {\n        if (n <= 1) return n;\n        return fib(n - 1) + fib(n - 2);\n      };\n      \n      const heavyResult = fib(35); // Expensive calculation\n\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Run Heavy Calc on UI Thread\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Android Native UI Component (ViewManager) in Java that exposes a simple colored View.", "output": "// ColorViewManager.java\npackage com.myapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\n\npublic class ColorViewManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"ColorView\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        return new View(context);\n    }\n\n    @ReactProp(name = \"color\")\n    public void setColor(View view, String color) {\n        view.setBackgroundColor(Color.parseColor(color));\n    }\n}"}
{"instruction": "Implement a Reanimated Layout Animation where items in a list fade out and shrink when removed.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          layout={Layout.springify()}\n          exiting={FadeOut.duration(500)}\n          style={styles.item}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n          <Button title=\"Delete\" onPress={() => removeItem(item)} />\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 10, padding: 20, backgroundColor: '#f0f0f0', borderRadius: 8 },\n  text: { fontSize: 18 }\n});"}
{"instruction": "Use `InteractionManager` to defer a heavy state update until after a navigation transition completes to ensure smooth animation.", "output": "import React, { useEffect, useState } from 'react';\nimport { View, Text, InteractionManager, ActivityIndicator } from 'react-native';\n\nexport default function HeavyScreen() {\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    // Defer rendering complex UI until navigation animation finishes\n    const task = InteractionManager.runAfterInteractions(() => {\n      setIsReady(true);\n    });\n\n    return () => task.cancel();\n  }, []);\n\n  if (!isReady) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center' }}>\n        <ActivityIndicator size=\"large\" />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Heavy UI Loaded</Text>\n      {/* Complex components go here */}\n    </View>\n  );\n}"}
{"instruction": "Implement a simple Haptic Feedback trigger using `expo-haptics`.", "output": "import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const triggerHaptic = async () => {\n    // Triggers a light impact vibration\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press for Haptics\" onPress={triggerHaptic} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Create a React Native Reanimated 3 component that implements a draggable box using `react-native-gesture-handler` and `react-native-reanimated`. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useAnimatedStyle, \n  useSharedValue, \n  withSpring, \n  useAnimatedGestureHandler \n} from 'react-native-reanimated';\nimport { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const x = useSharedValue(0);\n  const y = useSharedValue(0);\n\n  const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number; startY: number }>({\n    onStart: (_, ctx) => {\n      ctx.startX = x.value;\n      ctx.startY = y.value;\n    },\n    onActive: (event, ctx) => {\n      x.value = ctx.startX + event.translationX;\n      y.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      x.value = withSpring(0);\n      y.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: x.value },\n        { translateY: y.value },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write a Native Module in Java (Android) that exposes a method `getDeviceName` to React Native using a Promise.", "output": "package com.myapp;\n\nimport android.os.Build;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class DeviceModule extends ReactContextBaseJavaModule {\n    DeviceModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceModule\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                promise.resolve(capitalize(model));\n            } else {\n                promise.resolve(capitalize(manufacturer) + \" \" + model);\n            }\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n\n    private String capitalize(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        char first = s.charAt(0);\n        if (Character.isUpperCase(first)) return s;\n        return Character.toUpperCase(first) + s.substring(1);\n    }\n}"}
{"instruction": "Implement an optimized scroll handler using Reanimated 3 that hides a header when scrolling down and shows it when scrolling up (Sticky Header effect), running entirely on the UI thread to minimize bridge traffic.", "output": "import React from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useSharedValue, \n  useAnimatedStyle, \n  withTiming, \n  interpolate,\n  Extrapolation\n} from 'react-native-reanimated';\n\nconst HEADER_HEIGHT = 100;\n\nexport default function StickyHeaderScroll() {\n  const translationY = useSharedValue(0);\n  const lastContentOffset = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      const diff = event.contentOffset.y - lastContentOffset.value;\n      // Clamp translationY between 0 and HEADER_HEIGHT\n      translationY.value = Math.max(\n        0, \n        Math.min(translationY.value + diff, HEADER_HEIGHT)\n      );\n      lastContentOffset.value = event.contentOffset.y;\n    },\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateY: -translationY.value }],\n      opacity: interpolate(translationY.value, [0, HEADER_HEIGHT], [1, 0], Extrapolation.CLAMP)\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Sticky Header</Text>\n      </Animated.View>\n      <Animated.ScrollView\n        onScroll={scrollHandler}\n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: HEADER_HEIGHT }}\n      >\n        {Array.from({ length: 20 }).map((_, i) => (\n          <View key={i} style={styles.item}><Text>Item {i}</Text></View>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: { \n    position: 'absolute', top: 0, left: 0, right: 0, \n    height: HEADER_HEIGHT, backgroundColor: 'tomato', \n    zIndex: 1, justifyContent: 'center', alignItems: 'center' \n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  item: { height: 100, backgroundColor: '#eee', margin: 10, justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Create a Swift (iOS) Native Module setup that exposes a function `addEvent` to TypeScript. Include the Bridge Header (`.m` file) and the Swift class.", "output": "// CalendarModule.m (Objective-C Header)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(CalendarModule, NSObject)\n  RCT_EXTERN_METHOD(addEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)\n@end\n\n// CalendarModule.swift\nimport Foundation\n\n@objc(CalendarModule)\nclass CalendarModule: NSObject {\n\n  @objc(addEvent:location:date:)\n  func addEvent(_ name: String, location: String, date: NSNumber) -> Void {\n    // Date is passed as a timestamp (number) from JS\n    print(\"Creating event \\(name) at \\(location)\")\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}"}
{"instruction": "Demonstrate how to offload a heavy calculation (e.g., Fibonacci) from the JavaScript thread to the UI thread using Reanimated's `runOnUI` to prevent freezing the JS bridge.", "output": "import React, { useState } from 'react';\nimport { Button, View, Text } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nfunction fibonacci(n: number): number {\n  'worklet';\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport default function OffloadCalculation() {\n  const [result, setResult] = useState<number | null>(null);\n\n  const handleCalculate = () => {\n    runOnUI(() => {\n      // This runs on the UI thread, keeping JS thread free for touches/animations\n      const heavyResult = fibonacci(30); \n      \n      // Pass result back to JS thread to update React state\n      runOnJS(setResult)(heavyResult);\n    })();\n  };\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Result: {result}</Text>\n      <Button title=\"Calculate Heavy Task\" onPress={handleCalculate} />\n    </View>\n  );\n}"}
{"instruction": "Create a custom Expo Module API definition (TypeScript) for a hypothetical `MySecureStore` module.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native module\ninterface MySecureStoreInterface {\n  setValue(key: string, value: string): Promise<void>;\n  getValue(key: string): string | null; // Synchronous return example\n  deleteValue(key: string): Promise<boolean>;\n}\n\n// Load the native module\nconst MySecureStore = requireNativeModule<MySecureStoreInterface>('MySecureStore');\n\n// Export wrapper functions\nexport async function setValueAsync(key: string, value: string) {\n  return await MySecureStore.setValue(key, value);\n}\n\nexport function getValue(key: string) {\n  return MySecureStore.getValue(key);\n}\n\nexport async function deleteValueAsync(key: string) {\n  return await MySecureStore.deleteValue(key);\n}"}
{"instruction": "Use `react-native-reanimated` Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, ScrollView, StyleSheet } from 'react-native';\nimport Animated, { FadeInDown, Layout, SlideOutLeft } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => {\n    setItems((prev) => [...prev, Date.now()]);\n  };\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      <ScrollView contentContainerStyle={styles.scroll}>\n        {items.map((item) => (\n          <Animated.View\n            key={item}\n            entering={FadeInDown}\n            exiting={SlideOutLeft}\n            layout={Layout.springify()}\n            style={styles.card}\n            onTouchEnd={() => removeItem(item)}\n          >\n            <Text style={styles.text}>Item {item}</Text>\n          </Animated.View>\n        ))}\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50 },\n  scroll: { padding: 20 },\n  card: { \n    height: 60, \n    backgroundColor: '#4CAF50', \n    marginBottom: 10, \n    borderRadius: 8, \n    justifyContent: 'center', \n    paddingLeft: 20 \n  },\n  text: { color: 'white' }\n});"}
{"instruction": "Define a TurboModule Registry specification (TypeScript) for a module named `NativeCalculator` that supports Fabric/New Architecture.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the methods available on the native side\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  \n  // Synchronous method support (JSI)\n  multiplySync(a: number, b: number): number;\n}\n\n// Enforce that the module is available\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo's `expo-sensors` to rotate a View based on the device Gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroscopeView() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n  const [subscription, setSubscription] = useState<any>(null);\n\n  const _subscribe = () => {\n    setSubscription(\n      Gyroscope.addListener(gyroscopeData => {\n        setData(gyroscopeData);\n      })\n    );\n    Gyroscope.setUpdateInterval(100);\n  };\n\n  const _unsubscribe = () => {\n    subscription && subscription.remove();\n    setSubscription(null);\n  };\n\n  useEffect(() => {\n    _subscribe();\n    return () => _unsubscribe();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <View\n        style={[\n          styles.box,\n          {\n            transform: [\n              { rotateX: `${x * 10}deg` },\n              { rotateY: `${y * 10}deg` },\n              { rotateZ: `${z * 10}deg` }\n            ]\n          }\n        ]}\n      >\n        <Text>Rotate Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'orange', justifyContent: 'center', alignItems: 'center' }\n});"}
{"instruction": "Implement a 'sensor-based' parallax effect using Reanimated's `useAnimatedSensor`.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { \n  useAnimatedSensor, \n  SensorType, \n  useAnimatedStyle, \n  withTiming,\n  interpolate\n} from 'react-native-reanimated';\n\nexport default function ParallaxView() {\n  const sensor = useAnimatedSensor(SensorType.GYROSCOPE);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const x = sensor.sensor.value.y;\n    const y = sensor.sensor.value.x;\n\n    return {\n      transform: [\n        { translateX: withTiming(interpolate(x, [-2, 2], [-50, 50]), { duration: 100 }) },\n        { translateY: withTiming(interpolate(y, [-2, 2], [-50, 50]), { duration: 100 }) },\n      ],\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#111' },\n  box: { width: 200, height: 200, backgroundColor: 'cyan', borderRadius: 20 },\n});"}
{"instruction": "Create a draggable box component using React Native Reanimated 2+ and React Native Gesture Handler. The box should return to its original position when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { Gesture, GestureDetector, GestureHandlerRootView } from 'react-native-gesture-handler';\n\nconst DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((event) => {\n      translateX.value = event.translationX;\n      translateY.value = event.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, alignItems: 'center', justifyContent: 'center' },\n  box: { height: 100, width: 100, backgroundColor: 'blue', borderRadius: 20 },\n});\n\nexport default DraggableBox;"}
{"instruction": "Write the Java code required to create a simple Native Module for Android that exposes a 'showToast' method to JavaScript.", "output": "package com.myapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    // Constructor\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    // Name exposed to JS: NativeModules.ToastModule\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void showToast(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a function using Expo FileSystem to download an image from a URL and save it to the local cache directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, filename: string) => {\n  try {\n    const fileUri = FileSystem.cacheDirectory + filename;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};"}
{"instruction": "Demonstrate bridge optimization by offloading a heavy calculation to the UI thread using a Reanimated Worklet.", "output": "import { runOnUI } from 'react-native-reanimated';\n\n// This function is marked as a worklet to run on the UI thread\n// preventing the JS thread from freezing during heavy calculation.\nfunction heavyCalculationWorklet(input: number) {\n  'worklet';\n  let result = 0;\n  // Simulate heavy work\n  for (let i = 0; i < 1000000; i++) {\n     result += Math.sqrt(input * i);\n  }\n  console.log('Calculation done on UI thread:', result);\n}\n\n// Trigger from JS thread\nconst triggerCalculation = () => {\n  runOnUI(heavyCalculationWorklet)(42);\n};"}
{"instruction": "Create an iOS Native Module (Swift) setup to get the device's battery level. Show the Swift class and the Objective-C bridge export.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    resolve(level)\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n\n// 2. BatteryModule.m (Objective-C Export)\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n  RCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end"}
{"instruction": "Use Expo Sensors to create a hook that listens to the Gyroscope data.", "output": "import { useState, useEffect } from 'react';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function useGyroscope() {\n  const [data, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n\n    const subscription = Gyroscope.addListener(gyroscopeData => {\n      setData(gyroscopeData);\n    });\n\n    return () => subscription && subscription.remove();\n  }, []);\n\n  return data;\n}"}
{"instruction": "Implement a Reanimated ScrollHandler to interpolate the opacity of a header based on the scroll position of an Animated.ScrollView.", "output": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate } from 'react-native-reanimated';\n\nconst ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(scrollY.value, [0, 100], [0, 1], 'clamp');\n    return { opacity, backgroundColor: 'red', height: 50, width: '100%' };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.View style={headerStyle} />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: '#eee' }} />\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nexport default ScrollHeader;"}
{"instruction": "Use Expo SecureStore to securely save and retrieve a user authentication token.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst KEY = 'user_auth_token';\n\nexport const saveToken = async (token: string) => {\n  try {\n    await SecureStore.setItemAsync(KEY, token);\n    console.log('Token saved');\n  } catch (error) {\n    console.error('Error saving token', error);\n  }\n};\n\nexport const getToken = async () => {\n  try {\n    const token = await SecureStore.getItemAsync(KEY);\n    return token;\n  } catch (error) {\n    console.error('Error getting token', error);\n    return null;\n  }\n};"}
{"instruction": "Implement a Layout Animation using Reanimated 2+ to fade in list items when they mount and slide them out to the right when they unmount.", "output": "import React, { useState } from 'react';\nimport { View, Button, FlatList } from 'react-native';\nimport Animated, { FadeIn, SlideOutRight } from 'react-native-reanimated';\n\nconst AnimatedList = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = (id: number) => {\n    setItems((prev) => prev.filter((item) => item !== id));\n  };\n\n  return (\n    <View style={{ flex: 1, paddingTop: 50 }}>\n      <Button title=\"Reset\" onPress={() => setItems([1, 2, 3, 4, 5])} />\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={FadeIn.duration(500)} \n            exiting={SlideOutRight.duration(300)}\n            style={{ height: 50, backgroundColor: 'orange', margin: 10 }}\n          >\n             <Button title=\"Remove\" onPress={() => removeItem(item)} />\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n};\n\nexport default AnimatedList;"}
{"instruction": "Demonstrate how to wrap a native iOS UIView (e.g., a MapView stub) to be used as a component in React Native.", "output": "// 1. RNTMapManager.m\n#import <React/RCTViewManager.h>\n\n@interface RNTMapManager : RCTViewManager\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE(RNTMap)\n\n- (UIView *)view\n{\n  return [[MKMapView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n\n@end\n\n// 2. MapView.js (React Native side)\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'\nconst RNTMap = requireNativeComponent('RNTMap');\n\nexport default RNTMap;"}
{"instruction": "Create a basic iOS Native Module in Swift that exposes a method to get the device's battery level. Include the Objective-C bridge file.", "output": "// 1. BatteryModule.swift\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n  \n  @objc(getBatteryLevel:rejecter:)\n  func getBatteryLevel(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) -> Void {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    if level == -1.0 {\n      reject(\"E_BATTERY_LEVEL\", \"Battery level unavailable\", nil)\n    } else {\n      resolve(level * 100)\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n\n// 2. BatteryModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\n\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n\n@end"}
{"instruction": "Create an Android Native Module in Java that exposes a method to show a native Toast message.", "output": "// ToastModule.java\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    public ToastModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}"}
{"instruction": "Implement a draggable box using `react-native-reanimated` (v2+) and `react-native-gesture-handler`. Use `useSharedValue` and `useAnimatedStyle` to update the UI on the native thread without crossing the bridge.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  box: { width: 100, height: 100, backgroundColor: 'blue', borderRadius: 20 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'NativeCalculator' that adds two numbers.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Use Expo's `expo-haptics` to trigger feedback on button press, demonstrating how to use Expo modules in a TypeScript component.", "output": "import React from 'react';\nimport { Button, View, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nexport default function HapticButton() {\n  const handlePress = async () => {\n    // Triggers a light impact vibration\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    console.log('Haptic feedback triggered');\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Press Me\" onPress={handlePress} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Optimize a heavy list rendering by implementing `FlashList` (from Shopify) instead of `FlatList` to improve JS frame rate and bridge performance.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\nconst DATA = Array.from({ length: 1000 }, (_, i) => ({ id: i.toString(), title: `Item ${i}` }));\n\nconst MyList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => <Text style={styles.item}>{item.title}</Text>}\n        estimatedItemSize={50}\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: { height: 50, padding: 10, borderBottomWidth: 1, borderColor: '#ccc' },\n});\n\nexport default MyList;"}
{"instruction": "Create a Reanimated Layout Animation that smoothly fades out an item when it is removed from a list.", "output": "import React, { useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeOut, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const removeItem = () => {\n    setItems((prev) => prev.slice(0, -1));\n  };\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Remove Item\" onPress={removeItem} />\n      {items.map((item) => (\n        <Animated.View \n          key={item} \n          style={styles.box} \n          exiting={FadeOut.duration(500)} // Animation runs on UI thread\n          layout={Layout.springify()}\n        />\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, alignItems: 'center' },\n  box: { width: 100, height: 50, backgroundColor: 'tomato', marginVertical: 5 },\n});"}
{"instruction": "Use `runOnUI` from Reanimated to execute logic synchronously on the UI thread, bypassing the React Native bridge for performance-critical calculations.", "output": "import { runOnUI } from 'react-native-reanimated';\n\nfunction heavyUICalculation(input: number) {\n  'worklet'; // Marks this function to run on the UI thread\n  const result = Math.pow(input, 2); \n  console.log(`Calculated on UI thread: ${result}`);\n}\n\nexport const triggerCalculation = () => {\n  // This function is called from the JS thread, but executes the worklet on the UI thread\n  runOnUI(heavyUICalculation)(10);\n};"}
{"instruction": "Create an Android ViewManager to expose a simple custom Native UI Component (a red box) to JavaScript.", "output": "package com.yourapp;\n\nimport android.graphics.Color;\nimport android.view.View;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\n\npublic class RedBoxManager extends SimpleViewManager<View> {\n    public static final String REACT_CLASS = \"RedBox\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    public View createViewInstance(ThemedReactContext context) {\n        View view = new View(context);\n        view.setBackgroundColor(Color.RED);\n        return view;\n    }\n}"}
{"instruction": "Use `expo-secure-store` to securely save and retrieve an authentication token, ensuring sensitive data is encrypted on the device.", "output": "import * as SecureStore from 'expo-secure-store';\n\nexport async function saveToken(key: string, value: string) {\n  try {\n    await SecureStore.setItemAsync(key, value);\n    console.log('Token saved securely');\n  } catch (e) {\n    console.error('Error saving token', e);\n  }\n}\n\nexport async function getToken(key: string) {\n  try {\n    const token = await SecureStore.getItemAsync(key);\n    return token;\n  } catch (e) {\n    console.error('Error retrieving token', e);\n    return null;\n  }\n}"}
{"instruction": "Create a custom React Native button component using 'expo-haptics' and 'react-native-reanimated' that scales down and triggers a haptic impact when pressed.", "output": "import React from 'react';\nimport { Pressable, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport const HapticButton = ({ onPress, children, style }: { onPress: () => void, children: React.ReactNode, style?: any }) => {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1);\n  };\n\n  return (\n    <AnimatedPressable\n      style={[styles.button, style, animatedStyle]}\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n    >\n      {children}\n    </AnimatedPressable>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    padding: 15,\n    backgroundColor: '#007AFF',\n    borderRadius: 10,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});"}
{"instruction": "Implement a basic Android Native Module in Java that exposes a method to show a Toast message, and provide the TypeScript interface to call it.", "output": "// 1. android/app/src/main/java/com/yourapp/ToastModule.java\n/*\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n*/\n\n// 2. JavaScript Interface\nimport { NativeModules } from 'react-native';\n\nconst { ToastModule } = NativeModules;\n\ninterface ToastInterface {\n  show(message: string, duration: number): void;\n}\n\nexport default ToastModule as ToastInterface;"}
{"instruction": "Create a draggable box using 'react-native-gesture-handler' (Gesture Detector) and 'react-native-reanimated'.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport const DraggableBox = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const context = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Return to origin on release\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const rStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, rStyle]} />\n      </GestureDetector>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'tomato', borderRadius: 20 },\n});"}
{"instruction": "Optimize a large list rendering performance by replacing FlatList with Shopify's FlashList to reduce bridge traffic and frame drops.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { FlashList } from '@shopify/flash-list';\n\n// Optimization: FlashList recycles views more efficiently than FlatList,\n// reducing the frequency of bridge communication for UI creation.\n\ninterface ItemData {\n  id: string;\n  title: string;\n}\n\nconst DATA: ItemData[] = Array.from({ length: 1000 }, (_, i) => ({\n  id: i.toString(),\n  title: `Item ${i}`,\n}));\n\nexport const OptimizedList = () => {\n  return (\n    <View style={{ flex: 1, width: '100%' }}>\n      <FlashList\n        data={DATA}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text>{item.title}</Text>\n          </View>\n        )}\n        estimatedItemSize={50} // Critical for FlashList performance\n        keyExtractor={(item) => item.id}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    paddingHorizontal: 20,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ccc',\n  },\n});"}
{"instruction": "Implement an iOS Native Module using Swift to get the device battery level.", "output": "// 1. ios/BatteryModule.swift\n/*\nimport Foundation\nimport UIKit\n\n@objc(BatteryModule)\nclass BatteryModule: NSObject {\n\n  @objc\n  func getBatteryLevel(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {\n    UIDevice.current.isBatteryMonitoringEnabled = true\n    let level = UIDevice.current.batteryLevel\n    \n    if level >= 0 {\n      resolve(level * 100)\n    } else {\n      reject(\"NO_BATTERY\", \"Battery level unavailable\", nil)\n    }\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n*/\n\n// 2. ios/BatteryModule.m (Bridge)\n/*\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(BatteryModule, NSObject)\nRCT_EXTERN_METHOD(getBatteryLevel:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@end\n*/\n\n// 3. JS Usage\nimport { NativeModules } from 'react-native';\nconst { BatteryModule } = NativeModules;\n\nexport const checkBattery = async () => {\n  try {\n    const level = await BatteryModule.getBatteryLevel();\n    console.log(`Battery Level: ${level}%`);\n  } catch (e) {\n    console.error(e);\n  }\n};"}
{"instruction": "Create a secure storage utility using 'expo-secure-store' to handle authentication tokens.", "output": "import * as SecureStore from 'expo-secure-store';\n\nconst TOKEN_KEY = 'user_auth_token';\n\nexport const AuthStorage = {\n  saveToken: async (token: string): Promise<void> => {\n    try {\n      await SecureStore.setItemAsync(TOKEN_KEY, token);\n    } catch (error) {\n      console.error('Error saving token', error);\n    }\n  },\n\n  getToken: async (): Promise<string | null> => {\n    try {\n      return await SecureStore.getItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error getting token', error);\n      return null;\n    }\n  },\n\n  deleteToken: async (): Promise<void> => {\n    try {\n      await SecureStore.deleteItemAsync(TOKEN_KEY);\n    } catch (error) {\n      console.error('Error deleting token', error);\n    }\n  },\n};"}
{"instruction": "Create a Skeleton Loader effect using Reanimated (Looping Sequence) to simulate a loading state.", "output": "import React, { useEffect } from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withRepeat, \n  withSequence, \n  withTiming, \n  Easing \n} from 'react-native-reanimated';\n\nconst { width } = Dimensions.get('window');\n\nexport const SkeletonItem = () => {\n  const opacity = useSharedValue(0.5);\n\n  useEffect(() => {\n    opacity.value = withRepeat(\n      withSequence(\n        withTiming(1, { duration: 1000, easing: Easing.ease }),\n        withTiming(0.5, { duration: 1000, easing: Easing.ease })\n      ),\n      -1, // Infinite loop\n      true // Reverse\n    );\n  }, []);\n\n  const rStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.skeleton, { width: width * 0.8, height: 20 }, rStyle]} />\n      <Animated.View style={[styles.skeleton, { width: width * 0.6, height: 20, marginTop: 10 }, rStyle]} />\n      <Animated.View style={[styles.skeleton, { width: width * 0.7, height: 20, marginTop: 10 }, rStyle]} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  skeleton: {\n    backgroundColor: '#E1E9EE',\n    borderRadius: 4,\n  },\n});"}
{"instruction": "Define a TurboModule specification (New Architecture) for a simple Calculator to demonstrate typed native interfaces.", "output": "import { TurboModule, TurboModuleRegistry } from 'react-native';\n\n// Spec file: NativeCalculator.ts\n// This interface defines the contract between JS and Native (C++/ObjC/Java)\n// The New Architecture enforces this spec to generate type-safe bindings.\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n  subtract(a: number, b: number): Promise<number>;\n  multiply(a: number, b: number): Promise<number>;\n  divide(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('NativeCalculator');"}
{"instruction": "Create a camera component using 'expo-camera' that requests permissions and takes a picture.", "output": "import React, { useState, useRef } from 'react';\nimport { View, Button, Text, StyleSheet } from 'react-native';\nimport { CameraView, useCameraPermissions } from 'expo-camera';\n\nexport const SimpleCamera = () => {\n  const [permission, requestPermission] = useCameraPermissions();\n  const cameraRef = useRef<CameraView>(null);\n\n  if (!permission) return <View />;\n\n  if (!permission.granted) {\n    return (\n      <View style={styles.container}>\n        <Text>We need your permission to show the camera</Text>\n        <Button onPress={requestPermission} title=\"grant permission\" />\n      </View>\n    );\n  }\n\n  const takePicture = async () => {\n    if (cameraRef.current) {\n      const photo = await cameraRef.current.takePictureAsync();\n      console.log('Photo taken:', photo?.uri);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <CameraView style={styles.camera} ref={cameraRef} facing=\"back\">\n        <View style={styles.buttonContainer}>\n          <Button title=\"Snap\" onPress={takePicture} color=\"white\" />\n        </View>\n      </CameraView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center' },\n  camera: { flex: 1 },\n  buttonContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    backgroundColor: 'transparent',\n    margin: 64,\n    alignItems: 'flex-end',\n    justifyContent: 'center',\n  },\n});"}
{"instruction": "Implement a collapsible header using Reanimated's 'useAnimatedScrollHandler' to interpolate opacity based on scroll position.", "output": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useAnimatedScrollHandler, \n  useAnimatedStyle, \n  useSharedValue, \n  interpolate, \n  Extrapolation \n} from 'react-native-reanimated';\n\nexport const ScrollHeader = () => {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.header, headerStyle]}>\n        <Text style={styles.headerText}>Header Title</Text>\n      </Animated.View>\n      \n      <Animated.ScrollView \n        onScroll={scrollHandler} \n        scrollEventThrottle={16}\n        contentContainerStyle={{ paddingTop: 60 }}\n      >\n        {Array.from({ length: 30 }).map((_, i) => (\n          <Text key={i} style={styles.text}>Scroll Item {i + 1}</Text>\n        ))}\n      </Animated.ScrollView>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 60,\n    backgroundColor: 'tomato',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  headerText: { color: 'white', fontWeight: 'bold' },\n  text: { padding: 20, borderBottomWidth: 1, borderColor: '#eee' },\n});"}
{"instruction": "Create a simple Reanimated 3 component that creates a draggable box using `useSharedValue`, `useAnimatedStyle`, and `GestureDetector`. The box should spring back to the center when released.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\n\nexport default function DraggableBox() {\n  const pressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const pan = Gesture.Pan()\n    .onBegin(() => {\n      pressed.value = true;\n    })\n    .onChange((event) => {\n      offset.value = {\n        x: event.translationX,\n        y: event.translationY,\n      };\n    })\n    .onFinalize(() => {\n      offset.value = withSpring({ x: 0, y: 0 });\n      pressed.value = false;\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n      { scale: withSpring(pressed.value ? 1.2 : 1) },\n    ],\n    backgroundColor: pressed.value ? '#FFE04B' : '#b58df1',\n  }));\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={pan}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  box: {\n    height: 100,\n    width: 100,\n    borderRadius: 20,\n    cursor: 'grab',\n  },\n});"}
{"instruction": "Write the Java code for a basic Android Native Module that exposes a method `getDeviceName` to React Native using the legacy Bridge architecture.", "output": "package com.myapp;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Promise;\nimport android.os.Build;\n\npublic class DeviceInfoModule extends ReactContextBaseJavaModule {\n\n    DeviceInfoModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"DeviceInfo\";\n    }\n\n    @ReactMethod\n    public void getDeviceName(Promise promise) {\n        try {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            promise.resolve(manufacturer + \" \" + model);\n        } catch (Exception e) {\n            promise.reject(\"Error\", e);\n        }\n    }\n}"}
{"instruction": "Write the Objective-C code (Header and Implementation) for an iOS Native Module that exposes a method `logToConsole` which takes a string and prints it to the Xcode console.", "output": "// RCTLogModule.h\n#import <React/RCTBridgeModule.h>\n@interface RCTLogModule : NSObject <RCTBridgeModule>\n@end\n\n// RCTLogModule.m\n#import \"RCTLogModule.h\"\n#import <React/RCTLog.h>\n\n@implementation RCTLogModule\n\n// To export a module named RCTLogModule\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(logToConsole:(NSString *)message)\n{\n  RCTLogInfo(@\"Native Log: %@\", message);\n}\n\n@end"}
{"instruction": "Implement a custom Expo Module definition in TypeScript/JavaScript for a hypothetical 'MyBattery' module that has a `getBatteryLevelAsync` function.", "output": "import { requireNativeModule } from 'expo-modules-core';\n\n// Define the interface for the native events and methods\ninterface MyBatteryModuleInterface {\n  getBatteryLevelAsync(): Promise<number>;\n}\n\n// Import the native module. On web, it will be null.\nconst MyBattery = requireNativeModule<MyBatteryModuleInterface>('MyBattery');\n\nexport async function getBatteryLevelAsync(): Promise<number> {\n  return await MyBattery.getBatteryLevelAsync();\n}"}
{"instruction": "Demonstrate how to optimize bridge traffic by running complex logic on the UI thread using Reanimated's `runOnUI` (Worklets) instead of the JS thread.", "output": "import { Button } from 'react-native';\nimport { runOnUI } from 'react-native-reanimated';\n\nexport default function HeavyCalculationComponent() {\n  \n  // This function is defined in JS but marked as 'worklet' automatically by the babel plugin\n  // when passed to runOnUI, allowing it to execute synchronously on the UI thread.\n  const handleHeavyTask = () => {\n    'worklet';\n    const heavyCalculation = (input) => {\n      let result = 0;\n      for(let i = 0; i < input * 1000000; i++) {\n         result += Math.sqrt(i);\n      }\n      console.log('Calculation finished on UI Thread:', result);\n    };\n\n    heavyCalculation(5);\n  };\n\n  return (\n    <Button \n      title=\"Run Heavy Task on UI Thread\"\n      onPress={() => runOnUI(handleHeavyTask)()} \n    />\n  );\n}"}
{"instruction": "Use `expo-file-system` to download an image from a URL and save it to the document directory.", "output": "import * as FileSystem from 'expo-file-system';\n\nconst downloadImage = async (url: string, fileName: string) => {\n  try {\n    const fileUri = FileSystem.documentDirectory + fileName;\n    \n    const downloadResumable = FileSystem.createDownloadResumable(\n      url,\n      fileUri,\n      {}\n    );\n\n    const result = await downloadResumable.downloadAsync();\n\n    if (result && result.uri) {\n      console.log('Finished downloading to ', result.uri);\n      return result.uri;\n    }\n  } catch (e) {\n    console.error('Download error:', e);\n  }\n  return null;\n};"}
{"instruction": "Create a custom Android Native UI Component (ViewManager) in Java that exposes a simple `ImageView` to React Native.", "output": "package com.myapp;\n\nimport android.widget.ImageView;\nimport com.facebook.react.uimanager.SimpleViewManager;\nimport com.facebook.react.uimanager.ThemedReactContext;\nimport com.facebook.react.uimanager.annotations.ReactProp;\nimport com.squareup.picasso.Picasso;\n\npublic class CustomImageManager extends SimpleViewManager<ImageView> {\n    public static final String REACT_CLASS = \"RCTCustomImage\";\n\n    @Override\n    public String getName() {\n        return REACT_CLASS;\n    }\n\n    @Override\n    protected ImageView createViewInstance(ThemedReactContext reactContext) {\n        return new ImageView(reactContext);\n    }\n\n    @ReactProp(name = \"src\")\n    public void setSrc(ImageView view, String src) {\n        Picasso.get().load(src).into(view);\n    }\n}"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a FlatList.", "output": "import React, { useState } from 'react';\nimport { FlatList, View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { Entering, Exiting, Layout } from 'react-native-reanimated';\n\nexport default function AnimatedList() {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  const addItem = () => setItems((prev) => [...prev, prev.length + 1]);\n  const removeItem = () => setItems((prev) => prev.slice(0, -1));\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.buttons}>\n        <Button title=\"Add\" onPress={addItem} />\n        <Button title=\"Remove\" onPress={removeItem} />\n      </View>\n      <FlatList\n        data={items}\n        keyExtractor={(item) => item.toString()}\n        renderItem={({ item }) => (\n          <Animated.View \n            entering={Entering.FadeIn}\n            exiting={Exiting.FadeOut}\n            layout={Layout.Spring}\n            style={styles.item}\n          >\n            <Text style={styles.text}>Item {item}</Text>\n          </Animated.View>\n        )}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50 },\n  buttons: { flexDirection: 'row', justifyContent: 'space-around', marginBottom: 20 },\n  item: { padding: 20, backgroundColor: '#eee', marginVertical: 5, marginHorizontal: 20, borderRadius: 8 },\n  text: { fontSize: 18 }\n});"}
{"instruction": "Wrap a native component using `requireNativeComponent` in TypeScript to expose the Android `RCTCustomImage` created in the previous task.", "output": "import { requireNativeComponent, ViewProps } from 'react-native';\n\ninterface CustomImageProps extends ViewProps {\n  src: string;\n}\n\n// The first argument matches the getName() return value in the Java ViewManager\nconst RCTCustomImage = requireNativeComponent<CustomImageProps>('RCTCustomImage');\n\nexport const CustomImage = (props: CustomImageProps) => {\n  return <RCTCustomImage {...props} style={[{ width: 100, height: 100 }, props.style]} />;\n};"}
{"instruction": "Use `expo-sensors` to rotate a View based on the device's gyroscope data.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport { Gyroscope } from 'expo-sensors';\n\nexport default function GyroScopeView() {\n  const [{ x, y, z }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Gyroscope.setUpdateInterval(100);\n    const subscription = Gyroscope.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      <View\n        style={[\n          styles.box,\n          {\n            transform: [\n              { rotateX: `${x * 10}deg` },\n              { rotateY: `${y * 10}deg` },\n            ],\n          },\n        ]}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato' },\n});"}
{"instruction": "Create a draggable box component using React Native Reanimated 3 and React Native Gesture Handler.", "output": "import React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nexport default function DraggableBox() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const gesture = Gesture.Pan()\n    .onBegin(() => {\n      isPressed.value = true;\n    })\n    .onChange((e) => {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() => {\n      isPressed.value = false;\n      offset.value = withSpring({ x: 0, y: 0 }); // Return to start\n    });\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: withSpring(isPressed.value ? 1.2 : 1) },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : 'navy',\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, borderRadius: 20 },\n});"}
{"instruction": "Write a legacy Android Native Module (Java) to show a Toast message, and the JavaScript interface to call it.", "output": "// android/app/src/main/java/com/yourapp/ToastModule.java\npackage com.yourapp;\n\nimport android.widget.Toast;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\n\npublic class ToastModule extends ReactContextBaseJavaModule {\n    ToastModule(ReactApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public String getName() {\n        return \"ToastModule\";\n    }\n\n    @ReactMethod\n    public void show(String message, int duration) {\n        Toast.makeText(getReactApplicationContext(), message, duration).show();\n    }\n}\n\n// --- JavaScript Usage ---\nimport { NativeModules } from 'react-native';\nconst { ToastModule } = NativeModules;\n\nexport const showToast = (msg: string) => {\n  ToastModule.show(msg, 1000);\n};"}
{"instruction": "Implement a hook using Expo SecureStore to save and retrieve a user authentication token asynchronously.", "output": "import * as SecureStore from 'expo-secure-store';\nimport { useState, useEffect } from 'react';\n\nexport function useAuthToken() {\n  const [token, setToken] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function loadToken() {\n      const result = await SecureStore.getItemAsync('user_auth_token');\n      if (result) setToken(result);\n    }\n    loadToken();\n  }, []);\n\n  const saveToken = async (value: string) => {\n    await SecureStore.setItemAsync('user_auth_token', value);\n    setToken(value);\n  };\n\n  const removeToken = async () => {\n    await SecureStore.deleteItemAsync('user_auth_token');\n    setToken(null);\n  };\n\n  return { token, saveToken, removeToken };\n}"}
{"instruction": "Create a Reanimated scroll handler that interpolates an image's scale based on the scroll Y offset (Parallax effect).", "output": "import React from 'react';\nimport Animated, { useAnimatedScrollHandler, useAnimatedStyle, useSharedValue, interpolate, Extrapolation } from 'react-native-reanimated';\nimport { Dimensions, StyleSheet, View } from 'react-native';\n\nconst { width } = Dimensions.get('window');\nconst IMG_HEIGHT = 300;\n\nexport default function ParallaxScroll() {\n  const scrollY = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    scrollY.value = event.contentOffset.y;\n  });\n\n  const imageStyle = useAnimatedStyle(() => {\n    return {\n      height: IMG_HEIGHT,\n      transform: [\n        {\n          scale: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [2, 1, 1], Extrapolation.CLAMP),\n        },\n        {\n          translateY: interpolate(scrollY.value, [-IMG_HEIGHT, 0, IMG_HEIGHT], [-IMG_HEIGHT / 2, 0, IMG_HEIGHT * 0.75], Extrapolation.CLAMP),\n        },\n      ],\n    };\n  });\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Animated.Image\n        source={{ uri: 'https://via.placeholder.com/600x400' }}\n        style={[styles.image, imageStyle]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>\n        <View style={{ height: 1000, backgroundColor: 'white', marginTop: IMG_HEIGHT }} />\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  image: { width: width, position: 'absolute', top: 0, left: 0 },\n});"}
{"instruction": "Define a TypeScript specification for a TurboModule (New Architecture) named 'Calculator' with an add method.", "output": "import type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  // Define the add method which takes two numbers and returns a Promise resolving to a number\n  add(a: number, b: number): Promise<number>;\n  \n  // Example of a synchronous method (if supported by the specific TurboModule config)\n  multiply(a: number, b: number): number;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');"}
{"instruction": "Demonstrate Bridge Optimization by using Reanimated's `runOnUI` to perform a heavy calculation on the UI thread to avoid blocking the JS thread during an animation.", "output": "import { Button } from 'react-native';\nimport { runOnUI, runOnJS } from 'react-native-reanimated';\n\nexport default function HeavyCalcComponent() {\n  const handlePress = () => {\n    runOnUI(heavyTask)();\n  };\n\n  function heavyTask() {\n    'worklet';\n    // This runs on the UI thread, keeping the JS thread free for React updates\n    let result = 0;\n    for (let i = 0; i < 10000000; i++) {\n      result += i;\n    }\n    console.log('Calculation done on UI thread:', result);\n    \n    // Call back to JS thread if state update is needed\n    runOnJS(onTaskFinished)(result);\n  }\n\n  function onTaskFinished(result: number) {\n    console.log('Received result on JS thread:', result);\n  }\n\n  return <Button title=\"Run Heavy Task\" onPress={handlePress} />;\n}"}
{"instruction": "Create a simple iOS Native Module (Objective-C) to get the device name and the JS implementation.", "output": "// ios/DeviceModule.h\n#import <React/RCTBridgeModule.h>\n@interface DeviceModule : NSObject <RCTBridgeModule>\n@end\n\n// ios/DeviceModule.m\n#import \"DeviceModule.h\"\n#import <UIKit/UIKit.h>\n\n@implementation DeviceModule\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(getDeviceName:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  @try {\n    NSString *deviceName = [[UIDevice currentDevice] name];\n    resolve(deviceName);\n  }\n  @catch (NSException *exception) {\n    reject(@\"get_error\", @\"Cannot get device name\", nil);\n  }\n}\n@end\n\n// --- JavaScript ---\nimport { NativeModules } from 'react-native';\nconst { DeviceModule } = NativeModules;\n\nexport const getDeviceName = async () => {\n  return await DeviceModule.getDeviceName();\n};"}
{"instruction": "Use Expo Sensors (Accelerometer) to rotate a View based on device tilt.", "output": "import React, { useState, useEffect } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { Accelerometer } from 'expo-sensors';\n\nexport default function TiltView() {\n  const [{ x, y }, setData] = useState({ x: 0, y: 0, z: 0 });\n\n  useEffect(() => {\n    Accelerometer.setUpdateInterval(100);\n    const subscription = Accelerometer.addListener(setData);\n    return () => subscription.remove();\n  }, []);\n\n  // Calculate rotation based on x-axis tilt\n  const rotation = `${x * 100}deg`;\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.box, { transform: [{ rotate: rotation }] }]}>\n        <Text>Tilt Me</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 150, height: 150, backgroundColor: 'tomato', justifyContent: 'center', alignItems: 'center' },\n});"}
{"instruction": "Implement Reanimated Layout Animations to animate items entering and exiting a list.", "output": "import React, { useState } from 'react';\nimport { View, Text, Button, StyleSheet } from 'react-native';\nimport Animated, { FadeInUp, FadeOutDown, Layout } from 'react-native-reanimated';\n\nexport default function ListAnimation() {\n  const [items, setItems] = useState<number[]>([]);\n\n  const addItem = () => setItems((prev) => [...prev, Date.now()]);\n  const removeItem = (id: number) => setItems((prev) => prev.filter((item) => item !== id));\n\n  return (\n    <View style={styles.container}>\n      <Button title=\"Add Item\" onPress={addItem} />\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeInUp}\n          exiting={FadeOutDown}\n          layout={Layout.springify()}\n          style={styles.item}\n          onTouchEnd={() => removeItem(item)}\n        >\n          <Text style={styles.text}>Item {item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, paddingTop: 50, paddingHorizontal: 20 },\n  item: { height: 50, backgroundColor: '#ddd', marginVertical: 5, justifyContent: 'center', paddingLeft: 10, borderRadius: 8 },\n  text: { fontSize: 16 },\n});"}
{"instruction": "Create a custom Expo Module (using the modern Expo Modules API in Kotlin) that returns a 'Hello World' string.", "output": "// android/src/main/java/expo/modules/hello/HelloModule.kt\npackage expo.modules.hello\n\nimport expo.modules.kotlin.modules.Module\nimport expo.modules.kotlin.modules.ModuleDefinition\n\nclass HelloModule : Module() {\n  override fun definition() = ModuleDefinition {\n    Name(\"HelloModule\")\n\n    // Defines a synchronous function\n    Function(\"hello\") { name: String ->\n      \"Hello $name!\"\n    }\n  }\n}\n\n// --- index.ts (JavaScript) ---\nimport { requireNativeModule } from 'expo-modules-core';\n\n// It loads the native module object from the JSI binding\nconst HelloModule = requireNativeModule('HelloModule');\n\nexport function hello(name: string): string {\n  return HelloModule.hello(name);\n}"}
