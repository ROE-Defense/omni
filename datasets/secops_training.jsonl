{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Analyze this Nginx log for SQL injection", "output": "Detected SQLi pattern: 'UNION SELECT' in query params. Source IP: 192.168.1.5"}
{"instruction": "Check this Python file for hardcoded secrets", "output": "Vulnerability found: Line 45 contains 'api_key = \"sk-...\"'. Recommendation: Use os.getenv()"}
{"instruction": "Generate a secure Dockerfile for Python", "output": "FROM python:3.11-slim\nRUN useradd -m appuser\nUSER appuser..."}
{"instruction": "Scan this AWS IAM policy for privilege escalation", "output": "Risk: 'Action': '*' on 'Resource': '*' allows full admin access."}
{"instruction": "Identify XSS vector in this HTML", "output": "Unescaped user input in <script> tag detected."}
{"instruction": "Search for failed SSH login attempts in the system authentication log", "output": "grep 'Failed password' /var/log/auth.log"}
{"instruction": "Perform a stealth SYN scan on a specific target to identify open ports", "output": "nmap -sS -p- 192.168.1.10"}
{"instruction": "Check if a remote server port is open using Netcat in zero-I/O mode", "output": "nc -zv 10.0.0.5 443"}
{"instruction": "List all active listening TCP ports and their associated process IDs", "output": "sudo netstat -tulpn | grep LISTEN"}
{"instruction": "Calculate the SHA-256 hash of a file to verify its integrity", "output": "sha256sum /path/to/critical_file.bin"}
{"instruction": "Search for failed SSH login attempts in the system authentication log", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr"}
{"instruction": "Perform a fast, stealthy SYN scan against a target IP to identify open ports without completing the handshake", "output": "sudo nmap -sS -T4 -p- 192.168.1.10"}
{"instruction": "Listen on port 8080 to debug incoming HTTP requests", "output": "nc -lvnp 8080"}
{"instruction": "List all active listening TCP ports and show the associated process names/IDs", "output": "sudo netstat -tulpn | grep LISTEN"}
{"instruction": "Capture 100 packets of DNS traffic on interface eth0 and write to a file for analysis", "output": "sudo tcpdump -i eth0 -c 100 udp port 53 -w dns_traffic.pcap"}
{"instruction": "Perform a stealthy SYN scan against a target subnet to identify open ports and operating systems, saving the output to a file.", "output": "sudo nmap -sS -O -oN scan_results.txt 192.168.1.0/24"}
{"instruction": "Analyze the authentication log to find and count unique IP addresses responsible for failed SSH login attempts.", "output": "grep 'Failed password' /var/log/auth.log | grep -oE '\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b' | sort | uniq -c | sort -nr"}
{"instruction": "Capture network traffic on interface eth0 filtering for port 80 and write the raw packets to a pcap file for later analysis.", "output": "sudo tcpdump -i eth0 -w capture.pcap port 80"}
{"instruction": "Use Netcat to verify if a remote server is accepting connections on port 443 with a 3-second timeout, without sending any data.", "output": "nc -zv -w 3 10.0.0.5 443"}
{"instruction": "Recursively search the web directory for files containing potential PHP web shell indicators like 'eval' or 'base64_decode'.", "output": "grep -rnE \"eval\\(|base64_decode\\(\" /var/www/html"}
{"instruction": "Search for failed SSH login attempts in the authentication log", "output": "grep 'Failed password' /var/log/auth.log"}
{"instruction": "Perform a fast, stealthy SYN scan on a target IP address to identify open ports", "output": "nmap -sS -T4 -p- 192.168.1.15"}
{"instruction": "List all listening TCP ports and the processes associated with them", "output": "sudo ss -tulnp"}
{"instruction": "Check the SSL certificate expiration dates for a remote domain", "output": "echo | openssl s_client -servername example.com -connect example.com:443 2>/dev/null | openssl x509 -noout -dates"}
{"instruction": "Capture 50 packets on interface eth0 and save them to a pcap file for analysis", "output": "sudo tcpdump -i eth0 -c 50 -w traffic_capture.pcap"}
{"instruction": "Perform a stealth SYN scan on ports 1 through 65535 against a target IP without sending an ICMP ping", "output": "nmap -sS -p 1-65535 -Pn 192.168.1.105"}
{"instruction": "Search the authentication log for failed SSH login attempts, extract the IP addresses, count occurrences, and sort them in descending order", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "List all processes currently listening on TCP or UDP ports along with their numeric ports and associated process IDs", "output": "ss -tulpn"}
{"instruction": "Recursively find all PHP files in the web root and grep for the dangerous 'eval(' function to identify potential webshells", "output": "find /var/www/html -type f -name '*.php' -print0 | xargs -0 grep -n 'eval('"}
{"instruction": "Establish a Netcat listener on port 4444 to receive an incoming reverse shell connection", "output": "nc -lvnp 4444"}
{"instruction": "Perform a stealth SYN scan against a target IP to identify open ports without completing the TCP handshake", "output": "nmap -sS 192.168.1.10"}
{"instruction": "Analyze the authentication log to count the number of failed login attempts per IP address", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Set up a Netcat listener on port 9090 to debug network connectivity or receive file transfers", "output": "nc -lvnp 9090"}
{"instruction": "Capture 100 packets of traffic on the eth0 interface specifically targeting port 80 using tcpdump", "output": "tcpdump -i eth0 -c 100 port 80"}
{"instruction": "List all network connections currently listening on TCP and UDP ports along with their process IDs", "output": "ss -tulpn"}
{"instruction": "Perform a stealthy SYN scan on a target IP ignoring ping checks and scanning all 65535 ports.", "output": "nmap -sS -Pn -p- -T4 192.168.1.15"}
{"instruction": "Analyze the auth.log file to identify the top 10 IP addresses responsible for failed SSH login attempts.", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Establish a Netcat listener on port 4444 to catch an incoming reverse shell connection.", "output": "nc -lvnp 4444"}
{"instruction": "Find all files on the system that have the SUID bit set, which could potentially be used for privilege escalation.", "output": "find / -perm -4000 -type f -exec ls -la {} \\; 2>/dev/null"}
{"instruction": "Check the SSL certificate expiration date of a remote domain using OpenSSL.", "output": "echo | openssl s_client -servername example.com -connect example.com:443 2>/dev/null | openssl x509 -noout -dates"}
{"instruction": "Perform a stealth SYN scan on all ports for the target IP 192.168.1.15 and output results to an XML file", "output": "nmap -sS -p- -oX scan_results.xml 192.168.1.15"}
{"instruction": "Capture 100 packets of traffic on interface eth0 related to port 443 and save to a pcap file", "output": "tcpdump -i eth0 -c 100 -w capture.pcap port 443"}
{"instruction": "Parse the authentication log to count specific failed password attempts per IP address, sorted numerically", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Check the SSL certificate expiration date of a remote server", "output": "echo | openssl s_client -servername example.com -connect example.com:443 2>/dev/null | openssl x509 -noout -enddate"}
{"instruction": "Recursively search for files in the /var/www directory containing the string 'eval(' to identify potential webshells", "output": "grep -r \"eval(\" /var/www"}
{"instruction": "Search for failed SSH login attempts within the authentication log and count unique IP addresses", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Perform a stealthy TCP SYN scan against a specific IP address to identify open web ports", "output": "nmap -sS -p 80,443 -T4 192.168.1.105"}
{"instruction": "Listen on a specific port using netcat to verify firewall rules or debug connectivity", "output": "nc -lvnp 8080"}
{"instruction": "Check for listening ports and the processes associated with them using netstat", "output": "netstat -tulpn | grep LISTEN"}
{"instruction": "Calculate the SHA-256 hash of a critical system binary to verify file integrity", "output": "sha256sum /bin/login"}
{"instruction": "Perform a stealth SYN scan on the local subnet 192.168.1.0/24 to identify active hosts and open ports without completing the TCP handshake.", "output": "nmap -sS 192.168.1.0/24"}
{"instruction": "Search the system authentication log for failed SSH login attempts to identify potential brute-force activity.", "output": "grep 'Failed password' /var/log/auth.log"}
{"instruction": "List all listening TCP and UDP sockets on the local machine, including the numeric ports and associated processes.", "output": "sudo ss -tulpn"}
{"instruction": "Calculate the SHA-256 hash of a critical system binary to verify its file integrity.", "output": "sha256sum /bin/login"}
{"instruction": "Use Netcat to test connectivity to a specific IP address on port 8080 in verbose mode without sending any data.", "output": "nc -zv 192.168.1.50 8080"}
{"instruction": "Perform a stealthy TCP SYN scan against a target IP for the top 100 ports without sending ICMP pings.", "output": "nmap -sS -Pn --top-ports 100 192.168.1.15"}
{"instruction": "Analyze the auth.log file to count and sort failed SSH login attempts by source IP address.", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Start a verbose Netcat listener on port 4444 to capture incoming reverse shell connection attempts.", "output": "nc -lvnp 4444"}
{"instruction": "Recursively search a directory for files containing strings that match a standard credit card number pattern.", "output": "grep -rE '(\\d{4}[- ]){3}\\d{4}' /var/www/html"}
{"instruction": "Generate a SHA-256 hash of a suspicious binary file to compare against threat intelligence databases.", "output": "sha256sum /tmp/unknown_executable"}
{"instruction": "Perform a stealthy SYN scan on ports 1 through 1000 of target 192.168.1.10, detecting OS and service versions, and output the results to XML.", "output": "nmap -sS -p 1-1000 -O -sV -oX scan_results.xml 192.168.1.10"}
{"instruction": "Analyze the Apache access log to identify IP addresses attempting SQL injection via 'UNION SELECT', counting the occurrences per IP and sorting by frequency.", "output": "grep \"UNION SELECT\" /var/log/apache2/access.log | awk '{print $1}' | sort | uniq -c | sort -nr"}
{"instruction": "Start a verbose Netcat listener on port 4444 to capture incoming connection data and redirect the stream to 'capture.txt'.", "output": "nc -lvnp 4444 > capture.txt"}
{"instruction": "Generate a SHA-256 hash for the file '/tmp/suspicious_binary' to verify its integrity or compare against known malware signatures.", "output": "sha256sum /tmp/suspicious_binary"}
{"instruction": "Capture network traffic on interface eth0 using tcpdump, excluding SSH traffic (port 22), and save the raw packets to 'capture.pcap' for later analysis.", "output": "sudo tcpdump -i eth0 port not 22 -w capture.pcap"}
{"instruction": "Perform a stealth SYN scan on a target IP for common web ports 80 and 443 without pinging the host first.", "output": "nmap -sS -Pn -p 80,443 <target_ip>"}
{"instruction": "Search the system authentication logs for failed SSH login attempts to identify potential brute-force activity.", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Check if a specific port on a remote server is open and listening using Netcat in verbose zero-I/O mode.", "output": "nc -zv <remote_host> <port>"}
{"instruction": "List all processes listening on TCP and UDP ports along with their PIDs to audit active network services.", "output": "sudo ss -tulpn"}
{"instruction": "Calculate the SHA-256 hash of a suspicious file to verify integrity or compare against known malware signatures.", "output": "sha256sum <filename>"}
{"instruction": "Perform a stealthy SYN scan against target 192.168.1.15 for all 65535 ports, treating the host as online.", "output": "nmap -sS -p- -Pn 192.168.1.15"}
{"instruction": "Parse /var/log/auth.log to display the top 10 IP addresses associated with failed SSH login attempts.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Capture full-sized packets on interface eth0 filtered for traffic on port 443 and save the output to a pcap file.", "output": "tcpdump -i eth0 -s 0 port 443 -w capture_https.pcap"}
{"instruction": "Search the entire filesystem for files with the SUID bit set that are owned by the root user, discarding error messages.", "output": "find / -user root -perm -4000 -type f 2>/dev/null"}
{"instruction": "List all listening TCP and UDP sockets along with the process ID and service name responsible for them.", "output": "ss -tulnp"}
{"instruction": "Perform a stealth SYN scan on a target subnet, skipping the ping check and saving the output to a text file.", "output": "nmap -sS -Pn -oN scan_results.txt 192.168.1.0/24"}
{"instruction": "Analyze the auth.log file to count the number of failed SSH login attempts per IP address, sorted by frequency.", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Capture full-packet DNS traffic on interface eth0 and write it to a pcap file for later analysis in Wireshark.", "output": "sudo tcpdump -i eth0 port 53 -w dns_traffic.pcap"}
{"instruction": "Find all files in the /usr/bin directory that have the SUID bit set and are owned by the root user.", "output": "find /usr/bin -user root -perm -4000 -exec ls -ldb {} \\;"}
{"instruction": "Check for active network connections and listening ports, displaying the associated Process ID and program name.", "output": "sudo netstat -tulpn"}
{"instruction": "Perform a ping scan on the local subnet to identify live hosts without scanning ports", "output": "nmap -sn 192.168.1.0/24"}
{"instruction": "Parse the authentication log to count failed SSH login attempts grouped by source IP address", "output": "grep 'Failed password' /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Verify if a specific port is open on a remote server using Netcat in zero-I/O mode", "output": "nc -zv 10.0.0.5 443"}
{"instruction": "Retrieve the start and expiration dates of a remote server's SSL/TLS certificate", "output": "echo | openssl s_client -servername example.com -connect example.com:443 2>/dev/null | openssl x509 -noout -dates"}
{"instruction": "List all listening TCP and UDP sockets along with the processes using them", "output": "sudo ss -tulpn"}
{"instruction": "Search for failed SSH login attempts within the system authentication log.", "output": "grep 'Failed password' /var/log/auth.log"}
{"instruction": "Perform a service version detection scan on ports 80 and 443 without pinging the host.", "output": "nmap -sV -Pn -p 80,443 192.168.1.10"}
{"instruction": "List all currently listening TCP and UDP sockets along with their process IDs.", "output": "ss -tulnp"}
{"instruction": "Calculate the SHA-256 hash of a specific file to verify its integrity.", "output": "sha256sum /usr/bin/sudo"}
{"instruction": "Capture the first 100 packets on interface eth0 and save them to a file for analysis.", "output": "tcpdump -i eth0 -c 100 -w capture.pcap"}
{"instruction": "Perform a stealth SYN scan on a specific target IP while treating the host as online (skipping ping).", "output": "nmap -sS -Pn 192.168.1.15"}
{"instruction": "Monitor the authentication log in real-time for failed SSH login attempts.", "output": "tail -f /var/log/auth.log | grep \"Failed password\""}
{"instruction": "Check for listening TCP ports and the processes associated with them using socket statistics.", "output": "sudo ss -tulpn"}
{"instruction": "Connect to a remote server on port 80 to manually verify the service banner and connectivity.", "output": "nc -v 10.0.0.5 80"}
{"instruction": "Capture network traffic on interface eth0 focusing only on port 443 and write it to a file.", "output": "sudo tcpdump -i eth0 port 443 -w traffic_capture.pcap"}
{"instruction": "Perform a stealth SYN scan on port 443 of IP 192.168.1.50 without pinging the host first to avoid detection.", "output": "nmap -sS -Pn -p 443 192.168.1.50"}
{"instruction": "Search the auth.log file for failed SSH login attempts, extract the source IP addresses, and sort them by frequency count.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Capture full-packet DNS traffic on interface eth0 and write it to a file named dns_traffic.pcap for forensic analysis.", "output": "tcpdump -i eth0 -s 0 -w dns_traffic.pcap port 53"}
{"instruction": "Calculate the SHA-256 hash of the critical configuration file /etc/shadow to verify file integrity.", "output": "openssl dgst -sha256 /etc/shadow"}
{"instruction": "Establish a verbose Netcat connection to a remote server at 10.10.10.5 on port 80 with a 3-second timeout to grab the banner.", "output": "nc -v -w 3 10.10.10.5 80"}
{"instruction": "Perform a stealth SYN scan on a specific target IP for web ports 80 and 443", "output": "nmap -sS -p 80,443 192.168.1.50"}
{"instruction": "Monitor the authentication log in real-time for failed SSH login attempts", "output": "tail -f /var/log/auth.log | grep 'Failed password'"}
{"instruction": "List all active listening ports and their associated process IDs", "output": "sudo ss -tulpn"}
{"instruction": "Start a Netcat listener on port 9000 to debug inbound connectivity", "output": "nc -lvnp 9000"}
{"instruction": "Search recursively for files containing a specific IP address within a directory", "output": "grep -rn '192.168.1.100' /var/www/html/"}
{"instruction": "Write a Python script to perform a basic TCP connect scan on a target IP for a specific range of ports to identify open services.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"[+] Port {port} is OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example usage: Scan localhost ports 1-1024\n    scan_ports(\"127.0.0.1\", 1, 1024)"}
{"instruction": "Create a Bash script to parse an Nginx access log file and extract IP addresses that have generated more than 100 requests, sorting them by frequency.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\nTHRESHOLD=100\n\necho \"Analyzing $LOG_FILE for high-frequency IPs...\"\n\n# Extract IP (1st column), count occurrences, sort numeric reverse, filter by threshold\nawk '{print $1}' \"$LOG_FILE\" | \\\nsort | uniq -c | sort -nr | \\\nawk -v limit=\"$THRESHOLD\" '$1 > limit {print $0}'\n\necho \"Analysis complete.\""}
{"instruction": "Generate a Bash script using `iptables` to drop all incoming traffic by default, but allow established connections, SSH (port 22), and HTTP/HTTPS (ports 80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default chain policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules updated.\""}
{"instruction": "Write a Python script that checks a list of URLs to see if they are sending the 'X-Frame-Options' security header to prevent clickjacking.", "output": "import requests\n\ndef check_security_headers(urls):\n    for url in urls:\n        try:\n            response = requests.get(url, timeout=5)\n            headers = response.headers\n            if 'X-Frame-Options' not in headers:\n                print(f\"[ALERT] {url} is missing 'X-Frame-Options' header.\")\n            else:\n                print(f\"[OK] {url} has 'X-Frame-Options': {headers['X-Frame-Options']}\")\n        except requests.exceptions.RequestException as e:\n            print(f\"[ERROR] Could not connect to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    target_urls = [\"http://example.com\", \"http://test.local\"]\n    check_security_headers(target_urls)"}
{"instruction": "Create a Bash script for server hardening that disables root login via SSH and ensures the SSH protocol is set to version 2 in the sshd_config file.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup the configuration\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" \"$CONFIG_FILE\"; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\nelse\n    echo \"PermitRootLogin no\" >> \"$CONFIG_FILE\"\nfi\n\n# Enforce Protocol 2\nif grep -q \"^Protocol\" \"$CONFIG_FILE\"; then\n    sed -i 's/^Protocol.*/Protocol 2/' \"$CONFIG_FILE\"\nelse\n    echo \"Protocol 2\" >> \"$CONFIG_FILE\"\nfi\n\n# Reload SSH service to apply changes\nsystemctl reload sshd\necho \"SSH hardening applied. Root login disabled.\""}
{"instruction": "Write a Python script acting as a mini-SIEM agent that tails `/var/log/auth.log` and alerts if 5 failed SSH login attempts are detected from the same IP within one minute.", "output": "import time\nimport re\nfrom collections import defaultdict\n\nLOG_FILE = '/var/log/auth.log'\nfailed_attempts = defaultdict(list)\n\ndef tail_log(filename):\n    with open(filename, 'r') as f:\n        f.seek(0, 2) # Go to the end of file\n        while True:\n            line = f.readline()\n            if not line:\n                time.sleep(0.1)\n                continue\n            yield line\n\ndef monitor_ssh_failures():\n    print(\"Monitoring auth.log for brute force attempts...\")\n    log_gen = tail_log(LOG_FILE)\n    \n    for line in log_gen:\n        if \"Failed password\" in line:\n            # Extract IP address\n            ip_match = re.search(r'(\\d{1,3}\\.){3}\\d{1,3}', line)\n            if ip_match:\n                ip = ip_match.group()\n                now = time.time()\n                failed_attempts[ip].append(now)\n                \n                # Filter out attempts older than 60 seconds\n                failed_attempts[ip] = [t for t in failed_attempts[ip] if now - t < 60]\n                \n                if len(failed_attempts[ip]) >= 5:\n                    print(f\"[ALERT] Potential Brute Force detected from IP: {ip}\")\n                    # Reset counter to avoid spamming alerts for the same burst\n                    failed_attempts[ip] = []\n\nif __name__ == \"__main__\":\n    monitor_ssh_failures()"}
{"instruction": "Generate a configuration script for `nftables` that defines a table `inet filter`, creates input/forward/output chains, allows loopback, and drops invalid packets.", "output": "#!/bin/bash\n\n# Flush current ruleset\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create base chains with default policies\nnft add chain inet filter input '{ type filter hook input priority 0 ; policy drop ; }'\nnft add chain inet filter forward '{ type filter hook forward priority 0 ; policy drop ; }'\nnft add chain inet filter output '{ type filter hook output priority 0 ; policy accept ; }'\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback interface\nnft add rule inet filter input iif lo accept\n\n# Drop invalid packets\nnft add rule inet filter input ct state invalid drop\n\n# Allow SSH and Web traffic\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\necho \"Nftables configured successfully.\""}
{"instruction": "Write a Python script that uses `subprocess` to run `pip list --outdated` and saves the list of vulnerable/outdated Python packages to a JSON file for review.", "output": "import subprocess\nimport json\n\ndef audit_python_packages():\n    print(\"Running pip audit...\")\n    try:\n        # Run pip list --outdated expecting JSON output\n        result = subprocess.run(\n            ['pip', 'list', '--outdated', '--format=json'],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        \n        outdated_packages = json.loads(result.stdout)\n        report = []\n        \n        for pkg in outdated_packages:\n            report.append({\n                \"package\": pkg['name'],\n                \"current_version\": pkg['version'],\n                \"latest_version\": pkg['latest_version']\n            })\n            \n        with open('outdated_packages_report.json', 'w') as f:\n            json.dump(report, f, indent=4)\n            \n        print(f\"Audit complete. Found {len(report)} outdated packages. Saved to outdated_packages_report.json\")\n        \n    except subprocess.CalledProcessError as e:\n        print(f\"Error running pip: {e}\")\n    except json.JSONDecodeError:\n        print(\"Error decoding pip output.\")\n\nif __name__ == \"__main__\":\n    audit_python_packages()"}
{"instruction": "Create a Bash script that calculates SHA-256 checksums of critical system files (passwd, shadow) and compares them against a baseline to detect unauthorized changes.", "output": "#!/bin/bash\n\nBASELINE_FILE=\"/var/log/sys_integrity.sha256\"\nFILES_TO_MONITOR=\"/etc/passwd /etc/shadow /etc/group\"\n\n# Check if baseline exists\nif [ ! -f \"$BASELINE_FILE\" ]; then\n    echo \"Baseline not found. Creating new baseline...\"\n    sha256sum $FILES_TO_MONITOR > \"$BASELINE_FILE\"\n    chmod 600 \"$BASELINE_FILE\"\n    echo \"Baseline created at $BASELINE_FILE\"\nelse\n    echo \"Verifying file integrity...\"\n    # Verify files against the baseline\n    sha256sum -c \"$BASELINE_FILE\" > /dev/null 2>&1\n    \n    if [ $? -ne 0 ]; then\n        echo \"[CRITICAL] Integrity Check FAILED! The following files have changed:\"\n        sha256sum -c \"$BASELINE_FILE\" | grep \": FAILED\"\n    else\n        echo \"[OK] Integrity Check Passed. No changes detected.\"\n    fi\nfi"}
{"instruction": "Write a Python script that downloads a text file containing a list of malicious IP addresses and generates `ufw` (Uncomplicated Firewall) commands to deny incoming traffic from those IPs.", "output": "import requests\nimport subprocess\n\n# Example blocklist URL\nBLOCKLIST_URL = \"https://lists.blocklist.de/lists/ssh.txt\"\n\ndef update_firewall_blocklist():\n    print(\"Fetching blocklist...\")\n    try:\n        response = requests.get(BLOCKLIST_URL, timeout=10)\n        if response.status_code == 200:\n            ips = response.text.splitlines()\n            count = 0\n            for ip in ips:\n                ip = ip.strip()\n                if ip:\n                    # Construct UFW deny command\n                    # WARNING: This executes system commands. Ensure source is trusted.\n                    cmd = ['ufw', 'deny', 'from', ip, 'to', 'any']\n                    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n                    count += 1\n            print(f\"Successfully added {count} IPs to UFW blocklist.\")\n        else:\n            print(f\"Failed to download blocklist. Status code: {response.status_code}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    update_firewall_blocklist()"}
{"instruction": "Write a Python script to parse an Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, which may indicate a scanning attempt.", "output": "import re\nfrom collections import Counter\n\ndef detect_scanners(log_file_path, threshold=10):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    status_pattern = r'\\s404\\s'\n    \n    ips = []\n    \n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                if re.search(status_pattern, line):\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        ips.append(match.group(1))\n        \n        ip_counts = Counter(ips)\n        \n        print(f\"IPs with > {threshold} 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# detect_scanners('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script using 'iptables' to implement a default-deny policy for incoming traffic, allow loopback, allow established connections, and specifically allow SSH (port 22) and HTTP (port 80).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote server to ensure valid encryption is in place.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET),\n                               server_hostname=hostname)\n    \n    # Set a timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        \n        print(f\"Certificate for {hostname} expires on: {expire_date}\")\n        print(f\"Days remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"WARNING: Certificate expires in less than 30 days.\")\n            \n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\n# Example usage\n# check_ssl_expiry('www.example.com')"}
{"instruction": "Write a Bash script to audit the system for files with the SUID bit set, which allows users to execute the file with the permissions of the file owner (often root), representing a potential privilege escalation risk.", "output": "#!/bin/bash\n\necho \"Searching for SUID binaries...\"\n\n# Find files with SUID bit set (perm -4000)\n# 2>/dev/null suppresses permission denied errors during search\nfind / -type f -perm -4000 -ls 2>/dev/null > suid_audit.txt\n\necho \"Audit complete. Results saved to suid_audit.txt\"\n\n# Display the count\nCOUNT=$(wc -l < suid_audit.txt)\necho \"Found $COUNT SUID binaries.\""}
{"instruction": "Write a Python script to perform a basic port scan on a specific target IP to identify open ports within a defined range (e.g., 20-1024) for vulnerability assessment.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    \n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        \n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n            open_ports.append(port)\n        sock.close()\n        \n    return open_ports\n\n# Example usage\n# scan_ports('127.0.0.1', 20, 80)"}
{"instruction": "Create a Bash script using 'nftables' to create a table and chain that drops all traffic from a specific blacklist of IP addresses.", "output": "#!/bin/bash\n\n# Define the blacklist IPs\nBLACKLIST_IPS=(\"192.0.2.5\" \"198.51.100.23\" \"203.0.113.10\")\n\n# Create the table\nnft add table inet filter\n\n# Create the input chain\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Create a set for blacklisted IPs\nnft add set inet filter blacklist { type ipv4_addr \\; }\n\n# Add IPs to the set\nfor ip in \"${BLACKLIST_IPS[@]}\"; do\n    nft add element inet filter blacklist { $ip }\ndone\n\n# Add rule to drop traffic from IPs in the set\nnft add rule inet filter input ip saddr @blacklist drop\n\necho \"nftables blacklist configured.\""}
{"instruction": "Write a Python script to verify the integrity of critical system files (e.g., /etc/passwd, /bin/ls) by calculating their SHA-256 hashes and comparing them against a known baseline dictionary.", "output": "import hashlib\n\ndef calculate_hash(file_path):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            # Read file in chunks to avoid memory issues\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\ndef verify_integrity(baseline_dict):\n    for file_path, expected_hash in baseline_dict.items():\n        current_hash = calculate_hash(file_path)\n        \n        if current_hash is None:\n            print(f\"[MISSING] {file_path} not found!\")\n        elif current_hash == expected_hash:\n            print(f\"[OK] {file_path}\")\n        else:\n            print(f\"[ALERT] Integrity mismatch for {file_path}!\")\n            print(f\"   Expected: {expected_hash}\")\n            print(f\"   Found:    {current_hash}\")\n\n# Example Baseline\n# baseline = {\n#     '/etc/passwd': 'known_hash_here',\n#     '/bin/ls': 'known_hash_here'\n# }\n# verify_integrity(baseline)"}
{"instruction": "Write a Bash script to parse '/var/log/auth.log' (or secure log) to extract and count unique IP addresses that have attempted failed SSH logins.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top failed SSH login attempts by IP:\"\n\n# Grep for 'Failed password', extract IP (usually field 11 or 13 depending on distro), sort, and count unique\ngrep \"Failed password\" \"$LOG_FILE\" | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | uniq -c | sort -nr | head -n 10\n\n# Note: Adjust regex or awk field if log format differs (e.g., RHEL vs Debian)"}
{"instruction": "Write a Python script to scan a directory recursively and identify files that are 'world-writable' (permission 777 or similar), which is a security hardening violation.", "output": "import os\nimport stat\n\ndef find_world_writable(start_path):\n    print(f\"Scanning {start_path} for world-writable files...\")\n    \n    for root, dirs, files in os.walk(start_path):\n        for name in files:\n            filepath = os.path.join(root, name)\n            try:\n                file_stat = os.stat(filepath)\n                mode = file_stat.st_mode\n                \n                # Check if 'others' have write permission (S_IWOTH)\n                if mode & stat.S_IWOTH:\n                    print(f\"[WARNING] World-writable: {filepath} ({oct(mode)[-3:]})\")\n                    \n            except OSError as e:\n                # Permission denied errors etc.\n                continue\n\n# Example usage\n# find_world_writable('/var/www/html')"}
{"instruction": "Write a Bash hardening script to disable unused filesystems (like cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs, udf) to reduce the kernel attack surface.", "output": "#!/bin/bash\n\nFILESYSTEMS=(\"cramfs\" \"freevxfs\" \"jffs2\" \"hfs\" \"hfsplus\" \"squashfs\" \"udf\")\nCONFIG_FILE=\"/etc/modprobe.d/dev-sec.conf\"\n\necho \"Disabling unused filesystems...\"\n\n# Create or clear the config file\n: > \"$CONFIG_FILE\"\n\nfor fs in \"${FILESYSTEMS[@]}\"; do\n    echo \"install $fs /bin/true\" >> \"$CONFIG_FILE\"\n    echo \"Filesystem $fs disabled.\"\ndone\n\necho \"Configuration written to $CONFIG_FILE. Reboot required to take full effect.\""}
{"instruction": "Create a Python script to perform a basic port scan on a local server to identify open ports within a specified range.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Scan localhost for demonstration\n    scan_ports(\"127.0.0.1\", 20, 1024)"}
{"instruction": "Write a Bash script to parse /var/log/auth.log and extract IP addresses that have failed SSH login attempts more than 5 times.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"IP addresses with more than $THRESHOLD failed login attempts:\"\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"$ip ($count attempts)\"\n    fi\ndone"}
{"instruction": "Generate a Bash script using iptables to implement a 'default drop' policy for incoming traffic, while allowing established connections, loopback, and SSH.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save settings (Debian/Ubuntu based)\n# netfilter-persistent save\necho \"Firewall rules applied successfully.\""}
{"instruction": "Create a Python script to analyze an Apache access log file and identify potential SQL injection attempts by looking for common SQL keywords in the request URI.", "output": "import re\n\ndef detect_sqli(log_file_path):\n    sqli_patterns = [r\"UNION\", r\"SELECT\", r\"INSERT\", r\"DROP\", r\"--\", r\"' OR '1'='1\"]\n    regex = re.compile(\"|\".join(sqli_patterns), re.IGNORECASE)\n    \n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                if regex.search(line):\n                    print(f\"[ALERT] Potential SQLi detected: {line.strip()}\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    detect_sqli(\"/var/log/apache2/access.log\")"}
{"instruction": "Write a Bash script to harden the SSH configuration by disabling root login and password authentication, enforcing key-based auth.", "output": "#!/bin/bash\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Ensure PubkeyAuthentication is yes\nsed -i 's/^#PubkeyAuthentication.*/PubkeyAuthentication yes/' \"$SSHD_CONFIG\"\n\n# Restart SSH service\nsystemctl restart sshd\necho \"SSH hardening applied. Backup saved to $BACKUP.\""}
{"instruction": "Create a Python script to audit file permissions of critical system files (e.g., /etc/shadow, /etc/passwd) and report if they are world-writable.", "output": "import os\nimport stat\n\ncritical_files = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/group\", \"/etc/gshadow\"]\n\ndef check_permissions(file_path):\n    try:\n        st = os.stat(file_path)\n        # Check if world writable (Others have Write permission)\n        if st.st_mode & stat.S_IWOTH:\n            print(f\"[CRITICAL] {file_path} is world-writable!\")\n        else:\n            print(f\"[OK] {file_path} permissions are safe.\")\n    except FileNotFoundError:\n        print(f\"[WARN] {file_path} not found.\")\n\nif __name__ == \"__main__\":\n    for f in critical_files:\n        check_permissions(f)"}
{"instruction": "Generate a Bash script using nftables to block a specific list of malicious IP addresses provided in a text file.", "output": "#!/bin/bash\nBLOCKLIST_FILE=\"malicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Ensure nftables is installed and table exists\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\nif [[ -f \"$BLOCKLIST_FILE\" ]]; then\n    while IFS= read -r ip; do\n        # Skip empty lines or comments\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        \n        echo \"Blocking IP: $ip\"\n        nft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr \"$ip\" drop\n    done < \"$BLOCKLIST_FILE\"\nelse\n    echo \"Blocklist file not found.\"\nfi"}
{"instruction": "Write a Python script that tails a log file in real-time and sends an alert (mock print) if the keyword 'PANIC' or 'CRITICAL' is found.", "output": "import time\nimport os\n\ndef tail_log(file_path):\n    try:\n        with open(file_path, 'r') as f:\n            # Move to the end of file\n            f.seek(0, os.SEEK_END)\n            \n            while True:\n                line = f.readline()\n                if not line:\n                    time.sleep(0.1)\n                    continue\n                \n                if \"PANIC\" in line or \"CRITICAL\" in line:\n                    print(f\"[SIEM ALERT] Critical event found: {line.strip()}\")\n    except FileNotFoundError:\n        print(\"File not found.\")\n\nif __name__ == \"__main__\":\n    # Replace with actual log file\n    tail_log(\"/var/log/syslog\")"}
{"instruction": "Create a Bash script to check for available security updates on a Debian/Ubuntu system and list them without installing.", "output": "#!/bin/bash\n\necho \"Updating package lists...\"\napt-get update > /dev/null 2>&1\n\necho \"Checking for security updates...\"\n# List upgrades, filter for 'security' repository\napt-get -s dist-upgrade | grep \"^Inst\" | grep -i \"security\"\n\nif [ $? -eq 0 ]; then\n    echo \"Security updates are available.\"\nelse\n    echo \"No immediate security updates found.\"\nfi"}
{"instruction": "Write a Python script to calculate the hash (SHA-256) of a specific file to verify its integrity against a known hash.", "output": "import hashlib\nimport sys\n\ndef verify_integrity(file_path, expected_hash):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            # Read file in chunks to handle large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        \n        calculated_hash = sha256_hash.hexdigest()\n        print(f\"Calculated Hash: {calculated_hash}\")\n        \n        if calculated_hash == expected_hash:\n            print(\"[SUCCESS] Integrity verified.\")\n        else:\n            print(\"[FAILURE] Hash mismatch! File may be corrupted or altered.\")\n            \n    except FileNotFoundError:\n        print(\"File not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    if len(sys.argv) == 3:\n        verify_integrity(sys.argv[1], sys.argv[2])\n    else:\n        print(\"Usage: python script.py <file_path> <expected_hash>\")"}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a given domain to identify potential security lapses.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET),\n                               server_hostname=domain)\n    \n    # Set a timeout for the connection\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((domain, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse the expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        print(f\"Domain: {domain}\")\n        print(f\"Expires on: {expire_date}\")\n        print(f\"Days remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"WARNING: Certificate expiring soon!\")\n            \n    except Exception as e:\n        print(f\"Error checking {domain}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == '__main__':\n    target_domain = input(\"Enter domain to check: \")\n    check_ssl_expiry(target_domain)"}
{"instruction": "Create a Bash script to parse Nginx access logs and list the top 10 IP addresses by request count.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IP addresses by request count:\"\n\n# Assumes standard Nginx log format where IP is the first field\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Python script that generates an executable shell script containing iptables rules to block a list of malicious IP addresses provided in a text file.", "output": "import os\n\ndef generate_block_script(ip_file, output_script='block_ips.sh'):\n    try:\n        with open(ip_file, 'r') as f:\n            ips = [line.strip() for line in f if line.strip()]\n        \n        with open(output_script, 'w') as out:\n            out.write(\"#!/bin/bash\\n\")\n            out.write(\"# Auto-generated iptables blocking script\\n\\n\")\n            \n            for ip in ips:\n                # Validate basic IP format roughly to avoid command injection\n                if all(c in '0123456789.' for c in ip):\n                    rule = f\"iptables -A INPUT -s {ip} -j DROP\"\n                    out.write(f\"echo 'Blocking {ip}'\\n\")\n                    out.write(rule + \"\\n\")\n            \n            out.write(\"\\nservice iptables save\\n\")\n            \n        print(f\"Script generated: {output_script}\")\n        os.chmod(output_script, 0o755)\n        \n    except FileNotFoundError:\n        print(\"IP list file not found.\")\n\nif __name__ == '__main__':\n    # specific_threats.txt should contain one IP per line\n    generate_block_script('specific_threats.txt')"}
{"instruction": "Develop a Bash script for server hardening that disables root login via SSH.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Ensure run as root\nif [[ $EUID -ne 0 ]]; then\n   echo \"This script must be run as root\"\n   exit 1\nfi\n\n# Backup configuration\ncp \"$SSHD_CONFIG\" \"$BACKUP_CONFIG\"\necho \"Backup created at $BACKUP_CONFIG\"\n\n# Use sed to find PermitRootLogin and set it to no\n# This handles commented out lines or existing 'yes' settings\nif grep -q \"^PermitRootLogin\" \"$SSHD_CONFIG\"; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nelse\n    # If the directive doesn't exist or is commented out everywhere, append it\n    echo \"PermitRootLogin no\" >> \"$SSHD_CONFIG\"\nfi\n\necho \"Root login disabled in configuration.\"\necho \"Restarting SSH service...\"\nsystemctl restart sshd"}
{"instruction": "Write a Python script to audit a Linux system for users with UID 0 (root privileges) other than the actual root account.", "output": "import pwd\n\ndef check_root_uids():\n    print(\"Auditing users with UID 0...\")\n    suspicious_users = []\n    \n    for p in pwd.getpwall():\n        if p.pw_uid == 0:\n            if p.pw_name != 'root':\n                suspicious_users.append(p.pw_name)\n                print(f\"[ALERT] User '{p.pw_name}' has UID 0!\")\n            else:\n                print(f\"[OK] User '{p.pw_name}' is UID 0 (expected).\")\n    \n    if not suspicious_users:\n        print(\"No unauthorized UID 0 users found.\")\n    else:\n        print(f\"Found {len(suspicious_users)} suspicious accounts.\")\n\nif __name__ == '__main__':\n    check_root_uids()"}
{"instruction": "Create a Bash script using `nftables` to configure a basic stateful firewall that allows SSH, HTTP, and HTTPS, but drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create a table for inet (IPv4 and IPv6)\nnft add table inet filter\n\n# Create input, forward, and output chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback interface\nnft add rule inet filter input iif lo accept\n\n# Allow SSH (22), HTTP (80), HTTPS (443)\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\nnft add rule inet filter input ip6 nexthdr icmpv6 accept\n\necho \"Nftables rules applied successfully.\"\nnft list ruleset"}
{"instruction": "Write a Python script to parse a generic CSV firewall log and identify source IPs that have been denied more than a threshold number of times.", "output": "import csv\nfrom collections import Counter\n\ndef analyze_firewall_logs(log_file, threshold=100):\n    ip_counter = Counter()\n    \n    try:\n        with open(log_file, mode='r') as csvfile:\n            reader = csv.DictReader(csvfile)\n            # Assumes columns: 'timestamp', 'action', 'src_ip', 'dst_ip', 'dst_port'\n            for row in reader:\n                if row.get('action') == 'DENY':\n                    src_ip = row.get('src_ip')\n                    if src_ip:\n                        ip_counter[src_ip] += 1\n                        \n        print(f\"IPs with > {threshold} DENY events:\")\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n    except Exception as e:\n        print(f\"Error parsing logs: {e}\")\n\nif __name__ == '__main__':\n    # Example usage\n    analyze_firewall_logs('firewall_logs.csv', threshold=50)"}
{"instruction": "Create a Bash script to verify the file permissions of critical system files (e.g., /etc/shadow, /etc/passwd) to ensure they are secure.", "output": "#!/bin/bash\n\ncheck_perms() {\n    FILE=$1\n    EXPECTED=$2\n    \n    if [ -f \"$FILE\" ]; then\n        CURRENT=$(stat -c \"%a\" \"$FILE\")\n        if [ \"$CURRENT\" -le \"$EXPECTED\" ]; then\n            echo \"[OK] $FILE: $CURRENT (Expected <= $EXPECTED)\"\n        else\n            echo \"[ALERT] $FILE: $CURRENT (Too permissive! Expected <= $EXPECTED)\"\n        fi\n    else\n        echo \"[MISSING] $FILE does not exist.\"\n    fi\n}\n\necho \"Starting Permission Audit...\"\n\n# /etc/shadow should be readable only by root (usually 600 or 640)\ncheck_perms \"/etc/shadow\" 600\n\n# /etc/passwd should be readable by all but writable only by root (644)\ncheck_perms \"/etc/passwd\" 644\n\n# /etc/ssh/sshd_config should be writable only by root (600)\ncheck_perms \"/etc/ssh/sshd_config\" 600\n\n# /var/log/auth.log contains sensitive info (640)\ncheck_perms \"/var/log/auth.log\" 640"}
{"instruction": "Write a Python script to scan a list of internal servers to check if a specific port (e.g., a database port) is openly accessible.", "output": "import socket\n\ndef scan_internal_port(server_list, port, timeout=1):\n    print(f\"Scanning for open port {port}...\")\n    \n    for server in server_list:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(timeout)\n        result = sock.connect_ex((server, port))\n        \n        if result == 0:\n            print(f\"[OPEN] {server}:{port} is accessible.\")\n        else:\n            # Connection failed or refused (Secure)\n            pass\n        \n        sock.close()\n\nif __name__ == '__main__':\n    # List of internal IP addresses to audit\n    internal_servers = ['192.168.1.10', '192.168.1.11', '192.168.1.12']\n    # Check for MySQL default port 3306\n    scan_internal_port(internal_servers, 3306)"}
{"instruction": "Create a Bash script that uses `auditd` logs to report any recent modifications to the `/etc/hosts` file.", "output": "#!/bin/bash\n\n# Requires auditd to be installed and running\nFILE_WATCH=\"/etc/hosts\"\n\necho \"Checking audit logs for modifications to $FILE_WATCH...\"\n\n# ausearch queries the audit daemon logs\n# -f specifies the file\n# -i interprets numeric entities into text\n# -ts recent sets the time start to 10 minutes ago (can be adjusted)\n\nif command -v ausearch &> /dev/null; then\n    ausearch -f \"$FILE_WATCH\" -i -ts today | while read -r line; do\n        echo \"$line\"\n    done\nelse\n    echo \"Error: 'ausearch' command not found. Please install auditd.\"\nfi\n\n# To ensure this works, a rule must exist. This command adds a temporary rule:\n# auditctl -w /etc/hosts -p wa -k hosts_change"}
{"instruction": "Write a Bash script to harden SSH configuration by disabling root login and enforcing empty password checks.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"${SSH_CONFIG}.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSH_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSH_CONFIG\nfi\n\n# Prevent empty passwords\nif grep -q \"^PermitEmptyPasswords\" $SSH_CONFIG; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSH_CONFIG\nelse\n    echo \"PermitEmptyPasswords no\" >> $SSH_CONFIG\nfi\n\necho \"SSH Hardening complete. Restarting service...\"\nsystemctl reload sshd"}
{"instruction": "Create a Python script for Log Analysis that parses a standard Apache access log to identify IP addresses causing 404 errors.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n\ndef analyze_404s(filepath):\n    ip_counter = Counter()\n    try:\n        with open(filepath, 'r') as file:\n            for line in file:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        ip_counter[match.group(1)] += 1\n        \n        print(\"Top IPs generating 404 errors:\")\n        for ip, count in ip_counter.most_common(10):\n            print(f\"{ip}: {count}\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == '__main__':\n    analyze_404s(log_file_path)"}
{"instruction": "Write a Bash script using iptables to implement a 'Default Drop' firewall policy while allowing loopback, established connections, and SSH.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (adjust port if necessary)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based example)\nnetfilter-persistent save\n\necho \"Firewall configured: Default DROP, SSH allowed.\""}
{"instruction": "Develop a Python script to perform a basic vulnerability scan by checking if specific insecure ports (Telnet, FTP) are open on a local server.", "output": "import socket\n\ntarget = \"127.0.0.1\"\n# Ports to check: 21 (FTP), 23 (Telnet)\nvulnerable_ports = [21, 23]\n\ndef scan_ports(ip, ports):\n    print(f\"Scanning {ip} for insecure services...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f\"[!] ALERT: Port {port} is OPEN. Check service configuration.\")\n        else:\n            print(f\"[-] Port {port} is closed.\")\n        sock.close()\n\nif __name__ == '__main__':\n    scan_ports(target, vulnerable_ports)"}
{"instruction": "Write a Bash script to audit file permissions of critical system files (/etc/shadow, /etc/passwd) to ensure they are compliant.", "output": "#!/bin/bash\n\ncheck_perms() {\n    FILE=$1\n    EXPECTED=$2\n    CURRENT=$(stat -c \"%a\" $FILE)\n    \n    if [ \"$CURRENT\" -ne \"$EXPECTED\" ]; then\n        echo \"[FAIL] $FILE is $CURRENT (Expected: $EXPECTED). Fixing...\"\n        chmod $EXPECTED $FILE\n    else\n        echo \"[OK] $FILE is $CURRENT\"\n    fi\n}\n\n# Audit critical files\ncheck_perms \"/etc/shadow\" 600\ncheck_perms \"/etc/gshadow\" 600\ncheck_perms \"/etc/passwd\" 644\ncheck_perms \"/etc/group\" 644"}
{"instruction": "Create a Python script that generates an nftables configuration file to rate-limit SSH connections to prevent brute force attacks.", "output": "def generate_nftables_config(interface=\"eth0\", ssh_port=22, max_attempts=3, window_seconds=60):\n    config = f\"\"\"\n#!/usr/sbin/nft -f\n\nflush ruleset\n\ntable inet filter {{\n    chain input {{\n        type filter hook input priority 0; policy drop;\n\n        # Allow loopback\n        iifname \"lo\" accept\n\n        # Allow established/related\n        ct state established,related accept\n\n        # Rate limit SSH on {interface}\n        tcp dport {ssh_port} ct state new flow table ssh-meter {{ ip saddr limit rate {max_attempts}/minute }} accept\n        \n        # Drop excessive SSH attempts\n        tcp dport {ssh_port} drop\n    }}\n    chain forward {{\n        type filter hook forward priority 0; policy drop;\n    }}\n    chain output {{\n        type filter hook output priority 0; policy accept;\n    }}\n}}\n\"\"\"\n    return config\n\nif __name__ == \"__main__\":\n    print(generate_nftables_config())"}
{"instruction": "Write a Python script for SIEM-style analysis that detects multiple failed login attempts from the same IP in the Linux auth.log.", "output": "import re\n\nlog_path = \"/var/log/auth.log\"\nthreshold = 5\nfailed_logins = {}\n\n# Regex to capture IP from sshd failed password lines\n# Example: Failed password for root from 192.168.1.5 port 22 ssh2\npattern = re.compile(r\"Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)\")\n\ntry:\n    with open(log_path, \"r\") as f:\n        for line in f:\n            if \"sshd\" in line and \"Failed password\" in line:\n                match = pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_logins[ip] = failed_logins.get(ip, 0) + 1\n\n    print(f\"IPs with > {threshold} failed login attempts:\")\n    for ip, count in failed_logins.items():\n        if count > threshold:\n            print(f\"[ALERT] {ip} : {count} attempts\")\n\nexcept PermissionError:\n    print(\"Error: Run with sudo to read auth.log\")"}
{"instruction": "Write a Bash script to list all SUID (Set owner User ID up on execution) binaries, which can be potential privilege escalation vulnerabilities.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\necho \"-----------------------------\"\n\n# Find files with SUID bit set (-perm -4000)\nfind / -type f -perm -4000 -exec ls -ld {} \\; 2>/dev/null > suid_audit.txt\n\necho \"Scan complete. Results saved to suid_audit.txt.\"\necho \"Total SUID binaries found: $(wc -l < suid_audit.txt)\"\n\n# Display top 5 for review\nhead -n 5 suid_audit.txt"}
{"instruction": "Create a Python script that checks the SSL/TLS certificate expiration date of a remote server to ensure security compliance.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=3) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse date format: 'May 25 12:00:00 2025 GMT'\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                days_remaining = (expire_date - datetime.datetime.now()).days\n                \n                print(f\"Domain: {hostname}\")\n                print(f\"Expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                \n                if days_remaining < 30:\n                    print(\"[WARNING] Certificate expires in less than 30 days!\")\n                else:\n                    print(\"[OK] Certificate valid.\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Write a Bash script that reads a list of malicious IP addresses from a file and blocks them using iptables.", "output": "#!/bin/bash\n\nBLOCKLIST=\"malicious_ips.txt\"\n\nif [ ! -f \"$BLOCKLIST\" ]; then\n    echo \"Error: $BLOCKLIST not found.\"\n    exit 1\nfi\n\necho \"Blocking IPs from $BLOCKLIST...\"\n\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    # Check if rule exists to avoid duplicates\n    iptables -C INPUT -s \"$ip\" -j DROP 2>/dev/null\n    if [ $? -eq 1 ]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked: $ip\"\n    else\n        echo \"Skipping $ip (already blocked)\"\n    fi\ndone < \"$BLOCKLIST\""}
{"instruction": "Python script to parse an Apache access log file and alert on IP addresses that have exceeded 100 requests, useful for identifying potential DoS sources or scanners.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    ips = []\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = re.search(ip_pattern, line)\n                if match:\n                    ips.append(match.group(1))\n        \n        counts = Counter(ips)\n        for ip, count in counts.items():\n            if count > 100:\n                print(f\"ALERT: Potential high-volume source detected: {ip} - Requests: {count}\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs(\"/var/log/apache2/access.log\")"}
{"instruction": "Bash script using iptables to immediately block all incoming traffic from a specific malicious subnet.", "output": "#!/bin/bash\n\n# Subnet to block\nMALICIOUS_SUBNET=\"192.168.100.0/24\"\n\necho \"Blocking traffic from subnet: $MALICIOUS_SUBNET\"\n\n# Append rule to INPUT chain to DROP traffic from source\niptables -A INPUT -s $MALICIOUS_SUBNET -j DROP\n\n# Save rules (Debian/Ubuntu based)\nif command -v iptables-save &> /dev/null; then\n    iptables-save > /etc/iptables/rules.v4\n    echo \"Rule added and saved.\"\nelse\n    echo \"Rule added but not saved (iptables-save not found).\"\nfi"}
{"instruction": "Bash script to harden the SSH configuration by disabling root login and enforcing key-based authentication.", "output": "#!/bin/bash\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Create backup\ncp $SSHD_CONFIG \"${SSHD_CONFIG}.bak\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Reload SSH service\nsystemctl reload sshd\necho \"SSH configuration hardened: Root login and password auth disabled.\""}
{"instruction": "Python script to check installed python packages against a mock database of known vulnerable versions (Local Vulnerability Assessment).", "output": "import subprocess\nimport sys\n\n# Example database of vulnerable package versions\nVULN_DB = {\n    \"requests\": \"2.20.0\",\n    \"flask\": \"0.12\",\n    \"django\": \"2.1\"\n}\n\ndef check_packages():\n    # Get installed packages using pip\n    try:\n        result = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze']).decode('utf-8')\n        installed = {}\n        for line in result.splitlines():\n            if '==' in line:\n                pkg, ver = line.split('==')\n                installed[pkg.lower()] = ver\n        \n        print(\"Scanning installed packages for known vulnerabilities...\")\n        for pkg, vuln_ver in VULN_DB.items():\n            if pkg in installed and installed[pkg] <= vuln_ver:\n                print(f\"[VULNERABLE] {pkg} version {installed[pkg]} is installed (Fixed in > {vuln_ver})\")\n            elif pkg in installed:\n                print(f\"[OK] {pkg} version {installed[pkg]}\")\n    except Exception as e:\n        print(f\"Error checking packages: {e}\")\n\nif __name__ == \"__main__\":\n    check_packages()"}
{"instruction": "Bash script to analyze `/var/log/auth.log` and extract the top 5 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found.\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\n# Filter for 'Failed password', extract IP (usually field before port), count unique, sort desc\ngrep \"Failed password\" $LOG_FILE | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Bash script to configure `nftables` as a host-based firewall: Allow Loopback, Established, SSH, HTTP/HTTPS, and Drop everything else.", "output": "#!/bin/bash\n\n# Flush existing ruleset\nnft flush ruleset\n\n# Create filter table for IPv4/IPv6\nnft add table inet filter\n\n# Create input chain with default DROP policy\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow traffic from established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback interface traffic\nnft add rule inet filter input iif lo accept\n\n# Allow SSH (22), HTTP (80), HTTPS (443)\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables firewall rules applied.\""}
{"instruction": "Python script to audit file permissions of critical system files (e.g., /etc/shadow) to ensure they are not world-writable.", "output": "import os\nimport stat\n\nCRITICAL_FILES = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/group\", \"/etc/ssh/sshd_config\"]\n\ndef audit_permissions():\n    print(\"Starting File Permission Audit...\")\n    for filepath in CRITICAL_FILES:\n        try:\n            st = os.stat(filepath)\n            # Check if Others have Write permission (S_IWOTH)\n            if st.st_mode & stat.S_IWOTH:\n                print(f\"[RISK] {filepath} is WORLD-WRITABLE! ({oct(st.st_mode)[-3:]})\")\n            else:\n                print(f\"[SECURE] {filepath} permissions ok ({oct(st.st_mode)[-3:]})\")\n        except FileNotFoundError:\n            print(f\"[INFO] File not found: {filepath}\")\n        except PermissionError:\n            print(f\"[ERROR] Permission denied checking: {filepath}\")\n\nif __name__ == \"__main__\":\n    audit_permissions()"}
{"instruction": "Bash script to check if the system requires a reboot following kernel security updates.", "output": "#!/bin/bash\n\nREBOOT_FILE=\"/var/run/reboot-required\"\n\nif [ -f \"$REBOOT_FILE\" ]; then\n    echo \"WARNING: System reboot required due to updates.\"\n    # Check if specific packages caused this\n    if [ -f \"$REBOOT_FILE.pkgs\" ]; then\n        echo \"Packages triggering reboot:\"\n        cat \"$REBOOT_FILE.pkgs\"\n    fi\nelse\n    echo \"System is up to date. No reboot required.\"\nfi"}
{"instruction": "Python script to parse a JSON-formatted application log and detect if specific error codes occur frequently.", "output": "import json\n\ndef detect_security_events(json_log_file):\n    security_event_count = 0\n    threshold = 5\n    \n    try:\n        with open(json_log_file, 'r') as f:\n            # Assuming file contains a list of JSON objects\n            logs = json.load(f)\n            \n        for entry in logs:\n            # Check for specific security error codes\n            if entry.get(\"level\") == \"ERROR\" and entry.get(\"code\") in [401, 403]:\n                security_event_count += 1\n        \n        if security_event_count > threshold:\n            print(f\"SIEM ALERT: High number of Authorization Failures detected ({security_event_count})\")\n        else:\n            print(f\"Status Normal. Auth failures: {security_event_count}\")\n            \n    except Exception as e:\n        print(f\"Failed to process logs: {e}\")\n\n# Example usage with a dummy filename\n# detect_security_events(\"app_security.json\")"}
{"instruction": "Bash script to enforce password aging policies in `/etc/login.defs` for server hardening.", "output": "#!/bin/bash\nLOGIN_DEFS=\"/etc/login.defs\"\n\necho \"Applying password aging policy to $LOGIN_DEFS...\"\n\n# Set Maximum days a password may be used to 90\nsed -i 's/^PASS_MAX_DAYS.*/PASS_MAX_DAYS   90/' $LOGIN_DEFS\n\n# Set Minimum days allowed between password changes to 7\nsed -i 's/^PASS_MIN_DAYS.*/PASS_MIN_DAYS   7/' $LOGIN_DEFS\n\n# Set Number of days warning given before a password expires to 14\nsed -i 's/^PASS_WARN_AGE.*/PASS_WARN_AGE   14/' $LOGIN_DEFS\n\necho \"Password policy updated. Verify with: grep PASS_ $LOGIN_DEFS\""}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential vulnerability scanning.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 10\nip_counts = defaultdict(int)\n\n# Regex to capture IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counts[ip_address] += 1\n\n    print(f'IPs with > {threshold} 404 errors:')\n    for ip, count in ip_counts.items():\n        if count > threshold:\n            print(f'{ip}: {count}')\nexcept FileNotFoundError:\n    print('Log file not found.')"}
{"instruction": "Write a Bash script for Server Hardening that searches for and lists all world-writable files on the system, excluding virtual filesystems like /proc and /sys.", "output": "#!/bin/bash\n\necho \"Scanning for world-writable files...\"\n\n# Find files with write permission for 'others' (o+w)\n# -xdev prevents crossing filesystem boundaries (ignoring network mounts/proc)\n# -type f looks only for files\n\nfind / -xdev -type f -perm -0002 -print 2>/dev/null | while read -r file; do\n    echo \"[WARNING] World-writable file found: $file\"\n    # Optional: ls -l \"$file\"\ndone\n\necho \"Scan complete.\""}
{"instruction": "Generate a Python script to check the SSL/TLS certificate expiration date of a remote server to ensure secure communications are maintained.", "output": "import ssl\nimport socket\nimport datetime\n\ndef get_ssl_expiry_date(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(\n        socket.socket(socket.AF_INET),\n        server_hostname=hostname,\n    )\n    \n    # Set a timeout for the connection\n    conn.settimeout(3.0)\n\n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        # Parse the expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        return expire_date\n    except Exception as e:\n        return f\"Error: {e}\"\n    finally:\n        conn.close()\n\nhost = 'www.example.com'\nexpiry = get_ssl_expiry_date(host)\nprint(f\"Certificate for {host} expires on: {expiry}\")"}
{"instruction": "Create a Bash script using 'iptables' to set up a basic defensive firewall: allow loopback, allow established connections, allow SSH (port 22) and HTTP/HTTPS (80/443), and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow traffic on loopback interface\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (Optional, limited to prevent log flood)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script for file integrity monitoring (Hardening) that calculates and stores the SHA-256 hashes of critical system binaries.", "output": "import hashlib\nimport os\n\ncritical_files = [\n    '/bin/ls',\n    '/bin/ps',\n    '/etc/passwd',\n    '/etc/shadow'\n]\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to avoid memory issues with large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return \"File Access Error\"\n\nprint(\"--- File Integrity Baseline ---\")\nfor file_path in critical_files:\n    if os.path.exists(file_path):\n        file_hash = calculate_sha256(file_path)\n        print(f\"{file_path}: {file_hash}\")\n    else:\n        print(f\"{file_path}: NOT FOUND\")"}
{"instruction": "Create a Bash script using 'nftables' to block a specific malicious IP address and log any attempts from it.", "output": "#!/bin/bash\n\nBAD_IP=\"192.0.2.100\"\n\n# Create the table if it doesn't exist\nnft add table inet filter\n\n# Create the input chain if it doesn't exist\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add rule to log and drop traffic from the bad IP\n# The 'index 0' ensures it is placed at the top of the ruleset\nnft insert rule inet filter input ip saddr $BAD_IP log prefix \"Blocked Malicious IP: \" drop\n\necho \"Blocked $BAD_IP via nftables.\""}
{"instruction": "Write a Python script for SIEM-style analysis that parses Linux 'auth.log' to detect Brute Force SSH attacks (more than 5 failed attempts from a single IP).", "output": "import re\nfrom collections import defaultdict\n\nLOG_FILE = '/var/log/auth.log'\nTHRESHOLD = 5\n\n# Regex to extract IP from failed password lines\n# Example line: Failed password for root from 192.168.1.5 port 22 ssh2\nregex = r\"Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n\nfailed_attempts = defaultdict(int)\n\ntry:\n    with open(LOG_FILE, 'r') as f:\n        for line in f:\n            if \"Failed password\" in line:\n                match = re.search(regex, line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n\n    print(\"--- Potential SSH Brute Force Detected ---\")\n    for ip, count in failed_attempts.items():\n        if count > THRESHOLD:\n            print(f\"IP: {ip} | Failed Attempts: {count}\")\n\nexcept PermissionError:\n    print(\"Error: Run as root to read auth.log\")\nexcept FileNotFoundError:\n    print(\"Error: Log file not found\")"}
{"instruction": "Create a Bash script for Server Hardening that locks user accounts which have empty password fields in /etc/shadow.", "output": "#!/bin/bash\n\n# Must be run as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"This script must be run as root\"\n    exit 1\nfi\n\necho \"Checking for accounts with empty passwords...\"\n\n# awk parses /etc/shadow. Field 2 is the password hash. \n# If empty (::) or just (!:), the account has no password set.\nawk -F: '($2 == \"\" || $2 == \"!\") {print $1}' /etc/shadow | while read -r user; do\n    echo \"Locking account with empty password: $user\"\n    passwd -l \"$user\"\ndone\n\necho \"Audit complete.\""}
{"instruction": "Write a Python script for a local Vulnerability Scan that checks if specific dangerous ports (Telnet 23, FTP 21) are open on the localhost.", "output": "import socket\n\ntarget = \"127.0.0.1\"\n# Ports to check: 21 (FTP), 23 (Telnet), 3389 (RDP)\nports_to_check = [21, 23, 3389]\n\nprint(f\"Scanning {target} for insecure services...\")\n\nfor port in ports_to_check:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target, port))\n    \n    if result == 0:\n        print(f\"[ALERT] Port {port} is OPEN. Ensure this is intended.\")\n    else:\n        print(f\"[OK] Port {port} is closed.\")\n    \n    sock.close()"}
{"instruction": "Generate a Bash script for Server Hardening that modifies the SSH configuration to disable root login and enforce Protocol 2.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $SSHD_CONFIG $BACKUP_CONFIG\n\necho \"Hardening SSH configuration...\"\n\n# Disable Root Login\n# If PermitRootLogin exists, change it. If not, append it.\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Enforce Protocol 2 (Modern SSH versions default to this, but good for legacy checks)\nif grep -q \"^Protocol\" $SSHD_CONFIG; then\n    sed -i 's/^Protocol.*/Protocol 2/' $SSHD_CONFIG\nelse\n    echo \"Protocol 2\" >> $SSHD_CONFIG\nfi\n\necho \"Configuration updated. Restart sshd service to apply changes.\""}
{"instruction": "Write a Python script to parse a standard Apache/Nginx access log file and identify IP addresses that have generated more than 50 '404 Not Found' errors, which may indicate a vulnerability scan or enumeration attempt.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nip_404_count = defaultdict(int)\nTHRESHOLD = 50\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(?P<ip>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(?P<status>404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_404_count[match.group('ip')] += 1\n\n    print(f\"IPs with > {THRESHOLD} 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > THRESHOLD:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Create a Bash script that accepts an IP address as an argument and adds a rule to the 'iptables' firewall to drop all incoming packets from that specific IP.", "output": "#!/bin/bash\n\nTARGET_IP=$1\n\nif [ -z \"$TARGET_IP\" ]; then\n    echo \"Usage: $0 <IP_ADDRESS>\"\n    exit 1\nfi\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n    echo \"Please run as root\"\n    exit 1\nfi\n\n# Add rule to drop traffic from the IP\niptables -A INPUT -s \"$TARGET_IP\" -j DROP\n\nif [ $? -eq 0 ]; then\n    echo \"Successfully blocked IP: $TARGET_IP\"\nelse\n    echo \"Failed to update iptables\"\nfi"}
{"instruction": "Write a Python script for server hardening that checks specific critical files (like /etc/shadow and /etc/passwd) to ensure their file permissions are secure (not world-writable).", "output": "import os\nimport stat\n\ncritical_files = ['/etc/shadow', '/etc/passwd', '/etc/group', '/etc/gshadow']\n\ndef check_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        mode = st.st_mode\n        \n        # Check if world writable (others have write permission)\n        if mode & stat.S_IWOTH:\n            print(f\"[ALERT] {filepath} is world-writable!\")\n        else:\n            print(f\"[OK] {filepath} permissions look safe.\")\n            \n        # Specific check for /etc/shadow (should be 0640 or 0600)\n        if filepath == '/etc/shadow':\n            if mode & stat.S_IROTH:\n                print(f\"[ALERT] {filepath} is world-readable!\")\n\n    except FileNotFoundError:\n        print(f\"[MISSING] {filepath} not found.\")\n\nfor f in critical_files:\n    check_permissions(f)"}
{"instruction": "Develop a Bash script to automate SSH server hardening by disabling root login and password authentication in the sshd_config file, then reloading the service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication (Enforce Key-based)\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Validate config and restart\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardening applied and service reloaded.\"\nelse\n    echo \"Configuration test failed. Restoring backup.\"\n    cp $BACKUP $SSHD_CONFIG\nfi"}
{"instruction": "Write a Python script to calculate the SHA-256 hash of a system binary (e.g., /bin/ls) to verify file integrity and detect potential tampering (Tripwire-like functionality).", "output": "import hashlib\nimport sys\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to avoid memory issues with large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\ntarget_file = \"/bin/ls\"\nexpected_hash = \"KNOWN_GOOD_HASH_HERE\" # Replace with actual baseline hash\n\ncurrent_hash = calculate_sha256(target_file)\n\nif current_hash:\n    print(f\"File: {target_file}\")\n    print(f\"Current Hash: {current_hash}\")\n    if expected_hash != \"KNOWN_GOOD_HASH_HERE\" and current_hash != expected_hash:\n        print(\"[WARNING] Hash mismatch! File may be tampered.\")\nelse:\n    print(f\"Error: {target_file} not found.\")"}
{"instruction": "Create a Bash script using 'nftables' to configure a basic host-based firewall that allows loopback, established connections, and SSH, but drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create a table for IP filter\nnft add table inet filter\n\n# Create input chain with default drop policy\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback traffic\nnft add rule inet filter input iif lo accept\n\n# Allow traffic from established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH (port 22)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"Basic nftables configuration applied.\""}
{"instruction": "Write a Python script that uses the 'socket' library to scan a local server for open common ports (21, 22, 80, 443, 3306) to identify exposed services.", "output": "import socket\n\ntarget_host = \"127.0.0.1\"\nports_to_scan = [21, 22, 80, 443, 3306, 8080]\n\nprint(f\"Scanning {target_host} for open ports...\")\n\nfor port in ports_to_scan:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_host, port))\n    \n    if result == 0:\n        print(f\"Port {port}: OPEN\")\n    else:\n        print(f\"Port {port}: Closed/Filtered\")\n    \n    sock.close()"}
{"instruction": "Write a Bash script that parses /var/log/auth.log (or /var/log/secure) to count and list the top 10 IP addresses attempting failed SSH logins.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    LOG_FILE=\"/var/log/secure\"\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | \\\nawk '{for(i=1;i<=NF;i++) if($i ~ /^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$/) print $i}' | \\\nsort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a Python script that checks the HTTP response headers of a given URL for missing security headers (e.g., X-Frame-Options, Content-Security-Policy) to identify configuration weaknesses.", "output": "import requests\n\ntarget_url = \"http://localhost\"\nsecurity_headers = [\n    \"X-Frame-Options\",\n    \"X-XSS-Protection\",\n    \"Content-Security-Policy\",\n    \"Strict-Transport-Security\",\n    \"X-Content-Type-Options\"\n]\n\ntry:\n    response = requests.head(target_url, timeout=5)\n    headers = response.headers\n    \n    print(f\"Analyzing headers for: {target_url}\\n\")\n    \n    for sec_header in security_headers:\n        if sec_header in headers:\n            print(f\"[OK] {sec_header}: {headers[sec_header]}\")\n        else:\n            print(f\"[MISSING] {sec_header} not found!\")\n            \nexcept requests.exceptions.RequestException as e:\n    print(f\"Error connecting to target: {e}\")"}
{"instruction": "Write a Bash script to enforce password aging policies for a specific user to ensure compliance with security standards (e.g., max days 90, min days 7, warning 14).", "output": "#!/bin/bash\n\nUSERNAME=$1\n\nif [ -z \"$USERNAME\" ]; then\n    echo \"Usage: $0 <username>\"\n    exit 1\nfi\n\n# Set Password Aging Policies\n# -M: Max days valid\n# -m: Min days between changes\n# -W: Warning days before expiry\n\nchage -M 90 -m 7 -W 14 \"$USERNAME\"\n\nif [ $? -eq 0 ]; then\n    echo \"Password aging policy updated for user: $USERNAME\"\n    chage -l \"$USERNAME\"\nelse\n    echo \"Failed to update policy. User may not exist or insufficient privileges.\"\nfi"}
{"instruction": "Create a Python script using the `socket` library to perform a basic port scan on a target IP address for a specified range of ports. This helps in identifying exposed services.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example usage: Scan localhost ports 20-80\n    scan_ports(\"127.0.0.1\", 20, 80)"}
{"instruction": "Write a Bash script to parse a standard Apache access log (`access.log`) and identify IP addresses that have generated more than 100 requests. This simulates a basic SIEM logic for detecting potential DoS attacks or scanning.", "output": "#!/bin/bash\n\nLOG_FILE=\"access.log\"\nTHRESHOLD=100\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found.\"\n    exit 1\nfi\n\necho \"IPs with more than $THRESHOLD requests:\"\n\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"$ip - $count requests\"\n    fi\ndone"}
{"instruction": "Develop a Bash script for server hardening that modifies the SSH configuration (`/etc/ssh/sshd_config`) to disable root login and enforce key-based authentication by disabling password auth.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Create a backup\ncp \"$SSHD_CONFIG\" \"$BACKUP_CONFIG\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\n\necho \"SSH Hardening complete. Root login and Password Auth disabled.\""}
{"instruction": "Write a Python script that reads a list of suspicious IP addresses from a file named `blacklist.txt` and generates `iptables` commands to drop traffic from those sources.", "output": "import os\n\ndef generate_iptables_rules(filename):\n    try:\n        with open(filename, 'r') as file:\n            ips = file.readlines()\n            \n        print(\"# Generated iptables rules\")\n        for ip in ips:\n            ip = ip.strip()\n            if ip:\n                rule = f\"iptables -A INPUT -s {ip} -j DROP\"\n                print(rule)\n                # Uncomment the line below to actually execute the command (requires root)\n                # os.system(rule)\n    except FileNotFoundError:\n        print(f\"Error: {filename} not found.\")\n\nif __name__ == \"__main__\":\n    generate_iptables_rules(\"blacklist.txt\")"}
{"instruction": "Create a Bash script to scan the filesystem for files with the SUID (Set User ID) bit set. These files run with the permissions of the file owner and can be potential security risks if misconfigured.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\n# Find files with permission 4000 (SUID bit)\nfind / -perm /4000 -type f -exec ls -ld {} \\; 2>/dev/null > suid_files.txt\n\necho \"Scan complete. Results saved to suid_files.txt.\"\n\n# Display top 5 results\nhead -n 5 suid_files.txt"}
{"instruction": "Write a Python script to analyze a Linux authentication log (e.g., `/var/log/auth.log`) and count the number of failed SSH login attempts for each user.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_auth_log(log_path):\n    failed_attempts = defaultdict(int)\n    # Regex to capture user from failed password line\n    pattern = re.compile(r\"Failed password for (invalid user )?(\\w+) from\")\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"sshd\" in line and \"Failed password\" in line:\n                    match = pattern.search(line)\n                    if match:\n                        user = match.group(2)\n                        failed_attempts[user] += 1\n        \n        print(\"Failed SSH Login Attempts per User:\")\n        for user, count in failed_attempts.items():\n            print(f\"{user}: {count}\")\n            \n    except FileNotFoundError:\n        print(f\"Log file {log_path} not found.\")\n    except PermissionError:\n        print(\"Permission denied. Try running with sudo.\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log(\"/var/log/auth.log\")"}
{"instruction": "Generate a Bash script to configure a basic `nftables` firewall ruleset. The rules should allow loopback, established connections, SSH (port 22), HTTP (port 80), and HTTPS (port 443), while dropping all other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table inet filter\nnft add table inet filter\n\n# Create input chain with default drop policy\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"NFTables firewall configured.\""}
{"instruction": "Create a Python utility to check the expiration date of an SSL certificate for a given hostname. This is useful for monitoring and preventing expired certificates.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse the expiration date\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                return days_remaining\n    except Exception as e:\n        print(f\"Error checking SSL for {hostname}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Write a Bash script to automate system updates and cleanup on a Debian/Ubuntu server. This helps in keeping the system patched against vulnerabilities and removing unused dependencies.", "output": "#!/bin/bash\n\n# Check for root privileges\nif [ \"$(id -u)\" -ne 0 ]; then\n   echo \"This script must be run as root\"\n   exit 1\nfi\n\necho \"Updating package lists...\"\napt-get update -y\n\necho \"Upgrading installed packages...\"\napt-get upgrade -y\n\necho \"Performing distribution upgrade...\"\napt-get dist-upgrade -y\n\necho \"Removing unused packages and dependencies...\"\napt-get autoremove -y\napt-get autoclean -y\n\necho \"System update and cleanup complete.\""}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM). The script should calculate the SHA-256 hash of a critical file (e.g., `/etc/passwd`) to establish a baseline or detect changes.", "output": "import hashlib\n\ndef calculate_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to handle large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nif __name__ == \"__main__\":\n    target_file = \"/etc/passwd\"\n    file_hash = calculate_file_hash(target_file)\n    \n    if file_hash:\n        print(f\"File: {target_file}\")\n        print(f\"SHA-256 Hash: {file_hash}\")\n        # In a real scenario, this hash would be compared to a stored baseline.\n    else:\n        print(f\"File {target_file} not found.\")"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify and count the top 10 IP addresses making requests. This helps identify potential botnets or DoS sources.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Top 10 Source IPs:\")\n        for ip, count in ip_counter.most_common(10):\n            print(f\"{ip}: {count} requests\")\n            \n    except FileNotFoundError:\n        print(f\"Error: File {log_file_path} not found.\")\n\nif __name__ == '__main__':\n    # Replace with actual log path\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that disables root login via SSH and restarts the SSH service to apply changes.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSH_CONFIG $BACKUP_CONFIG\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSH_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSH_CONFIG\nfi\n\n# Restart SSH service (detects systemd vs init.d)\nif command -v systemctl &> /dev/null; then\n    systemctl restart sshd\nelse\n    service ssh restart\nfi\n\necho \"Root login disabled and SSH service restarted.\""}
{"instruction": "Generate a Python script for a simple internal Vulnerability Scan that checks specific ports (21, 22, 23, 80, 443, 3306) on localhost to see if they are open.", "output": "import socket\n\ndef scan_ports(target_ip, ports):\n    print(f\"Scanning {target_ip} for open ports...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"[+] Port {port} is OPEN\")\n        else:\n            print(f\"[-] Port {port} is CLOSED\")\n        sock.close()\n\nif __name__ == '__main__':\n    # Scanning localhost for common services\n    target = '127.0.0.1'\n    target_ports = [21, 22, 23, 80, 443, 3306]\n    scan_ports(target, target_ports)"}
{"instruction": "Create a Bash script using iptables to implement a 'Default Drop' firewall policy. It should allow loopback traffic, established connections, and SSH, but drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback interface\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (Optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \" --log-level 7\n\necho \"Firewall configured: Default DROP, Allow Loopback/SSH/Established.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (FIM). It should calculate the SHA-256 hash of critical system files and compare them against a known baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary: {filepath: known_hash}\nBASELINE = {\n    '/etc/passwd': 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', # Example hash\n    '/etc/hosts': '87ac298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'  # Example hash\n}\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\ndef check_integrity():\n    print(\"Starting Integrity Check...\")\n    for filepath, known_hash in BASELINE.items():\n        current_hash = calculate_hash(filepath)\n        if current_hash is None:\n            print(f\"[ALERT] File missing: {filepath}\")\n        elif current_hash != known_hash:\n            print(f\"[ALERT] Integrity mismatch for {filepath}!\")\n            print(f\"Expected: {known_hash}\")\n            print(f\"Found:    {current_hash}\")\n        else:\n            print(f\"[OK] {filepath} is intact.\")\n\nif __name__ == '__main__':\n    check_integrity()"}
{"instruction": "Create a Bash script for Log Analysis that searches the authentication logs (/var/log/auth.log) for failed SSH login attempts and extracts the unique IP addresses responsible.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Scanning for failed SSH login attempts...\"\n\n# Look for 'Failed password', extract IP (usually field 11 or 13 depending on distro), sort and count unique\ngrep \"Failed password for\" $LOG_FILE | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr\n\necho \"Scan complete.\""}
{"instruction": "Write a Bash script for Server Hardening that searches for files with SUID or SGID bits set, which can be potential privilege escalation vectors, and saves the list to a file.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"/var/log/suid_sgid_audit.txt\"\n\necho \"Starting Audit of SUID/SGID files...\"\necho \"Audit Date: $(date)\" > $OUTPUT_FILE\n\n# Find files with SUID (4000) or SGID (2000) permissions\n# -perm /6000 looks for either bit\n# -type f ensures we only look at files\nfind / -perm /6000 -type f -exec ls -ld {} \\; 2>/dev/null >> $OUTPUT_FILE\n\necho \"Audit complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Create an nftables configuration script (Bash) for a web server. It should define a table and chain, allow HTTP/HTTPS and SSH, and drop all other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing ruleset\nnft flush ruleset\n\n# Create a table for IP version 4\nnft add table ip filter\n\n# Create an input chain with a default drop policy\nnft add chain ip filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow traffic on loopback\nnft add rule ip filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule ip filter input ct state established,related accept\n\n# Allow SSH (22), HTTP (80), HTTPS (443)\nnft add rule ip filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule ip filter input ip protocol icmp accept\n\necho \"nftables rules applied for Web Server.\""}
{"instruction": "Write a Python script for Security Operations that checks the SSL/TLS certificate expiration date of a remote domain to prevent service outages or security warnings.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(\n        socket.socket(socket.AF_INET), \n        server_hostname=hostname\n    )\n    \n    # 3 second timeout\n    conn.settimeout(3.0)\n\n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date string\n        # Format usually: 'May 25 23:59:59 2024 GMT'\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        \n        print(f\"Domain: {hostname}\")\n        print(f\"Expires On: {expire_date}\")\n        print(f\"Days Remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"[WARNING] Certificate expires in less than 30 days!\")\n            \n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == '__main__':\n    check_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script for Server Hardening that disables IP forwarding (to prevent the server from acting as a router/gateway) and disables source routing in the sysctl configuration.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\necho \"Hardening Network Stack...\"\n\n# Disable IP Forwarding\nsysctl -w net.ipv4.ip_forward=0\n\n# Disable Source Routing\nsysctl -w net.ipv4.conf.all.accept_source_route=0\nsysctl -w net.ipv4.conf.default.accept_source_route=0\n\n# Persist changes in /etc/sysctl.conf\nif ! grep -q \"net.ipv4.ip_forward = 0\" $SYSCTL_CONF; then\n    echo \"net.ipv4.ip_forward = 0\" >> $SYSCTL_CONF\nfi\n\nif ! grep -q \"net.ipv4.conf.all.accept_source_route = 0\" $SYSCTL_CONF; then\n    echo \"net.ipv4.conf.all.accept_source_route = 0\" >> $SYSCTL_CONF\nfi\n\n# Apply changes\nsysctl -p\n\necho \"IP Forwarding and Source Routing disabled.\""}
{"instruction": "Write a Python script to parse a standard Apache access log file named 'access.log', count the number of 404 (Not Found) errors, and print the total count.", "output": "import re\n\nlog_file = 'access.log'\ncount_404 = 0\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            # Look for HTTP status code 404\n            if re.search(r'\\s404\\s', line):\n                count_404 += 1\n    print(f'Total 404 errors found: {count_404}')\nexcept FileNotFoundError:\n    print(f'Error: {log_file} not found.')"}
{"instruction": "Create a Bash script to block incoming traffic from a specific IP address provided as an argument using iptables.", "output": "#!/bin/bash\n\nTARGET_IP=$1\n\nif [ -z \"$TARGET_IP\" ]; then\n  echo \"Usage: $0 <IP_ADDRESS>\"\n  exit 1\nfi\n\n# Drop all incoming packets from the specified IP\niptables -A INPUT -s \"$TARGET_IP\" -j DROP\n\necho \"Blocked incoming traffic from $TARGET_IP\""}
{"instruction": "Write a Python script to perform a banner grab on a specified target IP and port to identify the service version (defensive auditing).", "output": "import socket\n\ndef grab_banner(ip, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(2)\n        s.connect((ip, port))\n        banner = s.recv(1024)\n        print(f'Banner for {ip}:{port} -> {banner.decode().strip()}')\n        s.close()\n    except Exception as e:\n        print(f'Error connecting to {ip}:{port} : {e}')\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.10'\n    target_port = 22\n    grab_banner(target_ip, target_port)"}
{"instruction": "Write a Bash script to harden an SSH server by disabling root login in the sshd_config file and reloading the service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $CONFIG_FILE \"${CONFIG_FILE}.bak\"\n\n# Disable Root Login using sed\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Check configuration validity and reload\nif sshd -t; then\n    systemctl reload sshd\n    echo \"Root login disabled and SSHD reloaded.\"\nelse\n    echo \"Configuration test failed. Reverting...\"\n    cp \"${CONFIG_FILE}.bak\" $CONFIG_FILE\nfi"}
{"instruction": "Write a Python function to generate a basic nftables configuration string that allows established connections and drops invalid traffic.", "output": "def generate_nftables_config():\n    config = \"\"\"\nflush ruleset\n\ntable inet filter {\n    chain input {\n        type filter hook input priority 0; policy drop;\n\n        # Accept loopback\n        iifname \"lo\" accept\n\n        # Accept established and related connections\n        ct state established,related accept\n\n        # Drop invalid connections\n        ct state invalid drop\n\n        # Allow SSH (example)\n        tcp dport 22 accept\n    }\n    chain forward {\n        type filter hook forward priority 0; policy drop;\n    }\n    chain output {\n        type filter hook output priority 0; policy accept;\n    }\n}\n\"\"\"\n    return config\n\nprint(generate_nftables_config())"}
{"instruction": "Write a Bash one-liner to analyze /var/log/auth.log and list the top 10 IP addresses responsible for failed SSH login attempts.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -10"}
{"instruction": "Write a Python script to audit file permissions of '/etc/shadow' and alert if they are not set to 0600 or stricter.", "output": "import os\nimport stat\n\nfile_path = '/etc/shadow'\n\ntry:\n    st = os.stat(file_path)\n    # Get permission bits in octal\n    perms = oct(st.st_mode & 0o777)\n    \n    # Check if permissions are strictly 600 (owner read/write only)\n    if perms != '0o600':\n        print(f'[ALERT] {file_path} permissions are unsafe: {perms}. Should be 0600.')\n    else:\n        print(f'[OK] {file_path} permissions are correct.')\nexcept OSError as e:\n    print(f'Could not check file: {e}')"}
{"instruction": "Write a Bash script that wraps Nmap to scan a specific subnet for open web ports (80, 443) and saves the output to a text file.", "output": "#!/bin/bash\n\nSUBNET=$1\nOUTPUT_FILE=\"web_scan_results.txt\"\n\nif [ -z \"$SUBNET\" ]; then\n    echo \"Usage: $0 <CIDR_SUBNET>\"\n    exit 1\nfi\n\necho \"Scanning $SUBNET for web ports...\"\nnmap -p 80,443 --open -oN $OUTPUT_FILE $SUBNET\n\necho \"Scan complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Write a Python script to read a JSON-formatted security log file and identify entries with a severity level of 'CRITICAL'.", "output": "import json\n\nlog_file = 'security_events.json'\n\ntry:\n    with open(log_file, 'r') as f:\n        data = json.load(f)\n        \n    print(\"Critical Events Detected:\")\n    for entry in data:\n        if entry.get('severity') == 'CRITICAL':\n            print(f\"Timestamp: {entry.get('timestamp')} - Message: {entry.get('message')}\")\n            \nexcept Exception as e:\n    print(f\"Error processing logs: {e}\")"}
{"instruction": "Write a Bash script to harden network settings by disabling IP forwarding and ICMP redirects in sysctl.conf.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\n# Helper function to set sysctl params\nset_sysctl() {\n    key=$1\n    value=$2\n    if grep -q \"^$key\" $SYSCTL_CONF; then\n        sed -i \"s/^$key.*/$key = $value/\" $SYSCTL_CONF\n    else\n        echo \"$key = $value\" >> $SYSCTL_CONF\n    fi\n}\n\n# Disable IP Forwarding\nset_sysctl \"net.ipv4.ip_forward\" \"0\"\n\n# Disable ICMP Redirects\nset_sysctl \"net.ipv4.conf.all.accept_redirects\" \"0\"\nset_sysctl \"net.ipv4.conf.default.accept_redirects\" \"0\"\n\n# Apply changes\nsysctl -p\necho \"Network hardening applied.\""}
{"instruction": "Python script to parse a standard Apache/Nginx access log and identify IP addresses that have generated more than 50 '404 Not Found' errors, indicating potential directory fuzzing or scanning.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    four_oh_four_ips = []\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        four_oh_four_ips.append(match.group(1))\n\n        counts = Counter(four_oh_four_ips)\n        print(\"Suspicious IPs (Over 50 404s):\")\n        for ip, count in counts.items():\n            if count > 50:\n                print(f\"IP: {ip} - Count: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Bash script to harden SSH configuration by disabling root login, disabling password authentication, and changing the default port, then restarting the service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Change Port to 2222 (Example)\nsed -i 's/^#Port 22/Port 2222/' $CONFIG_FILE\nsed -i 's/^Port 22/Port 2222/' $CONFIG_FILE\n\n# Validate config and restart\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Reverting...\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Python script to perform a local audit of installed pip packages against known vulnerabilities using the 'pip-audit' library (simulating a vulnerability scan task).", "output": "import subprocess\nimport json\nimport sys\n\ndef scan_packages():\n    print(\"Scanning installed packages for vulnerabilities...\")\n    try:\n        # Requires 'pip-audit' to be installed\n        result = subprocess.run(\n            ['pip-audit', '-f', 'json'],\n            capture_output=True,\n            text=True\n        )\n        \n        if result.returncode not in [0, 1]:\n            print(f\"Error running audit: {result.stderr}\")\n            return\n\n        audit_data = json.loads(result.stdout)\n        \n        if not audit_data.get('dependencies'):\n             print(\"No vulnerabilities found.\")\n             return\n\n        found_vulns = False\n        for dep in audit_data['dependencies']:\n            if dep.get('vulns'):\n                found_vulns = True\n                print(f\"[!] Package: {dep['name']} ({dep['version']})\")\n                for vuln in dep['vulns']:\n                    print(f\"    - ID: {vuln['id']}\")\n                    print(f\"    - Fix Versions: {vuln['fix_versions']}\")\n        \n        if not found_vulns:\n            print(\"No known vulnerabilities found in current environment.\")\n            \n    except FileNotFoundError:\n        print(\"pip-audit not installed. Run: pip install pip-audit\")\n\nif __name__ == \"__main__\":\n    scan_packages()"}
{"instruction": "Bash script using iptables to implement a 'Default Drop' firewall policy, allowing only SSH (port 22), HTTP (80), and HTTPS (443), while maintaining established connections.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\necho \"Firewall rules updated: Default DROP applied.\""}
{"instruction": "Python script using regex to analyze a string (simulating a log line) for common SQL Injection signatures (defensive input validation/detection).", "output": "import re\n\ndef detect_sqli(log_string):\n    # Regex for common SQLi patterns (UNION SELECT, OR 1=1, comment hacking)\n    sqli_patterns = [\n        r\"(?i)union\\s+select\",\n        r\"(?i)select\\s+.*\\s+from\",\n        r\"(?i)or\\s+['\\\"]?1['\\\"]?\\s*=\\s*['\\\"]?1\",\n        r\"--\",\n        r\";\\s*DROP\\s+TABLE\"\n    ]\n    \n    detected = False\n    for pattern in sqli_patterns:\n        if re.search(pattern, log_string):\n            print(f\"[ALERT] Potential SQL Injection detected: {pattern}\")\n            detected = True\n    \n    return detected\n\n# Example Usage\ntest_log = \"GET /search?q=admin' OR 1=1-- HTTP/1.1\"\nif detect_sqli(test_log):\n    print(f\"Blocked request: {test_log}\")\nelse:\n    print(\"Request clean.\")"}
{"instruction": "Bash script to audit the system for world-writable files, which pose a security risk, and save the list to a report file.", "output": "#!/bin/bash\n\nREPORT_FILE=\"world_writable_audit.txt\"\n\necho \"Starting Audit for World-Writable Files...\" > $REPORT_FILE\necho \"Date: $(date)\" >> $REPORT_FILE\necho \"----------------------------------------\" >> $REPORT_FILE\n\n# Find files with write permission for 'others' (! -type l excludes symlinks)\n# 2>/dev/null suppresses permission denied errors on system directories\nfind / -xdev -type f -perm -0002 -print 2>/dev/null >> $REPORT_FILE\n\necho \"Audit complete. Review $REPORT_FILE for potentially dangerous files.\""}
{"instruction": "Python script to verify file permissions of critical system files (e.g., /etc/shadow, /etc/passwd) to ensure they are not too permissive.", "output": "import os\nimport stat\n\ndef check_permissions(filepath, max_perm_octal):\n    try:\n        st = os.stat(filepath)\n        # Get octal permission (e.g., 644)\n        current_perm = oct(st.st_mode & 0o777)\n        \n        # Convert to integers for comparison\n        curr_int = int(current_perm, 8)\n        max_int = int(str(max_perm_octal), 8)\n        \n        if curr_int > max_int:\n            print(f\"[FAIL] {filepath}: Current {current_perm} (Max allowed: {max_perm_octal})\")\n        else:\n            print(f\"[PASS] {filepath}: {current_perm}\")\n            \n    except FileNotFoundError:\n        print(f\"[ERR] {filepath} not found.\")\n\n# Security Best Practices\n# /etc/shadow should be 600 or 000 (root only)\n# /etc/passwd should be 644 (root write, others read)\ncheck_permissions(\"/etc/shadow\", 600)\ncheck_permissions(\"/etc/passwd\", 644)\ncheck_permissions(\"/etc/ssh/sshd_config\", 600)"}
{"instruction": "Bash script using 'nftables' to create a table and chain that bans a specific list of malicious IP addresses read from a text file.", "output": "#!/bin/bash\n\nBLOCKLIST=\"malicious_ips.txt\"\nTABLE_NAME=\"security_filter\"\nCHAIN_NAME=\"blocklist\"\n\n# Initialize table and chain\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\nif [ -f \"$BLOCKLIST\" ]; then\n    while IFS= read -r ip; do\n        # Skip empty lines or comments\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        \n        echo \"Blocking IP: $ip\"\n        nft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr $ip drop\n    done < \"$BLOCKLIST\"\nelse\n    echo \"Blocklist file not found.\"\nfi\n\n# List rules\n# nft list table ip $TABLE_NAME"}
{"instruction": "Bash one-liner to parse /var/log/auth.log (or /var/log/secure) to count and display the top 10 IP addresses attempting failed SSH logins.", "output": "grep \"Failed password\" /var/log/auth.log | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Python script to scan localhost ports to verify that only expected services are listening (System Integrity Check).", "output": "import socket\n\ndef scan_listening_ports(target_ip='127.0.0.1', ports_to_scan=range(1, 1025)):\n    open_ports = []\n    print(f\"Scanning {target_ip} for listening services...\")\n    \n    for port in ports_to_scan:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    return open_ports\n\ndef verify_baseline(open_ports, allowed_ports):\n    unexpected = [p for p in open_ports if p not in allowed_ports]\n    if unexpected:\n        print(f\"[ALERT] Unexpected ports open: {unexpected}\")\n    else:\n        print(\"[OK] System matches port baseline.\")\n\n# Define allowed ports (e.g., SSH, DNS, HTTP)\nBASELINE = [22, 53, 80, 443]\n\nfound = scan_listening_ports()\nverify_baseline(found, BASELINE)"}
{"instruction": "Create a Python script to scan a specific target IP for open ports within a defined range (e.g., 1-1024) to identify potential entry points.", "output": "import socket\n\ndef port_scan(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Replace with target IP\n    target = \"192.168.1.1\"\n    port_scan(target, 1, 1024)"}
{"instruction": "Write a Bash script to identify all files on the system with the SUID bit set, which is a common check during server hardening to prevent privilege escalation.", "output": "#!/bin/bash\necho \"Searching for SUID binaries...\"\nfind / -user root -perm -4000 -print 2>/dev/null\necho \"Search complete.\""}
{"instruction": "Develop a Python script to analyze a web server log file (e.g., access.log) for common SQL injection patterns like 'UNION SELECT' or 'OR 1=1'.", "output": "import re\n\ndef analyze_logs(log_file):\n    sqli_patterns = [r\"UNION SELECT\", r\"OR 1=1\", r\"--\", r\"xp_cmdshell\"]\n    print(f\"Analyzing {log_file} for SQL Injection attempts...\")\n    try:\n        with open(log_file, 'r') as file:\n            for line in file:\n                for pattern in sqli_patterns:\n                    if re.search(pattern, line, re.IGNORECASE):\n                        print(f\"[ALERT] Potential SQLi detected: {line.strip()}\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs(\"access.log\")"}
{"instruction": "Write a Bash script to configure `iptables` with a strict defensive posture: flush existing rules, set default policies to DROP, and allow only loopback, established connections, and SSH.", "output": "#!/bin/bash\n# Flush existing rules\niptables -F\n\n# Set default chain policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Iptables configured successfully.\""}
{"instruction": "Create a Python utility to check the expiration date of an SSL certificate for a given hostname to prevent security warnings or service downtime.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expiry_date_str = cert['notAfter']\n                expiry_date = datetime.datetime.strptime(expiry_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expiry_date - datetime.datetime.now()).days\n                print(f\"Certificate for {hostname} expires in {days_left} days ({expiry_date})\")\n    except Exception as e:\n        print(f\"Error checking SSL: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Write a Bash script to harden a Linux server by creating a modprobe configuration file to disable unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs).", "output": "#!/bin/bash\ncat > /etc/modprobe.d/cis_fs_hardening.conf << 'EOF'\ninstall cramfs /bin/true\ninstall freevxfs /bin/true\ninstall jffs2 /bin/true\ninstall hfs /bin/true\ninstall hfsplus /bin/true\ninstall squashfs /bin/true\ninstall udf /bin/true\nEOF\necho \"Unused filesystems disabled via /etc/modprobe.d/cis_fs_hardening.conf\""}
{"instruction": "Create a Python script to parse `/var/log/auth.log` (or similar) and identify IP addresses with more than 5 failed SSH login attempts.", "output": "import re\nfrom collections import defaultdict\n\ndef check_failed_logins(log_path):\n    failed_attempts = defaultdict(int)\n    # Pattern to match: Failed password for <user> from <ip>\n    pattern = re.compile(r\"Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)\")\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(f\"File {log_path} not found.\")\n        return\n\n    print(\"IPs with > 5 failed login attempts:\")\n    for ip, count in failed_attempts.items():\n        if count > 5:\n            print(f\"{ip}: {count} failures\")\n\nif __name__ == \"__main__\":\n    check_failed_logins(\"/var/log/auth.log\")"}
{"instruction": "Write a Bash script using `nftables` to create a firewall configuration that allows incoming traffic on ports 80 (HTTP), 443 (HTTPS), and 22 (SSH), while dropping everything else.", "output": "#!/bin/bash\n# Create table\nnft add table inet filter\n\n# Create chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow established/related\nnft add rule inet filter input ct state established,related accept\n\n# Allow Loopback\nnft add rule inet filter input iif lo accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\necho \"Nftables rules applied.\""}
{"instruction": "Develop a Python script to audit the `sshd_config` file and warn if 'PermitRootLogin' is set to 'yes' or if 'PasswordAuthentication' is enabled.", "output": "def audit_ssh_config(config_path=\"/etc/ssh/sshd_config\"):\n    issues = []\n    try:\n        with open(config_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith('#') or not line:\n                    continue\n                \n                if \"PermitRootLogin\" in line and \"yes\" in line:\n                    issues.append(\"PermitRootLogin is set to yes\")\n                if \"PasswordAuthentication\" in line and \"yes\" in line:\n                    issues.append(\"PasswordAuthentication is set to yes\")\n        \n        if issues:\n            print(\"Security Issues Found:\")\n            for issue in issues:\n                print(f\"- {issue}\")\n        else:\n            print(\"No obvious issues found in checked parameters.\")\n            \n    except FileNotFoundError:\n        print(\"sshd_config not found.\")\n\nif __name__ == \"__main__\":\n    audit_ssh_config()"}
{"instruction": "Write a Bash script to audit user accounts by listing any non-root users with UID 0 (a critical security risk) and accounts with empty passwords.", "output": "#!/bin/bash\necho \"Checking for non-root users with UID 0...\"\nawk -F: '($3 == 0) { print $1 }' /etc/passwd\n\necho \"Checking for accounts with empty passwords...\"\nawk -F: '($2 == \"\") { print $1 }' /etc/shadow\n\necho \"Audit complete.\""}
{"instruction": "Write a Python script for Log Analysis that parses a standard Apache/Nginx access log file to identify and count the top 5 IP addresses returning 404 (Not Found) errors, which may indicate a scanning attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    four_oh_four_ips = []\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        four_oh_four_ips.append(match.group(1))\n        \n        counts = Counter(four_oh_four_ips)\n        print(\"Top 5 IPs generating 404 errors:\")\n        for ip, count in counts.most_common(5):\n            print(f\"{ip}: {count}\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/nginx/access.log')"}
{"instruction": "Create a Bash script for Server Hardening that disables root login via SSH and changes the default SSH port to 2222 to reduce automated brute-force attacks.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Change Port\n# Check if Port is commented out or exists\nif grep -q \"^#Port\" $SSHD_CONFIG; then\n    sed -i 's/^#Port.*/Port 2222/' $SSHD_CONFIG\nelif grep -q \"^Port\" $SSHD_CONFIG; then\n    sed -i 's/^Port.*/Port 2222/' $SSHD_CONFIG\nelse\n    echo \"Port 2222\" >> $SSHD_CONFIG\nfi\n\n# Test configuration and reload\nsshd -t && systemctl reload sshd\necho \"SSH hardening applied. Port changed to 2222 and Root login disabled.\""}
{"instruction": "Write a Python script for Vulnerability Scanning that checks a list of internal servers to see if their SSL certificates are expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        expiry_date = datetime.datetime.strptime(ssl_info['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n        days_left = (expiry_date - datetime.datetime.utcnow()).days\n        \n        if days_left < 30:\n            print(f\"[ALERT] {hostname} certificate expires in {days_left} days.\")\n        else:\n            print(f\"[OK] {hostname} certificate is valid for {days_left} days.\")\n            \n    except Exception as e:\n        print(f\"[ERROR] Could not connect to {hostname}: {e}\")\n    finally:\n        conn.close()\n\nservers = ['example.com', 'intranet.local']\nfor server in servers:\n    check_ssl_expiry(server)"}
{"instruction": "Generate a Bash script using 'iptables' to set up a basic stateful firewall. It should drop all incoming traffic by default, accept loopback traffic, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Basic stateful firewall rules applied.\""}
{"instruction": "Write a Python script for System Auditing that verifies file permissions on critical system files (like /etc/shadow and /etc/passwd) to ensure they comply with security best practices.", "output": "import os\nimport stat\n\ndef check_permissions(filepath, max_perm_octal):\n    try:\n        file_stat = os.stat(filepath)\n        # Get permission bits in octal\n        current_perm = oct(file_stat.st_mode & 0o777)\n        \n        # Convert octal strings to integers for comparison\n        curr_int = int(current_perm, 8)\n        max_int = int(max_perm_octal, 8)\n        \n        if curr_int > max_int:\n            print(f\"[FAIL] {filepath} is too open: {current_perm} (Max allowed: {max_perm_octal})\")\n        else:\n            print(f\"[PASS] {filepath} permissions are secure: {current_perm}\")\n            \n    except FileNotFoundError:\n        print(f\"[WARN] File {filepath} not found.\")\n\n# Define critical files and max allowed permissions (octal string)\nfiles_to_check = {\n    '/etc/shadow': '000',\n    '/etc/gshadow': '000',\n    '/etc/passwd': '644',\n    '/etc/group': '644'\n}\n\nfor f, p in files_to_check.items():\n    check_permissions(f, p)"}
{"instruction": "Create a Bash script using 'nftables' to limit incoming SSH connections to prevent brute-force attacks (allow max 10 connections per minute from a single IP).", "output": "#!/bin/bash\n\n# Create table if not exists\nnft add table ip filter\n\n# Create input chain\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule: Accept SSH if under limit, drop if over limit\n# Tracks flow by source IP, expires entries after 60s\nnft add rule ip filter input tcp dport 22 ct state new meter ssh-meter { ip saddr limit rate 10/minute } accept\nnft add rule ip filter input tcp dport 22 drop\n\necho \"nftables rate limiting for SSH applied.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (FIM) that calculates SHA-256 hashes of binaries in /bin and stores them in a dictionary. This is a foundational step for detecting unauthorized changes.", "output": "import os\nimport hashlib\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef scan_directory(directory):\n    baseline = {}\n    print(f\"Scanning {directory}...\")\n    for filename in os.listdir(directory):\n        filepath = os.path.join(directory, filename)\n        if os.path.isfile(filepath):\n            file_hash = calculate_hash(filepath)\n            if file_hash:\n                baseline[filename] = file_hash\n    return baseline\n\nif __name__ == \"__main__\":\n    # Scan /bin (or /usr/bin) for baseline\n    hashes = scan_directory(\"/bin\")\n    print(f\"Hashed {len(hashes)} files.\")\n    # In a real scenario, save 'hashes' to a secure file or DB"}
{"instruction": "Create a Bash script for Log Analysis that searches the Linux 'auth.log' for failed password attempts and extracts the unique usernames targeted.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Auth log not found at $LOG_FILE\"\n    exit 1\nfi\n\necho \"Usernames targeted by failed login attempts:\"\n\n# Grep for 'Failed password', extract the field before 'from', sort and unique\ngrep \"Failed password\" $LOG_FILE | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | sort | uniq -c | sort -nr\n\n# Note: This handles standard sshd log format. 'invalid user' entries might slightly vary."}
{"instruction": "Write a Python script for Security Auditing that checks if specific users (like 'root') have a password set or if they are locked/disabled by inspecting /etc/shadow (requires root privileges).", "output": "import spwd\nimport crypt\n\ndef check_account_status(username):\n    try:\n        # Get shadow entry\n        entry = spwd.getspnam(username)\n        password_hash = entry.sp_pwdp\n        \n        if password_hash == '!':\n            print(f\"User '{username}': Account is LOCKED (no password set).\")\n        elif password_hash == '*':\n            print(f\"User '{username}': Account is DISABLED (cannot login).\")\n        elif password_hash.startswith('!') and len(password_hash) > 1:\n            print(f\"User '{username}': Account is LOCKED (password expired/locked).\")\n        else:\n            print(f\"User '{username}': Account is ACTIVE (password set).\")\n            \n    except KeyError:\n        print(f\"User '{username}' not found in shadow database.\")\n    except PermissionError:\n        print(\"Error: This script requires root privileges to read /etc/shadow.\")\n\nif __name__ == \"__main__\":\n    check_account_status('root')\n    check_account_status('sysadmin')"}
{"instruction": "Create a Bash script for Server Hardening that searches for and removes setuid and setgid bits from all files on the system, excluding a whitelist of necessary binaries (like sudo or ping), to mitigate privilege escalation risks.", "output": "#!/bin/bash\n\n# Define a file to store the list of SUID/SGID files found\nOUTPUT_FILE=\"/root/suid_files_audit.txt\"\n\necho \"Scanning for SUID/SGID files...\"\nfind / -perm /6000 -type f 2>/dev/null > $OUTPUT_FILE\n\necho \"Found files listed in $OUTPUT_FILE. Removing bits from non-whitelisted files...\"\n\n# Whitelist of common binaries that need SUID (Adjust as needed)\nWHITELIST=\"/usr/bin/sudo|/usr/bin/passwd|/usr/bin/ping|/usr/bin/mount|/usr/bin/umount|/usr/bin/su\"\n\nwhile read -r file; do\n    if echo \"$file\" | grep -E -q \"$WHITELIST\"; then\n        echo \"Skipping whitelisted: $file\"\n    else\n        echo \"Removing SUID/SGID from: $file\"\n        chmod -s \"$file\"\n    fi\ndone < $OUTPUT_FILE\n\necho \"Hardening complete.\""}
{"instruction": "Write a Python script to check for open common ports (21, 22, 80, 443) on a local target IP for vulnerability assessment purposes.", "output": "import socket\n\ntarget_ip = '127.0.0.1'\nports_to_scan = [21, 22, 80, 443]\n\nprint(f'Scanning {target_ip}...')\nfor port in ports_to_scan:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f'Port {port}: OPEN')\n    else:\n        print(f'Port {port}: CLOSED')\n    sock.close()"}
{"instruction": "Create a Bash script to parse Apache access logs and identify the top 5 IP addresses generating 404 (Not Found) errors, useful for detecting scanning activity.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/apache2/access.log\"\n\nif [[ -f \"$LOG_FILE\" ]]; then\n    echo \"Top 5 IPs generating 404 errors:\"\n    awk '($9 ~ /404/)' \"$LOG_FILE\" | awk '{print $1}' | sort | uniq -c | sort -rn | head -n 5\nelse\n    echo \"Log file not found.\"\nfi"}
{"instruction": "Write a Bash script that accepts an IP address as an argument and adds an iptables rule to drop all incoming traffic from that IP (Firewall Block).", "output": "#!/bin/bash\nBLOCK_IP=$1\n\nif [[ -z \"$BLOCK_IP\" ]]; then\n    echo \"Usage: $0 <IP_ADDRESS>\"\n    exit 1\nfi\n\n# Append rule to drop traffic from the specific IP\niptables -A INPUT -s \"$BLOCK_IP\" -j DROP\necho \"Blocked all incoming traffic from $BLOCK_IP\""}
{"instruction": "Develop a Python script to parse a generic JSON log file simulating SIEM data and alert if the number of 'failed_login' events exceeds a specific threshold.", "output": "import json\n\ndef analyze_siem_logs(file_path, threshold=5):\n    try:\n        with open(file_path, 'r') as f:\n            logs = json.load(f)\n        \n        failed_count = 0\n        for entry in logs:\n            if entry.get('event') == 'failed_login':\n                failed_count += 1\n        \n        if failed_count >= threshold:\n            print(f'ALERT: High number of failed logins detected: {failed_count}')\n        else:\n            print(f'Status Normal: {failed_count} failed logins.')\n            \n    except FileNotFoundError:\n        print('Log file not found.')\n\n# Example usage\n# analyze_siem_logs('siem_data.json')"}
{"instruction": "Write a Bash script for server hardening that sets strict permissions (600/644) on critical identity files like /etc/passwd and /etc/shadow.", "output": "#!/bin/bash\n\necho \"Hardening file permissions...\"\n\n# /etc/shadow should only be readable by root\nchmod 600 /etc/shadow\n\n# /etc/passwd must be readable by everyone but writable only by root\nchmod 644 /etc/passwd\n\n# /etc/gshadow should be protected\nchmod 600 /etc/gshadow\n\n# /etc/group readable by everyone, writable by root\nchmod 644 /etc/group\n\necho \"Permissions updated.\""}
{"instruction": "Create a Bash script using nftables to configure a basic web server firewall: Allow loopback, established connections, HTTP, HTTPS, and SSH, then drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established/related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\necho \"Nftables firewall configured.\""}
{"instruction": "Write a Python script that uses pip to list outdated Python packages installed on the system, aiding in vulnerability management.", "output": "import subprocess\nimport json\n\ndef list_outdated_packages():\n    try:\n        # Run pip list --outdated with JSON format\n        result = subprocess.run(\n            ['pip', 'list', '--outdated', '--format=json'], \n            capture_output=True, \n            text=True\n        )\n        packages = json.loads(result.stdout)\n        \n        print(f\"{'Package':<20} {'Current':<10} {'Latest':<10}\")\n        print(\"-\"*40)\n        for pkg in packages:\n            print(f\"{pkg['name']:<20} {pkg['version']:<10} {pkg['latest_version']:<10}\")\n            \n    except Exception as e:\n        print(f\"Error checking packages: {e}\")\n\nif __name__ == '__main__':\n    list_outdated_packages()"}
{"instruction": "Write a Bash script to monitor /var/log/auth.log in real-time and display a warning message whenever a 'Failed password' entry appears.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/auth.log\"\n\necho \"Monitoring $LOG_FILE for failed login attempts...\"\n\n# tail -F follows the file even if it is rotated\ntail -F \"$LOG_FILE\" | while read line; do\n    if echo \"$line\" | grep -q \"Failed password\"; then\n        echo \"[WARNING] Suspicious Activity: $line\"\n    fi\ndone"}
{"instruction": "Write a Python script that generates a bash script string to apply iptables rules allowing traffic only on a specific list of ports.", "output": "def generate_iptables_script(allowed_ports):\n    script = \"#!/bin/bash\\n\"\n    script += \"# Flush existing rules\\n\"\n    script += \"iptables -F\\n\"\n    script += \"# Set default policy to DROP\\n\"\n    script += \"iptables -P INPUT DROP\\n\"\n    script += \"# Allow established connections\\n\"\n    script += \"iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\\n\"\n    \n    for port in allowed_ports:\n        script += f\"iptables -A INPUT -p tcp --dport {port} -j ACCEPT\\n\"\n        \n    return script\n\nports = [22, 80, 443, 3306]\nprint(generate_iptables_script(ports))"}
{"instruction": "Create a Bash script to harden SSH configuration by disabling root login and password authentication in sshd_config.", "output": "#!/bin/bash\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp \"$CONFIG_FILE\" \"$CONFIG_FILE.bak\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\n\n# Disable Password Authentication (Ensure keys are set up first!)\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\n# Check syntax and restart if valid\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Reverting...\"\n    mv \"$CONFIG_FILE.bak\" \"$CONFIG_FILE\"\nfi"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential vulnerability scanning.", "output": "import re\nfrom collections import defaultdict\n\nlog_file = '/var/log/apache2/access.log'\nip_404_count = defaultdict(int)\n\n# Regex to extract IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_404_count[ip_address] += 1\n\n    print(\"Suspicious IPs (More than 10 404s):\")\n    for ip, count in ip_404_count.items():\n        if count > 10:\n            print(f\"{ip}: {count} errors\")\nexcept FileNotFoundError:\n    print(f\"Log file not found: {log_file}\")"}
{"instruction": "Write a Bash script for Server Hardening that locks down SSH access by disabling root login and password authentication in the sshd_config file, then reloads the service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Password Authentication\nif grep -q \"^PasswordAuthentication\" $SSHD_CONFIG; then\n    sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nelse\n    echo \"PasswordAuthentication no\" >> $SSHD_CONFIG\nfi\n\n# Validate syntax and reload\nsshd -t && systemctl reload sshd\necho \"SSH Hardening complete.\""}
{"instruction": "Generate a Python script for Server Hardening that audits the file permissions of critical system files (e.g., /etc/shadow, /etc/passwd) to ensure they comply with security best practices.", "output": "import os\nimport stat\n\nfiles_to_check = {\n    '/etc/shadow': '600',\n    '/etc/passwd': '644',\n    '/etc/group': '644',\n    '/etc/gshadow': '600'\n}\n\ndef get_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        return oct(st.st_mode)[-3:]\n    except FileNotFoundError:\n        return None\n\nprint(\"Starting Permission Audit...\")\nfor filepath, expected in files_to_check.items():\n    current = get_permissions(filepath)\n    if current:\n        if current != expected:\n            print(f\"[ALERT] {filepath} is {current}, expected {expected}\")\n        else:\n            print(f\"[OK] {filepath}\")\n    else:\n        print(f\"[MISSING] {filepath}\")"}
{"instruction": "Create a Bash script using 'iptables' to implement a basic firewall strategy: Allow loopback, allow established connections, allow SSH (port 22), and drop all other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script for Vulnerability Scanning that checks the SSL/TLS certificate of a specific domain to see if it is expired or expiring within the next 7 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=5) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                not_after = cert['notAfter']\n                # Parse date format: 'May 25 23:59:59 2024 GMT'\n                expiry_date = datetime.datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expiry_date - datetime.datetime.now()).days\n\n                if days_left < 0:\n                    print(f\"[CRITICAL] Certificate for {hostname} EXPIRED on {expiry_date}.\")\n                elif days_left < 7:\n                    print(f\"[WARNING] Certificate for {hostname} expires in {days_left} days.\")\n                else:\n                    print(f\"[OK] Certificate for {hostname} is valid for {days_left} days.\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\ncheck_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script for Log Analysis (SIEM) that monitors '/var/log/auth.log' in real-time for 'Failed password' events and alerts the user on the console.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\necho \"Monitoring $LOG_FILE for failed login attempts...\"\n\n# Tail the log file and grep for failure patterns\ntail -F $LOG_FILE | while read line; do\n    if echo \"$line\" | grep -q \"Failed password\"; then\n        # Extract timestamp and IP (assuming standard syslog format)\n        TIMESTAMP=$(echo \"$line\" | awk '{print $1, $2, $3}')\n        IP=$(echo \"$line\" | grep -oP 'from \\K[\\d.]+')\n        echo \"[ALERT] Failed Login detected at $TIMESTAMP from IP: $IP\"\n    fi\ndone"}
{"instruction": "Write a Bash script using 'nftables' to create a table and chain that blocks a specific list of malicious IP addresses found in a text file.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\nSET_NAME=\"blocked_ips\"\n\n# Initialize nftables config if not present\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Create a set for IP addresses\nnft add set ip $TABLE_NAME $SET_NAME { type ipv4_addr \\; }\n\n# Add rule to drop traffic from IPs in the set\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr @$SET_NAME drop\n\n# Populate the set from file\nif [ -f \"$BLACKLIST_FILE\" ]; then\n    while IFS= read -r ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        nft add element ip $TABLE_NAME $SET_NAME { $ip }\n        echo \"Blocked: $ip\"\n    done < \"$BLACKLIST_FILE\"\nelse\n    echo \"Blacklist file not found.\"\nfi"}
{"instruction": "Generate a Python script for Server Hardening that scans for world-writable files in a specific directory (recursively) and reports them.", "output": "import os\nimport stat\n\ndef find_world_writable(start_dir):\n    print(f\"Scanning {start_dir} for world-writable files...\")\n    for root, dirs, files in os.walk(start_dir):\n        for name in files:\n            filepath = os.path.join(root, name)\n            try:\n                st = os.stat(filepath)\n                # Check if 'others' have write permission (S_IWOTH)\n                if st.st_mode & stat.S_IWOTH:\n                    print(f\"[RISK] World-writable file found: {filepath}\")\n            except OSError as e:\n                print(f\"Could not access {filepath}: {e}\")\n\n# Example usage scanning /var/www\nfind_world_writable('/var/www')"}
{"instruction": "Create a Bash script for Vulnerability Scanning that performs a local port audit by listing all listening TCP ports and the associated process name using 'ss' or 'netstat'.", "output": "#!/bin/bash\n\necho \"Starting Local Port Audit...\"\necho \"--------------------------------------------------\"\necho \"PROTO | LOCAL ADDRESS | STATE | PID/PROGRAM\"\necho \"--------------------------------------------------\"\n\n# Use ss (socket statistics) as it is modern replacement for netstat\n# -t: tcp, -l: listening, -n: numeric, -p: processes\nss -tlnp | awk 'NR>1 {print $1, $4, $2, $6}' | while read proto addr state proc; do\n    # Format output for readability\n    echo \"$proto   | $addr     | $state | $proc\"\ndone\n\necho \"--------------------------------------------------\"\necho \"Audit Complete. Verify any unknown processes.\""}
{"instruction": "Write a Python script for Security Operations that queries the 'haveibeenpwned' API (simulated logic) or a local hash database to check if a specific SHA1 password hash is compromised.", "output": "import hashlib\nimport requests\n\ndef check_pwned_api(password):\n    # Hash the password using SHA1\n    sha1password = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()\n    head, tail = sha1password[:5], sha1password[5:]\n    \n    url = f\"https://api.pwnedpasswords.com/range/{head}\"\n    try:\n        res = requests.get(url, timeout=5)\n        if res.status_code != 200:\n            raise RuntimeError(f\"API Error: {res.status_code}\")\n        \n        # Check if the tail of the hash exists in the response\n        hashes = (line.split(':') for line in res.text.splitlines())\n        for h, count in hashes:\n            if h == tail:\n                return int(count)\n        return 0\n    except Exception as e:\n        print(f\"Error checking password: {e}\")\n        return -1\n\n# Example Usage\npwd = \"password123\"\ncount = check_pwned_api(pwd)\nif count > 0:\n    print(f\"[ALERT] The password '{pwd}' has been exposed {count} times.\")\nelse:\n    print(f\"[OK] The password '{pwd}' was not found in the breach database.\")"}
{"instruction": "Write a Python script to parse a standard Apache access log file named 'access.log'. The script should identify and print any IP address that has generated more than 50 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import defaultdict\n\nlog_file = 'access.log'\nip_404_count = defaultdict(int)\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_404_count[ip_address] += 1\n\n    print(\"IPs with > 50 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > 50:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(f\"File {log_file} not found.\")"}
{"instruction": "Create a Bash script to harden the SSH daemon configuration. The script should back up the existing config, disable root login, disable password authentication, and reload the sshd service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\n# Backup existing config\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\necho \"Backup created at $BACKUP_FILE\"\n\n# Apply hardening settings using sed\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\n# Validate config and reload service\nif sshd -t; then\n    systemctl reload sshd\n    echo \"SSH hardening applied and service reloaded.\"\nelse\n    echo \"Configuration test failed. Restoring backup.\"\n    cp \"$BACKUP_FILE\" \"$CONFIG_FILE\"\nfi"}
{"instruction": "Write a Bash script to configure a basic 'iptables' firewall. The policy should set default DROP for INPUT and FORWARD chains, accept loopback traffic, allow established connections, and allow incoming TCP traffic only on ports 22 (SSH), 80 (HTTP), and 443 (HTTPS).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow specific ports\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional, limited)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules configured.\""}
{"instruction": "Develop a Python script using the 'socket' library to check the status of common service ports (21, 22, 80, 443, 3306) on a specific target IP address to verify exposure.", "output": "import socket\n\ntarget_ip = \"192.168.1.10\"  # Replace with target IP\nports_to_check = [21, 22, 80, 443, 3306]\n\nprint(f\"Scanning {target_ip}...\")\n\nfor port in ports_to_check:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f\"Port {port}: OPEN\")\n    else:\n        print(f\"Port {port}: CLOSED/FILTERED\")\n    sock.close()"}
{"instruction": "Write a Bash one-liner to extract and count the top 10 source IP addresses attempting failed SSH logins from the '/var/log/auth.log' file.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Python script that audits critical system files ('/etc/passwd', '/etc/shadow', '/etc/group'). It should check if their permissions are too open (e.g., world-writable or world-readable for shadow) and print a compliance warning.", "output": "import os\nimport stat\n\nfiles_to_check = {\n    '/etc/passwd': 0o644,\n    '/etc/shadow': 0o640,\n    '/etc/group': 0o644\n}\n\nfor filepath, expected_mode in files_to_check.items():\n    if not os.path.exists(filepath):\n        print(f\"[MISSING] {filepath}\")\n        continue\n\n    file_stat = os.stat(filepath)\n    current_mode = stat.S_IMODE(file_stat.st_mode)\n\n    # Check if world writable (bit 0o002)\n    if current_mode & stat.S_IWOTH:\n        print(f\"[CRITICAL] {filepath} is world-writable!\")\n    \n    # specific check for shadow world-readable\n    if filepath == '/etc/shadow' and (current_mode & stat.S_IROTH):\n        print(f\"[CRITICAL] {filepath} is world-readable!\")\n        \n    print(f\"[INFO] {filepath} Mode: {oct(current_mode)} (Expected: {oct(expected_mode)})\")"}
{"instruction": "Create a Bash script that reads a list of malicious IP addresses from a file named 'blacklist.txt' and adds them to an 'nftables' set named 'blackhole' to block traffic.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\nTABLE_NAME=\"filter\"\nSET_NAME=\"blackhole\"\n\n# Ensure table and set exist\nnft add table inet $TABLE_NAME\nnft add set inet $TABLE_NAME $SET_NAME { type ipv4_addr\\; }\nnft add rule inet $TABLE_NAME input ip saddr @$SET_NAME drop\n\n# Read IPs and add to set\nif [ -f \"$BLACKLIST_FILE\" ]; then\n    while IFS= read -r ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [ -z \"$ip\" ] && continue\n        nft add element inet $TABLE_NAME $SET_NAME { \"$ip\" }\n        echo \"Blocked IP: $ip\"\n    done < \"$BLACKLIST_FILE\"\nelse\n    echo \"Blacklist file not found.\"\nfi"}
{"instruction": "Write a Python function that parses a list of JSON-formatted log dictionaries. It should detect and return a list of users who have had 3 or more failed login attempts with the status 'failure'.", "output": "def detect_bruteforce(logs):\n    \"\"\"\n    logs: list of dicts, e.g., [{'user': 'admin', 'status': 'failure', 'timestamp': 162000}]\n    \"\"\"\n    failed_counts = {}\n    flagged_users = []\n\n    for entry in logs:\n        if entry.get('status') == 'failure':\n            user = entry.get('user')\n            if user:\n                failed_counts[user] = failed_counts.get(user, 0) + 1\n\n    for user, count in failed_counts.items():\n        if count >= 3:\n            flagged_users.append(user)\n            \n    return flagged_users\n\n# Example Usage:\n# data = [\n#   {\"user\": \"alice\", \"status\": \"failure\"},\n#   {\"user\": \"alice\", \"status\": \"failure\"},\n#   {\"user\": \"alice\", \"status\": \"failure\"},\n#   {\"user\": \"bob\", \"status\": \"success\"}\n# ]\n# print(detect_bruteforce(data))"}
{"instruction": "Write a Bash script to identify user accounts in '/etc/passwd' that have a UID of 0 but are not the 'root' user, which indicates a potential security backdoor.", "output": "#!/bin/bash\n\necho \"Scanning for non-root users with UID 0...\"\n\nwhile IFS=: read -r username password uid gid userid home shell; do\n    if [ \"$uid\" -eq 0 ] && [ \"$username\" != \"root\" ]; then\n        echo \"[ALERT] User '$username' has UID 0!\"\n    fi\ndone < /etc/passwd\n\necho \"Scan complete.\""}
{"instruction": "Create a Python script to connect to a list of servers on port 22 and retrieve the SSH banner string to audit the SSH versions running in the infrastructure.", "output": "import socket\n\nservers = ['192.168.1.50', '192.168.1.51']\n\nprint(\"Auditing SSH Banners...\")\n\nfor server in servers:\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(2)\n        s.connect((server, 22))\n        banner = s.recv(1024).decode().strip()\n        print(f\"[+] {server}: {banner}\")\n        s.close()\n    except Exception as e:\n        print(f\"[-] {server}: Failed to retrieve banner ({e})\")"}
{"instruction": "Write a Python script to scan a specific target IP for open ports within a defined range (1-1024) using the socket library.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example usage\n    target = \"127.0.0.1\"\n    scan_ports(target, 1, 1024)"}
{"instruction": "Create a Bash script to parse an Apache access log file, identify IP addresses with more than 100 requests, and list them.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/apache2/access.log\"\nTHRESHOLD=100\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"IP addresses with more than $THRESHOLD requests:\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"$ip ($count requests)\"\n    fi\ndone"}
{"instruction": "Write a Bash script to configure iptables firewall rules that drop all incoming traffic by default, but allow SSH, HTTP, HTTPS, and established connections.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP for input and forward\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP (80) and HTTPS (443)\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules applied.\""}
{"instruction": "Develop a Python script to check the SSL certificate expiration date of a given domain name.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((domain, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                cert = ssock.getpeercert()\n                not_after = cert['notAfter']\n                # Parse the date format: 'May 25 23:59:59 2024 GMT'\n                expiry_date = datetime.datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expiry_date - datetime.datetime.utcnow()).days\n                print(f\"Domain: {domain}\")\n                print(f\"Expires on: {expiry_date}\")\n                print(f\"Days remaining: {days_left}\")\n    except Exception as e:\n        print(f\"Error checking {domain}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"example.com\")"}
{"instruction": "Write a Bash script for basic server hardening that disables root login via SSH and restarts the SSH service.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup the config file\ncp \"$SSH_CONFIG\" \"$SSH_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" \"$SSH_CONFIG\"; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSH_CONFIG\"\nelse\n    echo \"PermitRootLogin no\" >> \"$SSH_CONFIG\"\nfi\n\n# Disable Empty Passwords\nif grep -q \"^PermitEmptyPasswords\" \"$SSH_CONFIG\"; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' \"$SSH_CONFIG\"\nelse\n    echo \"PermitEmptyPasswords no\" >> \"$SSH_CONFIG\"\nfi\n\necho \"Hardening configuration applied. Restarting SSH service...\"\nsystemctl restart sshd"}
{"instruction": "Write a Python script to calculate SHA-256 hashes of all files in a specific directory to establish a baseline for File Integrity Monitoring (FIM).", "output": "import hashlib\nimport os\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef scan_directory(directory_path):\n    print(f\"Scanning directory: {directory_path}\")\n    for root, dirs, files in os.walk(directory_path):\n        for file in files:\n            filepath = os.path.join(root, file)\n            file_hash = calculate_sha256(filepath)\n            if file_hash:\n                print(f\"{file_hash}  {filepath}\")\n\nif __name__ == \"__main__\":\n    scan_directory(\"/etc/nginx\")"}
{"instruction": "Create a Bash script to generate nftables rules that block a list of suspicious IP addresses read from a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"suspicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\nif [ ! -f \"$BLOCKLIST_FILE\" ]; then\n    echo \"Blocklist file not found.\"\n    exit 1\nfi\n\n# Ensure the table and chain exist (basic setup)\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\necho \"Adding rules to block IPs...\"\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    echo \"Blocking $ip\"\n    nft add rule ip $TABLE_NAME $CHAIN_NAME saddr \"$ip\" drop\ndone < \"$BLOCKLIST_FILE\"\n\necho \"Done.\""}
{"instruction": "Write a Python script to parse a standard auth.log file and detect multiple failed SSH login attempts from the same IP address.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_auth_log(log_path, threshold=5):\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from sshd failed password lines\n    # Example: \"Failed password for root from 192.168.1.5 port 22 ssh2\"\n    pattern = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if 'sshd' in line and 'Failed password' in line:\n                    match = pattern.search(line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n        return\n\n    print(f\"IPs with more than {threshold} failed login attempts:\")\n    for ip, count in failed_attempts.items():\n        if count > threshold:\n            print(f\"{ip}: {count} attempts\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log(\"/var/log/auth.log\")"}
{"instruction": "Write a Bash script to verify and fix permissions on critical system files (/etc/shadow, /etc/passwd) to ensure they are secure.", "output": "#!/bin/bash\n\n# Secure /etc/shadow: root read/write, shadow group read, no others\necho \"Securing /etc/shadow...\"\nchown root:shadow /etc/shadow\nchmod 640 /etc/shadow\n\n# Secure /etc/passwd: root read/write, others read only\necho \"Securing /etc/passwd...\"\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\n\n# Secure /etc/group\necho \"Securing /etc/group...\"\nchown root:root /etc/group\nchmod 644 /etc/group\n\n# Secure /etc/gshadow\necho \"Securing /etc/gshadow...\"\nchown root:shadow /etc/gshadow\nchmod 640 /etc/gshadow\n\necho \"Critical file permissions verified and updated.\""}
{"instruction": "Write a Python script to perform a simple banner grab on a target server and port to identify the running service version.", "output": "import socket\n\ndef banner_grab(ip, port):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(2)\n        sock.connect((ip, port))\n        \n        # Send a generic request if necessary, or just wait for banner\n        # Some services like HTTP require a request to send a header back\n        if port == 80 or port == 8080:\n            sock.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')\n            \n        banner = sock.recv(1024)\n        print(f\"Banner for {ip}:{port} ->\\n{banner.decode('utf-8', errors='ignore').strip()}\")\n        sock.close()\n    except Exception as e:\n        print(f\"Could not grab banner: {e}\")\n\nif __name__ == \"__main__\":\n    banner_grab(\"127.0.0.1\", 22)"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 50 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 50\nip_counter = Counter()\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+) .*? \"(?:GET|POST|PUT|HEAD|DELETE) .*?\" (?P<status>404) ')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_counter[match.group('ip')] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_counter.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script for Server Hardening that disables root login and enforces empty password checks in the SSH configuration file.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Prevent empty passwords\nif grep -q \"^PermitEmptyPasswords\" $SSHD_CONFIG; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\nelse\n    echo \"PermitEmptyPasswords no\" >> $SSHD_CONFIG\nfi\n\necho \"SSH hardening applied. Restart sshd to take effect.\""}
{"instruction": "Create a Python script for Vulnerability Scanning that checks a list of internal servers to verify if their SSL certificates are expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\nhostnames = ['example.com', 'internal-service.local']\nport = 443\n\ndef get_ssl_expiry_date(hostname):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    conn.settimeout(3.0)\n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        # Parse date format: 'May 25 12:00:00 2025 GMT'\n        return datetime.datetime.strptime(ssl_info['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n    except Exception as e:\n        return None\n    finally:\n        conn.close()\n\nnow = datetime.datetime.now()\nfor host in hostnames:\n    expire_date = get_ssl_expiry_date(host)\n    if expire_date:\n        days_left = (expire_date - now).days\n        if days_left < 30:\n            print(f\"ALERT: {host} expires in {days_left} days.\")\n        else:\n            print(f\"OK: {host} expires in {days_left} days.\")\n    else:\n        print(f\"ERROR: Could not connect to {host}\")"}
{"instruction": "Write a Bash script using `iptables` to implement a basic firewall strategy: Drop all incoming traffic by default, but allow loopback, established connections, and SSH (port 22).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (Hardening) that calculates SHA-256 hashes of critical system binaries in `/bin` and compares them against a known baseline dictionary.", "output": "import hashlib\nimport os\n\n# Example baseline (in production, load this from a secure database)\nbaseline = {\n    '/bin/ls': 'expected_hash_string_here',\n    '/bin/ps': 'expected_hash_string_here'\n}\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nprint(\"Starting Integrity Check...\")\nfor filepath, expected_hash in baseline.items():\n    current_hash = calculate_sha256(filepath)\n    if current_hash is None:\n        print(f\"MISSING: {filepath}\")\n    elif current_hash != expected_hash:\n        print(f\"ALTERED: {filepath} (Hash Mismatch!)\")\n    else:\n        print(f\"OK: {filepath}\")"}
{"instruction": "Write a Bash script for Vulnerability Assessment that searches the filesystem for files that are world-writable (permission 777) and saves the list to a report file.", "output": "#!/bin/bash\n\nREPORT_FILE=\"world_writable_report.txt\"\nSEARCH_DIR=\"/var/www/html\" # Restrict search scope for performance/safety\n\necho \"Scanning for world-writable files in $SEARCH_DIR...\" > $REPORT_FILE\n\n# Find files with write permission for 'others'\nfind $SEARCH_DIR -type f -perm -002 -print >> $REPORT_FILE 2>/dev/null\n\necho \"Scan complete. Check $REPORT_FILE for results.\""}
{"instruction": "Create a Python script for SIEM/Log Analysis that reads `/var/log/auth.log` (or similar) to detect and count failed SSH login attempts grouped by username.", "output": "import re\nfrom collections import Counter\n\nlog_path = '/var/log/auth.log'\nuser_counter = Counter()\n\n# Regex for common linux SSH failure patterns\nfail_pattern = re.compile(r'Failed password for (invalid user )?(?P<user>\\S+) from')\n\ntry:\n    with open(log_path, 'r') as f:\n        for line in f:\n            if 'sshd' in line:\n                match = fail_pattern.search(line)\n                if match:\n                    user_counter[match.group('user')] += 1\n\n    print(\"Failed SSH Login Attempts by User:\")\n    for user, count in user_counter.most_common():\n        print(f\"User: {user:<15} Count: {count}\")\nexcept PermissionError:\n    print(\"Error: Need root privileges to read auth.log\")"}
{"instruction": "Write a Bash script using `nftables` to create a configuration that limits ICMP echo requests (ping) to prevent flood attacks.", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create chain for input\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow established traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Rate limit ICMP Echo Requests (Ping) - 1 per second, burst 5\nnft add rule inet filter input ip protocol icmp icmp type echo-request limit rate 1/second burst 5 packets accept\n\necho \"nftables ICMP rate limit applied.\""}
{"instruction": "Create a Python script for Hardening that audits the local system to check if necessary security packages (like `fail2ban` and `ufw`) are installed.", "output": "import subprocess\nimport sys\n\nrequired_packages = ['fail2ban', 'ufw', 'unattended-upgrades']\n\ndef check_package(package_name):\n    try:\n        # using dpkg-query for Debian/Ubuntu systems\n        subprocess.check_call(['dpkg-query', '-W', '-f=${Status}', package_name], \n                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\nprint(\"Security Package Audit:\")\nall_installed = True\nfor pkg in required_packages:\n    if check_package(pkg):\n        print(f\"[+] {pkg} is installed.\")\n    else:\n        print(f\"[-] {pkg} is MISSING.\")\n        all_installed = False\n\nif not all_installed:\n    print(\"\\nRecommendation: Install missing packages immediately.\")"}
{"instruction": "Write a Bash script for Vulnerability Management that lists all listening ports and the associated process, helping identify unauthorized services running on the server.", "output": "#!/bin/bash\n\necho \"Scanning for listening ports and associated processes...\"\n\n# Check if netstat is available, otherwise use ss\nif command -v netstat >/dev/null 2>&1; then\n    netstat -tulnp | grep 'LISTEN'\nelse\n    ss -tulnp | grep 'LISTEN'\nfi\n\necho \"\\nReview the list above for any unknown services or high ports.\""}
{"instruction": "Write a Python script to parse a standard Apache access log file named 'access.log'. The script should identify and print IP addresses that have generated more than 10 '404 Not Found' errors, which may indicate a directory enumeration attempt.", "output": "import re\nfrom collections import defaultdict\n\nlog_file = 'access.log'\nip_404_count = defaultdict(int)\n\n# Regex to extract IP and status code\n# Example line: 192.168.1.1 - - [10/Oct/2023:13:55:36 -0700] \"GET /unknown HTTP/1.1\" 404 232\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(404)\\s')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_404_count[ip_address] += 1\n\n    print(\"IPs with > 10 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(f\"File {log_file} not found.\")"}
{"instruction": "Create a Bash script for server hardening that backs up the existing SSH configuration, disables root login, and restarts the SSH service.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\necho \"Backing up SSH config to $BACKUP_CONFIG...\"\ncp $SSH_CONFIG $BACKUP_CONFIG\n\necho \"Disabling PermitRootLogin...\"\n# Use sed to replace or append the setting\nif grep -q \"^PermitRootLogin\" $SSH_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSH_CONFIG\nfi\n\necho \"Restarting SSH service...\"\nsystemctl restart sshd\necho \"Hardening complete.\""}
{"instruction": "Write a Python script using the 'socket' library to perform a basic port scan on 'localhost' to check if common insecure ports (21, 23, 80) are open.", "output": "import socket\n\ntarget_ip = '127.0.0.1'\nports_to_check = [21, 23, 80]  # FTP, Telnet, HTTP\n\nprint(f\"Scanning {target_ip} for insecure ports...\")\n\nfor port in ports_to_check:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f\"[ALERT] Port {port} is OPEN\")\n    else:\n        print(f\"Port {port} is closed\")\n    sock.close()"}
{"instruction": "Generate a Bash script that configures `iptables` to set default policies to DROP, allows loopback traffic, maintains established connections, and permits incoming SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default chain policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"iptables rules updated successfully.\""}
{"instruction": "Write a Python script that reads a list of malicious IP addresses from 'blacklist.txt' and generates a configuration string for an `nftables` set named 'blackhole'.", "output": "def generate_nftables_config(filename):\n    try:\n        with open(filename, 'r') as f:\n            ips = [line.strip() for line in f if line.strip()]\n        \n        if not ips:\n            print(\"No IPs found.\")\n            return\n\n        # Format IPs as a comma-separated list\n        ip_list_str = \", \".join(ips)\n        \n        nft_config = f\"\"\"\n        table ip filter {{\n            set blackhole {{\n                type ipv4_addr\n                elements = {{ {ip_list_str} }}\n            }}\n            chain input {{\n                type filter hook input priority 0;\n                ip saddr @blackhole drop\n            }}\n        }}\n        \"\"\"\n        print(nft_config)\n        \n    except FileNotFoundError:\n        print(f\"File {filename} not found.\")\n\ngenerate_nftables_config('blacklist.txt')"}
{"instruction": "Create a Bash script to analyze `/var/log/auth.log` (or `/var/log/secure`) to count the number of failed SSH login attempts per user, sorting the results to show the most targeted usernames.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found.\"\n    exit 1\nfi\n\necho \"Failed SSH login attempts by user:\"\n\n# Grep for 'Failed password', extract the user (usually field before 'from'), sort and count\ngrep \"Failed password for\" $LOG_FILE | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | sort | uniq -c | sort -nr"}
{"instruction": "Write a Python script for system hardening that checks critical system files (`/etc/shadow`, `/etc/passwd`) to ensure their file permissions are secure (e.g., `/etc/shadow` should be 0600 or 0000).", "output": "import os\nimport stat\n\nfiles_to_check = {\n    '/etc/shadow': 0o600,\n    '/etc/gshadow': 0o600,\n    '/etc/passwd': 0o644,\n    '/etc/group': 0o644\n}\n\ndef check_perms(filepath, max_perm):\n    if not os.path.exists(filepath):\n        print(f\"[MISSING] {filepath} does not exist.\")\n        return\n\n    # Get current file mode\n    st = os.stat(filepath)\n    current_mode = st.st_mode & 0o777\n\n    # Check if current mode is less than or equal to max_perm (logic simplified for basic hardening)\n    # Specifically checking if bits allowed in max_perm cover current_mode is complex,\n    # so we check exact match or stricter for owner-only files.\n    \n    if current_mode > max_perm:\n        print(f\"[ALERT] {filepath} is too permissive: {oct(current_mode)} (Expected <= {oct(max_perm)})\")\n    else:\n        print(f\"[OK] {filepath} permission is {oct(current_mode)}\")\n\nfor f, p in files_to_check.items():\n    check_perms(f, p)"}
{"instruction": "Create a Bash script that checks for available security updates on a Debian/Ubuntu system and appends the list of upgradable security packages to a log file.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/security_updates.log\"\nDATE=$(date)\n\necho \"Checking for security updates on $DATE...\" >> $LOG_FILE\n\n# Update package lists silently\napt-get update -q\n\n# Simulate upgrade and grep for security archives\n# Debian/Ubuntu security updates often come from the -security suite\napt-get -s dist-upgrade | grep \"^Inst\" | grep -i \"security\" >> $LOG_FILE\n\nif [ $? -eq 0 ]; then\n    echo \"Security updates found and logged.\"\nelse\n    echo \"No security updates found.\" >> $LOG_FILE\nfi"}
{"instruction": "Write a Python script to simulate a simple SIEM rule: Ingest a list of JSON login events and alert if a specific user fails to log in 5 times within a 60-second window.", "output": "import json\nfrom collections import defaultdict, deque\n\n# Mock stream of events (timestamp in seconds)\nevents = [\n    {\"user\": \"admin\", \"status\": \"fail\", \"time\": 100},\n    {\"user\": \"admin\", \"status\": \"fail\", \"time\": 110},\n    {\"user\": \"alice\", \"status\": \"success\", \"time\": 115},\n    {\"user\": \"admin\", \"status\": \"fail\", \"time\": 120},\n    {\"user\": \"admin\", \"status\": \"fail\", \"time\": 130},\n    {\"user\": \"admin\", \"status\": \"fail\", \"time\": 140}, # 5th fail in < 60s\n    {\"user\": \"bob\", \"status\": \"fail\", \"time\": 150}\n]\n\nfailed_logins = defaultdict(deque)\nTIME_WINDOW = 60\nTHRESHOLD = 5\n\nprint(\"Processing events...\")\n\nfor event in events:\n    if event['status'] == 'fail':\n        user = event['user']\n        timestamp = event['time']\n        \n        # Add current failure timestamp\n        failed_logins[user].append(timestamp)\n        \n        # Remove failures older than the time window\n        while failed_logins[user] and failed_logins[user][0] <= timestamp - TIME_WINDOW:\n            failed_logins[user].popleft()\n            \n        # Check threshold\n        if len(failed_logins[user]) >= THRESHOLD:\n            print(f\"[ALERT] Brute force detected for user '{user}': {len(failed_logins[user])} failed attempts within {TIME_WINDOW}s\")"}
{"instruction": "Create a Bash script that uses `auditctl` to add audit rules for monitoring write access and attribute changes to `/etc/passwd` and `/etc/shadow`.", "output": "#!/bin/bash\n\n# Check if auditd is installed\nif ! command -v auditctl &> /dev/null; then\n    echo \"auditctl could not be found. Please install auditd.\"\n    exit 1\nfi\n\necho \"Adding audit rules for critical files...\"\n\n# -w: watch file, -p wa: permissions write/attribute change, -k: key for searching logs\nauditctl -w /etc/passwd -p wa -k identity_changes\nauditctl -w /etc/shadow -p wa -k identity_changes\n\necho \"Current audit rules:\"\nauditctl -l"}
{"instruction": "Create a Python script to parse an Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nip_counts = defaultdict(int)\n\n# Regex to capture IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counts[ip_address] += 1\n\n    print(\"IPs with > 10 404 errors:\")\n    for ip, count in ip_counts.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script using iptables to immediately block a specific abusive IP address passed as an argument and log the event.", "output": "#!/bin/bash\n\nTARGET_IP=$1\n\nif [ -z \"$TARGET_IP\" ]; then\n    echo \"Usage: $0 <IP_ADDRESS>\"\n    exit 1\nfi\n\n# Log the blocking action\nlogger \"Blocking IP $TARGET_IP due to suspicious activity\"\n\n# Add rule to drop packets from the IP\niptables -A INPUT -s \"$TARGET_IP\" -j DROP\n\necho \"IP $TARGET_IP has been blocked.\""}
{"instruction": "Generate a Bash script for server hardening that disables Root login and enforces Protocol 2 in the SSH configuration.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"$SSH_CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\n\n# Enforce Protocol 2 (if not already default in modern sshd, explicit setting is safe)\nif grep -q \"^Protocol\" $SSH_CONFIG; then\n    sed -i 's/^Protocol.*/Protocol 2/' $SSH_CONFIG\nelse\n    echo \"Protocol 2\" >> $SSH_CONFIG\nfi\n\n# Restart SSH service\nsystemctl reload sshd\necho \"SSH hardening applied.\""}
{"instruction": "Create a Python script for a local security audit that scans the local machine (localhost) for open ports in the range 1-1024 to identify unnecessary running services.", "output": "import socket\n\ntarget = '127.0.0.1'\nopen_ports = []\n\nprint(f\"Scanning {target} for open reserved ports...\")\n\nfor port in range(1, 1025):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(0.1)\n    result = sock.connect_ex((target, port))\n    if result == 0:\n        open_ports.append(port)\n    sock.close()\n\nif open_ports:\n    print(f\"Open ports found: {open_ports}\")\nelse:\n    print(\"No open ports found in range 1-1024.\")"}
{"instruction": "Write a Bash script to search the system authentication logs (auth.log) for failed SSH login attempts and extract the unique usernames used.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found at $LOG_FILE\"\n    exit 1\nfi\n\necho \"Unique usernames with failed login attempts:\"\ngrep \"Failed password for\" \"$LOG_FILE\" | awk '{print $(NF-5)}' | sort | uniq"}
{"instruction": "Create a basic nftables configuration script (Bash) that flushes existing rules, allows loopback and established traffic, allows SSH (port 22), and drops all other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Define the table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configuration applied.\""}
{"instruction": "Write a Python script to check the SSL certificate expiration date of a remote server (e.g., for monitoring internal web apps).", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=3) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse date format: May 30 12:00:00 2025 GMT\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                if days_remaining < 30:\n                    print(\"WARNING: Certificate expiring soon!\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\n# Example usage\ncheck_ssl_expiry('www.example.com')"}
{"instruction": "Generate a Bash script to audit file permissions on critical system files (/etc/passwd, /etc/shadow, /etc/group) and correct them if they are insecure.", "output": "#!/bin/bash\n\n# Function to set permissions\nsecure_file() {\n    FILE=$1\n    PERM=$2\n    OWNER=$3\n    \n    if [ -f \"$FILE\" ]; then\n        chmod $PERM $FILE\n        chown $OWNER $FILE\n        echo \"Secured $FILE (Mode: $PERM, Owner: $OWNER)\"\n    else\n        echo \"Warning: $FILE does not exist.\"\n    fi\n}\n\n# /etc/shadow should be readable only by root (600 or 640 depending on distro, 600 is stricter)\nsecure_file \"/etc/shadow\" 600 \"root:root\"\n\n# /etc/passwd must be readable by all, writable only by root\nsecure_file \"/etc/passwd\" 644 \"root:root\"\n\n# /etc/group must be readable by all, writable only by root\nsecure_file \"/etc/group\" 644 \"root:root\"\n\necho \"Critical file permission audit complete.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (FIM) that calculates SHA-256 hashes of files in a specified directory to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef scan_directory(directory_path):\n    print(f\"Scanning {directory_path}...\")\n    for root, dirs, files in os.walk(directory_path):\n        for file in files:\n            filepath = os.path.join(root, file)\n            file_hash = calculate_sha256(filepath)\n            if file_hash:\n                print(f\"{filepath}: {file_hash}\")\n\n# Example usage\nscan_directory('/etc/cron.daily')"}
{"instruction": "Write a Bash script to list all installed packages on a Debian/Ubuntu system that have available security updates.", "output": "#!/bin/bash\n\n# Update package lists first\napt-get update -q\n\n# List upgradable packages\necho \"Checking for available security updates...\"\n\n# Use apt list --upgradable and grep for security repositories usually labeled 'security'\napt list --upgradable 2>/dev/null | grep -i \"security\"\n\nif [ $? -ne 0 ]; then\n    echo \"No immediate security updates found (or unable to parse repository names).\"\n    echo \"Listing all upgradable packages:\"\n    apt list --upgradable 2>/dev/null | grep -v \"Listing...\"\nfi"}
{"instruction": "Create a Python script to check the expiration date of an SSL certificate for a given domain to prevent security lapses.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((domain, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                cert = ssock.getpeercert()\n                expire_date = cert['notAfter']\n                # Parse the date format: May 30 12:00:00 2025 GMT\n                expire_dt = datetime.datetime.strptime(expire_date, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expire_dt - datetime.datetime.now()).days\n                return f'Domain: {domain}, Days until expiry: {days_left}'\n    except Exception as e:\n        return f'Error checking {domain}: {str(e)}'\n\nprint(check_ssl_expiry('www.example.com'))"}
{"instruction": "Write a Bash script using iptables to immediately block a specific IP address that is flooding the server and log the event.", "output": "#!/bin/bash\n\nATTACKER_IP=\"192.0.2.55\"\nLOG_MSG=\"Blocking IP due to suspicious activity\"\n\n# Log the action\nlogger -t FirewallBlock \"$LOG_MSG: $ATTACKER_IP\"\n\n# Drop packets from the IP\niptables -A INPUT -s $ATTACKER_IP -j DROP\n\n# Save rules (Debian/Ubuntu style)\nnetfilter-persistent save\n\necho \"Blocked $ATTACKER_IP\""}
{"instruction": "Develop a Python script for Log Analysis that parses a standard Apache access log to identify IP addresses attempting SQL injection attacks.", "output": "import re\n\ndef detect_sqli(log_file_path):\n    # Regex for common SQL injection patterns (UNION, SELECT, OR 1=1, etc.)\n    sqli_pattern = re.compile(r\"(UNION\\s+SELECT|'\\s+OR\\s+'1'='1|--|;)\", re.IGNORECASE)\n    suspicious_ips = set()\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                if sqli_pattern.search(line):\n                    # Extract IP at the start of the line\n                    ip = line.split()[0]\n                    suspicious_ips.add(ip)\n    except FileNotFoundError:\n        return \"Log file not found.\"\n\n    return list(suspicious_ips)\n\n# Example usage\n# print(detect_sqli('/var/log/apache2/access.log'))"}
{"instruction": "Create a Bash script for server hardening that disables unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs) to reduce the attack surface.", "output": "#!/bin/bash\n\nFILESYSTEMS=(\"cramfs\" \"freevxfs\" \"jffs2\" \"hfs\" \"hfsplus\" \"squashfs\")\n\nfor fs in \"${FILESYSTEMS[@]}\"; do\n    echo \"install $fs /bin/true\" > /etc/modprobe.d/$fs.conf\n    rmmod $fs 2>/dev/null\n    echo \"Filesystem $fs disabled.\"\ndone\n\necho \"Unused filesystems hardened.\""}
{"instruction": "Write a Python script acting as a File Integrity Monitor (FIM) that calculates SHA-256 hashes of critical system files to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/ssh/sshd_config']\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            # Read file in chunks to avoid memory issues\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File missing\"\n    except PermissionError:\n        return \"Permission denied\"\n\nresults = {f: calculate_hash(f) for f in critical_files}\nprint(results)"}
{"instruction": "Create a Bash script using nftables to configure a base firewall policy that drops all incoming traffic except SSH (22), HTTP (80), and HTTPS (443).", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow established/related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow specific ports\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\necho \"nftables policy applied.\""}
{"instruction": "Write a Python script to audit HTTP response headers of a target URL to check for missing security headers (X-Frame-Options, X-XSS-Protection, Content-Security-Policy).", "output": "import requests\n\ndef audit_headers(url):\n    required_headers = [\n        'X-Frame-Options',\n        'X-XSS-Protection',\n        'Content-Security-Policy',\n        'Strict-Transport-Security'\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        missing = []\n\n        for req in required_headers:\n            if req not in headers:\n                missing.append(req)\n        \n        if missing:\n            return f\"Missing headers for {url}: {', '.join(missing)}\"\n        else:\n            return f\"All checked security headers present for {url}\"\n            \n    except requests.exceptions.RequestException as e:\n        return f\"Connection error: {e}\"\n\nprint(audit_headers('http://localhost'))"}
{"instruction": "Create a Bash script to audit the system for SUID (Set User ID) binaries, which can be potential privilege escalation vectors.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"/tmp/suid_audit_$(date +%F).txt\"\n\necho \"Starting SUID binary audit...\"\necho \"Results saved to $OUTPUT_FILE\"\n\n# Find files with SUID bit set, ignore /proc, /sys, /dev\nfind / -context -perm /4000 -type f 2>/dev/null > \"$OUTPUT_FILE\"\n\nCOUNT=$(wc -l < \"$OUTPUT_FILE\")\necho \"Audit complete. Found $COUNT SUID binaries.\""}
{"instruction": "Develop a Python script to parse Linux auth.log and count the number of failed SSH login attempts per IP address.", "output": "import re\nfrom collections import Counter\n\ndef analyze_ssh_failures(log_path='/var/log/auth.log'):\n    ip_pattern = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n    ips = []\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ips.append(match.group(1))\n        \n        return Counter(ips).most_common(10)\n    except FileNotFoundError:\n        return \"Auth log not found.\"\n    except PermissionError:\n        return \"Permission denied reading log.\"\n\nprint(\"Top 10 Failed SSH Logins by IP:\")\nprint(analyze_ssh_failures())"}
{"instruction": "Write a Bash hardening script to configure SSH (sshd_config) to disable root login and enforce protocol 2.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nelse\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Enforce Protocol 2 (Modern sshd defaults to 2, but explicit is good)\nif grep -q \"^Protocol\" $CONFIG_FILE; then\n    sed -i 's/^Protocol.*/Protocol 2/' $CONFIG_FILE\nelse\n    echo \"Protocol 2\" >> $CONFIG_FILE\nfi\n\n# Restart SSH service\nsystemctl restart sshd\necho \"SSH Hardening applied.\""}
{"instruction": "Create a Python script to parse a standard Apache/Nginx access log file and identify IP addresses that have generated more than 50 '404 Not Found' errors, which may indicate a vulnerability scanner or forced browsing attempt.", "output": "import re\nfrom collections import Counter\n\ndef detect_scanners(log_file_path, threshold=50):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    four_oh_four_ips = []\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        four_oh_four_ips.append(match.group(1))\n\n        ip_counts = Counter(four_oh_four_ips)\n        \n        print(f\"IPs with > {threshold} 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"IP: {ip} - Count: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# detect_scanners('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script that uses 'iptables' to block a list of malicious IP addresses provided in a text file named 'blacklist.txt'. The script should check if the rule exists before adding it to avoid duplicates.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\n\nif [ ! -f \"$BLACKLIST_FILE\" ]; then\n    echo \"Blacklist file not found!\"\n    exit 1\nfi\n\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n\n    # Check if rule already exists\n    iptables -C INPUT -s \"$ip\" -j DROP 2>/dev/null\n\n    if [ $? -eq 1 ]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked IP: $ip\"\n    else\n        echo \"IP $ip is already blocked.\"\n    fi\ndone < \"$BLACKLIST_FILE\""}
{"instruction": "Develop a Python script for server hardening that audits file permissions of critical system files (e.g., /etc/shadow, /etc/passwd). It should alert if '/etc/shadow' is world-readable.", "output": "import os\nimport stat\n\ndef audit_permissions(file_path):\n    try:\n        st = os.stat(file_path)\n        mode = st.st_mode\n        \n        # Check if world readable (others have read permission)\n        if mode & stat.S_IROTH:\n            print(f\"[CRITICAL] {file_path} is world-readable! ({oct(mode)[-3:]})\")\n        else:\n            print(f\"[OK] {file_path} permissions seem secure ({oct(mode)[-3:]}).\")\n            \n    except FileNotFoundError:\n        print(f\"[ERROR] File {file_path} not found.\")\n\nfiles_to_check = ['/etc/shadow', '/etc/passwd', '/etc/ssh/sshd_config']\n\nfor f in files_to_check:\n    audit_permissions(f)"}
{"instruction": "Create a Bash script using 'nftables' to implement a rate-limiting rule for SSH connections to prevent brute-force attacks. Limit to 3 connections per minute per IP.", "output": "#!/bin/bash\n\n# Flush existing rules (Use with caution in production)\n# nft flush ruleset\n\n# Create a table if it doesn't exist\nnft add table ip filter\n\n# Create an input chain\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule: Accept SSH on port 22, but drop if > 3 connections/minute from same IP\nnft add rule ip filter input tcp dport 22 ct state new limit rate 3/minute accept\nnft add rule ip filter input tcp dport 22 drop\n\necho \"NFTables SSH rate limiting applied.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote server to ensure valid encryption configuration.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    \n    try:\n        with socket.create_connection((hostname, port), timeout=5) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse the expiration date\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                \n                if days_remaining < 30:\n                    print(\"[WARNING] Certificate expires in less than 30 days!\")\n                    \n    except Exception as e:\n        print(f\"Error checking SSL for {hostname}: {e}\")\n\n# Example usage\n# check_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script for log analysis that parses '/var/log/auth.log' (or secure) to identify top 10 IP addresses attempting SSH logins with failed passwords.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log file not found.\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\n\n# Filter for 'Failed password', extract IP (usually field 11 or 13 depending on format), count, and sort\ngrep \"Failed password\" \"$LOG_FILE\" | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Develop a Python script acting as a basic internal port scanner to audit a specific server for unauthorized open ports (range 1-1024).", "output": "import socket\n\ndef audit_ports(target_ip):\n    print(f\"Starting audit on {target_ip}...\")\n    open_ports = []\n    \n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    if open_ports:\n        print(f\"Open ports found: {open_ports}\")\n    else:\n        print(\"No open ports found in range 1-1024.\")\n\n# Example usage\n# audit_ports('192.168.1.5')"}
{"instruction": "Write a Bash script to harden the SSH configuration by disabling root login and password authentication, enforcing key-based auth only. (Note: Modifies /etc/ssh/sshd_config).", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\n# Validate config before restart (sshd -t)\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration check failed. Reverting...\"\n    cp \"$BACKUP_FILE\" \"$CONFIG_FILE\"\nfi"}
{"instruction": "Create a Python script that monitors a specific directory (integrity monitoring) and logs alerts if a file is modified, created, or deleted. Use a simple polling mechanism.", "output": "import os\nimport time\n\ndef file_integrity_monitor(path_to_watch):\n    print(f\"Monitoring {path_to_watch}...\")\n    before = dict ([(f, None) for f in os.listdir (path_to_watch)])\n    \n    while True:\n        time.sleep (2)\n        after = dict ([(f, None) for f in os.listdir (path_to_watch)])\n        \n        added = [f for f in after if not f in before]\n        removed = [f for f in before if not f in after]\n        \n        if added:\n             print(f\"[ALERT] Added: {', '.join (added)}\")\n        if removed:\n             print(f\"[ALERT] Removed: {', '.join (removed)}\")\n             \n        before = after\n\n# Example usage\n# file_integrity_monitor('/tmp/test_dir')"}
{"instruction": "Write a Python script to parse a web server log for potential SQL Injection attempts by looking for common SQL keywords (UNION, SELECT, OR 1=1) in the URL parameters.", "output": "import urllib.parse\n\ndef detect_sqli(log_line):\n    # Common SQLi signatures (simplified)\n    signatures = [\"UNION SELECT\", \"OR 1=1\", \"--\", \"/*\", \"DROP TABLE\", \"INSERT INTO\"]\n    \n    # Decode URL encoding (e.g., %20 -> space)\n    decoded_line = urllib.parse.unquote(log_line).upper()\n    \n    for sig in signatures:\n        if sig in decoded_line:\n            return True, sig\n    return False, None\n\ndef scan_log_for_sqli(log_path):\n    try:\n        with open(log_path, 'r') as f:\n            for line_num, line in enumerate(f, 1):\n                is_attack, sig = detect_sqli(line)\n                if is_attack:\n                    print(f\"[ALERT] SQLi Pattern '{sig}' found at line {line_num}: {line.strip()}\")\n    except FileNotFoundError:\n        print(\"File not found.\")\n\n# Example usage\n# scan_log_for_sqli('access.log')"}
{"instruction": "Write a Python script to parse a standard Apache access log file named 'access.log' and identify the top 5 source IP addresses based on request frequency.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ips = []\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = ip_pattern.match(line)\n                if match:\n                    ips.append(match.group(1))\n        \n        counter = Counter(ips)\n        print(\"Top 5 Source IPs:\")\n        for ip, count in counter.most_common(5):\n            print(f\"{ip}: {count} requests\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == '__main__':\n    analyze_logs('access.log')"}
{"instruction": "Create a Bash script using iptables to set a default DROP policy for INPUT and FORWARD chains, allow loopback traffic, allow established connections, and specifically allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Firewall rules updated.\""}
{"instruction": "Write a Python automation script to verify that the '/etc/shadow' file has strict permissions (0600 or 0000) and is owned by the root user (UID 0).", "output": "import os\nimport stat\n\ndef audit_shadow_file():\n    target_file = '/etc/shadow'\n    try:\n        file_stat = os.stat(target_file)\n        \n        # Check ownership (UID 0 is root)\n        if file_stat.st_uid != 0:\n            print(f\"[FAIL] {target_file} is not owned by root.\")\n        else:\n            print(f\"[PASS] {target_file} is owned by root.\")\n            \n        # Check permissions (should be <= 600 octal)\n        mode = stat.S_IMODE(file_stat.st_mode)\n        if mode <= 0o600:\n            print(f\"[PASS] Permissions are safe: {oct(mode)}\")\n        else:\n            print(f\"[FAIL] Permissions are unsafe: {oct(mode)}\")\n            \n    except FileNotFoundError:\n        print(f\"Error: {target_file} not found.\")\n    except PermissionError:\n        print(\"Error: Permission denied. Run as root.\")\n\nif __name__ == '__main__':\n    audit_shadow_file()"}
{"instruction": "Generate a Bash script to audit the SSH configuration file (/etc/ssh/sshd_config) to ensure that 'PermitRootLogin' is set to 'no' and 'PasswordAuthentication' is set to 'no'.", "output": "#!/bin/bash\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\n\ncheck_config() {\n    KEY=$1\n    EXPECTED=$2\n    # Grep for the key, ignore comments, get the last occurrence\n    CURRENT=$(grep \"^${KEY}\" $CONFIG_FILE | tail -n 1 | awk '{print $2}')\n    \n    if [ \"$CURRENT\" == \"$EXPECTED\" ]; then\n        echo \"[PASS] $KEY is set to $EXPECTED\"\n    else\n        echo \"[FAIL] $KEY is set to '$CURRENT' (Expected: $EXPECTED)\"\n    fi\n}\n\nif [ -f \"$CONFIG_FILE\" ]; then\n    check_config \"PermitRootLogin\" \"no\"\n    check_config \"PasswordAuthentication\" \"no\"\nelse\n    echo \"SSH config file not found.\"\nfi"}
{"instruction": "Write a Python script to parse a Linux auth.log file and detect IP addresses that have generated more than 5 \"Failed password\" events, indicating a potential brute-force attempt.", "output": "import re\n\ndef detect_brute_force(log_path='/var/log/auth.log', threshold=5):\n    failed_attempts = {}\n    # Regex to extract IP from standard auth.log format\n    # Example: Failed password for user x from 192.168.1.1 port...\n    regex = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = regex.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] = failed_attempts.get(ip, 0) + 1\n        \n        print(f\"IPs with > {threshold} failed login attempts:\")\n        for ip, count in failed_attempts.items():\n            if count > threshold:\n                print(f\"IP: {ip} | Attempts: {count}\")\n                \n    except Exception as e:\n        print(f\"Error reading log: {e}\")\n\nif __name__ == '__main__':\n    detect_brute_force()"}
{"instruction": "Create a Bash script using nftables to create a table named 'filter', a chain named 'input', and a rule to drop any packets marked as 'invalid' state by the connection tracker.", "output": "#!/bin/bash\n\n# Create the table\nnft add table inet filter\n\n# Create the input chain with a default priority\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Drop invalid packets (CT state invalid)\nnft add rule inet filter input ct state invalid drop\n\necho \"nftables configured to drop invalid packets.\""}
{"instruction": "Write a Python script to perform a local port scan on 'localhost' (127.0.0.1) for ports 1 through 1024 to identify listening services for defensive auditing.", "output": "import socket\n\ndef scan_local_ports():\n    target = '127.0.0.1'\n    print(f\"Scanning {target} for open privileged ports...\")\n    \n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.1)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == '__main__':\n    scan_local_ports()"}
{"instruction": "Generate a Bash hardening script that disables common unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs, udf) to reduce the kernel attack surface.", "output": "#!/bin/bash\n\nFILESYSTEMS=\"cramfs freevxfs jffs2 hfs hfsplus squashfs udf\"\nCONF_FILE=\"/etc/modprobe.d/cis_hardening.conf\"\n\necho \"Disabling unused filesystems...\"\n\nfor fs in $FILESYSTEMS; do\n    # Prevent module loading\n    echo \"install $fs /bin/true\" >> $CONF_FILE\n    # Unload if currently loaded\n    modprobe -r $fs 2>/dev/null\n    echo \"filesystem $fs disabled.\"\ndone\n\necho \"Configuration written to $CONF_FILE\""}
{"instruction": "Write a Python script using the 'ssl' and 'socket' libraries to check if the SSL certificate of a remote server is expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443, buffer_days=30):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse expiration date (format: May 30 12:00:00 2025 GMT)\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                remaining = expire_date - datetime.datetime.now()\n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {remaining.days}\")\n                \n                if remaining.days < buffer_days:\n                    print(\"WARNING: Certificate is expiring soon!\")\n                else:\n                    print(\"Certificate status: OK\")\n    except Exception as e:\n        print(f\"Error checking SSL: {e}\")\n\nif __name__ == '__main__':\n    check_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script to search for files with the SUID bit set, which allows executables to run with the permissions of the file owner, and output the list for security review.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\n# Find files with permission 4000 (SUID) set\n# -perm /4000 checks for the bit, -type f ensures it's a file\nfind / -context -perm /4000 -type f 2>/dev/null > suid_files.txt\n\necho \"Scan complete. List saved to suid_files.txt.\"\necho \"Displaying first 10 entries:\"\nhead -n 10 suid_files.txt"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have made more than 100 requests, indicating potential bot activity or a brute-force attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_apache_log(log_file_path, threshold=100):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(f\"IPs with > {threshold} requests:\")\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Usage example\n# analyze_apache_log('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that configures SSH to disable root login and enforce key-based authentication by modifying the sshd_config file.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Validate syntax and restart SSH service\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp $BACKUP $SSHD_CONFIG\nfi"}
{"instruction": "Develop a Python script for Vulnerability Assessment that checks a list of URLs to ensure they are serving specific security headers (X-Frame-Options, X-Content-Type-Options, HSTS).", "output": "import requests\n\ndef check_security_headers(urls):\n    required_headers = [\n        'Strict-Transport-Security',\n        'X-Frame-Options',\n        'X-Content-Type-Options'\n    ]\n\n    for url in urls:\n        try:\n            response = requests.get(url, timeout=5)\n            print(f\"\\nScanning {url}...\")\n            missing = []\n            for header in required_headers:\n                if header not in response.headers:\n                    missing.append(header)\n            \n            if missing:\n                print(f\"[ALERT] Missing headers: {', '.join(missing)}\")\n            else:\n                print(\"[OK] All core security headers present.\")\n        except requests.exceptions.RequestException as e:\n            print(f\"[ERROR] Could not connect to {url}: {e}\")\n\n# Usage\n# check_security_headers(['https://example.com', 'https://test.site'])"}
{"instruction": "Create a Bash script to generate a basic Firewall configuration using iptables. The policy should drop all incoming traffic by default, but allow loopback, established connections, SSH (port 22), HTTP (80), and HTTPS (443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Allow HTTPS\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based example)\n# netfilter-persistent save\necho \"Basic firewall rules applied.\""}
{"instruction": "Write a Python script for Security Auditing that scans critical system files (like /etc/shadow and /etc/passwd) to verify their file permissions are set securely (e.g., not world-writable).", "output": "import os\nimport stat\n\ndef check_file_permissions(files):\n    for file_path in files:\n        if not os.path.exists(file_path):\n            print(f\"[MISSING] {file_path}\")\n            continue\n\n        file_stat = os.stat(file_path)\n        mode = file_stat.st_mode\n        \n        # Check if world writable\n        if mode & stat.S_IWOTH:\n            print(f\"[FAIL] {file_path} is World Writable! ({oct(mode)[-3:]})\")\n        # Check if group writable\n        elif mode & stat.S_IWGRP:\n            print(f\"[WARN] {file_path} is Group Writable ({oct(mode)[-3:]})\")\n        else:\n            print(f\"[PASS] {file_path} permissions seem secure ({oct(mode)[-3:]})\")\n\n# Usage\n# check_file_permissions(['/etc/passwd', '/etc/shadow', '/etc/hosts'])"}
{"instruction": "Generate a Bash command for Log Analysis that extracts all failed SSH login attempts from /var/log/auth.log and counts the occurrences per username.", "output": "#!/bin/bash\n# Extract failed passwords and invalid users from auth.log\n# Adjust log path if necessary (e.g., /var/log/secure on RHEL/CentOS)\n\ngrep \"Failed password\" /var/log/auth.log | awk '{ \n    # Identify the username field position varies slightly depending on \"invalid user\" presence\n    match($0, /for (invalid user )?(\\S+)/, groups);\n    if (groups[2] != \"\") print groups[2];\n}' | sort | uniq -c | sort -nr"}
{"instruction": "Create a Python script that automates Firewall Rule Generation. The script should read a list of malicious IP addresses from a text file and generate the corresponding `nftables` commands to block them.", "output": "def generate_nft_blocklist(filename, table_name='filter', chain_name='input'):\n    try:\n        with open(filename, 'r') as f:\n            ips = [line.strip() for line in f if line.strip()]\n        \n        print(\"#!/usr/sbin/nft -f\")\n        print(f\"add table ip {table_name}\")\n        print(f\"add chain ip {table_name} {chain_name} {{ type filter hook input priority 0; }}\")\n        \n        # Create a set for efficiency in real nftables, but here we generate individual rules for demonstration\n        print(f\"add set ip {table_name} blackhole {{ type ipv4_addr; }}\")\n        \n        elements = \", \".join(ips)\n        print(f\"add element ip {table_name} blackhole {{ {elements} }}\")\n        print(f\"add rule ip {table_name} {chain_name} ip saddr @blackhole drop\")\n            \n    except Exception as e:\n        print(f\"Error reading file: {e}\")\n\n# Usage\n# Create a file 'bad_ips.txt' first\n# generate_nft_blocklist('bad_ips.txt')"}
{"instruction": "Write a Bash script for Vulnerability Management that lists installed packages and checks for available security updates using `apt` (Debian/Ubuntu).", "output": "#!/bin/bash\n\n# Update package list\napt-get update -q\n\n# List upgradable packages\necho \"--- Packages with available updates ---\"\napt list --upgradable\n\n# Check for specific security updates (using unattended-upgrades dry run logic as a proxy)\nif command -v unattended-upgrade &> /dev/null; then\n    echo -e \"\\n--- Security Updates Available ---\"\n    unattended-upgrade --dry-run -d 2>&1 | grep \"Checking\" | awk '{print $2}'\nelse\n    echo \"unattended-upgrades tool not found. Install it for specific security patch filtering.\"\nfi"}
{"instruction": "Develop a Python script for SIEM integration that parses a JSON-formatted application log file and alerts on any entry with a severity level of 'ERROR' or 'CRITICAL'.", "output": "import json\nimport sys\n\ndef parse_json_logs(log_file):\n    alert_levels = {'ERROR', 'CRITICAL'}\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line_num, line in enumerate(f, 1):\n                try:\n                    entry = json.loads(line)\n                    level = entry.get('level', 'INFO').upper()\n                    \n                    if level in alert_levels:\n                        timestamp = entry.get('timestamp', 'Unknown Time')\n                        message = entry.get('message', 'No message provided')\n                        print(f\"[ALERT] Line {line_num}: {level} at {timestamp} - {message}\")\n                        \n                except json.JSONDecodeError:\n                    continue # Skip malformed lines\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Usage\n# parse_json_logs('app_events.json')"}
{"instruction": "Create a Bash script for System Auditing that sets up `auditd` rules to monitor write access and attribute changes to the `/etc/passwd` and `/etc/shadow` files.", "output": "#!/bin/bash\n\n# Check if auditd is installed\nif ! command -v auditctl &> /dev/null; then\n    echo \"auditd is not installed. Please install it first.\"\n    exit 1\nfi\n\n# Add rule to watch /etc/passwd for writes (w) and attribute changes (a)\n# -k allows us to search logs for this specific key later\nauditctl -w /etc/passwd -p wa -k identity_changes\n\n# Add rule to watch /etc/shadow\nauditctl -w /etc/shadow -p wa -k identity_changes\n\n# Make rules immutable (optional, requires reboot to undo)\n# auditctl -e 2\n\necho \"Audit rules added for identity files.\"\necho \"Verify with: auditctl -l\""}
{"instruction": "Python script to check SSL/TLS certificate expiration for a given hostname to ensure timely renewal.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443, days_alert=30):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=3) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n                remaining = expire_date - datetime.datetime.utcnow()\n                if remaining.days < days_alert:\n                    print(f\"ALERT: Certificate for {hostname} expires in {remaining.days} days.\")\n                else:\n                    print(f\"OK: Certificate for {hostname} is valid for {remaining.days} days.\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")"}
{"instruction": "Bash script to iterate through a text file of malicious IP addresses and block them using iptables.", "output": "#!/bin/bash\nBLOCKLIST=\"malicious_ips.txt\"\n\nif [[ ! -f \"$BLOCKLIST\" ]]; then\n    echo \"File not found!\"\n    exit 1\nfi\n\nwhile IFS= read -r ip; do\n    # Check if IP is valid (basic regex)\n    if [[ $ip =~ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked IP: $ip\"\n    fi\ndone < \"$BLOCKLIST\""}
{"instruction": "Python script to analyze Apache/Nginx access logs and detect IP addresses generating excessive 404 errors (potential scanning activity).", "output": "import re\nfrom collections import defaultdict\n\ndef detect_scanners(log_file, threshold=50):\n    ip_counts = defaultdict(int)\n    # Regex for standard Common Log Format (CLF)\n    log_pattern = re.compile(r'(\\d+\\.\\d+\\.\\d+\\.\\d+) .* \"(?:GET|POST|HEAD) .*\" 404')\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = log_pattern.match(line)\n                if match:\n                    ip_counts[match.group(1)] += 1\n    except FileNotFoundError:\n        return \"Log file not found.\"\n\n    suspicious_ips = [ip for ip, count in ip_counts.items() if count > threshold]\n    return suspicious_ips"}
{"instruction": "Bash script to harden SSH configuration by disabling root login and password authentication.", "output": "#!/bin/bash\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Create backup\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\n\n# Disable Password Authentication (Force Key-based)\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\necho \"SSH hardening applied.\""}
{"instruction": "Python script to generate a basic nftables configuration string for a web server (Allow SSH, HTTP, HTTPS; Drop others).", "output": "def generate_nftables_config():\n    config = \"\"\"\n#!/usr/sbin/nft -f\n\nflush ruleset\n\ntable inet filter {\n    chain input {\n        type filter hook input priority 0; policy drop;\n        \n        # Accept established and related traffic\n        ct state established,related accept\n        \n        # Accept loopback\n        iif \"lo\" accept\n        \n        # Allow specific ports\n        tcp dport 22 accept\n        tcp dport 80 accept\n        tcp dport 443 accept\n        \n        # Allow ICMP (Ping)\n        ip protocol icmp accept\n    }\n    chain forward {\n        type filter hook forward priority 0; policy drop;\n    }\n    chain output {\n        type filter hook output priority 0; policy accept;\n    }\n}\n\"\"\"\n    return config\n\nprint(generate_nftables_config())"}
{"instruction": "Bash one-liner to audit /etc/shadow for users with empty passwords.", "output": "#!/bin/bash\n# Requires root privileges\n# Field 2 in shadow file contains the password hash. If empty, no password is set.\nawk -F: '($2 == \"\" ) { print \"ALERT: User with empty password found: \" $1 }' /etc/shadow"}
{"instruction": "Python script to verify if critical ports (22, 80, 443) are open on a list of internal servers.", "output": "import socket\n\ndef check_ports(server_list, ports=[22, 80, 443]):\n    results = {}\n    for server in server_list:\n        results[server] = []\n        for port in ports:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            result = sock.connect_ex((server, port))\n            if result == 0:\n                results[server].append(port)\n            sock.close()\n    return results\n\n# Example usage\n# print(check_ports(['192.168.1.10', '192.168.1.11']))"}
{"instruction": "Bash script to secure /tmp and /var/tmp directories by remounting them with noexec, nosuid, and nodev options.", "output": "#!/bin/bash\n\nsecure_partition() {\n    local partition=$1\n    # Check if already mounted with secure options\n    if ! mount | grep \" on $partition \" | grep -qE \"noexec|nosuid|nodev\"; then\n        echo \"Securing $partition...\"\n        mount -o remount,noexec,nosuid,nodev \"$partition\"\n    else\n        echo \"$partition is already secured.\"\n    fi\n}\n\nsecure_partition \"/tmp\"\nsecure_partition \"/var/tmp\""}
{"instruction": "Bash command to extract the top 10 IP addresses making requests from an Nginx access log.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\n\n# Extract IP (1st column), sort, count unique occurrences, sort numerically descending, take top 10\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Python script to calculate SHA256 hashes of critical system binaries to establish a baseline for file integrity monitoring.", "output": "import hashlib\nimport os\n\ndef get_file_hash(filepath):\n    hasher = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            # Read in chunks to handle large files\n            while chunk := f.read(4096):\n                hasher.update(chunk)\n        return hasher.hexdigest()\n    except IOError:\n        return None\n\ncritical_files = ['/bin/ls', '/bin/ps', '/usr/bin/whoami', '/etc/passwd']\nbaseline = {}\n\nfor file in critical_files:\n    file_hash = get_file_hash(file)\n    if file_hash:\n        baseline[file] = file_hash\n        print(f\"{file}: {file_hash}\")\n    else:\n        print(f\"{file}: Error reading file\")"}
{"instruction": "Create a Python script to parse a web server log file (e.g., Apache/Nginx access log) and identify the top 5 IP addresses with the highest request count. This is useful for identifying potential DoS sources or aggressive crawlers.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'\n    ip_counter = Counter()\n    \n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                match = re.search(ip_pattern, line)\n                if match:\n                    ip_counter[match.group()] += 1\n                    \n        print(\"Top 5 IP Addresses by Request Count:\")\n        for ip, count in ip_counter.most_common(5):\n            print(f\"{ip}: {count}\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script to harden an SSH configuration by disabling root login and enforcing empty password checks. The script should backup the original config file first.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\n# Backup configuration\ncp $SSHD_CONFIG $BACKUP_CONFIG\necho \"Backup created at $BACKUP_CONFIG\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Empty Passwords\nif grep -q \"^PermitEmptyPasswords\" $SSHD_CONFIG; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\nelse\n    echo \"PermitEmptyPasswords no\" >> $SSHD_CONFIG\nfi\n\necho \"SSH Hardening applied. Please restart sshd service to take effect.\""}
{"instruction": "Develop a Python script to check for weak file permissions on critical system files (e.g., /etc/shadow, /etc/passwd). It should alert if 'others' have write permissions or if specific sensitive files are world-readable.", "output": "import os\nimport stat\n\nfiles_to_check = [\n    '/etc/passwd',\n    '/etc/shadow',\n    '/etc/group',\n    '/etc/gshadow'\n]\n\ndef check_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        mode = st.st_mode\n        \n        # Check if world writable (Others have Write bit set)\n        if mode & stat.S_IWOTH:\n            print(f\"[CRITICAL] {filepath} is world-writable!\")\n            \n        # Check if /etc/shadow is world readable\n        if filepath == '/etc/shadow' and (mode & stat.S_IROTH):\n            print(f\"[CRITICAL] {filepath} is world-readable!\")\n            \n        print(f\"[INFO] Checked {filepath}: {oct(mode)[-3:]}\")\n        \n    except FileNotFoundError:\n        print(f\"[WARN] File {filepath} not found.\")\n\nfor f in files_to_check:\n    check_permissions(f)"}
{"instruction": "Create a Bash script using `iptables` to implement a basic firewall strategy: Drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH (port 22).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \" --log-level 7\n\necho \"Basic firewall rules applied.\""}
{"instruction": "Write a Python script that acts as a simple vulnerability scanner by checking the version of installed packages (using `subprocess` to call `apt`) against a list of known vulnerable versions.", "output": "import subprocess\n\n# Dictionary of package_name: vulnerable_version_threshold\n# This is a mock database for demonstration\nvuln_db = {\n    \"curl\": \"7.68.0\",\n    \"openssl\": \"1.1.1f\"\n}\n\ndef get_installed_version(package_name):\n    try:\n        result = subprocess.check_output(['dpkg', '-s', package_name], stderr=subprocess.STDOUT).decode()\n        for line in result.split('\\n'):\n            if line.startswith('Version: '):\n                return line.split(' ')[1]\n    except subprocess.CalledProcessError:\n        return None\n\ndef scan_packages():\n    print(\"Starting local version scan...\")\n    for pkg, bad_ver in vuln_db.items():\n        installed_ver = get_installed_version(pkg)\n        if installed_ver:\n            # A real scanner would use strict version comparison logic (e.g., packaging.version)\n            # Here we do a simple string check for demonstration\n            if installed_ver <= bad_ver:\n                print(f\"[WARN] {pkg} version {installed_ver} may be vulnerable (Threshold: {bad_ver})\")\n            else:\n                print(f\"[OK] {pkg} version {installed_ver} is likely patched.\")\n        else:\n            print(f\"[INFO] {pkg} is not installed.\")\n\nscan_packages()"}
{"instruction": "Create a Bash script to analyze the Linux authentication log (`/var/log/auth.log` or `/var/log/secure`) and count the number of failed SSH login attempts per IP address.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    LOG_FILE=\"/var/log/secure\"\nfi\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found.\"\n    exit 1\nfi\n\necho \"Scanning for failed SSH login attempts...\"\n\n# Grep for 'Failed password', extract IP (usually field 11 or 13 depending on distro), sort and count\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{for(i=1;i<=NF;i++) if($i ~ /[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/) print $i}' | sort | uniq -c | sort -nr | head -n 10\n\necho \"Done.\""}
{"instruction": "Write a Python script using the `socket` library to perform a simple port scan on the localhost (127.0.0.1) to identify open ports in a specific range (e.g., 20-1024). This is for auditing listening services.", "output": "import socket\n\ndef scan_local_ports(start_port, end_port):\n    target_ip = \"127.0.0.1\"\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        \n        if result == 0:\n            print(f\"[OPEN] Port {port} is listening\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    scan_local_ports(20, 100)"}
{"instruction": "Develop a Bash script using `nftables` to create a table and chain that blocks a specific list of malicious IP addresses read from a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"malicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\nSET_NAME=\"blocked_ips\"\n\n# Check if nftables is installed\nif ! command -v nft &> /dev/null; then\n    echo \"nftables could not be found\"\n    exit 1\nfi\n\n# Create table and chain if they don't exist\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Create a set for blocked IPs\nnft add set ip $TABLE_NAME $SET_NAME { type ipv4_addr\\; }\n\n# Add rule to drop traffic from IPs in the set\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr @$SET_NAME drop\n\n# Populate the set from file\nif [ -f \"$BLOCKLIST_FILE\" ]; then\n    while IFS= read -r ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        nft add element ip $TABLE_NAME $SET_NAME { $ip }\n        echo \"Blocked: $ip\"\n    done < \"$BLOCKLIST_FILE\"\nelse\n    echo \"Blocklist file not found.\"\nfi"}
{"instruction": "Create a Python script for SIEM-like analysis that detects potential SQL Injection attempts in a log file by looking for common SQL keywords and syntax characters (e.g., 'UNION', 'SELECT', 'OR 1=1').", "output": "import re\n\ndef detect_sqli(log_line):\n    # Regex patterns for common SQLi vectors\n    patterns = [\n        r\"(?i)UNION\\s+SELECT\",    # UNION based\n        r\"(?i)OR\\s+['\\\"]?1['\\\"]?=['\\\"]?1\", # Tautology\n        r\"--\",                    # SQL comment\n        r\";\\s*DROP\\s+TABLE\",      # Destructive\n        r\"'\\s*OR\\s*'\"\n    ]\n    \n    for pattern in patterns:\n        if re.search(pattern, log_line):\n            return True, pattern\n    return False, None\n\ndef scan_log_for_attacks(log_path):\n    print(f\"Scanning {log_path} for SQL Injection patterns...\")\n    try:\n        with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:\n            for i, line in enumerate(f):\n                is_attack, signature = detect_sqli(line)\n                if is_attack:\n                    print(f\"[ALERT] Line {i+1}: Potential SQLi detected (Sig: {signature})\")\n                    print(f\"Payload: {line.strip()[:100]}...\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# scan_log_for_attacks('access.log')"}
{"instruction": "Write a Bash script for server hardening that enforces password aging policies. It should set the maximum password age to 90 days and the minimum age to 7 days for a specific user.", "output": "#!/bin/bash\n\nTARGET_USER=\"admin_user\"\nMAX_DAYS=90\nMIN_DAYS=7\nWARN_DAYS=14\n\nif id \"$TARGET_USER\" &>/dev/null; then\n    echo \"Applying password policies for user: $TARGET_USER\"\n    \n    # chage: -M (max days), -m (min days), -W (warning days)\n    chage -M $MAX_DAYS -m $MIN_DAYS -W $WARN_DAYS $TARGET_USER\n    \n    echo \"Policy Applied:\"\n    chage -l $TARGET_USER | grep -E \"Minimum|Maximum|Warning\"\nelse\n    echo \"User $TARGET_USER does not exist.\"\nfi"}
{"instruction": "Create a Python script for Log Analysis that parses a web server log file (e.g., access.log) to identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 10\nip_counts = defaultdict(int)\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counts[ip_address] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_counts.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script for Server Hardening that disables root login via SSH and restarts the sshd service to apply changes.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Check if running as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"This script must be run as root\"\n    exit 1\nfi\n\necho \"Disabling Root Login in SSH...\"\n\n# Backup config\ncp $SSHD_CONFIG \"${SSHD_CONFIG}.bak\"\n\n# Use sed to modify PermitRootLogin to no\n# If entry exists, change it; if not, append it.\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Validate config and restart\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Restoring backup.\"\n    mv \"${SSHD_CONFIG}.bak\" $SSHD_CONFIG\nfi"}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM) that calculates and stores the SHA-256 hashes of critical system binaries to detect unauthorized modifications.", "output": "import hashlib\nimport os\nimport json\n\ncritical_files = [\n    '/bin/ls',\n    '/bin/ps',\n    '/usr/bin/passwd',\n    '/etc/shadow'\n]\noutput_db = 'file_hashes.json'\n\ndef get_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\nhash_db = {}\nfor file in critical_files:\n    if os.path.exists(file):\n        hash_db[file] = get_file_hash(file)\n    else:\n        hash_db[file] = \"MISSING\"\n\nwith open(output_db, 'w') as f:\n    json.dump(hash_db, f, indent=4)\n\nprint(f\"Hashes saved to {output_db}\")"}
{"instruction": "Write a Bash script using 'iptables' to create a firewall rule that drops all incoming traffic from a specific malicious IP address and logs the event.", "output": "#!/bin/bash\n\nBLOCK_IP=\"192.0.2.100\"\nLOG_PREFIX=\"[IPTABLES-DROP]: \"\n\n# Check root\nif [ \"$(id -u)\" -ne 0 ]; then echo \"Run as root\"; exit 1; fi\n\n# Log packets from the IP before dropping\niptables -I INPUT -s $BLOCK_IP -j LOG --log-prefix \"$LOG_PREFIX\" --log-level 4\n\n# Drop packets from the IP\niptables -I INPUT -s $BLOCK_IP -j DROP\n\necho \"Blocked and logging enabled for IP: $BLOCK_IP\""}
{"instruction": "Create a Python script using the 'nmap' library (python-nmap) to perform a basic vulnerability scan (port discovery) on a local subnet to identify active hosts and open ports.", "output": "import nmap\n\n# Initialize the scanner\nnm = nmap.PortScanner()\n\n# Define target subnet (Example: Localhost/Subnet)\ntarget = '192.168.1.0/24'\n\nprint(f\"Scanning {target} for open ports...\")\n\n# Scan for common ports\nnm.scan(hosts=target, arguments='-p 22,80,443,3389 --open')\n\nfor host in nm.all_hosts():\n    print(f\"Host: {host} ({nm[host].hostname()})\")\n    print(f\"State: {nm[host].state()}\")\n    for proto in nm[host].all_protocols():\n        ports = nm[host][proto].keys()\n        for port in sorted(ports):\n            print(f\"\\tPort: {port}\\tState: {nm[host][proto][port]['state']}\")"}
{"instruction": "Write a Bash script for Security Auditing that scans the system for files with SUID (Set User ID) permissions, which can be potential privilege escalation vectors.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_audit_report.txt\"\n\necho \"Starting SUID file audit...\"\necho \"Report generated at $(date)\" > $OUTPUT_FILE\n\n# Find files with SUID bit set owned by root\nfind / -user root -perm -4000 -print 2>/dev/null >> $OUTPUT_FILE\n\necho \"Audit complete. Check $OUTPUT_FILE for the list of SUID binaries.\""}
{"instruction": "Develop a Python script to check the SSL/TLS certificate expiration date of a remote server to ensure encryption validity.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = 'www.example.com'\nport = 443\n\ncontext = ssl.create_default_context()\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            # Extract expiration date\n            expire_date_str = cert['notAfter']\n            # Convert format: May 25 12:00:00 2025 GMT\n            expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n            \n            days_left = (expire_date - datetime.datetime.now()).days\n            print(f\"Certificate for {hostname} expires on: {expire_date}\")\n            print(f\"Days remaining: {days_left}\")\nexcept Exception as e:\n    print(f\"Error checking SSL: {e}\")"}
{"instruction": "Write a Bash script using 'nftables' to configure a base firewall policy: Allow established/related traffic, allow Loopback, allow SSH, and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Define the table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH (Port 22)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configuration applied.\""}
{"instruction": "Create a Python script that queries a mock Threat Intelligence API to check if a specific IP address is flagged as malicious.", "output": "import requests\n\n# Mock API endpoint (Replace with real Threat Intel API like VirusTotal or AbuseIPDB)\napi_url = \"https://api.abuseipdb.com/api/v2/check\"\napi_key = \"YOUR_API_KEY_HERE\"\nip_to_check = \"198.51.100.42\"\n\nheaders = {\n    'Key': api_key,\n    'Accept': 'application/json'\n}\nparams = {\n    'ipAddress': ip_to_check,\n    'maxAgeInDays': '90'\n}\n\n# Note: This requires a valid key to run successfully\ntry:\n    # response = requests.get(url=api_url, headers=headers, params=params)\n    # For demonstration, we simulate a response structure\n    print(f\"Checking reputation for {ip_to_check}...\")\n    \n    # Simulated logic\n    risk_score = 85 # Simulated high risk\n    if risk_score > 50:\n        print(f\"ALERT: IP {ip_to_check} has a high risk score: {risk_score}\")\n    else:\n        print(f\"IP {ip_to_check} appears clean.\")\n        \nexcept Exception as e:\n    print(f\"Failed to query API: {e}\")"}
{"instruction": "Write a Bash script for User Account Auditing that lists all users with a UID of 0 (root privileges) to detect unauthorized backdoor accounts.", "output": "#!/bin/bash\n\necho \"Auditing for users with UID 0 (Root Privileges)...\"\n\n# Parse /etc/passwd looking for UID 0 (3rd field)\n# Format: username:password:UID:GID:...\nawk -F: '($3 == 0) {print $1}' /etc/passwd > root_users.txt\n\necho \"The following accounts have root privileges:\"\ncat root_users.txt\n\n# Check if anyone other than 'root' exists\ncount=$(grep -v \"^root$\" root_users.txt | wc -l)\n\nif [ \"$count\" -gt 0 ]; then\n    echo \"WARNING: Non-standard root accounts detected!\"\nelse\n    echo \"Status: Normal (Only 'root' has UID 0).\"\nfi"}
{"instruction": "Write a Python script to analyze a web access log file and detect potential SQL Injection attempts using regular expressions.", "output": "import re\n\ndef detect_sqli(log_file_path):\n    # Common SQLi patterns: UNION SELECT, OR 1=1, comment sequence, etc.\n    sqli_patterns = [\n        r\"union\\s+select\",\n        r\"'\\s*OR\\s*\\d+=\\d+\",\n        r\"--\",\n        r\";\\s*DROP\\s+TABLE\",\n        r\"exec\\(\\s*sp_\"\n    ]\n    \n    compiled_patterns = [re.compile(p, re.IGNORECASE) for p in sqli_patterns]\n\n    with open(log_file_path, 'r') as f:\n        for line_num, line in enumerate(f, 1):\n            for pattern in compiled_patterns:\n                if pattern.search(line):\n                    print(f\"[ALERT] Potential SQLi detected on line {line_num}: {line.strip()}\")\n                    break\n\n# Example usage\n# detect_sqli('/var/log/nginx/access.log')"}
{"instruction": "Create a Bash script to harden SSH configuration by disabling root login and password authentication.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication (Enforce Key-based)\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\n\necho \"SSH hardening applied. Backup saved to $BACKUP.\""}
{"instruction": "Write a Python script to generate a basic iptables configuration file that allows specific ports and drops everything else.", "output": "def generate_iptables_rules(allowed_ports):\n    rules = [\n        \"*filter\",\n        \":INPUT DROP [0:0]\",\n        \":FORWARD DROP [0:0]\",\n        \":OUTPUT ACCEPT [0:0]\",\n        # Allow established connections\n        \"-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\",\n        # Allow loopback\n        \"-A INPUT -i lo -j ACCEPT\"\n    ]\n\n    for port, proto in allowed_ports:\n        rules.append(f\"-A INPUT -p {proto} --dport {port} -j ACCEPT\")\n\n    rules.append(\"COMMIT\")\n    return \"\\n\".join(rules)\n\n# Usage: Allow SSH (22) and HTTP (80)\nconfig = generate_iptables_rules([(22, 'tcp'), (80, 'tcp')])\nprint(config)"}
{"instruction": "Create a Bash script to search for files with SUID permission set, which could be potential privilege escalation vectors.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/suid_audit.log\"\necho \"Starting SUID file scan at $(date)\" > $LOG_FILE\n\n# Find files with SUID bit set (-4000)\nfind / -perm -4000 -type f 2>/dev/null | while read -r file; do\n    owner=$(stat -c '%U' \"$file\")\n    perms=$(stat -c '%a' \"$file\")\n    echo \"SUID File Found: $file (Owner: $owner, Perms: $perms)\" | tee -a $LOG_FILE\ndone\n\necho \"Scan complete. Results saved to $LOG_FILE\""}
{"instruction": "Write a Python script to perform a basic port scan on a local server to identify listening services (Banner Grabbing).", "output": "import socket\n\ndef banner_grab(host, ports):\n    print(f\"Scanning {host}...\")\n    for port in ports:\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(1)\n            result = s.connect_ex((host, port))\n            if result == 0:\n                # Try to receive a banner\n                s.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')\n                try:\n                    banner = s.recv(1024).decode().strip()\n                except:\n                    banner = \"No banner received\"\n                print(f\"[OPEN] Port {port}: {banner[:50]}\")\n            s.close()\n        except Exception as e:\n            pass\n\n# Example usage\n# banner_grab('127.0.0.1', [21, 22, 80, 443])"}
{"instruction": "Create a Bash script using 'nftables' to block traffic from a specific list of IP addresses.", "output": "#!/bin/bash\n\n# List of malicious IPs\nBLOCKLIST=(\"192.0.2.55\" \"203.0.113.12\" \"198.51.100.99\")\n\n# Initialize table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add drop rules\nfor ip in \"${BLOCKLIST[@]}\"; do\n    nft add rule inet filter input ip saddr $ip drop\n    echo \"Blocked IP: $ip\"\ndone\n\necho \"Nftables updated.\""}
{"instruction": "Write a Python script to audit file permissions in a specific directory, identifying world-writable files.", "output": "import os\nimport stat\n\ndef find_world_writable(directory):\n    print(f\"Auditing {directory} for world-writable files...\")\n    for root, dirs, files in os.walk(directory):\n        for name in files:\n            filepath = os.path.join(root, name)\n            try:\n                file_stat = os.stat(filepath)\n                # Check if 'Others' have Write permission\n                if file_stat.st_mode & stat.S_IWOTH:\n                    print(f\"[RISK] World-writable: {filepath}\")\n            except OSError as e:\n                print(f\"[ERROR] Could not access {filepath}: {e}\")\n\n# Example usage\n# find_world_writable('/var/www/html')"}
{"instruction": "Create a Bash script to parse authentication logs and identify IP addresses with more than 5 failed login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\necho \"Checking for brute force attempts...\"\n\n# Extract IPs from 'Failed password' lines, count them, and filter by threshold\ngrep \"Failed password\" $LOG_FILE | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"[ALERT] IP $ip has $count failed login attempts.\"\n    fi\ndone"}
{"instruction": "Write a Python script to check installed pip packages against a hypothetical list of vulnerable package versions.", "output": "import pkg_resources\n\ndef check_vulnerable_packages(vuln_db):\n    # vuln_db format: {'package_name': 'vulnerable_version'}\n    installed_packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}\n    \n    for pkg, vuln_ver in vuln_db.items():\n        if pkg in installed_packages:\n            if installed_packages[pkg] == vuln_ver:\n                print(f\"[VULNERABLE] {pkg} version {vuln_ver} is installed.\")\n            else:\n                print(f\"[OK] {pkg} is installed ({installed_packages[pkg]}), but not the vulnerable version.\")\n\n# Example database\nvulns = {'requests': '2.0.0', 'django': '1.8.0'}\ncheck_vulnerable_packages(vulns)"}
{"instruction": "Create a Bash script to apply kernel hardening settings via sysctl (e.g., disable IP forwarding, ignore ICMP redirects).", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/sysctl.d/99-security-hardening.conf\"\n\ncat <<EOF > $CONFIG_FILE\n# Disable IP Forwarding\nnet.ipv4.ip_forward = 0\n\n# Ignore ICMP Redirects (prevent MITM)\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\n\n# Enable TCP SYN Cookies (protect against SYN floods)\nnet.ipv4.tcp_syncookies = 1\n\n# Log Martian Packets (spoofed source IPs)\nnet.ipv4.conf.all.log_martians = 1\nEOF\n\n# Apply settings\nsysctl --system\necho \"Kernel hardening parameters applied.\""}
{"instruction": "Write a Python script to parse an Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, which might indicate a directory brute-force attempt.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nip_counts = defaultdict(int)\n\n# Regex to capture IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counts[ip_address] += 1\n\n    print(\"Potential Scanners (IPs with > 10 404 errors):\")\n    for ip, count in ip_counts.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(f\"Log file not found at {log_file_path}\")"}
{"instruction": "Create a Bash script using `iptables` to drop all incoming traffic from a specific malicious IP address (e.g., 192.168.1.100) and log the dropped packet.", "output": "#!/bin/bash\n\nMALICIOUS_IP=\"192.168.1.100\"\n\n# Log the packet before dropping it\niptables -A INPUT -s $MALICIOUS_IP -j LOG --log-prefix \"IPTABLES-DROP: \" --log-level 4\n\n# Drop the traffic\niptables -A INPUT -s $MALICIOUS_IP -j DROP\n\necho \"Blocked and logging enabled for $MALICIOUS_IP\""}
{"instruction": "Write a Python script for server hardening that checks if critical system files (like /etc/passwd, /etc/shadow) are world-writable.", "output": "import os\nimport stat\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/group', '/etc/gshadow']\n\nprint(\"Checking file permissions...\")\nfor file_path in critical_files:\n    try:\n        file_stat = os.stat(file_path)\n        # Check if Other has Write permission (S_IWOTH)\n        if file_stat.st_mode & stat.S_IWOTH:\n            print(f\"[ALERT] {file_path} is WORLD-WRITABLE!\")\n        else:\n            print(f\"[OK] {file_path} permissions are secure.\")\n    except FileNotFoundError:\n        print(f\"[INFO] {file_path} does not exist.\")\n    except PermissionError:\n        print(f\"[ERROR] Permission denied checking {file_path}\")"}
{"instruction": "Generate a Bash script to analyze `/var/log/auth.log` and extract the top 5 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found!\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\ngrep \"Failed password\" $LOG_FILE | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Write a Python script to verify the SHA-256 integrity of a specific binary to detect potential tampering or unauthorized modification.", "output": "import hashlib\nimport sys\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\ntarget_file = \"/bin/ls\"\nexpected_hash = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" # Example hash\n\ncurrent_hash = calculate_sha256(target_file)\n\nif current_hash == expected_hash:\n    print(f\"Integrity Verified: {target_file}\")\nelse:\n    print(f\"[WARNING] Integrity Check Failed for {target_file}!\")\n    print(f\"Expected: {expected_hash}\")\n    print(f\"Found:    {current_hash}\")"}
{"instruction": "Create a Bash script using `nftables` to limit incoming SSH connections (port 22) to 10 per minute to mitigate brute-force attacks.", "output": "#!/bin/bash\n\n# Create table if it doesn't exist\nnft add table ip filter\n\n# Create chain if it doesn't exist\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop SSH connections exceeding 10 per minute\nnft add rule ip filter input tcp dport 22 ct state new limit rate 10/minute accept\nnft add rule ip filter input tcp dport 22 drop\n\necho \"NFTables rate limiting applied to port 22.\""}
{"instruction": "Write a Python script that performs a basic vulnerability check by connecting to a local port (e.g., 23 for Telnet) to see if an insecure service is running.", "output": "import socket\n\ndef check_port(port, service_name):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex(('127.0.0.1', port))\n    if result == 0:\n        print(f\"[VULNERABILITY WARNING] Insecure service '{service_name}' found running on port {port}.\")\n    else:\n        print(f\"[OK] Port {port} ({service_name}) is closed.\")\n    sock.close()\n\n# Check for Telnet (23) and FTP (21)\ncheck_port(23, \"Telnet\")\ncheck_port(21, \"FTP\")"}
{"instruction": "Generate a Bash script for server hardening that disables root login via SSH and restarts the SSH service.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"${SSH_CONFIG}.bak\"\n\n# Use sed to ensure PermitRootLogin is set to no\nif grep -q \"^PermitRootLogin\" $SSH_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSH_CONFIG\nfi\n\n# Restart SSH service (checking for systemd or init)\nif command -v systemctl &> /dev/null; then\n    systemctl restart sshd\nelse\n    service sshd restart\nfi\n\necho \"Root login disabled and SSH restarted.\""}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a given domain to prevent security lapses.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = 'www.example.com'\nport = 443\n\ncontext = ssl.create_default_context()\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            # Parse expiration date\n            expire_date_str = cert['notAfter']\n            expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n            \n            days_remaining = (expire_date - datetime.datetime.utcnow()).days\n            \n            print(f\"Certificate for {hostname} expires on: {expire_date}\")\n            print(f\"Days remaining: {days_remaining}\")\n            \n            if days_remaining < 30:\n                print(\"[ALERT] Certificate expires in less than 30 days!\")\nexcept Exception as e:\n    print(f\"Error checking certificate: {e}\")"}
{"instruction": "Create a Bash script to harden the network stack by disabling IP forwarding and ignoring ICMP echo requests (ping) via sysctl.", "output": "#!/bin/bash\n\n# Disable IP Forwarding (prevents routing traffic)\nsysctl -w net.ipv4.ip_forward=0\n\n# Ignore ICMP Echo Requests (Ping)\nsysctl -w net.ipv4.icmp_echo_ignore_all=1\n\n# Make changes persistent in /etc/sysctl.conf\nif ! grep -q \"net.ipv4.ip_forward=0\" /etc/sysctl.conf; then\n    echo \"net.ipv4.ip_forward=0\" >> /etc/sysctl.conf\nfi\n\nif ! grep -q \"net.ipv4.icmp_echo_ignore_all=1\" /etc/sysctl.conf; then\n    echo \"net.ipv4.icmp_echo_ignore_all=1\" >> /etc/sysctl.conf\nfi\n\necho \"Network stack hardened: IP Forwarding disabled, Ping disabled.\""}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file and identifies the top 5 IP addresses with the highest request count.", "output": "import re\nfrom collections import Counter\n\ndef analyze_apache_logs(log_file_path):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Top 5 IP Addresses by Request Count:\")\n        for ip, count in ip_counter.most_common(5):\n            print(f\"{ip}: {count}\")\n            \n    except FileNotFoundError:\n        print(f\"Error: File {log_file_path} not found.\")\n\nif __name__ == \"__main__\":\n    analyze_apache_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script for Server Hardening that disables root login via SSH and restarts the sshd service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Check if running as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"Please run as root.\"\n    exit 1\nfi\n\n# Backup config\ncp $SSHD_CONFIG $BACKUP_CONFIG\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Restart SSH service to apply changes\nif systemctl restart sshd; then\n    echo \"Root login disabled and SSH service restarted.\"\nelse\n    echo \"Failed to restart SSH service. Reverting changes...\"\n    cp $BACKUP_CONFIG $SSHD_CONFIG\nfi"}
{"instruction": "Write a Python script for a basic Vulnerability Scan that checks if a specific target IP has common ports open (21, 22, 80, 443).", "output": "import socket\n\ndef scan_ports(target_ip, ports):\n    print(f\"Scanning {target_ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        else:\n            print(f\"Port {port}: CLOSED\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    target = \"192.168.1.10\"  # Replace with target IP\n    common_ports = [21, 22, 80, 443, 3389, 8080]\n    scan_ports(target, common_ports)"}
{"instruction": "Generate a Bash script to create a basic iptables Firewall configuration that allows established connections, SSH, HTTP/HTTPS, and drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Allow HTTPS\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script for SIEM/Log Analysis that monitors `/var/log/auth.log` in real-time for failed SSH login attempts.", "output": "import time\nimport re\n\ndef monitor_auth_log(log_file):\n    print(f\"Monitoring {log_file} for failed SSH logins...\")\n    try:\n        with open(log_file, 'r') as f:\n            # Move to the end of the file\n            f.seek(0, 2)\n            while True:\n                line = f.readline()\n                if not line:\n                    time.sleep(0.1)\n                    continue\n                \n                # Check for failed password or invalid user\n                if \"Failed password\" in line or \"Invalid user\" in line:\n                     # Extract timestamp and IP if possible\n                     print(f\"[ALERT] Suspicious Activity Detected: {line.strip()}\")\n    except PermissionError:\n        print(\"Error: Run with sudo to read auth logs.\")\n    except FileNotFoundError:\n        print(\"Error: Log file not found.\")\n\nif __name__ == \"__main__\":\n    monitor_auth_log('/var/log/auth.log')"}
{"instruction": "Create a Bash script for Server Hardening that searches for files with SUID bits set, which can be potential privilege escalation vectors.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_files_audit.txt\"\n\necho \"Starting SUID bit scan...\"\necho \"Scan results saved to $OUTPUT_FILE\"\n\n# Find files with SUID bit set owned by root\nfind / -user root -perm -4000 -print 2>/dev/null > $OUTPUT_FILE\n\necho \"---------------------------------\"\necho \"Top 10 SUID binaries found:\"\nhead -n 10 $OUTPUT_FILE\necho \"---------------------------------\"\necho \"Please review $OUTPUT_FILE for unknown binaries.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote server (Vulnerability Scanning/Monitoring).", "output": "import ssl\nimport socket\nfrom datetime import datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse the date format: Mar 10 12:00:00 2025 GMT\n                expire_date = datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expire_date - datetime.utcnow()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_left}\")\n                \n                if days_left < 30:\n                    print(\"WARNING: Certificate expires in less than 30 days!\")\n    except Exception as e:\n        print(f\"Error checking SSL for {hostname}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.google.com\")"}
{"instruction": "Generate a Bash script using `nftables` to implement rate limiting on SSH connections to prevent brute-force attacks.", "output": "#!/bin/bash\n\n# Check for nftables\nif ! command -v nft &> /dev/null; then\n    echo \"nftables is not installed.\"\n    exit 1\nfi\n\n# Initialize table and chain\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Allow loopback\nnft add rule ip filter input iif lo accept\n\n# Allow established/related\nnft add rule ip filter input ct state established,related accept\n\n# SSH Rate Limiting: Allow SSH but drop if more than 3 attempts per minute\nnft add rule ip filter input tcp dport 22 ct state new limit rate 3/minute accept\nnft add rule ip filter input tcp dport 22 drop\n\n# Drop everything else\nnft add rule ip filter input drop\n\necho \"nftables rate limiting applied to SSH.\""}
{"instruction": "Write a Python script for System Integrity Monitoring (Hardening) that calculates SHA-256 hashes of critical system files to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_hash(file_path):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\ndef monitor_files(file_list):\n    print(\"File Integrity Report:\")\n    for file_path in file_list:\n        file_hash = calculate_hash(file_path)\n        print(f\"{file_path}: {file_hash}\")\n\nif __name__ == \"__main__\":\n    critical_files = [\n        \"/etc/passwd\",\n        \"/etc/shadow\",\n        \"/etc/hosts\",\n        \"/bin/ls\"\n    ]\n    monitor_files(critical_files)"}
{"instruction": "Create a Bash script for Server Hardening that applies sysctl network security parameters (e.g., disable IP forwarding, ignore ICMP redirects).", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.d/99-security-hardening.conf\"\n\necho \"Applying network hardening rules...\"\n\ncat <<EOF > $SYSCTL_CONF\n# Disable IP Forwarding\nnet.ipv4.ip_forward = 0\n\n# Ignore ICMP Echo Requests (Ping)\nnet.ipv4.icmp_echo_ignore_all = 1\n\n# Ignore ICMP Redirects\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\n\n# Disable source packet routing\nnet.ipv4.conf.all.accept_source_route = 0\n\n# Log Spoofed Packets, Source Routed Packets, Redirect Packets\nnet.ipv4.conf.all.log_martians = 1\nEOF\n\n# Apply changes\nsysctl -p $SYSCTL_CONF\n\necho \"Network parameters updated.\""}
{"instruction": "Create a Python script to parse an Apache access log file ('access.log') and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import defaultdict\n\nlog_file = 'access.log'\nip_404_count = defaultdict(int)\nTHRESHOLD = 10\n\n# Regex to extract IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*? HTTP/\\d\\.\\d\" (\\d{3}) ')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                status_code = match.group(2)\n                if status_code == '404':\n                    ip_404_count[ip_address] += 1\n\n    print(f\"IPs with > {THRESHOLD} 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > THRESHOLD:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script to harden the SSH configuration by disabling root login and enforcing key-based authentication (disabling password auth) in /etc/ssh/sshd_config.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP_CONFIG\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Password Authentication\nif grep -q \"^PasswordAuthentication\" $SSHD_CONFIG; then\n    sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nelse\n    echo \"PasswordAuthentication no\" >> $SSHD_CONFIG\nfi\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\necho \"SSH Hardening applied. Backup saved to $BACKUP_CONFIG\""}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM). The script should calculate SHA-256 hashes of files in a specific directory ('/etc/critical_conf') and alert if the hash differs from a known baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (In production, load this from a secure DB)\nbaseline = {\n    'config.json': 'a1b2c3d4...',\n    'settings.yaml': 'e5f6g7h8...'\n}\n\nmonitor_dir = '/etc/critical_conf'\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nprint(\"Starting File Integrity Check...\")\nfor filename, known_hash in baseline.items():\n    filepath = os.path.join(monitor_dir, filename)\n    current_hash = calculate_sha256(filepath)\n    \n    if current_hash is None:\n        print(f\"[ALERT] File missing: {filename}\")\n    elif current_hash != known_hash:\n        print(f\"[ALERT] Integrity mismatch for {filename}! Expected: {known_hash}, Got: {current_hash}\")\n    else:\n        print(f\"[OK] {filename} is intact.\")"}
{"instruction": "Write a Bash script using 'iptables' to create a basic firewall setup: drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Create a Python script to scan local network ports (localhost) to identify services listening on non-standard ports, useful for vulnerability assessment.", "output": "import socket\n\ntarget = \"127.0.0.1\"\n# Scanning a range of common and non-standard ports\nports_to_scan = [21, 22, 80, 443, 8080, 8443, 3306, 27017]\n\nprint(f\"Scanning {target} for open ports...\")\n\nfor port in ports_to_scan:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target, port))\n    if result == 0:\n        try:\n            service = socket.getservbyport(port)\n        except:\n            service = \"Unknown\"\n        print(f\"Port {port}: OPEN ({service})\")\n    sock.close()"}
{"instruction": "Write a Bash script to analyze '/var/log/auth.log' (or secure log) and count the number of failed 'sudo' attempts by user.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found.\"\n    exit 1\nfi\n\necho \"Failed SUDO attempts by user:\"\n# Filter for sudo errors, extract user, sort and count\ngrep \"sudo:\" $LOG_FILE | grep \"authentication failure\" | awk -F \"user=\" '{print $2}' | awk '{print $1}' | sort | uniq -c | sort -nr"}
{"instruction": "Generate an 'nftables' configuration script (Bash) to prevent a specific IP address (e.g., 192.168.1.100) from accessing the HTTP port (80).", "output": "#!/bin/bash\n\nBAD_IP=\"192.168.1.100\"\n\n# Create table if it doesn't exist\nnft add table ip filter\n\n# Create chain if it doesn't exist\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop HTTP traffic from the specific IP\nnft add rule ip filter input ip saddr $BAD_IP tcp dport 80 drop\n\necho \"nftables rule added: Dropping HTTP traffic from $BAD_IP\""}
{"instruction": "Create a Python script to check the SSL/TLS certificate expiration date of a remote domain to prevent security lapses due to expired certificates.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = 'www.example.com'\nport = 443\n\ndef get_ssl_expiry(host, port):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=host)\n    \n    # Set timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((host, port))\n        ssl_info = conn.getpeercert()\n        # Parse end date\n        expire_date_str = ssl_info['notAfter']\n        # Format: May 25 12:00:00 2025 GMT\n        expire_date = datetime.datetime.strptime(expire_date_str, r'%b %d %H:%M:%S %Y %Z')\n        return expire_date\n    except Exception as e:\n        return str(e)\n    finally:\n        conn.close()\n\nexpiry = get_ssl_expiry(hostname, port)\nprint(f\"Certificate for {hostname} expires on: {expiry}\")"}
{"instruction": "Write a Bash script for server hardening that searches for files with 'world-writable' permissions (777) and removes the write permission for 'others'.", "output": "#!/bin/bash\n\nSEARCH_DIR=\"/var/www/html\"\n\necho \"Scanning $SEARCH_DIR for world-writable files...\"\n\n# Find files (-type f) with permission 777 (or equivalent world-writable bit)\n# -perm -002 checks if 'others' have write permission\nfind $SEARCH_DIR -type f -perm -002 -print0 | while IFS= read -r -d '' file; do\n    echo \"Securing: $file\"\n    # Remove write permission for others (o-w)\n    chmod o-w \"$file\"\ndone\n\necho \"Scan and remediation complete.\""}
{"instruction": "Develop a Python script to audit AWS Security Groups (simulated JSON input) to identify groups that allow ingress from '0.0.0.0/0' on sensitive ports (22, 3389).", "output": "import json\n\n# Simulated AWS Security Group JSON Data\naws_sg_data = '''\n[\n    {\n        \"GroupId\": \"sg-12345\",\n        \"IpPermissions\": [\n            {\"FromPort\": 80, \"ToPort\": 80, \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]},\n            {\"FromPort\": 22, \"ToPort\": 22, \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]}\n        ]\n    },\n    {\n        \"GroupId\": \"sg-67890\",\n        \"IpPermissions\": [\n            {\"FromPort\": 443, \"ToPort\": 443, \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]}\n        ]\n    }\n]\n'''\n\nsensitive_ports = [22, 3389]\ndata = json.loads(aws_sg_data)\n\nprint(\"Auditing Security Groups...\")\nfor sg in data:\n    sg_id = sg['GroupId']\n    for rule in sg.get('IpPermissions', []):\n        from_port = rule.get('FromPort')\n        for ip_range in rule.get('IpRanges', []):\n            cidr = ip_range.get('CidrIp')\n            if cidr == '0.0.0.0/0' and from_port in sensitive_ports:\n                print(f\"[RISK] SG {sg_id} allows open access (0.0.0.0/0) on sensitive port {from_port}\")"}
{"instruction": "Create a Python script to parse a Linux authentication log (e.g., /var/log/auth.log) and identify IP addresses that have attempted to log in via SSH more than 5 times without success.", "output": "import re\nfrom collections import Counter\n\ndef analyze_ssh_failures(log_path, threshold=5):\n    ip_pattern = r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)'\n    failed_ips = []\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = re.search(ip_pattern, line)\n                if match:\n                    failed_ips.append(match.group(1))\n        \n        ip_counts = Counter(failed_ips)\n        \n        print(f\"IPs with > {threshold} failed attempts:\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"{ip}: {count} attempts\")\n                \n    except FileNotFoundError:\n        print(f\"Log file not found at {log_path}\")\n\nif __name__ == '__main__':\n    analyze_ssh_failures('/var/log/auth.log')"}
{"instruction": "Write a Bash script that uses iptables to implement a basic firewall policy: flush existing rules, set default policies to DROP for Input/Forward and ACCEPT for Output, allow loopback traffic, and allow established connections.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default chain policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow traffic on loopback interface\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow incoming traffic for established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (optional, adjust port if needed)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Basic firewall rules applied.\""}
{"instruction": "Develop a Python script for server hardening that scans a specific directory recursively and reports any files that are world-writable (permission 777 or similar).", "output": "import os\nimport stat\n\ndef check_world_writable(directory):\n    print(f\"Scanning {directory} for world-writable files...\")\n    for root, dirs, files in os.walk(directory):\n        for filename in files:\n            filepath = os.path.join(root, filename)\n            try:\n                file_stat = os.stat(filepath)\n                # Check if 'others' have write permission (S_IWOTH)\n                if file_stat.st_mode & stat.S_IWOTH:\n                    print(f\"[WARNING] World-writable file found: {filepath}\")\n            except PermissionError:\n                print(f\"[ERROR] Permission denied scanning: {filepath}\")\n\nif __name__ == '__main__':\n    # Example: Scan /etc directory\n    check_world_writable('/etc')"}
{"instruction": "Create a Bash script using nftables to rate-limit incoming SSH connections to prevent brute-force attacks (e.g., allow max 3 connections per minute per IP).", "output": "#!/bin/bash\n\n# Create table and chain if they don't exist\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule: Accept SSH on port 22, but drop if > 3 attempts in 60 seconds from same IP\nnft add rule ip filter input tcp dport 22 ct state new limit rate 3/minute accept\nnft add rule ip filter input tcp dport 22 drop\n\necho \"NFTables rate limiting applied to SSH.\""}
{"instruction": "Write a Python script that checks the HTTP response headers of a given URL to ensure security headers like 'X-Frame-Options', 'X-Content-Type-Options', and 'Strict-Transport-Security' are present.", "output": "import requests\n\ndef check_security_headers(url):\n    required_headers = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        print(f\"Analyzing headers for: {url}\")\n        \n        for h in required_headers:\n            if h in headers:\n                print(f\"[PASS] {h}: {headers[h]}\")\n            else:\n                print(f\"[FAIL] Missing header: {h}\")\n                \n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to URL: {e}\")\n\nif __name__ == '__main__':\n    target = input(\"Enter URL (e.g., https://example.com): \")\n    check_security_headers(target)"}
{"instruction": "Create a Bash script for server hardening that locks the root account password and disables Root login in the SSH configuration.", "output": "#!/bin/bash\n\n# Lock the root account password\npasswd -l root\necho \"Root password locked.\"\n\n# Backup SSH config\ncp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak\n\n# Disable Root Login in SSH config\n# Uses sed to find PermitRootLogin and set it to no\nif grep -q \"^PermitRootLogin\" /etc/ssh/sshd_config; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nelse\n    echo \"PermitRootLogin no\" >> /etc/ssh/sshd_config\nfi\n\necho \"SSH Root login disabled. Restarting SSH service...\"\nsystemctl restart sshd"}
{"instruction": "Write a Python script to calculate SHA-256 hashes of all files in a critical directory (e.g., /bin) to establish a baseline for file integrity monitoring.", "output": "import os\nimport hashlib\nimport json\n\ndef generate_baseline(directory, output_file='baseline.json'):\n    baseline = {}\n    print(f\"Generating SHA256 hashes for {directory}...\")\n    \n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            path = os.path.join(root, file)\n            try:\n                with open(path, \"rb\") as f:\n                    # Read file in chunks to handle large binaries\n                    file_hash = hashlib.sha256()\n                    while chunk := f.read(4096):\n                        file_hash.update(chunk)\n                    baseline[path] = file_hash.hexdigest()\n            except (PermissionError, OSError):\n                continue\n    \n    with open(output_file, 'w') as f:\n        json.dump(baseline, f, indent=4)\n    print(f\"Baseline saved to {output_file}\")\n\nif __name__ == '__main__':\n    generate_baseline('/bin')"}
{"instruction": "Develop a Bash script to parse Nginx access logs and extract the top 10 IP addresses generating the most requests.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 Source IPs from Nginx Log:\"\n\n# Assumes default combined log format where IP is the first field ($1)\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a Python script that acts as a simple port scanner to check if critical ports (22, 80, 443, 3306) are open on a local server for audit purposes.", "output": "import socket\n\ndef audit_ports(target_ip, ports):\n    print(f\"Auditing ports on {target_ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        else:\n            print(f\"Port {port}: CLOSED/FILTERED\")\n        sock.close()\n\nif __name__ == '__main__':\n    # Scan localhost\n    target = '127.0.0.1'\n    ports_to_check = [21, 22, 80, 443, 3306, 8080]\n    audit_ports(target, ports_to_check)"}
{"instruction": "Write a Bash script to verify file permissions on critical system files (/etc/passwd, /etc/shadow, /etc/group) and fix them if they are incorrect.", "output": "#!/bin/bash\n\n# Function to set permissions\nfix_perms() {\n    FILE=$1\n    OWNER=$2\n    GROUP=$3\n    PERMS=$4\n    \n    if [ -f \"$FILE\" ]; then\n        chown $OWNER:$GROUP \"$FILE\"\n        chmod $PERMS \"$FILE\"\n        echo \"Fixed $FILE: Owner=$OWNER, Group=$GROUP, Mode=$PERMS\"\n    else\n        echo \"Warning: $FILE does not exist.\"\n    fi\n}\n\n# Hardening standards\nfix_perms \"/etc/passwd\" \"root\" \"root\" \"644\"\nfix_perms \"/etc/group\" \"root\" \"root\" \"644\"\nfix_perms \"/etc/shadow\" \"root\" \"shadow\" \"640\"\nfix_perms \"/etc/gshadow\" \"root\" \"shadow\" \"640\"\n\necho \"Critical file permissions enforced.\""}
{"instruction": "Write a Python script to parse a Linux 'auth.log' file and identify IP addresses that have attempted to log in via SSH more than 5 times with a failure status.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/auth.log'\nfailed_attempts = defaultdict(int)\n\n# Regex to capture IP from sshd failed password lines\nip_pattern = re.compile(r'sshd\\[\\d+\\]: Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = ip_pattern.search(line)\n            if match:\n                ip = match.group(1)\n                failed_attempts[ip] += 1\n\n    print(\"IPs with > 5 failed login attempts:\")\n    for ip, count in failed_attempts.items():\n        if count > 5:\n            print(f\"{ip}: {count} attempts\")\nexcept FileNotFoundError:\n    print(f\"File not found: {log_file_path}\")\nexcept PermissionError:\n    print(\"Permission denied. Run with sudo.\")"}
{"instruction": "Create a Bash script using 'iptables' to set a default DROP policy for INPUT and FORWARD chains, allow loopback traffic, allow established connections, and allow incoming SSH (port 22) and HTTP (port 80).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script to check if a specific website is returning common security headers (Strict-Transport-Security, X-Frame-Options, X-Content-Type-Options).", "output": "import requests\n\ntarget_url = \"https://example.com\"\nsecurity_headers = [\n    \"Strict-Transport-Security\",\n    \"X-Frame-Options\",\n    \"X-Content-Type-Options\",\n    \"Content-Security-Policy\"\n]\n\ntry:\n    response = requests.get(target_url, timeout=5)\n    headers = response.headers\n    \n    print(f\"Scanning headers for: {target_url}\")\n    for sec_header in security_headers:\n        if sec_header in headers:\n            print(f\"[+] {sec_header}: Present\")\n        else:\n            print(f\"[-] {sec_header}: Missing\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error connecting to target: {e}\")"}
{"instruction": "Write a Bash script to search the entire filesystem for files with the SUID bit set, which can be a security risk for privilege escalation.", "output": "#!/bin/bash\n\necho \"Searching for SUID binaries...\"\n# -perm /4000 looks for the SUID bit\n# 2>/dev/null suppresses permission denied errors\nfind / -type f -perm /4000 -ls 2>/dev/null > suid_files.txt\n\necho \"Scan complete. Results saved to suid_files.txt\""}
{"instruction": "Create a Python script to monitor the integrity of critical system files (e.g., /etc/passwd, /etc/shadow) by calculating and comparing SHA-256 hashes.", "output": "import hashlib\nimport os\n\nfiles_to_watch = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/ssh/sshd_config\"]\nhash_db = {}\n\ndef calculate_hash(filepath):\n    sha256 = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            while chunk := f.read(8192):\n                sha256.update(chunk)\n        return sha256.hexdigest()\n    except PermissionError:\n        return \"PERMISSION_DENIED\"\n    except FileNotFoundError:\n        return \"NOT_FOUND\"\n\n# Initial Baseline\nprint(\"Generating baseline...\")\nfor f in files_to_watch:\n    hash_db[f] = calculate_hash(f)\n    print(f\"{f}: {hash_db[f]}\")\n\n# In a real scenario, this would loop or load a saved state to compare\nprint(\"\\n(Logic to compare against baseline would run here periodically)\")"}
{"instruction": "Write a Bash script using 'nftables' to create a table and chain that blocks a list of specific malicious IP addresses.", "output": "#!/bin/bash\n\n# Define the blacklist\nBAD_IPS=\"192.0.2.5 198.51.100.23\"\n\n# Create table and chain\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rules for each IP\nfor ip in $BAD_IPS; do\n    echo \"Blocking $ip\"\n    nft add rule ip filter input ip saddr $ip drop\ndone\n\necho \"nftables blacklist applied.\""}
{"instruction": "Write a Python script to check the expiration date of an SSL/TLS certificate for a given hostname and port.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = \"www.google.com\"\nport = 443\n\ncontext = ssl.create_default_context()\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            # Parse expiration date\n            expire_date_str = cert['notAfter']\n            expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n            \n            days_left = (expire_date - datetime.datetime.utcnow()).days\n            print(f\"Certificate for {hostname} expires on: {expire_date}\")\n            print(f\"Days remaining: {days_left}\")\nexcept Exception as e:\n    print(f\"Error checking SSL: {e}\")"}
{"instruction": "Write a Bash script to harden SSH configuration by disabling root login and password authentication (enforcing key-based auth).", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Disable Password Auth\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Check syntax and reload\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardened: Root login and password auth disabled.\"\nelse\n    echo \"Configuration error. Restoring backup.\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python script that performs a simple port scan on 'localhost' to identify listening ports between 1 and 1024.", "output": "import socket\n\ntarget = \"127.0.0.1\"\nopen_ports = []\n\nprint(f\"Scanning {target} for open ports (1-1024)...\")\n\nfor port in range(1, 1025):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(0.5)\n    result = sock.connect_ex((target, port))\n    if result == 0:\n        open_ports.append(port)\n    sock.close()\n\nprint(f\"Open ports found: {open_ports}\")"}
{"instruction": "Write a Bash script to parse Nginx access logs and extract the top 10 IP addresses generating 404 (Not Found) errors.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found.\"\n    exit 1\nfi\n\necho \"Top 10 IPs generating 404 errors:\"\n# grep for 404, awk to get IP (usually 1st column), sort, count unique, sort numeric descending\ngrep \" 404 \" $LOG_FILE | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 100 requests, indicating potential scanning or DoS activity.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Suspicious IPs (>100 requests):\")\n        for ip, count in ip_counter.items():\n            if count > 100:\n                print(f\"{ip}: {count} requests\")\n                \n    except FileNotFoundError:\n        print(f\"Error: File {log_file} not found.\")\n\nif __name__ == '__main__':\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script to harden a Linux server by configuring basic iptables firewall rules: allow loopback, allow established connections, allow SSH (port 22), allow HTTP/HTTPS, and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\n\necho \"Firewall rules configured successfully.\""}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM). The script should calculate the SHA-256 hash of a critical system file (e.g., /etc/passwd) and compare it against a stored known-good hash.", "output": "import hashlib\nimport sys\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\ndef check_integrity(filepath, known_hash):\n    current_hash = calculate_hash(filepath)\n    if current_hash is None:\n        print(f\"Error: Could not read {filepath}\")\n        return\n\n    if current_hash == known_hash:\n        print(f\"[OK] Integrity verified for {filepath}\")\n    else:\n        print(f\"[ALERT] File changed! {filepath}\")\n        print(f\"Expected: {known_hash}\")\n        print(f\"Found:    {current_hash}\")\n\n# Example usage\n# known_good_hash = 'stored_hash_value_here'\n# check_integrity('/etc/passwd', known_good_hash)"}
{"instruction": "Write a Bash script for SIEM-like log analysis that searches the authentication logs (/var/log/auth.log) for failed SSH login attempts and extracts the unique source IP addresses.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Extracting IPs with failed SSH login attempts...\"\n\n# Grep for 'Failed password', extract IP using awk (field usually varies, regex used here), sort and count unique\ngrep \"Failed password\" \"$LOG_FILE\" | grep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | sort | uniq -c | sort -nr\n\n# Note: This accounts for standard sshd logging formats."}
{"instruction": "Create a Python script that parses an Nmap XML output file to identify and report hosts with specific high-risk ports open (e.g., Telnet port 23 or FTP port 21).", "output": "import xml.etree.ElementTree as ET\nimport sys\n\ndef parse_nmap_xml(xml_file):\n    risky_ports = {'21': 'FTP', '23': 'Telnet'}\n    try:\n        tree = ET.parse(xml_file)\n        root = tree.getroot()\n        \n        print(\"Scanning report for risky open ports...\")\n        for host in root.findall('host'):\n            ip_addr = host.find(\"address[@addrtype='ipv4']\").get('addr')\n            ports = host.find('ports')\n            \n            if ports:\n                for port in ports.findall('port'):\n                    port_id = port.get('portid')\n                    state = port.find('state').get('state')\n                    \n                    if state == 'open' and port_id in risky_ports:\n                        print(f\"[ALERT] Host: {ip_addr} has {risky_ports[port_id]} (Port {port_id}) OPEN\")\n                        \n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n\nif __name__ == '__main__':\n    # Usage: python script.py scan_results.xml\n    if len(sys.argv) > 1:\n        parse_nmap_xml(sys.argv[1])\n    else:\n        print(\"Please provide an Nmap XML file path.\")"}
{"instruction": "Write a Bash script to automate server hardening by disabling the root user from logging in via SSH directly.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Ensure script is run as root\nif [ \"$(id -u)\" -ne 0 ]; then\n   echo \"This script must be run as root\"\n   exit 1\nfi\n\n# Backup config\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\necho \"Backup created at $BACKUP_FILE\"\n\n# Disable Root Login using sed\nif grep -q \"^PermitRootLogin\" \"$CONFIG_FILE\"; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\nelse\n    echo \"PermitRootLogin no\" >> \"$CONFIG_FILE\"\nfi\n\necho \"Root login disabled in configuration.\"\n\n# Restart SSH service to apply changes\nif systemctl restart sshd; then\n    echo \"SSH service restarted successfully.\"\nelse\n    echo \"Failed to restart SSH service. Check config.\"\nfi"}
{"instruction": "Create a Python script using the `ssl` and `socket` libraries to check if a remote server's SSL certificate is expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date (format: May 30 12:00:00 2024 GMT)\n        expire_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_str, r'%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.now()).days\n        \n        print(f\"Certificate for {hostname} expires on: {expire_date}\")\n        if days_remaining < 30:\n            print(f\"[WARNING] Certificate expires in {days_remaining} days!\")\n        else:\n            print(f\"[OK] Certificate valid for {days_remaining} days.\")\n            \n    except Exception as e:\n        print(f\"Connection error: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == '__main__':\n    check_ssl_expiry('www.example.com')"}
{"instruction": "Write a Bash script using `nftables` to create a firewall configuration that drops packets with invalid headers and limits the rate of incoming ICMP (ping) requests to prevent flooding.", "output": "#!/bin/bash\n\n# Clear current ruleset\nnft flush ruleset\n\n# Define the table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established/related connections\nnft add rule inet filter input ct state established,related accept\n\n# Drop invalid packets\nnft add rule inet filter input ct state invalid drop\n\n# Allow ICMP (Ping) but limit rate (2 per second)\nnft add rule inet filter input ip protocol icmp limit rate 2/second accept\n\n# Allow SSH (example)\nnft add rule inet filter input tcp dport 22 accept\n\n# List rules\nnft list ruleset\necho \"nftables configured.\""}
{"instruction": "Develop a Python script to scan a directory recursively and identify files with world-writable permissions (777), which pose a security risk.", "output": "import os\nimport stat\n\ndef find_world_writable(start_path):\n    print(f\"Scanning {start_path} for world-writable files...\")\n    for root, dirs, files in os.walk(start_path):\n        for name in files:\n            filepath = os.path.join(root, name)\n            try:\n                file_stat = os.stat(filepath)\n                # Check if 'others' have write permission (S_IWOTH)\n                if file_stat.st_mode & stat.S_IWOTH:\n                    print(f\"[RISK] World-writable file found: {filepath}\")\n            except OSError as e:\n                # Permission denied to read stat\n                pass\n\nif __name__ == '__main__':\n    # Example: Scan /var/www\n    find_world_writable('/var/www')"}
{"instruction": "Write a Bash script to verify system integrity by checking if any users in `/etc/passwd` have a UID of 0 other than the root user.", "output": "#!/bin/bash\n\necho \"Checking for non-root users with UID 0...\"\n\n# awk parses /etc/passwd, delimiter is :, checks if 3rd field (UID) is 0\n# If UID is 0 and the username (1st field) is NOT 'root', it prints the line.\nfound_users=$(awk -F: '($3 == 0 && $1 != \"root\") {print $1}' /etc/passwd)\n\nif [ -z \"$found_users\" ]; then\n    echo \"[OK] No unauthorized UID 0 accounts found.\"\nelse\n    echo \"[ALERT] The following non-root users have UID 0:\"\n    echo \"$found_users\"\nfi"}
{"instruction": "Write a Python script to parse a standard Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\nstatus_pattern = re.compile(r'\\\" 404 ')\n\nsuspicious_ips = []\n\ntry:\n    with open(log_file_path, 'r') as file:\n        for line in file:\n            if status_pattern.search(line):\n                match = ip_pattern.match(line)\n                if match:\n                    suspicious_ips.append(match.group(1))\n\n    ip_counts = Counter(suspicious_ips)\n    \n    print(\"IPs with > 10 404 errors:\")\n    for ip, count in ip_counts.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(f\"Log file not found at {log_file_path}\")"}
{"instruction": "Create a Bash script using 'iptables' to implement a basic firewall strategy: drop all incoming traffic by default, allow loopback, allow established connections, and allow incoming SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script that audits critical system files (e.g., /etc/shadow, /etc/passwd) to ensure their file permissions are secure (not world-writable).", "output": "import os\nimport stat\n\nfiles_to_check = ['/etc/shadow', '/etc/passwd', '/etc/group', '/etc/gshadow']\n\ndef check_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        mode = st.st_mode\n        \n        # Check if world writable\n        if mode & stat.S_IWOTH:\n            print(f\"[ALERT] {filepath} is world-writable!\")\n        \n        # Check if world readable (specific to shadow files)\n        if 'shadow' in filepath and (mode & stat.S_IROTH):\n            print(f\"[ALERT] {filepath} is world-readable!\")\n            \n        print(f\"[OK] Checked {filepath}\")\n    except FileNotFoundError:\n        print(f\"[MISSING] {filepath} does not exist.\")\n\nfor f in files_to_check:\n    check_permissions(f)"}
{"instruction": "Develop a Bash script for server hardening that disables root login via SSH and changes the default SSH port to 2222.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Change Port\nif grep -q \"^Port\" $SSHD_CONFIG; then\n    sed -i 's/^Port.*/Port 2222/' $SSHD_CONFIG\nelse\n    echo \"Port 2222\" >> $SSHD_CONFIG\nfi\n\n# Validate syntax and restart SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH hardening applied. Port changed to 2222.\"\nelse\n    echo \"Configuration error. Reverting...\"\n    cp \"$SSHD_CONFIG.bak\" $SSHD_CONFIG\nfi"}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a given domain to identify potential vulnerability/downtime risks.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse date format: May 25 23:59:59 2024 GMT\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Domain: {hostname}\")\n                print(f\"Expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                \n                if days_remaining < 30:\n                    print(\"[WARNING] Certificate expires in less than 30 days!\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\ncheck_ssl_expiry('example.com')"}
{"instruction": "Create a Bash script using 'nftables' to block a specific list of malicious IP addresses read from a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"malicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Ensure nftables is installed and table exists\nnft add table inet $TABLE_NAME\nnft add chain inet $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Loop through file and add drop rules\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    echo \"Blocking $ip\"\n    nft add rule inet $TABLE_NAME $CHAIN_NAME ip saddr $ip drop\ndone < \"$BLOCKLIST_FILE\"\n\necho \"Blocklist applied.\""}
{"instruction": "Write a Python script that scans the local machine for SUID (Set Owner User ID) binaries, which can be a security risk if misconfigured.", "output": "import os\nimport stat\n\ndef find_suid_binaries(search_path='/'):\n    print(f\"Scanning for SUID binaries in {search_path}...\")\n    for root, dirs, files in os.walk(search_path):\n        for name in files:\n            try:\n                filepath = os.path.join(root, name)\n                # Skip /proc, /sys, /dev to avoid errors and loops\n                if any(x in filepath for x in ['/proc', '/sys', '/dev', '/run']):\n                    continue\n                \n                st = os.lstat(filepath)\n                # Check for SUID bit (stat.S_ISUID)\n                if st.st_mode & stat.S_ISUID:\n                    print(f\"SUID Found: {filepath}\")\n            except (OSError, PermissionError):\n                pass # Ignore files we cannot read\n\nif __name__ == \"__main__\":\n    # Scanning only /usr/bin for demonstration speed; use '/' for full scan\n    find_suid_binaries('/usr/bin')"}
{"instruction": "Develop a Bash script for log analysis that extracts and counts failed SSH login attempts from '/var/log/auth.log' to identify brute-force targets.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found.\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\n\n# Grep for 'Failed password', extract IP (usually field 11 or near end), sort and count\ngrep \"Failed password for\" \"$LOG_FILE\" | \\\nawk '{for(i=1;i<=NF;i++) if ($i ~ /[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/) print $i}' | \\\nsort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Python script using the 'socket' library to perform a simple port scan on the localhost (127.0.0.1) to identify open ports in the range 1-1024.", "output": "import socket\n\ntarget = \"127.0.0.1\"\nprint(f\"Scanning {target} for open ports (1-1024)...\")\n\nfor port in range(1, 1025):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(0.5)\n    result = sock.connect_ex((target, port))\n    if result == 0:\n        try:\n            service = socket.getservbyport(port)\n        except:\n            service = \"unknown\"\n        print(f\"Port {port} is OPEN ({service})\")\n    sock.close()"}
{"instruction": "Create a Bash script to enforce password aging policies for a specific user to comply with security standards (force password change every 90 days).", "output": "#!/bin/bash\n\nUSER_NAME=\"target_user\"\nMAX_DAYS=90\nMIN_DAYS=7\nWARN_DAYS=14\n\n# Check if user exists\nif id \"$USER_NAME\" &>/dev/null; then\n    # chage: -M (max days), -m (min days), -W (warning days)\n    chage -M $MAX_DAYS -m $MIN_DAYS -W $WARN_DAYS \"$USER_NAME\"\n    \n    echo \"Password aging policy applied for $USER_NAME:\"\n    chage -l \"$USER_NAME\"\nelse\n    echo \"User $USER_NAME does not exist.\"\nfi"}
{"instruction": "Create a Python script that performs a basic TCP port scan on a specified target IP address for a defined range of ports to identify open services (Vulnerability Scanning).", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    open_ports = []\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"192.168.1.10\"\n    ports = scan_ports(target, 20, 100)\n    print(f\"Open ports: {ports}\")"}
{"instruction": "Write a Bash script to parse `/var/log/auth.log` and identify IP addresses that have failed SSH login attempts more than 5 times (Log Analysis).", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"Suspicious IP: $ip (Failed attempts: $count)\"\n    fi\ndone"}
{"instruction": "Develop a Python script to parse a standard Apache access log file and calculate the number of requests per IP address, highlighting potential DoS sources (Log Analysis).", "output": "import re\nfrom collections import Counter\n\ndef analyze_apache_log(log_path):\n    ip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.match(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n    except FileNotFoundError:\n        print(\"File not found.\")\n        return\n\n    print(\"Top 5 Requesting IPs:\")\n    for ip, count in ip_counter.most_common(5):\n        print(f\"{ip}: {count} requests\")\n\nif __name__ == \"__main__\":\n    analyze_apache_log(\"/var/log/apache2/access.log\")"}
{"instruction": "Create a Bash script to configure `iptables` rules that drop all incoming traffic by default, but allow SSH (port 22), HTTP (port 80), and HTTPS (port 443) (Firewall Rule Generation).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, and HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Iptables configured successfully.\""}
{"instruction": "Write a Python script that generates a basic `nftables.conf` configuration string based on a list of allowed ports provided in a dictionary (Firewall Rule Generation).", "output": "def generate_nftables_config(allowed_ports):\n    config = \"flush ruleset\\n\"\n    config += \"table inet filter {\\n\"\n    config += \"    chain input {\\n\"\n    config += \"        type filter hook input priority 0; policy drop;\\n\"\n    config += \"        iifname \\\"lo\\\" accept\\n\"\n    config += \"        ct state established,related accept\\n\"\n    \n    for proto, ports in allowed_ports.items():\n        ports_str = \", \".join(map(str, ports))\n        config += f\"        {proto} dport {{ {ports_str} }} accept\\n\"\n    \n    config += \"    }\\n\"\n    config += \"}\\n\"\n    return config\n\nif __name__ == \"__main__\":\n    rules = {\"tcp\": [22, 80, 443], \"udp\": [53]}\n    print(generate_nftables_config(rules))"}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and enforcing protocol version 2 (Server Hardening).", "output": "#!/bin/bash\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Enforce Protocol 2 (Usually default, but ensuring it exists)\nif ! grep -q \"^Protocol 2\" \"$SSHD_CONFIG\"; then\n    echo \"Protocol 2\" >> \"$SSHD_CONFIG\"\nfi\n\n# Restart SSH service\nsystemctl restart sshd\necho \"SSH hardening applied.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote server (Vulnerability Scanning/Monitoring).", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=5) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse date format: 'May 25 12:00:00 2025 GMT'\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_remaining = (expire_date - datetime.datetime.now()).days\n                print(f\"Certificate for {hostname} expires in {days_remaining} days ({expire_date}).\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Develop a Bash script to scan the filesystem for SUID and SGID binaries, which can be potential privilege escalation vectors if misconfigured (Server Hardening/Auditing).", "output": "#!/bin/bash\nOUTPUT_FILE=\"suid_sgid_audit.txt\"\n\necho \"Scanning for SUID/SGID binaries...\" > \"$OUTPUT_FILE\"\necho \"-----------------------------------\" >> \"$OUTPUT_FILE\"\n\n# Find SUID files\necho \"[SUID Files]\" >> \"$OUTPUT_FILE\"\nfind / -perm /4000 -type f -exec ls -ld {} \\; 2>/dev/null >> \"$OUTPUT_FILE\"\n\n# Find SGID files\necho \"\\n[SGID Files]\" >> \"$OUTPUT_FILE\"\nfind / -perm /2000 -type f -exec ls -ld {} \\; 2>/dev/null >> \"$OUTPUT_FILE\"\n\necho \"Audit complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Create a Python script that calculates SHA-256 hashes of critical system files to establish a baseline for file integrity monitoring (Server Hardening/blue team).", "output": "import hashlib\nimport os\n\ndef calculate_hash(filepath):\n    sha256 = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            while chunk := f.read(8192):\n                sha256.update(chunk)\n        return sha256.hexdigest()\n    except IOError:\n        return None\n\ndef monitor_files(file_list):\n    baseline = {}\n    for file in file_list:\n        if os.path.exists(file):\n            baseline[file] = calculate_hash(file)\n            print(f\"Hashed {file}: {baseline[file]}\")\n        else:\n            print(f\"File not found: {file}\")\n    return baseline\n\nif __name__ == \"__main__\":\n    critical_files = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/ssh/sshd_config\"]\n    monitor_files(critical_files)"}
{"instruction": "Write a Bash script to apply kernel parameter hardening by modifying `sysctl.conf` to disable IP forwarding and ignore ICMP echo requests (Server Hardening).", "output": "#!/bin/bash\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\n# Function to append or replace config\napply_setting() {\n    key=$1\n    value=$2\n    if grep -q \"^$key\" \"$SYSCTL_CONF\"; then\n        sed -i \"s/^$key.*/$key = $value/\" \"$SYSCTL_CONF\"\n    else\n        echo \"$key = $value\" >> \"$SYSCTL_CONF\"\n    fi\n}\n\n# Disable IP Forwarding\napply_setting \"net.ipv4.ip_forward\" \"0\"\n\n# Ignore ICMP Echo Requests (Ping)\napply_setting \"net.ipv4.icmp_echo_ignore_all\" \"1\"\n\n# Apply changes\nsysctl -p\necho \"Kernel hardening applied.\""}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file to identify IP addresses with more than 10 '404 Not Found' errors, simulating a basic SIEM detection rule for potential scanning activity.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    status_pattern = re.compile(r'\" 404 ')\n    found_ips = []\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if status_pattern.search(line):\n                    match = ip_pattern.match(line)\n                    if match:\n                        found_ips.append(match.group(1))\n        \n        ip_counts = Counter(found_ips)\n        print(\"IPs with > 10 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > 10:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script using 'iptables' to implement a default deny firewall policy. The script should allow loopback traffic, established connections, and SSH (port 22), while dropping everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\necho \"Firewall configured: Default DROP, allow Loopback/Established/SSH.\""}
{"instruction": "Write a Python script to perform a basic vulnerability scan by checking a list of URLs for missing security headers (X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security).", "output": "import requests\n\ndef check_security_headers(urls):\n    headers_to_check = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n\n    for url in urls:\n        try:\n            print(f\"Scanning {url}...\")\n            response = requests.get(url, timeout=5)\n            missing = []\n            for header in headers_to_check:\n                if header not in response.headers:\n                    missing.append(header)\n            \n            if missing:\n                print(f\"[VULN] {url} is missing: {', '.join(missing)}\")\n            else:\n                print(f\"[OK] {url} has all checked headers.\")\n        except requests.exceptions.RequestException as e:\n            print(f\"[ERROR] Could not connect to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    targets = ['http://localhost', 'https://example.com']\n    check_security_headers(targets)"}
{"instruction": "Write a Bash hardening script to secure SSH configuration. It should disable root login, disable empty passwords, and enforce Protocol 2 in '/etc/ssh/sshd_config'.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\nif [ ! -f \"$BACKUP\" ]; then\n    cp \"$SSHD_CONFIG\" \"$BACKUP\"\n    echo \"Backup created at $BACKUP\"\nfi\n\n# Disable Root Login\nsed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Empty Passwords\nsed -i 's/^#*PermitEmptyPasswords.*/PermitEmptyPasswords no/' \"$SSHD_CONFIG\"\n\n# Ensure Protocol 2 (Legacy check, modern SSH defaults to 2)\nif grep -q \"^Protocol\" \"$SSHD_CONFIG\"; then\n    sed -i 's/^Protocol.*/Protocol 2/' \"$SSHD_CONFIG\"\nelse\n    echo \"Protocol 2\" >> \"$SSHD_CONFIG\"\nfi\n\necho \"SSH Hardening complete. Restart sshd to apply changes.\"\n# systemctl restart sshd"}
{"instruction": "Create a Python script for file integrity monitoring (hardening). The script should calculate SHA-256 hashes of critical system files (e.g., /etc/passwd, /etc/shadow) and alert if they change compared to a baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (in real usage, load this from a secure storage)\nbaseline = {\n    '/etc/passwd': 'known_hash_placeholder',\n    '/etc/shadow': 'known_hash_placeholder'\n}\n\ndef calculate_hash(filepath):\n    sha256 = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            while True:\n                data = f.read(65536)\n                if not data:\n                    break\n                sha256.update(data)\n        return sha256.hexdigest()\n    except IOError:\n        return None\n\ndef check_integrity():\n    print(\"Starting File Integrity Check...\")\n    for filepath, known_hash in baseline.items():\n        current_hash = calculate_hash(filepath)\n        if current_hash is None:\n            print(f\"[ALERT] File missing or unreadable: {filepath}\")\n        elif known_hash == 'known_hash_placeholder':\n            print(f\"[INIT] Baseline needed for {filepath}: {current_hash}\")\n        elif current_hash != known_hash:\n            print(f\"[ALERT] Integrity violation detected: {filepath}\")\n        else:\n            print(f\"[OK] {filepath} is unchanged.\")\n\nif __name__ == \"__main__\":\n    check_integrity()"}
{"instruction": "Write a Bash script to generate 'nftables' rules for a web server. The rules should flush the existing ruleset, allow loopback, allow incoming TCP traffic on ports 80 and 443, and drop all other incoming traffic.", "output": "#!/bin/bash\n\n# Create a config file for nftables\ncat <<EOF > /etc/nftables.conf\nflush ruleset\n\ntable inet filter {\n    chain input {\n        type filter hook input priority 0; policy drop;\n\n        # Accept loopback\n        iifname \"lo\" accept\n\n        # Accept established and related connections\n        ct state established,related accept\n\n        # Accept HTTP and HTTPS\n        tcp dport { 80, 443 } accept\n\n        # Accept SSH (optional management)\n        tcp dport 22 accept\n\n        # ICMP (Ping) - optional limit\n        ip protocol icmp accept\n    }\n    chain forward {\n        type filter hook forward priority 0; policy drop;\n    }\n    chain output {\n        type filter hook output priority 0; policy accept;\n    }\n}\nEOF\n\n# Load the rules\nnft -f /etc/nftables.conf\necho \"nftables rules loaded for Web Server.\""}
{"instruction": "Write a Python script that acts as a simple port scanner (auditing tool) to identify open TCP ports on the localhost (127.0.0.1) between ports 1 and 1024.", "output": "import socket\n\ndef scan_ports(host, start_port, end_port):\n    print(f\"Scanning {host} from port {start_port} to {end_port}...\")\n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((host, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    if open_ports:\n        print(f\"Open ports on {host}: {open_ports}\")\n    else:\n        print(f\"No open ports found in range {start_port}-{end_port}.\")\n\nif __name__ == \"__main__\":\n    scan_ports('127.0.0.1', 1, 1024)"}
{"instruction": "Create a Bash script for Server Hardening that searches for files with SUID or SGID bits set, which can be potential privilege escalation vectors, and saves the list to a report file.", "output": "#!/bin/bash\n\nREPORT_FILE=\"/var/log/suid_sgid_report.txt\"\necho \"Generating SUID/SGID Report at $(date)\" > \"$REPORT_FILE\"\n\n# Find SUID files\necho \"--- SUID Files ---\" >> \"$REPORT_FILE\"\nfind / -perm /4000 -type f -exec ls -ld {} \\; 2>/dev/null >> \"$REPORT_FILE\"\n\n# Find SGID files\necho \"\" >> \"$REPORT_FILE\"\necho \"--- SGID Files ---\" >> \"$REPORT_FILE\"\nfind / -perm /2000 -type f -exec ls -ld {} \\; 2>/dev/null >> \"$REPORT_FILE\"\n\necho \"Scan complete. Review $REPORT_FILE for unknown binaries with elevated privileges.\""}
{"instruction": "Write a Python script for SIEM-style log analysis that parses '/var/log/auth.log' (or generic Linux auth logs) to detect potential brute-force SSH attacks by counting 'Failed password' attempts per IP address.", "output": "import re\nfrom collections import defaultdict\n\ndef detect_bruteforce(log_path, threshold=5):\n    # Regex to capture IP from sshd failed password lines\n    # Example: \"Failed password for user root from 192.168.1.5 port...\"\n    regex = r\"Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n    ip_counts = defaultdict(int)\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"sshd\" in line and \"Failed password\" in line:\n                    match = re.search(regex, line)\n                    if match:\n                        ip_counts[match.group(1)] += 1\n\n        print(f\"--- Potential Brute Force Attackers (> {threshold} failures) ---\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"[ALERT] IP: {ip} | Failed Attempts: {count}\")\n                \n    except PermissionError:\n        print(\"Error: Permission denied reading log file. Run as root.\")\n    except FileNotFoundError:\n        print(\"Error: Log file not found.\")\n\nif __name__ == \"__main__\":\n    detect_bruteforce('/var/log/auth.log')"}
{"instruction": "Write a Bash script for system hardening that sets secure file permissions (600) on critical configuration files (/etc/shadow, /etc/gshadow) and disables USB storage support to prevent data exfiltration.", "output": "#!/bin/bash\n\n# 1. Secure Critical Files\necho \"Securing file permissions...\"\nchmod 600 /etc/shadow\nchmod 600 /etc/gshadow\nchmod 644 /etc/passwd\nchmod 644 /etc/group\n\n# 2. Disable USB Storage\nCONFIG_FILE=\"/etc/modprobe.d/disable-usb-storage.conf\"\n\nif [ ! -f \"$CONFIG_FILE\" ]; then\n    echo \"Disabling USB storage kernel module...\"\n    echo \"install usb-storage /bin/true\" > \"$CONFIG_FILE\"\n    echo \"blacklist usb-storage\" >> \"$CONFIG_FILE\"\n    echo \"USB storage disabled.\"\nelse\n    echo \"USB storage configuration already exists.\"\nfi\n\necho \"Hardening tasks completed.\""}
{"instruction": "Create a Python script to parse an Apache access log and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential directory enumeration.", "output": "import re\nfrom collections import defaultdict\n\nlog_file = '/var/log/apache2/access.log'\nthreshold = 10\nip_counts = defaultdict(int)\n\n# Regex to extract IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s(\\d{3})\\s')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip = match.group(1)\n                status = match.group(2)\n                if status == '404':\n                    ip_counts[ip] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_counts.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script to configure a basic `iptables` firewall that allows established connections, allows incoming SSH (port 22) and HTTP/HTTPS (80/443), and drops all other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional)\niptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules updated.\""}
{"instruction": "Develop a Python script using the `socket` library to perform a basic TCP connect scan on a target IP address for a defined list of critical ports (e.g., 21, 22, 23, 80, 443, 3389) to identify potential exposure.", "output": "import socket\n\ntarget_ip = \"192.168.1.10\"  # Replace with target IP\nports_to_scan = [21, 22, 23, 80, 443, 3389]\n\nprint(f\"Scanning {target_ip}...\")\n\nfor port in ports_to_scan:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    \n    if result == 0:\n        print(f\"Port {port}: OPEN\")\n    else:\n        print(f\"Port {port}: Closed/Filtered\")\n    \n    sock.close()"}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and enforcing key-based authentication in `/etc/ssh/sshd_config`.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Validate config and restart SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration check failed. Reverting...\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python utility to connect to a remote server on port 443, retrieve the SSL certificate, and check if it expires within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = 'www.example.com'\nport = 443\n\ncontext = ssl.create_default_context()\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            # Date format: May 30 12:00:00 2024 GMT\n            not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n            days_left = (not_after - datetime.datetime.utcnow()).days\n            \n            print(f\"Certificate for {hostname} expires in {days_left} days.\")\n            if days_left < 30:\n                print(\"WARNING: Certificate expiring soon!\")\nexcept Exception as e:\n    print(f\"Error checking SSL: {e}\")"}
{"instruction": "Write a Bash one-liner or script using `grep`, `awk`, and `sort` to extract the top 5 source IP addresses from a standard Linux `auth.log` that have failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\necho \"Top 5 IPs with failed SSH attempts:\"\n\n# Search for 'Failed password', extract IP (field 11 usually, depends on format), count, sort, head\ngrep \"Failed password\" $LOG_FILE | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -5"}
{"instruction": "Create a Python script that accepts a list of IP addresses and generates an `nftables` configuration snippet to block these IPs in the input chain.", "output": "blocked_ips = ['192.168.1.100', '10.0.0.55', '172.16.0.23']\n\nprint(\"#!/usr/sbin/nft -f\")\nprint(\"table ip filter {\")\nprint(\"    chain input {\")\nprint(\"        type filter hook input priority 0; policy accept;\")\n\n# Generate rules\nfor ip in blocked_ips:\n    print(f\"        ip saddr {ip} drop\")\n\nprint(\"    }\")\nprint(\"}\")"}
{"instruction": "Write a Bash script to audit and fix permissions on critical system files (`/etc/passwd`, `/etc/shadow`, `/etc/group`), ensuring only root can write to them and `/etc/shadow` is not world-readable.", "output": "#!/bin/bash\n\n# 644: rw-r--r-- (Owner read/write, Group read, Others read)\n# 600: rw------- (Owner read/write, No one else)\n# 000: root:root ownership\n\necho \"Auditing critical file permissions...\"\n\n# /etc/passwd should be readable by all, writable only by root\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\n\n# /etc/group should be readable by all, writable only by root\nchown root:root /etc/group\nchmod 644 /etc/group\n\n# /etc/shadow must NOT be readable by others\nchown root:root /etc/shadow\nchmod 600 /etc/shadow\n\necho \"Permissions enforced.\""}
{"instruction": "Implement a simple File Integrity Monitor (FIM) in Python that calculates MD5 hashes of files in a specified directory and saves them to a baseline file for later comparison.", "output": "import os\nimport hashlib\nimport json\n\ntarget_dir = \"/etc/nginx\"\nbaseline_file = \"fim_baseline.json\"\n\ndef calculate_md5(file_path):\n    hash_md5 = hashlib.md5()\n    try:\n        with open(file_path, \"rb\") as f:\n            for chunk in iter(lambda: f.read(4096), b\"\"):\n                hash_md5.update(chunk)\n        return hash_md5.hexdigest()\n    except (IOError, OSError):\n        return None\n\nbaseline = {}\n\nfor root, dirs, files in os.walk(target_dir):\n    for filename in files:\n        filepath = os.path.join(root, filename)\n        file_hash = calculate_md5(filepath)\n        if file_hash:\n            baseline[filepath] = file_hash\n\nwith open(baseline_file, 'w') as f:\n    json.dump(baseline, f, indent=4)\n\nprint(f\"Baseline created for {target_dir} with {len(baseline)} files.\")"}
{"instruction": "Write a Bash script to scan `/etc/passwd` and identify any user accounts with a UID of 0 other than the 'root' user, which could indicate a backdoor.", "output": "#!/bin/bash\n\necho \"Scanning for non-root users with UID 0...\"\n\n# Format of /etc/passwd: user:x:uid:gid:comment:home:shell\n# We look for lines where UID ($3) is 0, but User ($1) is not 'root'\n\nawk -F: '($3 == 0 && $1 != \"root\") {print \"WARNING: Suspicious UID 0 account found: \" $1}' /etc/passwd\n\nif [ $(awk -F: '($3 == 0 && $1 != \"root\")' /etc/passwd | wc -l) -eq 0 ]; then\n    echo \"No suspicious UID 0 accounts found.\"\nfi"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, potentially indicating a scanning attempt.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 10\nip_404_count = defaultdict(int)\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_404_count[ip_address] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script for Server Hardening that secures the SSH configuration by disabling root login and enforcing protocol 2.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Enforce Protocol 2\nif grep -q \"^Protocol\" $SSHD_CONFIG; then\n    sed -i 's/^Protocol.*/Protocol 2/' $SSHD_CONFIG\nelse\n    echo \"Protocol 2\" >> $SSHD_CONFIG\nfi\n\necho \"SSH Hardening applied. Restart sshd to take effect.\""}
{"instruction": "Create a Python script for Vulnerability Scanning that checks a list of local servers to see if they have SSL certificates expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\nhostnames = ['example.com', 'myserver.local', 'intranet.local']\nport = 443\n\ndef get_ssl_expiry_date(host, port):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=host)\n    conn.settimeout(3.0)\n    try:\n        conn.connect((host, port))\n        ssl_info = conn.getpeercert()\n        return datetime.datetime.strptime(ssl_info['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n    except Exception as e:\n        return None\n\nprint(\"Checking SSL Expiry...\")\nfor host in hostnames:\n    expiry = get_ssl_expiry_date(host, port)\n    if expiry:\n        days_left = (expiry - datetime.datetime.utcnow()).days\n        if days_left < 30:\n            print(f\"ALERT: {host} expires in {days_left} days.\")\n        else:\n            print(f\"OK: {host} expires in {days_left} days.\")\n    else:\n        print(f\"ERROR: Could not connect to {host}\")"}
{"instruction": "Write a Bash script to generate Firewall Rules using `iptables`. The script should flush existing rules, set default policies to DROP, allow loopback, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow localhost\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu style)\n# netfilter-persistent save\necho \"Basic firewall rules applied.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (Hardening/SIEM) that calculates SHA-256 hashes of critical system files and alerts if they change compared to a baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (In production, load this from a secure database)\nbaseline = {\n    '/etc/passwd': 'original_hash_here',\n    '/etc/shadow': 'original_hash_here'\n}\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nprint(\"Starting Integrity Check...\")\nfor file_path, known_hash in baseline.items():\n    current_hash = calculate_hash(file_path)\n    if current_hash is None:\n        print(f\"ALERT: {file_path} is MISSING.\")\n    elif current_hash != known_hash:\n        print(f\"ALERT: {file_path} has been MODIFIED.\")\n        print(f\"Expected: {known_hash}\\nFound:    {current_hash}\")\n    else:\n        print(f\"OK: {file_path}\")"}
{"instruction": "Write a Bash script for Log Analysis that parses `/var/log/auth.log` (or `/var/log/secure`) to count the number of failed login attempts by username.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    LOG_FILE=\"/var/log/secure\"\nfi\n\necho \"Failed SSH login attempts by user:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{\n    # Handle format variations where user is sometimes at different fields\n    for(i=1;i<=NF;i++) {\n        if($i==\"for\") print $(i+1);\n    }\n}' | sort | uniq -c | sort -nr"}
{"instruction": "Create a Python script to generate an `nftables` configuration block. It should read a list of banned IP addresses from a text file and output a valid nftables set definition.", "output": "def generate_nftables_set(filename, set_name=\"blackhole\"):\n    try:\n        with open(filename, 'r') as f:\n            # Filter empty lines and strip whitespace\n            ips = [line.strip() for line in f if line.strip()]\n    except FileNotFoundError:\n        return \"# Error: File not found\"\n\n    if not ips:\n        return \"# No IPs to ban\"\n\n    nft_config = []\n    nft_config.append(f\"table inet filter {{\")\n    nft_config.append(f\"    set {set_name} {{\")\n    nft_config.append(\"        type ipv4_addr\")\n    nft_config.append(\"        elements = { \" + \", \".join(ips) + \" }\")\n    nft_config.append(\"    }\")\n    nft_config.append(f\"    chain input {{\")\n    nft_config.append(f\"        ip saddr @{set_name} drop\")\n    nft_config.append(\"    }\")\n    nft_config.append(\"}\")\n    \n    return \"\\n\".join(nft_config)\n\n# Usage example (assuming banned_ips.txt exists)\n# print(generate_nftables_set('banned_ips.txt'))"}
{"instruction": "Write a Bash script for Vulnerability Scanning/Auditing that searches the entire filesystem for files with the SUID bit set, which can be dangerous if misconfigured.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\n\n# find syntax: \n# -perm /4000 checks for SUID bit\n# -type f checks for files only\n# 2>/dev/null suppresses permission denied errors\n\nfind / -perm /4000 -type f -exec ls -ld {} \\; 2>/dev/null > suid_audit.txt\n\necho \"Scan complete. Results saved to suid_audit.txt.\"\necho \"Total SUID files found: $(wc -l < suid_audit.txt)\""}
{"instruction": "Create a Python script for basic Security Auditing that checks if specific dangerous ports (like Telnet 23 or FTP 21) are open on the local machine using the `socket` library.", "output": "import socket\n\nrisky_ports = {\n    21: 'FTP',\n    23: 'Telnet',\n    3389: 'RDP',\n    5900: 'VNC'\n}\n\ndef check_port(port, name):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex(('127.0.0.1', port))\n    sock.close()\n    return result == 0\n\nprint(\"Auditing Local Ports...\")\nissues_found = False\nfor port, name in risky_ports.items():\n    if check_port(port, name):\n        print(f\"[WARNING] Port {port} ({name}) is OPEN on localhost.\")\n        issues_found = True\n\nif not issues_found:\n    print(\"No high-risk ports found open locally.\")"}
{"instruction": "Write a Bash script to implement Rate Limiting using `iptables` to mitigate brute-force attacks on SSH (Port 22). It should drop connections from an IP if they attempt more than 3 connections in 60 seconds.", "output": "#!/bin/bash\n\n# Create a new chain for SSH checking\niptables -N SSH_CHECK\n\n# Send SSH traffic to the checking chain\niptables -A INPUT -p tcp --dport 22 -m state --state NEW -j SSH_CHECK\n\n# If IP is in the recent list and count > 3 within 60s, DROP\niptables -A SSH_CHECK -m recent --set --name SSH_BRUTE\niptables -A SSH_CHECK -m recent --update --seconds 60 --hitcount 4 --name SSH_BRUTE -j DROP\n\n# Otherwise accept\niptables -A SSH_CHECK -j ACCEPT\n\necho \"SSH Rate Limiting rules applied.\""}
{"instruction": "Create a Python script to scan a list of local ports to identify listening services (basic vulnerability surface assessment).", "output": "import socket\n\ndef scan_ports(target_ip, ports):\n    open_ports = []\n    print(f\"Scanning {target_ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"\n    # Common ports to check\n    port_list = [21, 22, 80, 443, 3306, 8080]\n    open_p = scan_ports(target, port_list)\n    print(f\"Open ports on {target}: {open_p}\")"}
{"instruction": "Write a Bash script using 'iptables' to block a specific IP address that has been identified as malicious.", "output": "#!/bin/bash\n\nIP_TO_BLOCK=\"192.168.1.100\"\n\n# Check if running as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"This script must be run as root\"\n    exit 1\nfi\n\n# Drop incoming packets from the IP\niptables -A INPUT -s \"$IP_TO_BLOCK\" -j DROP\n\n# Drop outgoing packets to the IP (optional, prevents C2 communication)\niptables -A OUTPUT -d \"$IP_TO_BLOCK\" -j DROP\n\necho \"Blocked traffic to/from $IP_TO_BLOCK\""}
{"instruction": "Create a Python script to parse an Apache access log and identify IP addresses that have generated more than 10 '404 Not Found' errors (indicating potential scanning).", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_logs(log_file):\n    ip_404_count = defaultdict(int)\n    log_pattern = re.compile(r'(\\d+\\.\\d+\\.\\d+\\.\\d+) .*? \"GET .*? HTTP/.*\" 404')\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    ip_404_count[ip] += 1\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n        return\n\n    print(\"Suspicious IPs (>10 404s):\")\n    for ip, count in ip_404_count.items():\n        if count > 10:\n            print(f\"{ip}: {count} errors\")\n\nif __name__ == \"__main__\":\n    analyze_logs(\"/var/log/apache2/access.log\")"}
{"instruction": "Write a Bash script to harden an SSH server configuration by disabling root login and password authentication.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\nif [ \"$(id -u)\" -ne 0 ]; then echo \"Run as root\"; exit 1; fi\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP_CONFIG\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication (Enforce Keys)\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Check syntax and restart\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Reverting...\"\n    cp \"$BACKUP_CONFIG\" \"$SSHD_CONFIG\"\nfi"}
{"instruction": "Develop a Python script to check a website's HTTP headers for missing security headers (e.g., X-Frame-Options, HSTS).", "output": "import requests\n\ndef check_headers(url):\n    security_headers = [\n        \"X-Frame-Options\",\n        \"Strict-Transport-Security\",\n        \"X-Content-Type-Options\",\n        \"Content-Security-Policy\"\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        print(f\"Analyzing headers for: {url}\")\n        \n        missing = []\n        for sec_header in security_headers:\n            if sec_header not in headers:\n                missing.append(sec_header)\n            else:\n                print(f\"[OK] {sec_header} present.\")\n        \n        if missing:\n            print(f\"\\n[ALERT] Missing Headers: {', '.join(missing)}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    check_headers(\"https://example.com\")"}
{"instruction": "Write a Bash script using 'nftables' to configure a basic stateful firewall (allow established connections, drop incoming by default).", "output": "#!/bin/bash\n\n# Flush current ruleset\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create input chain: drop default\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Create forward chain: drop default\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\n\n# Create output chain: accept default\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow SSH (adjust port if needed)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables firewall configured.\""}
{"instruction": "Create a Python script acting as a simple File Integrity Monitor (FIM) that calculates and stores SHA-256 hashes of critical system files.", "output": "import hashlib\nimport os\nimport json\n\nCRITICAL_FILES = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/ssh/sshd_config\"]\nDB_FILE = \"fim_baseline.json\"\n\ndef calculate_hash(filepath):\n    sha256 = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            while chunk := f.read(4096):\n                sha256.update(chunk)\n        return sha256.hexdigest()\n    except FileNotFoundError:\n        return None\n    except PermissionError:\n        return \"PERMISSION_DENIED\"\n\ndef run_fim():\n    baseline = {}\n    if os.path.exists(DB_FILE):\n        with open(DB_FILE, 'r') as f:\n            baseline = json.load(f)\n\n    new_state = {}\n    alerts = []\n\n    for filepath in CRITICAL_FILES:\n        current_hash = calculate_hash(filepath)\n        new_state[filepath] = current_hash\n\n        if filepath in baseline:\n            if baseline[filepath] != current_hash:\n                alerts.append(f\"ALERT: File modified -> {filepath}\")\n        elif baseline:\n             alerts.append(f\"ALERT: New file monitored -> {filepath}\")\n\n    # Save new state\n    with open(DB_FILE, 'w') as f:\n        json.dump(new_state, f)\n\n    if alerts:\n        print(\"\\n\".join(alerts))\n    else:\n        print(\"Integrity check complete. No changes detected.\")\n\nif __name__ == \"__main__\":\n    run_fim()"}
{"instruction": "Write a Bash script to extract and count unique IP addresses that failed SSH login attempts from '/var/log/auth.log'.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH attempts:\"\n\n# Grep for 'Failed password', extract IP (assumes standard format), sort, uniq count, sort numeric reverse\ngrep \"Failed password\" \"$LOG_FILE\" | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Create a Python script that checks the permissions of sensitive files (like /etc/shadow or private keys) to ensure they are not world-readable.", "output": "import os\nimport stat\n\ndef check_permissions(file_list):\n    print(f\"Checking permissions for {len(file_list)} files...\")\n    for filepath in file_list:\n        if not os.path.exists(filepath):\n            print(f\"[MISSING] {filepath}\")\n            continue\n\n        # Get file stats\n        st = os.stat(filepath)\n        mode = st.st_mode\n\n        # Check if world readable (Other Read bit is set)\n        if bool(mode & stat.S_IROTH):\n            print(f\"[VULN] {filepath} is world-readable! ({oct(mode)[-3:]})\")\n        # Check if world writable\n        elif bool(mode & stat.S_IWOTH):\n            print(f\"[VULN] {filepath} is world-writable! ({oct(mode)[-3:]})\")\n        else:\n            print(f\"[SECURE] {filepath} ({oct(mode)[-3:]})\")\n\nif __name__ == \"__main__\":\n    files_to_check = [\n        \"/etc/shadow\",\n        \"/etc/passwd\",\n        \"/etc/ssh/ssh_host_rsa_key\"\n    ]\n    check_permissions(files_to_check)"}
{"instruction": "Write a Bash script to audit user accounts by checking for empty passwords and ensuring password aging policies are set.", "output": "#!/bin/bash\n\n# Check for accounts with empty password fields in shadow file\necho \"--- Checking for empty passwords ---\"\nawk -F: '($2 == \"\") {print $1}' /etc/shadow\n\n# Check password aging for normal users (UID >= 1000)\necho \"\\n--- Checking Password Aging Policies ---\"\ngetent passwd | awk -F: '$3 >= 1000 {print $1}' | while read user; do\n    # Get max days for password validity\n    MAX_DAYS=$(chage -l \"$user\" | grep \"Maximum number of days\" | awk -F: '{print $2}' | xargs)\n    \n    if [ \"$MAX_DAYS\" == \"99999\" ]; then\n        echo \"[WARNING] User '$user' has no password expiration set.\"\n    else\n        echo \"[OK] User '$user' expires in $MAX_DAYS days.\"\n    fi\ndone"}
{"instruction": "Write a Python script for Log Analysis that parses a web server access log (e.g., Apache/Nginx) to detect potential scanning activity by identifying IP addresses that have generated an excessive number of HTTP 404 errors.", "output": "import re\nfrom collections import Counter\n\ndef analyze_404_spikes(logfile, threshold=50):\n    ip_counter = Counter()\n    # Regex to capture IP at start of line and status code 404\n    log_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\" 404 ')\n    \n    try:\n        with open(logfile, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(f\"--- IPs with > {threshold} 404 Errors ---\")\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f\"IP: {ip} | Count: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    analyze_404_spikes(\"/var/log/apache2/access.log\")"}
{"instruction": "Create a Bash script for Server Hardening that modifies the SSH configuration to disable root login and enforce key-based authentication (disable password auth).", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Validate config and restart service\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration check failed. Restoring backup.\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python script to perform a local vulnerability audit by checking installed Python packages against their latest versions using pip.", "output": "import subprocess\nimport json\nimport sys\n\ndef audit_packages():\n    print(\"Auditing installed Python packages for outdated versions...\")\n    try:\n        # Run pip list --outdated in JSON format\n        result = subprocess.check_output(\n            [sys.executable, '-m', 'pip', 'list', '--outdated', '--format=json'],\n            stderr=subprocess.DEVNULL\n        )\n        outdated_pkgs = json.loads(result)\n        \n        if not outdated_pkgs:\n            print(\"All packages are up to date.\")\n            return\n\n        print(f\"Found {len(outdated_pkgs)} outdated packages:\")\n        print(f\"{'Package':<20} {'Current':<10} {'Latest':<10}\")\n        print(\"-\" * 40)\n        for pkg in outdated_pkgs:\n            print(f\"{pkg['name']:<20} {pkg['version']:<10} {pkg['latest_version']:<10}\")\n            \n    except subprocess.CalledProcessError:\n        print(\"Error running pip list.\")\n\nif __name__ == \"__main__\":\n    audit_packages()"}
{"instruction": "Develop a Bash script to generate a basic iptables firewall configuration that drops all incoming traffic by default, but allows Loopback, Established connections, SSH (port 22), and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional, limited)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules configured.\""}
{"instruction": "Write a Python script for SIEM-like analysis that parses the Linux authentication log (/var/log/auth.log) to detect potential brute-force attacks by counting failed password attempts per IP address.", "output": "import re\n\ndef detect_ssh_bruteforce(log_path='/var/log/auth.log', limit=5):\n    failed_attempts = {}\n    # Regex to find IP in 'Failed password' lines\n    ip_pattern = re.compile(r'Failed password .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if 'Failed password' in line:\n                    match = ip_pattern.search(line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] = failed_attempts.get(ip, 0) + 1\n        \n        print(\"Potential Brute Force Sources (Failed Attempts > limit):\")\n        for ip, count in failed_attempts.items():\n            if count >= limit:\n                print(f\"Source IP: {ip} | Failures: {count}\")\n                \n    except PermissionError:\n        print(\"Permission denied: Run with sudo to read auth.log\")\n    except FileNotFoundError:\n        print(f\"Log file {log_path} not found.\")\n\nif __name__ == \"__main__\":\n    detect_ssh_bruteforce()"}
{"instruction": "Create a Bash script to harden network kernel parameters via sysctl, specifically disabling IP forwarding, ignoring ICMP redirects, and enabling protection against IP spoofing.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\necho \"Applying Network Kernel Hardening...\"\n\n# Append settings to sysctl.conf\ncat <<EOF >> $SYSCTL_CONF\n\n# --- Security Hardening ---\n# IP Spoofing protection\nnet.ipv4.conf.all.rp_filter = 1\nnet.ipv4.conf.default.rp_filter = 1\n\n# Ignore ICMP broadcast requests\nnet.ipv4.icmp_echo_ignore_broadcasts = 1\n\n# Disable source packet routing\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv6.conf.all.accept_source_route = 0\n\n# Ignore ICMP redirects\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\n\n# Disable IP forwarding (act as host, not router)\nnet.ipv4.ip_forward = 0\nEOF\n\n# Apply changes immediately\nsysctl -p\necho \"Kernel parameters updated.\""}
{"instruction": "Write a Python script to monitor the expiration date of SSL certificates for a list of critical domains, alerting if a certificate expires within 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domains):\n    context = ssl.create_default_context()\n    \n    for domain in domains:\n        try:\n            with socket.create_connection((domain, 443), timeout=3) as sock:\n                with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                    cert = ssock.getpeercert()\n                    not_after = cert['notAfter']\n                    # Parse date format: May 30 12:00:00 2025 GMT\n                    expiry_date = datetime.datetime.strptime(not_after, r'%b %d %H:%M:%S %Y %Z')\n                    remaining = (expiry_date - datetime.datetime.utcnow()).days\n                    \n                    status = \"OK\"\n                    if remaining < 30:\n                        status = \"WARNING: Expiring soon\"\n                    \n                    print(f\"Domain: {domain:<20} | Days Left: {remaining:<5} | Status: {status}\")\n        except Exception as e:\n            print(f\"Domain: {domain:<20} | Error: {e}\")\n\nif __name__ == \"__main__\":\n    domains_to_check = [\"www.google.com\", \"www.github.com\", \"expired.badssl.com\"]\n    check_ssl_expiry(domains_to_check)"}
{"instruction": "Develop a Bash script using nftables to configure a stateful firewall that drops invalid packets, allows established traffic, and permits specific services.", "output": "#!/bin/bash\n\n# Flush current ruleset\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create base chains with default policies\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback interface\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Drop invalid packets\nnft add rule inet filter input ct state invalid drop\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"Nftables configuration applied.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (FIM) that calculates and prints the SHA-256 hash of critical system files to detect unauthorized modifications.", "output": "import hashlib\nimport os\n\ndef calculate_sha256(filepath):\n    sha256 = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            # Read in chunks to handle large files\n            while chunk := f.read(8192):\n                sha256.update(chunk)\n        return sha256.hexdigest()\n    except FileNotFoundError:\n        return \"FILE_NOT_FOUND\"\n    except PermissionError:\n        return \"PERMISSION_DENIED\"\n\ndef monitor_integrity():\n    critical_files = [\n        \"/etc/passwd\",\n        \"/etc/shadow\",\n        \"/etc/ssh/sshd_config\",\n        \"/bin/ls\"\n    ]\n    \n    print(f\"{'File':<30} {'SHA-256 Hash'}\")\n    print(\"-\" * 95)\n    \n    for filepath in critical_files:\n        file_hash = calculate_sha256(filepath)\n        print(f\"{filepath:<30} {file_hash}\")\n\nif __name__ == \"__main__\":\n    monitor_integrity()"}
{"instruction": "Create a Bash script to audit the system for security risks, specifically finding users with empty passwords and identifying world-writable files.", "output": "#!/bin/bash\n\necho \"--- Starting System Security Audit ---\"\n\n# 1. Check for accounts with empty passwords in /etc/shadow\n# Field 2 is the password hash. If empty, no password is set.\necho \"[+] Checking for accounts with empty passwords...\"\nif [ -f /etc/shadow ]; then\n    awk -F: '($2 == \"\") {print \"WARNING: User \" $1 \" has no password set!\"}' /etc/shadow\nelse\n    echo \"Cannot read /etc/shadow (permission denied or not found).\"\nfi\n\n# 2. Check for World-Writable Files\n# Exclude /proc, /sys, and standard temp directories to reduce noise\necho \"[+] Checking for world-writable files (excluding /proc, /sys)...\"\nfind / -xdev -type f -perm -0002 -print 2>/dev/null | grep -v \"^/proc\" | grep -v \"^/sys\" | head -n 20\necho \"(List truncated to first 20 results)\"\n\necho \"--- Audit Complete ---\""}
{"instruction": "Create a Python script for File Integrity Monitoring (FIM). The script should calculate the SHA-256 hash of a specific critical system file (e.g., /etc/passwd) to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read the file in chunks to handle large files efficiently\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nfile_path = '/etc/passwd'\ncurrent_hash = calculate_file_hash(file_path)\n\nif current_hash:\n    print(f\"SHA-256 Hash of {file_path}: {current_hash}\")\nelse:\n    print(f\"File {file_path} not found.\")"}
{"instruction": "Write a Bash script to harden a Linux server by locking user accounts that have empty passwords.", "output": "#!/bin/bash\n\n# Identify accounts with empty password fields in /etc/shadow\nusers_with_empty_pw=$(awk -F: '($2 == \"\") {print $1}' /etc/shadow)\n\nif [ -z \"$users_with_empty_pw\" ]; then\n    echo \"No accounts with empty passwords found.\"\nelse\n    for user in $users_with_empty_pw; do\n        echo \"Locking account with empty password: $user\"\n        passwd -l \"$user\"\n    done\nfi"}
{"instruction": "Develop a Python script to analyze an Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nip_counter = Counter()\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counter[ip_address] += 1\n\n    print(\"IPs with > 10 404 errors:\")\n    for ip, count in ip_counter.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Create a Bash script using `iptables` to implement a basic firewall policy: drop all incoming traffic by default, but allow loopback, established connections, and incoming SSH (port 22).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Basic iptables firewall rules applied.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote domain to prevent service outages due to expired certificates.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=3) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse the date format: May 30 12:00:00 2025 GMT\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                print(f\"Certificate for {hostname} expires in {days_remaining} days (on {expire_date}).\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\ncheck_ssl_expiry('example.com')"}
{"instruction": "Create a Bash script to audit world-writable files on the system, which could be a security risk.", "output": "#!/bin/bash\n\necho \"Searching for world-writable files...\"\n\n# Find files with write permission for 'others' excluding proc, sys, and dev pseudo-filesystems\nfind / -xdev -type f -perm -0002 -print 2>/dev/null > world_writable_report.txt\n\ncount=$(wc -l < world_writable_report.txt)\necho \"Scan complete. Found $count world-writable files. See world_writable_report.txt for details.\""}
{"instruction": "Write a Python script that performs a basic port scan on a specific target IP (e.g., localhost) to identify open ports 22, 80, and 443 for auditing purposes.", "output": "import socket\n\ntarget_ip = '127.0.0.1'\nports_to_scan = [22, 80, 443]\n\nprint(f\"Scanning {target_ip}...\")\n\nfor port in ports_to_scan:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f\"Port {port}: Open\")\n    else:\n        print(f\"Port {port}: Closed\")\n    sock.close()"}
{"instruction": "Create a Bash script using `nftables` to block a specific malicious IP address and log the dropped packets.", "output": "#!/bin/bash\n\nMALICIOUS_IP=\"192.0.2.100\"\n\n# Create a table and chain if they don't exist (assuming 'inet filter' setup)\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add rule to log and drop traffic from the malicious IP\nnft add rule inet filter input ip saddr $MALICIOUS_IP log prefix \"Blocked Malicious IP: \" drop\n\necho \"nftables rule added to block and log $MALICIOUS_IP\""}
{"instruction": "Develop a Python script to check HTTP security headers (like X-Frame-Options and Strict-Transport-Security) of a given URL to ensure web server hardening.", "output": "import requests\n\ndef check_security_headers(url):\n    required_headers = [\n        'Strict-Transport-Security',\n        'X-Content-Type-Options',\n        'X-Frame-Options',\n        'Content-Security-Policy'\n    ]\n    \n    try:\n        response = requests.get(url)\n        headers = response.headers\n        print(f\"Security Headers for {url}:\")\n        for header in required_headers:\n            if header in headers:\n                print(f\"[PASS] {header}: {headers[header]}\")\n            else:\n                print(f\"[FAIL] {header} is missing\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Request failed: {e}\")\n\ncheck_security_headers('https://google.com')"}
{"instruction": "Write a Bash script to parse the system authentication log (auth.log) and extract the top 5 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file and identifies the top 5 IP addresses making requests, useful for identifying potential DoS sources or scanners.", "output": "import re\nfrom collections import Counter\n\ndef analyze_apache_log(log_file_path):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Top 5 Source IPs:\")\n        for ip, count in ip_counter.most_common(5):\n            print(f\"{ip}: {count} requests\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# analyze_apache_log('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script for Server Hardening that automatically disables root login and password authentication in the SSH configuration file to enforce key-based authentication.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Password Authentication\nif grep -q \"^PasswordAuthentication\" $SSHD_CONFIG; then\n    sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nelse\n    echo \"PasswordAuthentication no\" >> $SSHD_CONFIG\nfi\n\n# Check syntax and restart service\nsshd -t && systemctl restart sshd\necho \"SSH Hardening applied using key-based auth and no root login.\""}
{"instruction": "Write a Python script for Vulnerability Management that parses an Nmap XML output file to identify hosts with high-risk ports (e.g., Telnet port 23 or SMB port 445) open.", "output": "import xml.etree.ElementTree as ET\n\ndef check_high_risk_ports(nmap_xml_file):\n    risky_ports = {'21': 'FTP', '23': 'Telnet', '445': 'SMB', '3389': 'RDP'}\n    try:\n        tree = ET.parse(nmap_xml_file)\n        root = tree.getroot()\n        \n        for host in root.findall('host'):\n            address = host.find('address').get('addr')\n            ports = host.find('ports')\n            if ports:\n                for port in ports.findall('port'):\n                    portid = port.get('portid')\n                    state = port.find('state').get('state')\n                    if state == 'open' and portid in risky_ports:\n                        print(f\"[ALERT] Host {address} has risky port open: {portid} ({risky_ports[portid]})\")\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example usage\n# check_high_risk_ports('scan_results.xml')"}
{"instruction": "Create a Bash script to generate Firewall Rules using 'iptables' that blocks traffic from a list of IP addresses provided in a text file (blocklist.txt).", "output": "#!/bin/bash\n\nBLOCKLIST=\"blocklist.txt\"\n\nif [ ! -f \"$BLOCKLIST\" ]; then\n    echo \"Blocklist file not found!\"\n    exit 1\nfi\n\necho \"Applying blocklist rules...\"\n\nwhile IFS= read -r ip\ndo\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    # Check if rule exists to avoid duplicates\n    iptables -C INPUT -s \"$ip\" -j DROP 2>/dev/null\n    if [ $? -eq 1 ]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked: $ip\"\n    fi\ndone < \"$BLOCKLIST\"\n\necho \"Done.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (FIM) that calculates SHA-256 hashes of critical system files to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/hosts']\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except PermissionError:\n        return \"ACCESS_DENIED\"\n    except FileNotFoundError:\n        return \"NOT_FOUND\"\n\ndef run_integrity_check():\n    print(f\"{'File':<20} | {'SHA-256 Hash'}\")\n    print(\"-\" * 85)\n    for file in critical_files:\n        file_hash = calculate_hash(file)\n        print(f\"{file:<20} | {file_hash}\")\n\nif __name__ == \"__main__\":\n    run_integrity_check()"}
{"instruction": "Create a Bash script using 'nftables' to set up a basic stateful firewall that allows established connections, allows SSH/HTTP, and drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table ip filter\n\n# Create input chain\nnft add chain ip filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule ip filter input iif lo accept\n\n# Allow established and related connections\nnft add rule ip filter input ct state established,related accept\n\n# Allow SSH (22) and HTTP (80) and HTTPS (443)\nnft add rule ip filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule ip filter input ip protocol icmp accept\n\necho \"Basic stateful nftables policy applied.\""}
{"instruction": "Write a Python script for Security Auditing that checks if specific users have UID 0 (root privileges) in the /etc/passwd file, which indicates a potential backdoor or misconfiguration.", "output": "def check_uid_zero(passwd_path='/etc/passwd'):\n    unauthorized_admins = []\n    try:\n        with open(passwd_path, 'r') as f:\n            for line in f:\n                parts = line.strip().split(':')\n                if len(parts) > 2:\n                    username = parts[0]\n                    uid = parts[2]\n                    # UID 0 is root. root user is expected, others are suspicious.\n                    if uid == '0' and username != 'root':\n                        unauthorized_admins.append(username)\n        \n        if unauthorized_admins:\n            print(f\"[WARNING] Non-root users with UID 0 detected: {', '.join(unauthorized_admins)}\")\n        else:\n            print(\"[OK] Only 'root' has UID 0.\")\n            \n    except Exception as e:\n        print(f\"Error reading passwd file: {e}\")\n\nif __name__ == \"__main__\":\n    check_uid_zero()"}
{"instruction": "Create a Bash script for Log Analysis to extract and count failed SSH login attempts from /var/log/auth.log to identify brute-force attacks.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found.\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | \\\nawk '{for(i=1;i<=NF;i++) if($i~/^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$/) print $i}' | \\\nsort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Python script that queries the NIST NVD (National Vulnerability Database) API (mocked structure) to search for recent CVEs related to a specific keyword (e.g., 'nginx').", "output": "import requests\nimport json\n\ndef search_cves(keyword):\n    # Note: Real implementation requires an API Key for NVD 2.0\n    url = \"https://services.nvd.nist.gov/rest/json/cves/2.0\"\n    params = {\n        'keywordSearch': keyword,\n        'resultsPerPage': 5\n    }\n    \n    try:\n        print(f\"Searching for CVEs related to: {keyword}...\")\n        response = requests.get(url, params=params, timeout=10)\n        \n        if response.status_code == 200:\n            data = response.json()\n            vulnerabilities = data.get('vulnerabilities', [])\n            \n            for item in vulnerabilities:\n                cve = item.get('cve', {})\n                cve_id = cve.get('id')\n                descriptions = cve.get('descriptions', [])\n                desc_text = descriptions[0].get('value') if descriptions else \"No description\"\n                print(f\"[{cve_id}] {desc_text[:100]}...\")\n        else:\n            print(f\"API Request failed: {response.status_code}\")\n            \n    except Exception as e:\n        print(f\"Error connecting to NVD: {e}\")\n\n# Example usage\n# search_cves('nginx')"}
{"instruction": "Create a Bash script for Server Hardening that finds and lists all files with SUID permissions owned by root, as these can be potential privilege escalation vectors.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries owned by root...\"\necho \"These files execute with file owner permissions (root) rather than the user running them.\"\n\n# Find files with SUID bit set (4000) owned by root\n# -perm /4000 looks for SUID bit\n# -user root looks for root ownership\n# -type f looks for files only\n\nfind / -user root -perm /4000 -type f 2>/dev/null | xargs ls -ld\n\necho \"Scan complete.\""}
{"instruction": "Create a Python script for Log Analysis that parses a web server access log (e.g., Apache/Nginx) to identify IP addresses that have generated more than 100 requests, indicating potential bot activity or a DoS attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path, threshold=100):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(f\"IPs exceeding {threshold} requests:\")\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f\"{ip}: {count} requests\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Example usage\n# analyze_logs('/var/log/nginx/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that disables root login via SSH and changes the default SSH port to 2222 to reduce surface area against automated scanners.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $CONFIG_FILE \"${CONFIG_FILE}.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nelse\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Change Port to 2222\nif grep -q \"^Port\" $CONFIG_FILE; then\n    sed -i 's/^Port.*/Port 2222/' $CONFIG_FILE\nelse\n    echo \"Port 2222\" >> $CONFIG_FILE\nfi\n\n# Restart SSH service (checks for systemd)\nif systemctl list-units --full -all | grep -Fq \"ssh.service\"; then\n    systemctl restart ssh\nelif systemctl list-units --full -all | grep -Fq \"sshd.service\"; then\n    systemctl restart sshd\nfi\n\necho \"SSH hardening complete. Root login disabled, Port set to 2222.\""}
{"instruction": "Generate a Bash command using iptables to create a Firewall Rule that drops all incoming traffic from a specific malicious IP address (e.g., 192.168.1.100) and logs the dropped attempt.", "output": "#!/bin/bash\n\nMALICIOUS_IP=\"192.168.1.100\"\n\n# Log the packet before dropping\niptables -A INPUT -s $MALICIOUS_IP -j LOG --log-prefix \"IPTables-Dropped: \" --log-level 4\n\n# Drop the traffic\niptables -A INPUT -s $MALICIOUS_IP -j DROP\n\necho \"Rule added to drop and log traffic from $MALICIOUS_IP\""}
{"instruction": "Create a Python script for Vulnerability Assessment that checks the permissions of sensitive system files (like /etc/shadow and /etc/passwd) to ensure they are not world-writable.", "output": "import os\nimport stat\n\ndef check_permissions(file_path):\n    try:\n        file_stat = os.stat(file_path)\n        mode = file_stat.st_mode\n        \n        # Check if world writable (Others have Write permission)\n        if mode & stat.S_IWOTH:\n            print(f\"[CRITICAL] {file_path} is world-writable!\")\n        else:\n            print(f\"[OK] {file_path} permissions are safe.\")\n            \n    except FileNotFoundError:\n        print(f\"[ERROR] {file_path} does not exist.\")\n\nsensitive_files = ['/etc/shadow', '/etc/passwd', '/etc/group', '/etc/sudoers']\n\nfor f in sensitive_files:\n    check_permissions(f)"}
{"instruction": "Write a Bash script for SIEM/Log Analysis that scans the Linux authentication log (/var/log/auth.log) for 'Failed password' entries and extracts the top 5 usernames targeted by brute-force attacks.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found at $LOG_FILE\"\n    exit 1\nfi\n\necho \"Top 5 Usernames targeted by Brute Force:\"\n\ngrep \"Failed password\" $LOG_FILE | \\\nawk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | \\\ngrep -v \"invalid\" | \\\nsort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Python script for a basic local Vulnerability Scan that identifies open ports on the localhost (127.0.0.1) to detect unauthorized listening services.", "output": "import socket\n\ndef scan_local_ports(start_port, end_port):\n    target_ip = \"127.0.0.1\"\n    open_ports = []\n    \n    print(f\"Scanning localhost ({start_port}-{end_port})...\")\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    return open_ports\n\nif __name__ == \"__main__\":\n    # Scanning common ports range\n    found = scan_local_ports(1, 1024)\n    if found:\n        print(f\"Open ports found: {found}\")\n    else:\n        print(\"No open ports found in range.\")"}
{"instruction": "Generate a Bash script using nftables to configure a stateful firewall that allows established connections, SSH, and HTTP/HTTPS, but drops all other incoming traffic by default.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table ip filter\n\n# Create input chain with default drop policy\nnft add chain ip filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback interface\nnft add rule ip filter input iif lo accept\n\n# Allow established and related connections (Stateful)\nnft add rule ip filter input ct state established,related accept\n\n# Allow SSH (22), HTTP (80), HTTPS (443)\nnft add rule ip filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule ip filter input ip protocol icmp accept\n\necho \"nftables configured: Default DROP, Allowed: Established, SSH, Web, ICMP.\""}
{"instruction": "Write a Python script for Log Analysis designed to detect SQL Injection attempts by searching web logs for common SQL keywords and character sequences.", "output": "import re\n\ndef detect_sqli(log_line):\n    # Regex for common SQLi patterns (Union based, tautologies, comments)\n    sqli_patterns = [\n        r\"(?i)UNION\\s+SELECT\",\n        r\"(?i)OR\\s+['\\\"]?1['\\\"]?\\s*=\\s*['\\\"]?1\",\n        r\"--\",\n        r\"(?i)SELECT\\s+.*\\s+FROM\",\n        r\"(?i)INSERT\\s+INTO\",\n        r\"(?i)DROP\\s+TABLE\",\n        r\"%27\" # Encoded single quote\n    ]\n    \n    for pattern in sqli_patterns:\n        if re.search(pattern, log_line):\n            return True, pattern\n    return False, None\n\n# Simulation of reading a log file line by line\nsample_logs = [\n    \"GET /index.php?id=1 HTTP/1.1\",\n    \"GET /login.php?user=admin' OR '1'='1 HTTP/1.1\",\n    \"POST /search?q=test UNION SELECT user,password FROM users HTTP/1.1\"\n]\n\nfor line in sample_logs:\n    is_attack, signature = detect_sqli(line)\n    if is_attack:\n        print(f\"[ALERT] SQL Injection detected: {signature} in line: {line}\")"}
{"instruction": "Create a Bash script for Server Hardening that searches for files with the SUID bit set, which allows users to execute the file with the permissions of the file owner (often root), representing a potential privilege escalation vector.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_files_report.txt\"\n\necho \"Scanning for SUID files...\"\n\n# Find files with SUID bit set (perm -4000)\n# 2>/dev/null suppresses permission denied errors on directories the scanner can't read\nfind / -type f -perm -4000 -exec ls -ld {} \\; 2>/dev/null > $OUTPUT_FILE\n\necho \"Scan complete. Results saved to $OUTPUT_FILE.\"\necho \"Review this list to ensure only necessary binaries (like sudo, passwd) have SUID set.\""}
{"instruction": "Write a Python script for Server Hardening/Maintenance that automatically identifies and lists installed pip packages that are outdated compared to the PyPI repository.", "output": "import subprocess\nimport json\nimport sys\n\ndef check_outdated_packages():\n    print(\"Checking for outdated pip packages...\")\n    try:\n        # Run pip list --outdated with JSON output format\n        result = subprocess.run(\n            [sys.executable, '-m', 'pip', 'list', '--outdated', '--format=json'],\n            capture_output=True,\n            text=True\n        )\n        \n        if result.returncode != 0:\n            print(\"Error running pip list\")\n            return\n            \n        outdated = json.loads(result.stdout)\n        \n        if not outdated:\n            print(\"All packages are up to date.\")\n        else:\n            print(f\"Found {len(outdated)} outdated packages:\")\n            print(f\"{'Package':<20} {'Current':<10} {'Latest':<10}\")\n            print(\"-\" * 40)\n            for pkg in outdated:\n                print(f\"{pkg['name']:<20} {pkg['version']:<10} {pkg['latest_version']:<10}\")\n                \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    check_outdated_packages()"}
{"instruction": "Write a Python script for Log Analysis that parses a standard Apache/Nginx access log file. The script should identify and print any IP address that has made more than 100 requests within the log file, indicating potential bot activity or a DoS attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Suspicious IPs (>100 requests):\")\n        for ip, count in ip_counter.items():\n            if count > 100:\n                print(f\"{ip}: {count} requests\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Usage example\n# analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script for Server Hardening that secures the SSH configuration. The script should back up the existing config, disable root login, disable password authentication (enforcing keys), and restart the SSH service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Check if running as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"Please run as root.\"\n    exit 1\nfi\n\n# Backup configuration\ncp $SSHD_CONFIG $BACKUP\necho \"Backup created at $BACKUP\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Validate syntax and restart SSH\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH Hardening complete. Root login and Password Auth disabled.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp $BACKUP $SSHD_CONFIG\nfi"}
{"instruction": "Generate a Python script for internal Vulnerability Scanning that checks a list of internal servers to see if insecure legacy ports (Telnet - 23, FTP - 21) are open.", "output": "import socket\n\ndef check_insecure_ports(servers):\n    insecure_ports = {21: 'FTP', 23: 'Telnet'}\n    \n    print(f\"Scanning {len(servers)} servers for insecure ports...\")\n    \n    for server in servers:\n        for port, service in insecure_ports.items():\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            result = sock.connect_ex((server, port))\n            if result == 0:\n                print(f\"[ALERT] {server} has {service} (Port {port}) OPEN!\")\n            sock.close()\n\n# Usage\nserver_list = ['192.168.1.10', '192.168.1.11', '127.0.0.1']\ncheck_insecure_ports(server_list)"}
{"instruction": "Write a Bash script using iptables to implement a 'Default Drop' firewall policy. It should allow loopback traffic, allow established connections, allow incoming SSH, and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH (adjust port if necessary)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, limited to prevent log flooding)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall locked down. Default INPUT policy is DROP.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (Server Hardening). The script should calculate the SHA-256 hash of critical system files (e.g., /etc/passwd, /etc/shadow) and compare them against a stored baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (in a real scenario, load this from a secure database)\nbaseline = {\n    '/etc/passwd': 'stored_hash_value_here',\n    '/etc/shadow': 'stored_hash_value_here'\n}\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\ndef check_integrity():\n    print(\"Starting Integrity Check...\")\n    for filepath, expected_hash in baseline.items():\n        current_hash = calculate_hash(filepath)\n        if current_hash is None:\n            print(f\"[MISSING] File not found: {filepath}\")\n        elif current_hash != expected_hash:\n            # In a real run, you would alert here. Since baseline is dummy data, this will mismatch.\n            print(f\"[ALERT] Hash mismatch for {filepath}!\")\n            print(f\"Expected: {expected_hash}\")\n            print(f\"Actual:   {current_hash}\")\n        else:\n            print(f\"[OK] {filepath} is intact.\")\n\nif __name__ == \"__main__\":\n    check_integrity()"}
{"instruction": "Write a Bash one-liner for Log Analysis that extracts the top 10 user accounts targeted by failed SSH login attempts from the /var/log/auth.log file.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-5)}' | sort | uniq -c | sort -nr | head -10"}
{"instruction": "Create an nftables configuration script (Bash) to mitigate DDoS attacks by rate-limiting incoming HTTP connections to 10 per second per IP address.", "output": "#!/bin/bash\n\n# Initialize table and chain\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop traffic exceeding 10 requests per second from a single IP on port 80\nnft add rule ip filter input tcp dport 80 meter flood_meter { ip saddr limit rate over 10/second } drop\n\n# Accept traffic that passes the limit\nnft add rule ip filter input tcp dport 80 accept\n\necho \"NFTables rate limiting configured for HTTP.\""}
{"instruction": "Write a Python script for Vulnerability Scanning that checks a target URL for missing security headers (X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security).", "output": "import requests\n\ndef check_headers(url):\n    required_headers = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        print(f\"Scanning headers for: {url}\")\n        \n        missing = []\n        for req in required_headers:\n            if req not in headers:\n                missing.append(req)\n            else:\n                print(f\"[OK] {req} present.\")\n        \n        if missing:\n            print(\"\\n[VULN] Missing Headers:\")\n            for m in missing:\n                print(f\" - {m}\")\n        else:\n            print(\"\\n[SECURE] All checked headers are present.\")\n            \n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to URL: {e}\")\n\n# Usage\n# check_headers('https://example.com')"}
{"instruction": "Create a Bash script for Server Hardening that searches for files with 'world-writable' permissions (777) and removes the write permission for 'others'.", "output": "#!/bin/bash\n\necho \"Scanning for world-writable files...\"\n\n# Find files (type f) that are world writable (perm -002) excluding /proc and /sys\n# -print0 and xargs -0 handle filenames with spaces correctly\n\nfind / -xdev -type f -perm -0002 -print0 2>/dev/null | xargs -0 -I {} bash -c 'echo \"Securing {}\"; chmod o-w \"{}\"'\n\necho \"Scan and remediation complete. 'Other' write permissions removed.\""}
{"instruction": "Write a Python script for SIEM/Log Analysis that reads a JSON-formatted application log file and alerts if a specific error code (e.g., 'ERR_DB_01') appears more than 5 times in the last minute (simulated by counting total occurrences in the provided snippet).", "output": "import json\n\ndef parse_json_logs(log_file_path, target_error_code):\n    error_count = 0\n    \n    try:\n        with open(log_file_path, 'r') as f:\n            # Assuming file contains one JSON object per line\n            for line in f:\n                try:\n                    entry = json.loads(line)\n                    if entry.get('level') == 'ERROR' and entry.get('code') == target_error_code:\n                        error_count += 1\n                except json.JSONDecodeError:\n                    continue\n        \n        if error_count > 5:\n            print(f\"[ALERT] Critical Error {target_error_code} detected {error_count} times!\")\n        else:\n            print(f\"Status Normal. Error {target_error_code} count: {error_count}\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\n# Mock usage\n# parse_json_logs('app_audit.json', 'ERR_DB_01')"}
{"instruction": "Create a Python script for Log Analysis that parses a web server access log (Common Log Format) to identify IP addresses that have exceeded a specific threshold of requests, indicating a potential DoS attack or scanning activity.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path, threshold=100):\n    ip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.match(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(f'IPs exceeding {threshold} requests:')\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f'{ip}: {count} requests')\n\n    except FileNotFoundError:\n        print('Log file not found.')\n\n# Usage example\n# analyze_logs('/var/log/nginx/access.log', threshold=50)"}
{"instruction": "Write a Bash script for Server Hardening that disables USB storage support to prevent physical data exfiltration or malware introduction via USB drives.", "output": "#!/bin/bash\n\n# Create a blacklist configuration file for modprobe\necho \"blacklist usb-storage\" > /etc/modprobe.d/usb-storage.conf\necho \"blacklist uas\" >> /etc/modprobe.d/usb-storage.conf\n\n# Prevent loading even if requested\necho \"install usb-storage /bin/false\" >> /etc/modprobe.d/usb-storage.conf\necho \"install uas /bin/false\" >> /etc/modprobe.d/usb-storage.conf\n\n# Unload the module if it is currently loaded\nmodprobe -r usb-storage\nmodprobe -r uas\n\necho \"USB storage modules disabled and blacklisted.\""}
{"instruction": "Develop a Python script for Vulnerability Auditing that checks a list of domain names to verify if their SSL/TLS certificates are valid and prints the number of days until expiration.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domains):\n    context = ssl.create_default_context()\n    for domain in domains:\n        try:\n            with socket.create_connection((domain, 443), timeout=3) as sock:\n                with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                    cert = ssock.getpeercert()\n                    not_after = cert['notAfter']\n                    expiry_date = datetime.datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n                    days_left = (expiry_date - datetime.datetime.now()).days\n                    print(f'{domain}: Expires in {days_left} days')\n        except Exception as e:\n            print(f'{domain}: Error checking SSL - {e}')\n\n# Usage\n# check_ssl_expiry(['example.com', 'google.com'])"}
{"instruction": "Create a Bash script for Firewall Rule Generation using iptables that sets up a basic stateful firewall: drops all incoming traffic by default, allows established connections, allows SSH (port 22), and logs dropped packets.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (limit to prevent log flooding)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \" --log-level 7\n\necho \"Stateful iptables firewall configured.\""}
{"instruction": "Write a Python script for System Hardening that audits the permissions of critical system files (like /etc/shadow and /etc/passwd) to ensure they are not world-writable.", "output": "import os\nimport stat\n\ndef audit_file_permissions(files):\n    for filepath in files:\n        if not os.path.exists(filepath):\n            print(f'[MISSING] {filepath}')\n            continue\n            \n        st = os.stat(filepath)\n        mode = st.st_mode\n        \n        # Check if world-writable (Others having Write permission)\n        if mode & stat.S_IWOTH:\n            print(f'[CRITICAL] {filepath} is world-writable!')\n        else:\n            print(f'[OK] {filepath} permissions secure.')\n\n# Usage\nfiles_to_check = ['/etc/passwd', '/etc/shadow', '/etc/hosts', '/etc/ssh/sshd_config']\naudit_file_permissions(files_to_check)"}
{"instruction": "Create a Bash script using 'nftables' to block a dynamic list of malicious IP addresses stored in a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"bad_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\nSET_NAME=\"blackhole\"\n\n# Create table and chain if they don't exist\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Create a set for blocked IPs\nnft add set ip $TABLE_NAME $SET_NAME { type ipv4_addr \\; }\n\n# Add rule to drop traffic from IPs in the set\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr @$SET_NAME drop\n\n# Populate the set from file\nif [ -f \"$BLOCKLIST_FILE\" ]; then\n    while IFS= read -r ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        nft add element ip $TABLE_NAME $SET_NAME { $ip }\n    done < \"$BLOCKLIST_FILE\"\n    echo \"Blocklist updated from $BLOCKLIST_FILE\"\nelse\n    echo \"File $BLOCKLIST_FILE not found.\"\nfi"}
{"instruction": "Develop a Python script for Log Analysis designed to detect potential SQL Injection attempts by scanning log strings for common SQL keywords and patterns.", "output": "import re\n\ndef detect_sqli(log_line):\n    # Regex for common SQLi patterns (UNION SELECT, OR 1=1, comment injection)\n    sqli_patterns = [\n        r\"(?i)UNION\\s+SELECT\",\n        r\"(?i)SELECT\\s+.*\\s+FROM\",\n        r\"'\\s*OR\\s*'1'='1\",\n        r\"'\\s*OR\\s*1=1\",\n        r\"--\",\n        r\"(?i)INSERT\\s+INTO\",\n        r\"(?i)DROP\\s+TABLE\"\n    ]\n    \n    combined_pattern = \"|\".join(sqli_patterns)\n    \n    if re.search(combined_pattern, log_line):\n        return True, \"Potential SQL Injection detected\"\n    return False, \"Clean\"\n\n# Example Usage\nlogs = [\n    \"GET /user?id=1 HTTP/1.1\",\n    \"GET /search?q=' OR '1'='1 HTTP/1.1\",\n    \"POST /login user=admin' -- HTTP/1.1\"\n]\n\nfor line in logs:\n    is_threat, msg = detect_sqli(line)\n    if is_threat:\n        print(f\"ALERT: {msg} in line: {line}\")"}
{"instruction": "Write a Bash script for Server Hardening that audits the SSH configuration file (/etc/ssh/sshd_config) to ensure root login is disabled and empty passwords are not permitted.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\ncheck_setting() {\n    local key=\"$1\"\n    local expected=\"$2\"\n    # Grep the key, ignore comments, get last occurrence\n    local current=$(grep \"^${key}\" \"$SSHD_CONFIG\" | tail -n 1 | awk '{print $2}')\n    \n    if [ \"$current\" == \"$expected\" ]; then\n        echo \"[OK] $key is set to $expected\"\n    else\n        echo \"[WARNING] $key is set to '$current' (Expected: $expected)\"\n    fi\n}\n\nif [ ! -f \"$SSHD_CONFIG\" ]; then\n    echo \"SSHD config not found.\"\n    exit 1\nfi\n\necho \"Auditing SSH Configuration...\"\ncheck_setting \"PermitRootLogin\" \"no\"\ncheck_setting \"PermitEmptyPasswords\" \"no\"\ncheck_setting \"PasswordAuthentication\" \"no\""}
{"instruction": "Create a Python script for Port Scanning/Auditing that scans a specific local host to check if non-standard high-risk ports (like Telnet 23 or FTP 21) are open.", "output": "import socket\n\ndef audit_ports(target_ip, ports_to_check):\n    print(f\"Auditing {target_ip}...\")\n    for port in ports_to_check:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"[ALERT] Port {port} is OPEN\")\n        else:\n            print(f\"[OK] Port {port} is closed\")\n        sock.close()\n\n# Usage: Check for Telnet (23), FTP (21), and DNS (53)\naudit_ports('127.0.0.1', [21, 23, 53])"}
{"instruction": "Write a Bash script for Log Analysis that aggregates failed authentication attempts from /var/log/auth.log and alerts if a single user fails more than 5 times.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found.\"\n    exit 1\nfi\n\n# Extract usernames from failed password attempts\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | sort | uniq -c | while read count user; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"[ALERT] User '$user' has $count failed login attempts.\"\n    fi\ndone"}
{"instruction": "Write a Python script for basic vulnerability scanning that checks a target IP for open ports on a standard list (21, 22, 80, 443, 3306).", "output": "import socket\n\ndef scan_ports(target_ip, ports):\n    print(f\"Scanning {target_ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: Open\")\n        else:\n            print(f\"Port {port}: Closed/Filtered\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"  # Replace with target IP\n    port_list = [21, 22, 80, 443, 3306]\n    scan_ports(target, port_list)"}
{"instruction": "Create a Bash script using iptables to implement a 'Default Deny' firewall policy, allowing only loopback, established connections, SSH (port 22), and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional)\niptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script for Log Analysis (SIEM) that parses a Linux `auth.log` file to detect and count failed SSH login attempts by IP address.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_auth_log(log_path):\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from 'Failed password' lines\n    regex = r\"Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"Failed password\" in line:\n                    match = re.search(regex, line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(f\"Log file not found: {log_path}\")\n        return\n\n    print(\"Failed SSH Login Attempts by IP:\")\n    for ip, count in sorted(failed_attempts.items(), key=lambda x: x[1], reverse=True):\n        print(f\"{ip}: {count}\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log(\"/var/log/auth.log\")"}
{"instruction": "Create a Bash script for Server Hardening that secures the SSH configuration by disabling root login and password authentication, then reloads the service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nif ! grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Disable Password Authentication (Enforce Key-based)\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nif ! grep -q \"^PasswordAuthentication\" $CONFIG_FILE; then\n    echo \"PasswordAuthentication no\" >> $CONFIG_FILE\nfi\n\n# Validate config and reload SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Restoring backup.\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python script to check for SSL/TLS vulnerability by verifying if a remote server's certificate is close to expiration.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse expiration date\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                remaining_days = (expire_date - datetime.datetime.now()).days\n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {remaining_days}\")\n                \n                if remaining_days < 30:\n                    print(\"WARNING: Certificate expires in less than 30 days!\")\n                else:\n                    print(\"Certificate status is healthy.\")\n    except Exception as e:\n        print(f\"Error checking SSL: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Create a Bash script using `nftables` to immediately block traffic from a specific malicious IP address.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n  echo \"Usage: $0 <IP_ADDRESS_TO_BLOCK>\"\n  exit 1\nfi\n\nBLOCK_IP=$1\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Check if nftables is installed\nif ! command -v nft &> /dev/null; then\n    echo \"nftables is not installed.\"\n    exit 1\nfi\n\n# Add rule to drop packets from the specific IP\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr $BLOCK_IP counter drop\n\necho \"Blocked IP $BLOCK_IP in table '$TABLE_NAME' chain '$CHAIN_NAME'.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (Hardening/SIEM) that calculates SHA-256 hashes of critical system files to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to avoid memory issues with large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\ndef check_integrity(files):\n    print(\"File Integrity Report (SHA-256):\")\n    for file in files:\n        file_hash = calculate_hash(file)\n        print(f\"{file}: {file_hash}\")\n\nif __name__ == \"__main__\":\n    critical_files = [\n        \"/etc/passwd\",\n        \"/etc/shadow\",\n        \"/etc/ssh/sshd_config\",\n        \"/bin/ls\"\n    ]\n    check_integrity(critical_files)"}
{"instruction": "Create a Bash script to audit the system for files with SUID permission bits set, which can be a privilege escalation vulnerability.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\n\n# Find files with SUID bit set (perm -4000)\n# 2>/dev/null suppresses permission denied errors for the finder itself\nfind / -perm -4000 -type f -exec ls -ld {} \\; 2>/dev/null > suid_audit.txt\n\necho \"Scan complete. Results saved to suid_audit.txt.\"\n\n# Display the count\nCOUNT=$(wc -l < suid_audit.txt)\necho \"Found $COUNT SUID binaries. Review 'suid_audit.txt' for suspicious entries.\""}
{"instruction": "Write a Python script for Log Analysis that scans Apache access logs for common SQL Injection patterns in URL parameters.", "output": "import re\n\ndef detect_sqli(log_file):\n    # Common SQLi indicators (defensive pattern matching)\n    sqli_patterns = [\n        r\"UNION SELECT\",\n        r\"OR 1=1\",\n        r\"--\",\n        r\"waitfor delay\",\n        r\"information_schema\"\n    ]\n    \n    print(f\"Scanning {log_file} for SQL Injection patterns...\")\n    try:\n        with open(log_file, 'r') as f:\n            for line_num, line in enumerate(f, 1):\n                for pattern in sqli_patterns:\n                    if re.search(pattern, line, re.IGNORECASE):\n                        print(f\"[ALERT] Possible SQLi detected at line {line_num}: {pattern}\")\n                        print(f\"Log entry: {line.strip()}\")\n                        break\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example path to apache access log\n    detect_sqli(\"/var/log/apache2/access.log\")"}
{"instruction": "Create a Bash script for System Hardening that sets strict ownership and permissions on critical user account files (/etc/passwd, /etc/shadow, /etc/group).", "output": "#!/bin/bash\n\necho \"Hardening file permissions for account files...\"\n\n# /etc/passwd: owned by root, writable only by root, readable by all\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\necho \"/etc/passwd configured.\"\n\n# /etc/shadow: owned by root, readable only by shadow group (or root), no write\nchown root:shadow /etc/shadow\nchmod 640 /etc/shadow\necho \"/etc/shadow configured.\"\n\n# /etc/group: owned by root, writable only by root, readable by all\nchown root:root /etc/group\nchmod 644 /etc/group\necho \"/etc/group configured.\"\n\n# /etc/gshadow: owned by root, readable only by shadow group\nchown root:shadow /etc/gshadow\nchmod 640 /etc/gshadow\necho \"/etc/gshadow configured.\"\n\necho \"Critical file permissions updated.\""}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, which might indicate a scanning attempt.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 10\nip_404_counts = defaultdict(int)\n\n# Regex to extract IP and Status Code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as file:\n        for line in file:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_404_counts[ip_address] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_404_counts.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Create a Bash script using iptables to block a specific IP address (e.g., 192.168.1.100) from accessing the server and log the dropped packets with a specific prefix for SIEM ingestion.", "output": "#!/bin/bash\n\nTARGET_IP=\"192.168.1.100\"\n\n# Log the packet before dropping it\niptables -A INPUT -s $TARGET_IP -j LOG --log-prefix \"IPTABLES_DROP: \" --log-level 4\n\n# Drop packets from the specific IP\niptables -A INPUT -s $TARGET_IP -j DROP\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\n\necho \"Blocked $TARGET_IP and enabled logging.\""}
{"instruction": "Write a Python script for Server Hardening that audits the file permissions of critical system files (like /etc/shadow) to ensure they are set to 600 or stricter.", "output": "import os\nimport stat\n\ncritical_files = ['/etc/shadow', '/etc/gshadow', '/etc/passwd']\n\nfor file_path in critical_files:\n    if os.path.exists(file_path):\n        # Get file stats\n        file_stat = os.stat(file_path)\n        # Extract permission bits\n        permissions = oct(file_stat.st_mode)[-3:]\n        \n        # Convert to integer for comparison\n        perm_int = int(permissions)\n        \n        if perm_int > 600 and file_path in ['/etc/shadow', '/etc/gshadow']:\n            print(f\"[ALERT] Unsafe permissions on {file_path}: {permissions}\")\n        else:\n            print(f\"[OK] {file_path}: {permissions}\")\n    else:\n        print(f\"[MISSING] {file_path} not found.\")"}
{"instruction": "Create a Bash script for Server Hardening that disables Root login via SSH and changes the default SSH port to 2222 to reduce noise from automated scanners.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"${SSHD_CONFIG}.bak\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Change Port to 2222\nsed -i 's/^#Port 22/Port 2222/' $SSHD_CONFIG\nsed -i 's/^Port 22/Port 2222/' $SSHD_CONFIG\n\n# Validate syntax and restart SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH Hardening complete: Root login disabled, Port set to 2222.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp \"${SSHD_CONFIG}.bak\" $SSHD_CONFIG\nfi"}
{"instruction": "Write a Python script for Vulnerability Scanning that checks the SSL/TLS certificate of a remote domain to see if it is expired or expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\nhostname = 'www.example.com'\nport = 443\n\ncontext = ssl.create_default_context()\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            # Parse expiration date\n            expire_date_str = cert['notAfter']\n            expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n            \n            days_remaining = (expire_date - datetime.datetime.utcnow()).days\n            \n            print(f\"Certificate for {hostname} expires on: {expire_date}\")\n            print(f\"Days remaining: {days_remaining}\")\n            \n            if days_remaining < 0:\n                print(\"[CRITICAL] Certificate has expired!\")\n            elif days_remaining < 30:\n                print(\"[WARNING] Certificate expiring soon.\")\n            else:\n                print(\"[OK] Certificate valid.\")\nexcept Exception as e:\n    print(f\"Error checking SSL: {e}\")"}
{"instruction": "Create a Bash script using nftables to implement a 'Default Deny' firewall policy, allowing only loopback, established connections, SSH (port 22), and HTTP/HTTPS traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Define the table and base chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback traffic\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configured with Default Deny policy.\""}
{"instruction": "Write a Python script for SIEM/Log Analysis that reads a JSON-formatted log file (simulating cloud audit logs) and flags any entries where the 'action' is 'DeleteBucket' or 'DeleteInstance'.", "output": "import json\n\nlog_file = 'cloud_audit.json'\n\n# Example usage: flagging destructive actions\ndestructive_actions = ['DeleteBucket', 'DeleteInstance', 'TerminateInstances']\n\ntry:\n    with open(log_file, 'r') as f:\n        logs = json.load(f)\n        \n        # Assuming logs is a list of dicts\n        for entry in logs:\n            action = entry.get('eventName') or entry.get('action')\n            user = entry.get('userIdentity', {}).get('userName') or entry.get('user')\n            timestamp = entry.get('eventTime') or entry.get('timestamp')\n            \n            if action in destructive_actions:\n                print(f\"[ALERT] Destructive action detected!\")\n                print(f\"Action: {action}\")\n                print(f\"User: {user}\")\n                print(f\"Time: {timestamp}\")\n                print(\"-\" * 20)\nexcept FileNotFoundError:\n    print(\"Audit log file not found.\")\nexcept json.JSONDecodeError:\n    print(\"Invalid JSON format.\")"}
{"instruction": "Create a Bash script for Vulnerability Management that lists all installed packages on a Debian/Ubuntu system that have available security updates.", "output": "#!/bin/bash\n\n# Update package lists\napt-get update -q\n\n# List upgradable packages and grep for security updates\n# Security updates usually come from the -security repository\necho \"Checking for security updates...\"\n\napt list --upgradable 2>/dev/null | grep -i \"security\"\n\nif [ $? -ne 0 ]; then\n    echo \"No immediate security updates found via grep, checking count via unattended-upgrades dry run:\"\n    # Alternative method using unattended-upgrades dry run to be precise\n    unattended-upgrade --dry-run -d 2>&1 | grep \"checking\"\nfi"}
{"instruction": "Write a Python script for Network Security that performs a simple port scan on a specific local IP to check if non-standard ports (outside 20-1024) are open, which might indicate backdoors.", "output": "import socket\n\ntarget_ip = \"127.0.0.1\"\n# Scanning a range of high ports often used for testing or backdoors\nport_range = range(8000, 8100)\n\nprint(f\"Scanning {target_ip} for open ports in range 8000-8100...\")\n\nfor port in port_range:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(0.5)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f\"[OPEN] Port {port} is open.\")\n    sock.close()"}
{"instruction": "Create a Bash script for Server Hardening that searches for files with the SUID bit set (which allows files to run with owner permissions) and saves the list to a file for audit.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"/var/log/suid_audit.log\"\n\necho \"Starting SUID file audit at $(date)\" > $OUTPUT_FILE\n\n# Find files with SUID bit set (perm -4000)\n# 2>/dev/null suppresses permission denied errors for the scanner itself\nfind / -type f -perm -4000 -ls 2>/dev/null >> $OUTPUT_FILE\n\necho \"Audit complete. Results saved to $OUTPUT_FILE.\"\n\n# Display the count\nCOUNT=$(wc -l < $OUTPUT_FILE)\necho \"Found $COUNT SUID files.\""}
{"instruction": "Write a Python script for a SIEM task that parses an Apache access log file to identify and count IP addresses attempting SQL injection attacks based on common keywords (e.g., UNION, SELECT, OR 1=1).", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nsql_keywords = [r'UNION', r'SELECT', r'OR\\s+1=1', r'DROP\\s+TABLE', r'--']\npattern = re.compile('|'.join(sql_keywords), re.IGNORECASE)\n\nsuspicious_ips = []\n\ntry:\n    with open(log_file_path, 'r') as file:\n        for line in file:\n            if pattern.search(line):\n                # extracting IP at the start of standard combined log format\n                ip = line.split()[0]\n                suspicious_ips.append(ip)\n\n    ip_counts = Counter(suspicious_ips)\n    print(\"Potential SQL Injection Attempts by IP:\")\n    for ip, count in ip_counts.most_common():\n        print(f\"{ip}: {count} attempts\")\nexcept FileNotFoundError:\n    print(f\"Log file not found at {log_file_path}\")"}
{"instruction": "Create a Bash script for server hardening that audits the system for world-writable files and directories, which can be a security risk, and saves the list to a report file.", "output": "#!/bin/bash\n\nREPORT_FILE=\"/var/log/world_writable_audit.txt\"\n\necho \"Starting Audit for World-Writable Files...\" > \"$REPORT_FILE\"\necho \"Date: $(date)\" >> \"$REPORT_FILE\"\n\n# Find files that are world writable\necho \"--- Files ---\" >> \"$REPORT_FILE\"\nfind / -xdev -type f -perm -0002 -print >> \"$REPORT_FILE\" 2>/dev/null\n\n# Find directories that are world writable\necho \"--- Directories ---\" >> \"$REPORT_FILE\"\nfind / -xdev -type d -perm -0002 -print >> \"$REPORT_FILE\" 2>/dev/null\n\necho \"Audit complete. Results saved to $REPORT_FILE\""}
{"instruction": "Write a Python script to perform a basic vulnerability scan by checking the expiration date of an SSL/TLS certificate for a given hostname to prevent service downtime or security warnings.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                not_after = cert['notAfter']\n                # Parse the date format: May 25 12:00:00 2025 GMT\n                expiry_date = datetime.datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expiry_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expiry_date}\")\n                print(f\"Days remaining: {days_left}\")\n                \n                if days_left < 30:\n                    print(\"WARNING: Certificate expires in less than 30 days!\")\n                else:\n                    print(\"Certificate status: OK\")\n    except Exception as e:\n        print(f\"Error checking certificate: {e}\")\n\ncheck_ssl_expiry('example.com')"}
{"instruction": "Generate a Bash script using `iptables` to configure a firewall that drops invalid packets, allows established connections, allows SSH (port 22) and HTTP/HTTPS (80/443), and drops everything else by default.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Drop invalid packets\niptables -A INPUT -m state --state INVALID -j DROP\n\n# Allow established and related connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow loopback interface\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional, limited rate)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules configured successfully.\""}
{"instruction": "Write a Python script designed for server hardening that checks if the root user is allowed to log in via SSH by parsing the `sshd_config` file and recommends changes if enabled.", "output": "def audit_ssh_root_login(config_path='/etc/ssh/sshd_config'):\n    try:\n        with open(config_path, 'r') as f:\n            lines = f.readlines()\n            \n        root_login_status = \"Not Found (Default is usually Prohibit/Yes depending on version)\"\n        \n        for line in lines:\n            clean_line = line.strip()\n            # Ignore comments\n            if clean_line.startswith('#') or not clean_line:\n                continue\n                \n            if clean_line.lower().startswith('permitrootlogin'):\n                parts = clean_line.split()\n                if len(parts) >= 2:\n                    root_login_status = parts[1]\n                    \n        print(f\"PermitRootLogin setting: {root_login_status}\")\n        \n        if root_login_status.lower() != 'no':\n            print(\"SECURITY ALERT: Root login is not disabled.\")\n            print(\"Recommendation: Set 'PermitRootLogin no' in /etc/ssh/sshd_config and restart sshd.\")\n        else:\n            print(\"Audit Passed: Root login is disabled.\")\n            \n    except FileNotFoundError:\n        print(\"Error: sshd_config file not found.\")\n    except PermissionError:\n        print(\"Error: Run script with sudo to read configuration.\")\n\naudit_ssh_root_login()"}
{"instruction": "Create a Bash script utilizing `nftables` to create a table and chain that blocks a specific list of malicious IP addresses read from a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"bad_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\nSET_NAME=\"blocked_ips\"\n\n# Check if nftables is installed\nif ! command -v nft &> /dev/null; then\n    echo \"nftables could not be found\"\n    exit 1\nfi\n\n# Initialize table and chain if they don't exist\nnft add table inet $TABLE_NAME\nnft add chain inet $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Create a set for IPs\nnft add set inet $TABLE_NAME $SET_NAME { type ipv4_addr \\; }\n\n# Add rule to drop traffic from IPs in the set\nnft add rule inet $TABLE_NAME $CHAIN_NAME ip saddr @$SET_NAME drop\n\n# Populate the set from file\nif [ -f \"$BLOCKLIST_FILE\" ]; then\n    while IFS= read -r ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        nft add element inet $TABLE_NAME $SET_NAME { \"$ip\" }\n        echo \"Blocked IP: $ip\"\n    done < \"$BLOCKLIST_FILE\"\nelse\n    echo \"Blocklist file not found.\"\nfi"}
{"instruction": "Write a Python script for log analysis that ingests a Linux `auth.log` file and identifies users who have had more than 5 failed authentication attempts, suggesting a brute-force attack.", "output": "import re\nfrom collections import defaultdict\n\ndef detect_brute_force(log_path='/var/log/auth.log', threshold=5):\n    failed_attempts = defaultdict(int)\n    # Regex to capture user from standard sshd failed password log\n    # Example: Failed password for invalid user admin from 192.168.1.1 port 22 ssh2\n    regex = r\"Failed password for (?:invalid user )?(\\S+) from\"\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"Failed password\" in line:\n                    match = re.search(regex, line)\n                    if match:\n                        user = match.group(1)\n                        failed_attempts[user] += 1\n        \n        print(f\"--- Users with > {threshold} failed login attempts ---\")\n        found = False\n        for user, count in failed_attempts.items():\n            if count > threshold:\n                print(f\"User: {user} | Count: {count}\")\n                found = True\n        \n        if not found:\n            print(\"No anomalies detected based on current threshold.\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n    except PermissionError:\n        print(\"Permission denied. Try running as root.\")\n\ndetect_brute_force()"}
{"instruction": "Write a Bash script for vulnerability management that checks if specific critical packages (openssl, bash, ssh) have security updates available on a Debian/Ubuntu system.", "output": "#!/bin/bash\n\nPACKAGES=(\"openssl\" \"bash\" \"openssh-server\" \"sudo\")\n\necho \"Updating package lists...\"\nsudo apt-get update -qq\n\necho \"Checking for security updates on critical packages...\"\n\nfor pkg in \"${PACKAGES[@]}\"; do\n    # Check if the package is installed\n    if dpkg -l | grep -q \"^ii  $pkg \"; then\n        # Check for upgrades\n        info=$(apt list --upgradable 2>/dev/null | grep \"^$pkg/\")\n        if [ -n \"$info\" ]; then\n            echo \"[WARNING] Update available for $pkg:\"\n            echo \"$info\"\n        else\n            echo \"[OK] $pkg is up to date.\"\n        fi\n    else\n        echo \"[INFO] $pkg is not installed.\"\n    fi\ndone"}
{"instruction": "Write a Python script for server hardening that audits file permissions of critical system files (like /etc/shadow and /etc/passwd) to ensure they comply with security best practices (e.g., /etc/shadow should be 0640 or 0600 and owned by root).", "output": "import os\nimport stat\n\ncritical_files = {\n    '/etc/shadow': {'max_perm': 0o640, 'owner': 'root'},\n    '/etc/passwd': {'max_perm': 0o644, 'owner': 'root'},\n    '/etc/group':  {'max_perm': 0o644, 'owner': 'root'}\n}\n\ndef check_permissions():\n    print(\"Starting File Permission Audit...\")\n    for filepath, criteria in critical_files.items():\n        if not os.path.exists(filepath):\n            print(f\"[MISSING] {filepath} does not exist.\")\n            continue\n\n        file_stat = os.stat(filepath)\n        file_perm = file_stat.st_mode & 0o777\n        \n        # Get owner name\n        try:\n            import pwd\n            owner = pwd.getpwuid(file_stat.st_uid).pw_name\n        except ImportError:\n            owner = str(file_stat.st_uid)\n\n        issues = []\n        \n        # Check permissions (bitwise check if bits exceed max_perm)\n        # Logic: if file_perm has bits set that are NOT in max_perm, it's too loose\n        # However, simple comparison is usually enough for exact hardening guides\n        if file_perm > criteria['max_perm']:\n             issues.append(f\"Permissions too open: {oct(file_perm)} (Max: {oct(criteria['max_perm'])})\")\n        \n        if owner != criteria['owner']:\n            issues.append(f\"Wrong owner: {owner} (Expected: {criteria['owner']})\")\n\n        if issues:\n            print(f\"[FAIL] {filepath}: \" + \"; \".join(issues))\n        else:\n            print(f\"[PASS] {filepath}\")\n\ncheck_permissions()"}
{"instruction": "Create a Bash script to perform a network sweep (vulnerability scanning context) using `ping` to identify active hosts within a /24 subnet, saving the results to a file for asset inventory.", "output": "#!/bin/bash\n\nSUBNET=\"192.168.1\"\nOUTPUT_FILE=\"active_hosts.txt\"\n\necho \"Scanning subnet $SUBNET.0/24 for active hosts...\"\n> \"$OUTPUT_FILE\"\n\nfor i in {1..254}; do\n    IP=\"$SUBNET.$i\"\n    # Ping with 1 packet, 1 second timeout\n    ping -c 1 -W 1 \"$IP\" > /dev/null 2>&1\n    \n    if [ $? -eq 0 ]; then\n        echo \"Host Active: $IP\"\n        echo \"$IP\" >> \"$OUTPUT_FILE\"\n    fi\ndone\n\necho \"Scan complete. Active hosts listed in $OUTPUT_FILE\""}
{"instruction": "Create a Python script for Log Analysis that parses an Apache/Nginx access log file to identify IP addresses that have generated more than 100 '404 Not Found' errors, potentially indicating a vulnerability scanner or forced browsing attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    status_pattern = r'\" 404 '\n    suspicious_ips = []\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                if re.search(status_pattern, line):\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        suspicious_ips.append(match.group(1))\n\n        ip_counts = Counter(suspicious_ips)\n        \n        print(\"IPs with > 100 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > 100:\n                print(f\"{ip}: {count} attempts\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    analyze_logs('/var/log/nginx/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that searches the filesystem for world-writable files (permissions 777) and saves the list to a report file for audit purposes.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"/var/log/world_writable_audit.txt\"\nSEARCH_DIR=\"/\"\n\necho \"Starting audit for world-writable files...\" > \"$OUTPUT_FILE\"\n\n# Find files with write permission for others, excluding proc, sys, and dev directories\nfind \"$SEARCH_DIR\" -xdev -type f -perm -0002 -print >> \"$OUTPUT_FILE\" 2>/dev/null\n\necho \"Audit complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM). The script should calculate SHA-256 hashes of critical system binaries (e.g., /bin/ls, /bin/bash) and compare them against a known baseline dictionary to detect tampering.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (In production, this should be stored securely/offline)\nBASELINE = {\n    '/bin/ls': 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', # Example hash\n    '/bin/bash': 'valid_hash_here'\n}\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\ndef check_integrity():\n    print(\"Starting Integrity Check...\")\n    for filepath, expected_hash in BASELINE.items():\n        current_hash = calculate_sha256(filepath)\n        \n        if current_hash is None:\n            print(f\"[MISSING] {filepath} not found on disk.\")\n        elif current_hash != expected_hash:\n            print(f\"[ALERT] Hash mismatch for {filepath}! Potential compromise.\")\n            print(f\"Expected: {expected_hash}\\nFound:    {current_hash}\")\n        else:\n            print(f\"[OK] {filepath} verified.\")\n\nif __name__ == \"__main__\":\n    check_integrity()"}
{"instruction": "Create a Bash script using 'iptables' to implement a Firewall Rule that blocks SSH brute-force attacks. The rule should drop connections from an IP if it attempts to connect to port 22 more than 3 times within 60 seconds.", "output": "#!/bin/bash\n\n# Create a new chain for SSH checking\niptables -N SSH_CHECK\n\n# Send all SSH traffic to the check chain\niptables -A INPUT -p tcp --dport 22 -m state --state NEW -j SSH_CHECK\n\n# If an IP is in the recent list (setname SSH) and has hit count > 3 in 60s, DROP it\niptables -A SSH_CHECK -m recent --set --name SSH\niptables -A SSH_CHECK -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP\n\n# Allow the traffic if it passes the check\niptables -A SSH_CHECK -j ACCEPT\n\necho \"SSH Rate Limiting rules applied.\""}
{"instruction": "Write a Python script for Vulnerability Scanning that checks a list of internal web servers to see if they expose the 'Server' HTTP header, which discloses version information. This is a reconnaissance counter-measure.", "output": "import requests\n\ntargets = [\n    \"http://192.168.1.10\",\n    \"http://192.168.1.11\",\n    \"http://localhost:8080\"\n]\n\ndef check_server_header(url):\n    try:\n        response = requests.head(url, timeout=5)\n        server_header = response.headers.get('Server')\n        \n        if server_header:\n            print(f\"[WARN] {url} exposes Server header: {server_header}\")\n        else:\n            print(f\"[SECURE] {url} does not expose Server header.\")\n            \n    except requests.exceptions.RequestException as e:\n        print(f\"[ERROR] Could not connect to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    print(\"Scanning for Server Information Disclosure...\")\n    for target in targets:\n        check_server_header(target)"}
{"instruction": "Generate a Bash script for Server Hardening that parses '/etc/shadow' (requires root) to identify and lock user accounts that have empty password hashes.", "output": "#!/bin/bash\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\necho \"Scanning for accounts with empty passwords...\"\n\n# awk parses /etc/shadow. Field 2 is the password hash.\n# If field 2 is empty or specifically '::', print the username (Field 1).\nawk -F: '($2 == \"\" || $2 == \"::\") {print $1}' /etc/shadow | while read -r user; do\n    echo \"[ALERT] Locking account with empty password: $user\"\n    passwd -l \"$user\"\ndone\n\necho \"Scan complete.\""}
{"instruction": "Create a Python script for SIEM/Log Analysis that monitors the Linux 'auth.log' file in real-time (like tail -f) and prints an alert if 'Failed password' appears.", "output": "import time\nimport os\n\ndef monitor_auth_log(logfile='/var/log/auth.log'):\n    try:\n        file = open(logfile, 'r')\n        # Move to the end of file to read only new logs\n        file.seek(0, os.SEEK_END)\n        \n        print(f\"Monitoring {logfile} for failed logins...\")\n        \n        while True:\n            line = file.readline()\n            if not line:\n                time.sleep(0.1)\n                continue\n            \n            if \"Failed password\" in line:\n                print(f\"[ALERT] Failed Login Detected: {line.strip()}\")\n                \n    except FileNotFoundError:\n        print(\"Auth log file not found. Check permissions or path.\")\n    except KeyboardInterrupt:\n        print(\"Stopping monitor.\")\n        file.close()\n\nif __name__ == \"__main__\":\n    monitor_auth_log()"}
{"instruction": "Write a Bash script using 'nftables' to configure a firewall baseline. The script should flush existing rules, set default policies to drop incoming traffic, and allow loopback and established connections.", "output": "#!/bin/bash\n\n# Flush existing ruleset\nnft flush ruleset\n\n# Apply configuration\nnft -f - <<EOF\ntable inet filter {\n    chain input {\n        type filter hook input priority 0; policy drop;\n\n        # Accept traffic from loopback interface\n        iif \"lo\" accept\n\n        # Accept traffic initiated by us (established/related)\n        ct state established,related accept\n\n        # Allow SSH (adjust port if needed)\n        tcp dport 22 accept\n\n        # Allow ICMP (Ping)\n        ip protocol icmp accept\n    }\n    chain forward {\n        type filter hook forward priority 0; policy drop;\n    }\n    chain output {\n        type filter hook output priority 0; policy accept;\n    }\n}\nEOF\n\necho \"nftables baseline configuration applied.\""}
{"instruction": "Develop a Python script for Vulnerability Scanning that checks a list of internal IP addresses to see if they are using default or weak SSL/TLS versions (e.g., SSLv3 or TLS 1.0).", "output": "import ssl\nimport socket\n\ntargets = [('192.168.1.50', 443), ('192.168.1.51', 443)]\n\ndef check_weak_tls(ip, port):\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n    # We explicitly ask for TLS 1.0 to see if the server accepts it (Weak)\n    context.options &= ~ssl.OP_NO_TLSv1\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    try:\n        with socket.create_connection((ip, port), timeout=3) as sock:\n            with context.wrap_socket(sock) as ssock:\n                version = ssock.version()\n                if version == 'TLSv1':\n                    print(f\"[VULN] {ip}:{port} accepts weak protocol: {version}\")\n                else:\n                    print(f\"[INFO] {ip}:{port} negotiated: {version}\")\n    except ssl.SSLError:\n        print(f\"[OK] {ip}:{port} rejected weak TLS 1.0 connection.\")\n    except Exception as e:\n        print(f\"[ERR] {ip}:{port} connection failed: {e}\")\n\nif __name__ == \"__main__\":\n    print(\"Checking for TLS 1.0 support...\")\n    for ip, port in targets:\n        check_weak_tls(ip, port)"}
{"instruction": "Create a Bash script for Server Hardening that disables USB storage support to prevent physical data exfiltration or malware injection via USB drives.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/modprobe.d/usb-storage.conf\"\n\necho \"Disabling USB storage...\"\n\n# Create configuration to blacklist usb-storage module\necho \"install usb-storage /bin/true\" > \"$CONFIG_FILE\"\n\n# Unload the module if it is currently loaded\nif lsmod | grep -q \"usb_storage\"; then\n    rmmod usb_storage\n    echo \"Unloaded active usb_storage module.\"\nfi\n\necho \"USB storage disabled. Configuration written to $CONFIG_FILE.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (FIM) that calculates and prints the SHA-256 hash of critical system files (e.g., /etc/passwd, /etc/shadow) to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\ncritical_files = [\"/etc/passwd\", \"/etc/shadow\", \"/etc/hosts\", \"/etc/ssh/sshd_config\"]\n\nprint(\"{:<30} | {:<64}\".format(\"File\", \"SHA-256 Hash\"))\nprint(\"-\" * 95)\n\nfor file in critical_files:\n    file_hash = calculate_sha256(file)\n    print(\"{:<30} | {:<64}\".format(file, file_hash))"}
{"instruction": "Write a Bash script to implement a basic stateful firewall using iptables. The policy should drop all incoming traffic by default, allow loopback, allow established connections, and allow incoming SSH (port 22), HTTP (80), and HTTPS (443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional, limited to prevent log flooding)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\nps -ef | grep iptables"}
{"instruction": "Develop a Python script to analyze an Apache access log file. The script should count the number of 404 errors per IP address to identify potential vulnerability scanners or broken links.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = '/var/log/apache2/access.log'\nip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\nstatus_pattern = re.compile(r'\\\" 404 ')\n\noffenders = []\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            if status_pattern.search(line):\n                match = ip_pattern.match(line)\n                if match:\n                    offenders.append(match.group(1))\n\n    counts = Counter(offenders)\n    print(\"IP Addresses with high 404 counts:\")\n    for ip, count in counts.most_common(10):\n        print(f\"{ip}: {count} requests\")\nexcept FileNotFoundError:\n    print(f\"Log file not found at {log_file_path}\")"}
{"instruction": "Write a Bash script for server hardening that disables the root user from logging in via SSH and enforces protocol 2. It should backup the original config file before making changes.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Check if running as root\nif [[ $EUID -ne 0 ]]; then\n   echo \"This script must be run as root\"\n   exit 1\nfi\n\n# Backup configuration\ncp $SSHD_CONFIG $BACKUP\necho \"Backup created at $BACKUP\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Enforce Protocol 2\nif grep -q \"^Protocol\" $SSHD_CONFIG; then\n    sed -i 's/^Protocol.*/Protocol 2/' $SSHD_CONFIG\nelse\n    echo \"Protocol 2\" >> $SSHD_CONFIG\nfi\n\n# Validate syntax and restart service\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp $BACKUP $SSHD_CONFIG\nfi"}
{"instruction": "Create a Python script using the `socket` library to perform a simple local vulnerability check by verifying if specific unsafe ports (e.g., 21/FTP, 23/Telnet) are currently open on localhost.", "output": "import socket\n\ntarget = \"127.0.0.1\"\nunsafe_ports = {\n    21: \"FTP\",\n    23: \"Telnet\",\n    25: \"SMTP (Unencrypted)\",\n    69: \"TFTP\"\n}\n\nprint(f\"Scanning localhost ({target}) for unsafe services...\")\n\nfor port, service in unsafe_ports.items():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target, port))\n    if result == 0:\n        print(f\"[ALERT] Port {port} ({service}) is OPEN. Check configuration.\")\n    else:\n        print(f\"[OK] Port {port} ({service}) is closed.\")\n    sock.close()"}
{"instruction": "Write a Bash script to search for files with the SUID bit set, which can be a security risk for privilege escalation. The script should output the owner and filename of these files.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\necho \"--------------------------------\"\n\n# Find files with SUID bit set (-perm -4000)\n# 2>/dev/null suppresses permission denied errors on directories the scanner can't read\n\nfind / -type f -perm -4000 -exec ls -l {} \\; 2>/dev/null | awk '{print $3, $9}'\n\necho \"--------------------------------\"\necho \"Scan complete. Review the list above for unknown or suspicious SUID binaries.\""}
{"instruction": "Develop a Python script to check the SSL/TLS certificate expiration date of a remote domain to prevent security warnings or service downtime.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(\n        socket.socket(socket.AF_INET), \n        server_hostname=domain\n    )\n    \n    # Set timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((domain, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        \n        print(f\"Domain: {domain}\")\n        print(f\"Expires On: {expire_date}\")\n        print(f\"Days Remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"WARNING: Certificate expires in less than 30 days!\")\n            \n    except Exception as e:\n        print(f\"Error checking {domain}: {e}\")\n    finally:\n        conn.close()\n\n# Example usage\ncheck_ssl_expiry(\"example.com\")"}
{"instruction": "Write a Bash script using `nftables` to configure a firewall that drops invalid packets and prevents ping floods (ICMP rate limiting).", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create chain for input\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established/related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Drop invalid packets\nnft add rule inet filter input ct state invalid drop\n\n# Allow ICMP (Ping) but rate limit to 1 per second to prevent floods\nnft add rule inet filter input ip protocol icmp limit rate 1/second accept\n\n# Log dropped packets (optional)\nnft add rule inet filter input limit rate 5/minute log prefix \"NFT-Dropped: \"\n\necho \"NFTables rules applied.\""}
{"instruction": "Create a Python script that parses `/var/log/auth.log` (or `secure`) to identify and count failed SSH login attempts, grouping them by username to detect brute-force targeting specific accounts.", "output": "import re\nfrom collections import defaultdict\n\nlog_path = \"/var/log/auth.log\"\n# Regex for standard SSH failed password logs\npattern = re.compile(r\"Failed password for (invalid user )?(\\w+) from\")\n\nfailed_attempts = defaultdict(int)\n\ntry:\n    with open(log_path, \"r\") as f:\n        for line in f:\n            if \"sshd\" in line and \"Failed password\" in line:\n                match = pattern.search(line)\n                if match:\n                    # Group 2 captures the username\n                    user = match.group(2)\n                    failed_attempts[user] += 1\n\n    print(\"Failed SSH Login Attempts by User:\")\n    print(\"----------------------------------\")\n    for user, count in sorted(failed_attempts.items(), key=lambda item: item[1], reverse=True):\n        print(f\"User: {user:<20} Count: {count}\")\n\nexcept PermissionError:\n    print(\"Error: Run with sudo to read auth logs.\")\nexcept FileNotFoundError:\n    print(\"Error: Log file not found.\")"}
{"instruction": "Write a Bash script for system hardening that modifies `sysctl.conf` to disable IP forwarding, ignore ICMP broadcast requests, and disable source routing.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\necho \"Applying network hardening settings...\"\n\n# Helper function to set sysctl params\nset_sysctl() {\n    key=\"$1\"\n    value=\"$2\"\n    if grep -q \"^$key\" \"$SYSCTL_CONF\"; then\n        sed -i \"s/^$key.*/$key = $value/\" \"$SYSCTL_CONF\"\n    else\n        echo \"$key = $value\" >> \"$SYSCTL_CONF\"\n    fi\n}\n\n# Disable IP Forwarding (act as router)\nset_sysctl \"net.ipv4.ip_forward\" \"0\"\n\n# Ignore ICMP Echo Requests sent to broadcast/multicast (Smurf attack protection)\nset_sysctl \"net.ipv4.icmp_echo_ignore_broadcasts\" \"1\"\n\n# Disable Source Routing (prevent traffic redirection)\nset_sysctl \"net.ipv4.conf.all.accept_source_route\" \"0\"\nset_sysctl \"net.ipv4.conf.default.accept_source_route\" \"0\"\n\n# Apply changes\nsysctl -p\necho \"Network hardening complete.\""}
{"instruction": "Create a Python script that checks a list of URLs to verify if strict HTTP security headers (Strict-Transport-Security, X-Frame-Options, X-Content-Type-Options) are present.", "output": "import requests\n\nurls = ['https://example.com', 'https://test.site']\nheaders_to_check = ['Strict-Transport-Security', 'X-Frame-Options', 'X-Content-Type-Options']\n\nfor url in urls:\n    try:\n        response = requests.get(url, timeout=5)\n        print(f'Checking {url}:')\n        for header in headers_to_check:\n            if header in response.headers:\n                print(f'  [OK] {header} present')\n            else:\n                print(f'  [MISSING] {header}')\n    except requests.exceptions.RequestException as e:\n        print(f'Error connecting to {url}: {e}')"}
{"instruction": "Write a Bash one-liner to parse a standard Apache/Nginx access log and display the top 10 IP addresses making requests.", "output": "cat /var/log/nginx/access.log | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Bash script to configure iptables to drop all incoming traffic by default, but allow loopback, established connections, SSH (port 22), and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Save rules (Debian/Ubuntu)\nnetfilter-persistent save"}
{"instruction": "Create a Python script that parses a text-based server log to detect potential brute-force attacks by identifying IP addresses with more than 5 'Failed password' attempts.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/auth.log'\nip_counts = defaultdict(int)\nTHRESHOLD = 5\n\n# Regex to extract IP from standard auth logs\nip_pattern = re.compile(r'Failed password.*from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = ip_pattern.search(line)\n            if match:\n                ip = match.group(1)\n                ip_counts[ip] += 1\n\n    print('Potential Brute Force Sources:')\n    for ip, count in ip_counts.items():\n        if count > THRESHOLD:\n            print(f'IP: {ip} - Failed Attempts: {count}')\nexcept FileNotFoundError:\n    print('Log file not found.')"}
{"instruction": "Write a Bash script for basic server hardening that disables root login via SSH and sets specific file permissions on critical configuration files.", "output": "#!/bin/bash\n\n# Disable Root Login in SSH\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\n\n# Secure critical files\nchmod 600 /etc/shadow\nchmod 600 /etc/ssh/sshd_config\n\necho 'Hardening measures applied: Root SSH login disabled and permissions updated.'"}
{"instruction": "Create a Python script to verify file integrity by calculating and comparing the SHA-256 hash of a critical system binary against a known good hash.", "output": "import hashlib\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b''):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nfile_path = '/bin/ls'\n# Example known hash (this would be stored securely in a real scenario)\nknown_good_hash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' \n\ncurrent_hash = calculate_sha256(file_path)\n\nif current_hash == known_good_hash:\n    print(f'Integrity Verified: {file_path}')\nelse:\n    print(f'ALERT: Hash mismatch for {file_path}. Possible tampering.')"}
{"instruction": "Write a Bash script using nftables to block all traffic from a specific malicious IP address.", "output": "#!/bin/bash\n\nMALICIOUS_IP=\"192.0.2.100\"\n\n# Create table if not exists\nnft add table inet filter\n\n# Create input chain if not exists\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop traffic from the IP\nnft add rule inet filter input ip saddr $MALICIOUS_IP drop\n\necho \"Blocked traffic from $MALICIOUS_IP\""}
{"instruction": "Create a Python script that connects to a remote server via SSH to check if the OS requires a reboot (checking for /var/run/reboot-required).", "output": "import paramiko\n\ndef check_reboot_required(hostname, username, key_file):\n    client = paramiko.SSHClient()\n    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    \n    try:\n        client.connect(hostname, username=username, key_filename=key_file)\n        stdin, stdout, stderr = client.exec_command('[ -f /var/run/reboot-required ] && echo \"YES\" || echo \"NO\"')\n        result = stdout.read().decode().strip()\n        \n        if result == \"YES\":\n            print(f'{hostname}: Reboot REQUIRED')\n        else:\n            print(f'{hostname}: No reboot needed')\n    except Exception as e:\n        print(f'Connection failed: {e}')\n    finally:\n        client.close()\n\n# Usage\n# check_reboot_required('192.168.1.50', 'admin', '/path/to/key.pem')"}
{"instruction": "Write a Bash script to search the entire filesystem for files that are world-writable, which is a common security misconfiguration.", "output": "#!/bin/bash\n\necho \"Scanning for world-writable files...\"\n# -perm -0002 looks for the write bit for 'others'\n# -type f restricts to files\n# -ls lists details\n\nfind / -xdev -type f -perm -0002 -ls 2>/dev/null > world_writable_report.txt\n\necho \"Scan complete. Results saved to world_writable_report.txt\""}
{"instruction": "Create a Python script to parse a JSON-formatted SIEM log file and filter for events marked as 'CRITICAL' severity.", "output": "import json\n\ninput_log = 'siem_events.json'\noutput_report = 'critical_events.json'\n\ncritical_events = []\n\ntry:\n    with open(input_log, 'r') as f:\n        data = json.load(f)\n        # Assuming data is a list of event objects\n        for event in data:\n            if event.get('severity') == 'CRITICAL':\n                critical_events.append(event)\n    \n    with open(output_report, 'w') as f_out:\n        json.dump(critical_events, f_out, indent=4)\n        \n    print(f'Found {len(critical_events)} critical events.')\nexcept Exception as e:\n    print(f'Error processing logs: {e}')"}
{"instruction": "Write a Python script to perform a basic port scan on a target IP address for common services (SSH, HTTP, HTTPS) to identify potential entry points.", "output": "import socket\n\ndef scan_ports(ip):\n    ports = [22, 80, 443]\n    print(f\"Scanning {ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        else:\n            print(f\"Port {port}: CLOSED\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Replace with authorized target IP\n    target_ip = \"192.168.1.10\"\n    scan_ports(target_ip)"}
{"instruction": "Create a Bash script to parse an Apache access log file and identify the top 10 IP addresses making the most requests, useful for detecting potential DoS attempts.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/apache2/access.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 Source IPs:\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Bash script using `iptables` to block incoming traffic from a specific malicious IP address provided as an argument.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <IP_TO_BLOCK>\"\n    exit 1\nfi\n\nIP=$1\niptables -A INPUT -s \"$IP\" -j DROP\necho \"Blocked incoming traffic from $IP\""}
{"instruction": "Write a Python script to check if the `Strict-Transport-Security` (HSTS) header is present in an HTTP response to ensure the server enforces HTTPS.", "output": "import requests\n\ndef check_hsts(url):\n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        if 'Strict-Transport-Security' in headers:\n            print(f\"[SAFE] HSTS Header found: {headers['Strict-Transport-Security']}\")\n        else:\n            print(\"[WARN] HSTS Header missing!\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    check_hsts(\"https://example.com\")"}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and password authentication.", "output": "#!/bin/bash\nCONFIG=\"/etc/ssh/sshd_config\"\n\n# Create backup\ncp \"$CONFIG\" \"$CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG\"\n\n# Disable Password Authentication\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG\"\n\n# Restart SSH service to apply changes\nsystemctl restart sshd\necho \"SSH configuration hardened.\""}
{"instruction": "Write a Python script to analyze a Linux auth log file (`/var/log/auth.log`) and extract IP addresses associated with failed password attempts.", "output": "import re\n\ndef analyze_auth_log(log_path):\n    ip_pattern = r\"Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)\"\n    failed_ips = []\n    \n    try:\n        with open(log_path, 'r') as file:\n            for line in file:\n                match = re.search(ip_pattern, line)\n                if match:\n                    failed_ips.append(match.group(1))\n        \n        unique_ips = set(failed_ips)\n        print(\"IPs with failed login attempts:\")\n        for ip in unique_ips:\n            print(ip)\n            \n    except FileNotFoundError:\n        print(f\"File {log_path} not found.\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log(\"/var/log/auth.log\")"}
{"instruction": "Generate a Bash script using `nftables` to flush existing rules and set up a basic firewall that allows SSH, HTTP, and HTTPS while dropping other incoming traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established/related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\necho \"nftables firewall configured.\""}
{"instruction": "Write a Python script to audit file permissions on critical system files (e.g., `/etc/shadow`) to ensure they are not world-readable.", "output": "import os\nimport stat\n\ndef check_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        mode = st.st_mode\n        \n        # Check if world readable (others have read permission)\n        if mode & stat.S_IROTH:\n            print(f\"[ALERT] {filepath} is world-readable!\")\n        else:\n            print(f\"[OK] {filepath} permissions are secure.\")\n            \n    except FileNotFoundError:\n        print(f\"File {filepath} does not exist.\")\n\nif __name__ == \"__main__\":\n    check_permissions(\"/etc/shadow\")"}
{"instruction": "Create a Bash script to search for files with the SUID bit set in the `/usr/bin` directory, which could be potential privilege escalation vectors.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries in /usr/bin...\"\nfind /usr/bin -type f -perm -4000 -exec ls -ld {} \\;\necho \"Scan complete.\""}
{"instruction": "Write a Python script to calculate the SHA-256 hash of a file to verify its integrity against a known baseline.", "output": "import hashlib\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        print(f\"File: {filepath}\")\n        print(f\"SHA-256: {sha256_hash.hexdigest()}\")\n    except FileNotFoundError:\n        print(\"File not found.\")\n\nif __name__ == \"__main__\":\n    calculate_sha256(\"/bin/ls\")"}
{"instruction": "Write a Python script to parse a standard Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, which might indicate a scanning attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    status_pattern = r'\\s404\\s'\n    \n    suspect_ips = []\n    \n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                if re.search(status_pattern, line):\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        suspect_ips.append(match.group(1))\n                        \n        ip_counts = Counter(suspect_ips)\n        \n        print(\"IPs with > 10 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > 10:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script that uses iptables to immediately block traffic from a specific abusive IP address passed as an argument and logs the event to syslog.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n  echo \"Usage: $0 <IP_ADDRESS>\"\n  exit 1\nfi\n\nTARGET_IP=$1\n\n# Log the action\nlogger -t manual-block \"Blocking IP $TARGET_IP due to suspicious activity\"\n\n# Drop packets from the IP\niptables -A INPUT -s \"$TARGET_IP\" -j DROP\n\n# Save the rules (assuming Debian/Ubuntu based system)\nif command -v iptables-save &> /dev/null; then\n    iptables-save > /etc/iptables/rules.v4\nfi\n\necho \"Blocked $TARGET_IP\""}
{"instruction": "Write a Python script for server hardening that audits critical system files (like /etc/shadow and /etc/passwd) to ensure their file permissions are set securely (not world-writable).", "output": "import os\nimport stat\n\ndef check_permissions(filepath, max_perm_octal):\n    try:\n        file_stat = os.stat(filepath)\n        # Get the permission bits (last 3 octal digits)\n        mode = stat.S_IMODE(file_stat.st_mode)\n        \n        if mode > int(str(max_perm_octal), 8):\n            print(f\"[WARNING] {filepath} is too permissive: {oct(mode)}\")\n        else:\n            print(f\"[OK] {filepath} permissions are secure.\")\n            \n    except FileNotFoundError:\n        print(f\"[ERROR] File {filepath} not found.\")\n\nif __name__ == \"__main__\":\n    # /etc/shadow should generally be 600 or 640 depending on group ownership\n    check_permissions('/etc/shadow', 600)\n    # /etc/passwd should generally be 644\n    check_permissions('/etc/passwd', 644)"}
{"instruction": "Generate a Bash script to harden an SSH configuration by disabling root login and password authentication in /etc/ssh/sshd_config, then reloading the service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication (Force Key-based)\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Validate config before restart\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardened and service reloaded.\"\nelse\n    echo \"Configuration test failed. Restoring backup.\"\n    cp \"$BACKUP\" \"$SSHD_CONFIG\"\nfi"}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote server to identify potential security lapses in encryption maintenance.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(\n        socket.socket(socket.AF_INET),\n        server_hostname=hostname,\n    )\n    \n    # Set a timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, r'%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        \n        print(f\"Certificate for {hostname} expires on: {expire_date}\")\n        print(f\"Days remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"[ALERT] Certificate expires in less than 30 days!\")\n            \n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"example.com\")"}
{"instruction": "Create a Bash script using nftables to set up a basic stateful firewall that allows established traffic, SSH, HTTP/HTTPS, and drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create input, forward, output chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH (22), HTTP (80), HTTPS (443)\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"Nftables rules applied.\""}
{"instruction": "Write a Python script to scan the currently installed pip packages and cross-reference them against a list of known vulnerable package versions (simplified simulation of a vulnerability scanner).", "output": "import subprocess\nimport json\n\ndef check_outdated_vulnerable():\n    print(\"Checking for outdated packages...\")\n    \n    # Get outdated packages in JSON format\n    try:\n        result = subprocess.check_output(\n            ['pip', 'list', '--outdated', '--format=json'], \n            stderr=subprocess.STDOUT\n        )\n        outdated = json.loads(result)\n        \n        if not outdated:\n            print(\"No outdated packages found.\")\n            return\n\n        print(f\"Found {len(outdated)} outdated packages. Review for vulnerabilities:\")\n        print(\"{:<20} {:<15} {:<15}\".format(\"Package\", \"Installed\", \"Latest\"))\n        print(\"-\"*50)\n        \n        for pkg in outdated:\n            print(\"{:<20} {:<15} {:<15}\".format(\n                pkg['name'], pkg['version'], pkg['latest_version']\n            ))\n            \n        print(\"\\nRecommendation: Check CVE databases for these specific versions.\")\n        \n    except subprocess.CalledProcessError as e:\n        print(\"Error running pip:\", e)\n    except FileNotFoundError:\n        print(\"pip executable not found.\")\n\nif __name__ == \"__main__\":\n    check_outdated_vulnerable()"}
{"instruction": "Generate a Bash script to search the entire filesystem for files that are world-writable, which is a common misconfiguration allowing privilege escalation or data tampering.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/world_writable_audit.log\"\n\necho \"Starting Audit: Finding world-writable files...\" > \"$LOG_FILE\"\n\n# Find files (-type f) that are writable by others (-perm -002) \n# Exclude /proc, /sys, and /dev to avoid virtual filesystems\nfind / -path /proc -prune -o -path /sys -prune -o -path /dev -prune -o -type f -perm -002 -print >> \"$LOG_FILE\" 2>/dev/null\n\necho \"Audit complete. Results saved to $LOG_FILE\"\n\n# Display count\nCOUNT=$(wc -l < \"$LOG_FILE\")\necho \"Found $COUNT world-writable files.\""}
{"instruction": "Write a Python script acting as a simple SIEM agent that tails a text log file (like auth.log) and alerts if 'sudo' is used by a non-standard user.", "output": "import time\nimport os\n\ndef monitor_sudo_usage(logfile, allowed_users):\n    f = subprocess.Popen(['tail','-F',logfile], stdout=subprocess.PIPE,stderr=subprocess.PIPE)\n    p = select.poll()\n    p.register(f.stdout)\n\n    # Simpler implementation using file seeking for education\n    try:\n        with open(logfile, 'r') as f:\n            # Go to the end of the file\n            f.seek(0, os.SEEK_END)\n            \n            while True:\n                line = f.readline()\n                if not line:\n                    time.sleep(0.5)\n                    continue\n                \n                if \"sudo:\" in line:\n                    # Simple parsing logic assuming standard auth.log format\n                    parts = line.split()\n                    # Usually user is somewhat early in the line or before 'sudo'\n                    # This is a basic detection heuristic\n                    \n                    alert = True\n                    for user in allowed_users:\n                        if user in line:\n                            alert = False\n                            break\n                    \n                    if alert:\n                        print(f\"[SIEM ALERT] Suspicious sudo usage detected: {line.strip()}\")\n                        \n    except FileNotFoundError:\n        print(f\"Log file {logfile} not found.\")\n\nif __name__ == \"__main__\":\n    # Only 'admin' and 'root' should be using sudo\n    monitor_sudo_usage('/var/log/auth.log', ['admin', 'root'])"}
{"instruction": "Create a Bash script to analyze the 'lastb' log (failed login attempts) and extract the top 5 IP addresses targeting the server, useful for threat intelligence feeds.", "output": "#!/bin/bash\n\n# Check if lastb is available (requires root usually)\nif ! command -v lastb &> /dev/null; then\n    echo \"Error: 'lastb' command not found.\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed login attempts:\"\n\n# 1. Run lastb to get failed logins\n# 2. Awk to extract the 3rd column (IP address)\n# 3. Sort to group them\n# 4. Uniq -c to count occurrences\n# 5. Sort -nr to sort by count descending\n# 6. Head to get top 5\nlastb | awk '{print $3}' | grep -E '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Python script for Log Analysis that parses a standard Apache/Nginx access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential vulnerability scanning.", "output": "import re\nfrom collections import defaultdict\n\nlog_file_path = '/var/log/apache2/access.log'\nthreshold = 10\nip_counts = defaultdict(int)\n\n# Regex to capture IP and Status Code from common log format\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(404)\\s')\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip_address = match.group(1)\n                ip_counts[ip_address] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_counts.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Write a Bash script for Server Hardening that disables root login via SSH and restarts the SSH service to apply changes.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\necho \"Disabling Root Login in SSH...\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Use sed to ensure PermitRootLogin is set to no\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Restart SSH service (systemd)\nsystemctl restart sshd\n\necho \"Root login disabled. Backup saved to $SSHD_CONFIG.bak\""}
{"instruction": "Create a Python script for Vulnerability Scanning that checks local running services against a list of known vulnerable ports (e.g., Telnet on 23, FTP on 21) to flag unnecessary exposure.", "output": "import socket\n\n# List of ports to check (Port, Service Name)\ntarget_ports = [(21, 'FTP'), (23, 'Telnet'), (69, 'TFTP')]\ntarget_ip = '127.0.0.1'\n\nprint(f\"Checking for insecure services on {target_ip}...\")\n\nfor port, service in target_ports:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    result = sock.connect_ex((target_ip, port))\n    if result == 0:\n        print(f\"[WARNING] Port {port} ({service}) is OPEN. Verify if this is required.\")\n    else:\n        print(f\"[OK] Port {port} ({service}) is closed.\")\n    sock.close()"}
{"instruction": "Write a Bash script using 'iptables' to implement a default-drop firewall policy, allowing only Loopback, Established connections, SSH (port 22), and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set Default Policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules updated: Default DROP applied.\""}
{"instruction": "Create a Python script for File Integrity Monitoring (Hardening) that calculates SHA-256 hashes of critical system files (like /etc/passwd and /etc/shadow) and alerts if they change.", "output": "import hashlib\nimport os\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/ssh/sshd_config']\n# In a real scenario, load previous hashes from a secure database\nknown_hashes = {} \n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except PermissionError:\n        return \"PERMISSION_DENIED\"\n    except FileNotFoundError:\n        return \"NOT_FOUND\"\n\nprint(\"--- File Integrity Check ---\")\nfor file in critical_files:\n    current_hash = calculate_hash(file)\n    print(f\"File: {file}\\nHash: {current_hash}\\n\")"}
{"instruction": "Write a Bash script for SIEM/Log Analysis that searches the authentication logs (/var/log/auth.log) for 'Failed password' attempts and extracts the top 5 offending IP addresses.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file $LOG_FILE not found.\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Create a Python script to check for SSL/TLS certificate expiration (Vulnerability Scanning/Monitoring) for a list of domains.", "output": "import ssl\nimport socket\nimport datetime\n\ndomains = ['google.com', 'example.com']\n\ndef get_ssl_expiry(domain):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    conn.settimeout(3.0)\n    try:\n        conn.connect((domain, 443))\n        ssl_info = conn.getpeercert()\n        # Parse date format: 'May 20 23:59:59 2025 GMT'\n        expiry_date = datetime.datetime.strptime(ssl_info['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n        days_left = (expiry_date - datetime.datetime.utcnow()).days\n        return days_left\n    except Exception as e:\n        return str(e)\n    finally:\n        conn.close()\n\nfor d in domains:\n    days = get_ssl_expiry(d)\n    print(f\"Domain: {d}, Days until expiry: {days}\")"}
{"instruction": "Write a Bash script for Server Hardening that searches for users with empty passwords in /etc/shadow and locks those accounts.", "output": "#!/bin/bash\n\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\necho \"Scanning for accounts with empty passwords...\"\n\n# awk parses /etc/shadow. Field 2 is password hash. Empty means no password.\nawk -F: '($2 == \"\") {print $1}' /etc/shadow | while read -r user; do\n    echo \"[WARNING] User '$user' has no password. Locking account...\"\n    passwd -l \"$user\"\ndone\n\necho \"Scan complete.\""}
{"instruction": "Create a Python script for Firewall Rule Generation that reads a list of malicious IP addresses from a text file and generates 'nftables' commands to block them.", "output": "import sys\n\n# Assume malicious_ips.txt contains one IP per line\ninput_file = 'malicious_ips.txt'\n\ntry:\n    with open(input_file, 'r') as f:\n        ips = [line.strip() for line in f if line.strip()]\n\n    print(\"#!/usr/sbin/nft -f\")\n    print(\"table ip filter {\")\n    print(\"    chain input {\")\n    \n    for ip in ips:\n        # Basic validation could be added here\n        print(f\"        ip saddr {ip} drop\")\n        \n    print(\"    }\")\n    print(\"}\")\n\nexcept FileNotFoundError:\n    print(f\"Error: {input_file} not found.\")"}
{"instruction": "Write a Bash script using 'auditd' (Server Hardening) to set up a watch rule on the /etc/group file to log any write access or attribute changes.", "output": "#!/bin/bash\n\n# Check if auditctl is installed\nif ! command -v auditctl &> /dev/null; then\n    echo \"auditd is not installed. Please install it first.\"\n    exit 1\nfi\n\necho \"Adding audit rule for /etc/group...\"\n\n# -w: watch file path\n# -p wa: permissions to watch (write, attribute change)\n# -k: key name for log searching\nauditctl -w /etc/group -p wa -k identity_changes\n\n# Verify rule\nauditctl -l | grep identity_changes\n\necho \"Audit rule applied. Check logs with: ausearch -k identity_changes\""}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    four_oh_four_ips = []\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        four_oh_four_ips.append(match.group(1))\n        \n        counts = Counter(four_oh_four_ips)\n        print(f'IPs with > 10 404 errors:')\n        for ip, count in counts.items():\n            if count > 10:\n                print(f'{ip}: {count}')\n                \n    except FileNotFoundError:\n        print('Log file not found.')\n\nif __name__ == '__main__':\n    # Example usage\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script to generate IPTables firewall rules that flush existing rules, set default policies to DROP, allow loopback traffic, allow established connections, and allow incoming SSH (port 22) and HTTP (port 80).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\necho \"Firewall rules configured.\""}
{"instruction": "Create a Python script for Server Hardening that audits the local system for commonly opened ports (21, 22, 23, 80, 443, 3306) and reports which ones are listening.", "output": "import socket\n\ndef check_ports():\n    target = '127.0.0.1'\n    ports_to_check = [21, 22, 23, 80, 443, 3306]\n    print(f'Auditing open ports on {target}...')\n\n    for port in ports_to_check:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            print(f'[WARN] Port {port} is OPEN')\n        else:\n            print(f'[OK] Port {port} is closed')\n        sock.close()\n\nif __name__ == '__main__':\n    check_ports()"}
{"instruction": "Write a Bash script for Server Hardening that disables root login via SSH by modifying the sshd_config file and restarting the SSH service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Check if root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Use sed to modify PermitRootLogin to no\n# Note: This handles commented out lines or existing 'yes' settings\nif grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nelse\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Restart SSH service (checking for systemd)\nif systemctl is-active --quiet sshd; then\n    systemctl restart sshd\n    echo \"Root login disabled and SSHD restarted.\"\nelse\n    service ssh restart\n    echo \"Root login disabled and SSH restarted.\"\nfi"}
{"instruction": "Create a Python script for Vulnerability Scanning that checks a list of websites to see if they are missing critical security headers (X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security).", "output": "import requests\n\ndef check_security_headers(urls):\n    headers_to_check = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n\n    for url in urls:\n        try:\n            print(f'Scanning {url}...')\n            response = requests.get(url, timeout=5)\n            missing = []\n            for h in headers_to_check:\n                if h not in response.headers:\n                    missing.append(h)\n            \n            if missing:\n                print(f'  [!] Missing headers: {missing}')\n            else:\n                print('  [+] All checked headers present.')\n        except requests.exceptions.RequestException as e:\n            print(f'  [Error] Could not connect to {url}: {e}')\n\nif __name__ == '__main__':\n    targets = ['https://google.com', 'https://example.com']\n    check_security_headers(targets)"}
{"instruction": "Write a Bash script using `nftables` (nft) to create a table that drops all traffic by default but accepts loopback, SSH, and ICMP (ping).", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create chain with default drop policy\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established/related\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH (port 22)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configured: Drop all except SSH, ICMP, and Loopback.\""}
{"instruction": "Create a Python script for SIEM/Log Analysis that reads a Linux 'auth.log' file and counts the number of failed password attempts by username.", "output": "import re\nfrom collections import defaultdict\n\ndef parse_auth_log(log_path):\n    # Regex for standard Linux auth.log failed password entry\n    # Example: Failed password for invalid user admin from 192.168.1.5 port 22 ssh2\n    regex = r'Failed password for (?:invalid user )?(\\S+) from'\n    \n    failed_attempts = defaultdict(int)\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if 'Failed password' in line:\n                    match = re.search(regex, line)\n                    if match:\n                        user = match.group(1)\n                        failed_attempts[user] += 1\n        \n        print(\"Failed Login Attempts by User:\")\n        for user, count in sorted(failed_attempts.items(), key=lambda x: x[1], reverse=True):\n            print(f\"{user}: {count}\")\n\n    except PermissionError:\n        print(\"Error: Permission denied reading log file.\")\n    except FileNotFoundError:\n        print(\"Error: File not found.\")\n\nif __name__ == '__main__':\n    parse_auth_log('/var/log/auth.log')"}
{"instruction": "Write a Bash script for Server Hardening that searches for files with SUID or SGID bits set (which can be used for privilege escalation) and saves the list to a file for audit.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_sgid_audit.txt\"\n\necho \"Starting SUID/SGID Audit...\"\necho \"Scan date: $(date)\" > $OUTPUT_FILE\n\n# Find files with SUID (4000) or SGID (2000) permissions\n# -perm /6000 looks for either bit\n# -type f ensures we only look at files\nfind / -perm /6000 -type f -exec ls -ld {} \\; 2>/dev/null >> $OUTPUT_FILE\n\necho \"Audit complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Create a Python script for Operational Security that checks the SSL/TLS certificate expiration date of a domain and alerts if it expires within 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    \n    # Set timeout\n    conn.settimeout(3.0)\n\n    try:\n        conn.connect((domain, port))\n        cert = conn.getpeercert()\n        conn.close()\n\n        # Parse expiration date\n        expire_date_str = cert['notAfter']\n        # Format: May 25 23:59:59 2024 GMT\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_left = (expire_date - datetime.datetime.utcnow()).days\n        \n        print(f\"Domain: {domain}\")\n        print(f\"Expires on: {expire_date}\")\n        print(f\"Days remaining: {days_left}\")\n        \n        if days_left < 30:\n            print(\"[ALERT] Certificate expires in less than 30 days!\")\n        else:\n            print(\"[OK] Certificate is valid.\")\n            \n    except Exception as e:\n        print(f\"Error connecting to {domain}: {e}\")\n\nif __name__ == '__main__':\n    check_ssl_expiry('example.com')"}
{"instruction": "Write a Bash script for Incident Response/Forensics that collects volatile system data (current connections, running processes, open files) and saves it to a timestamped directory.", "output": "#!/bin/bash\n\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nEVIDENCE_DIR=\"/tmp/evidence_$TIMESTAMP\"\n\nmkdir -p $EVIDENCE_DIR\necho \"Collecting volatile data to $EVIDENCE_DIR...\"\n\n# Network connections\nnetstat -antup > \"$EVIDENCE_DIR/netstat.txt\" 2>/dev/null\n\n# Running processes\nps aux > \"$EVIDENCE_DIR/ps_aux.txt\"\n\n# Open files\nlsof > \"$EVIDENCE_DIR/lsof.txt\" 2>/dev/null\n\n# Currently logged in users\nw > \"$EVIDENCE_DIR/w.txt\"\n\n# System load and uptime\nuptime > \"$EVIDENCE_DIR/uptime.txt\"\n\n# ARP table\narp -a > \"$EVIDENCE_DIR/arp.txt\"\n\necho \"Collection complete. Archive created at $EVIDENCE_DIR\""}
{"instruction": "Create a Python script that performs a basic vulnerability scan by checking a list of URLs for the presence of an exposed '.git' directory, which is a common security misconfiguration.", "output": "import requests\n\ndef check_git_exposure(urls):\n    for url in urls:\n        target = f\"{url.rstrip('/')}/.git/HEAD\"\n        try:\n            response = requests.get(target, timeout=5)\n            if response.status_code == 200 and 'ref: refs/' in response.text:\n                print(f\"[VULNERABLE] Exposed .git found at: {target}\")\n            else:\n                print(f\"[SAFE] {url}\")\n        except requests.RequestException as e:\n            print(f\"[ERROR] Could not connect to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    targets = [\"http://example.com\", \"http://test-site.local\"]\n    check_git_exposure(targets)"}
{"instruction": "Write a Bash script for server hardening that disables root login via SSH and changes the default SSH port to 2222 in the sshd_config file.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Change Port\nif grep -q \"^Port\" $SSHD_CONFIG; then\n    sed -i 's/^Port.*/Port 2222/' $SSHD_CONFIG\nelse\n    echo \"Port 2222\" >> $SSHD_CONFIG\nfi\n\necho \"Hardening complete. Restart sshd to apply changes.\""}
{"instruction": "Develop a Python script for Log Analysis (SIEM) that reads a standard Apache access log file and detects IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import defaultdict\n\ndef detect_scanners(log_file_path, threshold=10):\n    ip_404_count = defaultdict(int)\n    log_pattern = re.compile(r'(\\d+\\.\\d+\\.\\d+\\.\\d+) .* \"(?:GET|POST|HEAD) .*\" 404')\n\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip = match.group(1)\n                ip_404_count[ip] += 1\n\n    print(f\"IPs with > {threshold} 404 errors:\")\n    for ip, count in ip_404_count.items():\n        if count > threshold:\n            print(f\"{ip}: {count}\")\n\nif __name__ == \"__main__\":\n    detect_scanners('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script using 'iptables' to implement a firewall rule that drops all incoming traffic from a specific malicious IP address and logs the dropped attempt.", "output": "#!/bin/bash\n\nBLOCK_IP=\"192.0.2.100\"\n\n# Log the packet before dropping\niptables -A INPUT -s $BLOCK_IP -j LOG --log-prefix \"IP Blocked: \" --log-level 4\n\n# Drop the packet\niptables -A INPUT -s $BLOCK_IP -j DROP\n\necho \"Rules added to block and log traffic from $BLOCK_IP\""}
{"instruction": "Write a Python script to check the security headers of a given website to ensure 'X-Frame-Options' and 'Strict-Transport-Security' are present.", "output": "import requests\n\ndef check_security_headers(url):\n    try:\n        response = requests.get(url)\n        headers = response.headers\n        \n        required_headers = ['X-Frame-Options', 'Strict-Transport-Security']\n        \n        print(f\"Scanning headers for: {url}\")\n        for header in required_headers:\n            if header in headers:\n                print(f\"[OK] {header}: {headers[header]}\")\n            else:\n                print(f\"[MISSING] {header} not found.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    check_security_headers('https://google.com')"}
{"instruction": "Generate a Bash script to apply network kernel hardening via sysctl, specifically disabling IP forwarding and ignoring ICMP echo requests (ping).", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.d/99-security.conf\"\n\ncat <<EOF > $SYSCTL_CONF\n# Disable IP Forwarding\nnet.ipv4.ip_forward = 0\n\n# Ignore ICMP Echo Requests (Disable Ping)\nnet.ipv4.icmp_echo_ignore_all = 1\n\n# Disable source packet routing\nnet.ipv4.conf.all.accept_source_route = 0\nEOF\n\n# Apply changes\nsysctl -p $SYSCTL_CONF\necho \"Network kernel hardening applied.\""}
{"instruction": "Create a Python script that parses '/var/log/auth.log' (or equivalent) to detect potential SSH brute force attacks by counting 'Failed password' attempts per user.", "output": "import re\n\ndef analyze_ssh_failures(log_path):\n    failures = {}\n    \n    with open(log_path, 'r') as f:\n        for line in f:\n            if \"Failed password\" in line:\n                # Extract username using regex\n                user_match = re.search(r'for (invalid user )?(\\w+) from', line)\n                if user_match:\n                    user = user_match.group(2)\n                    failures[user] = failures.get(user, 0) + 1\n\n    print(\"SSH Failed Login Attempts by User:\")\n    for user, count in failures.items():\n        print(f\"User: {user} | Failures: {count}\")\n\nif __name__ == \"__main__\":\n    # Note: Requires read permissions on auth.log\n    analyze_ssh_failures('/var/log/auth.log')"}
{"instruction": "Write a Bash script using 'nftables' to configure a basic stateful firewall that allows established connections, SSH, HTTP, and HTTPS, but drops everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Define table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH, HTTP, HTTPS\nnft add rule inet filter input tcp dport { 22, 80, 443 } accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"Nftables configured for stateful web/ssh access.\""}
{"instruction": "Develop a Python script to check for SSL/TLS certificate expiration dates for a list of domains to prevent security lapses.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domains):\n    context = ssl.create_default_context()\n    for domain in domains:\n        try:\n            with socket.create_connection((domain, 443)) as sock:\n                with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                    cert = ssock.getpeercert()\n                    expire_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n                    days_left = (expire_date - datetime.datetime.utcnow()).days\n                    print(f\"{domain}: Expires in {days_left} days ({expire_date})\")\n        except Exception as e:\n            print(f\"{domain}: Error checking SSL - {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(['google.com', 'github.com'])"}
{"instruction": "Create a Bash script to search for world-writable files on the system, which is a common server hardening task to prevent privilege escalation.", "output": "#!/bin/bash\n\necho \"Scanning for world-writable files (excluding /proc, /sys, /dev)...\"\n\n# Find files with write permission for 'others' (o+w)\n# -xdev prevents crossing filesystem boundaries\nfind / -xdev -type f -perm -0002 -print 2>/dev/null > world_writable_report.txt\n\necho \"Scan complete. Results saved to world_writable_report.txt\""}
{"instruction": "Write a Python script to parse a standard Apache/Nginx access log file and identify IP addresses that have generated more than 100 requests, which may indicate bot activity or a brute-force attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path):\n    ip_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"IPs with > 100 requests:\")\n        for ip, count in ip_counter.items():\n            if count > 100:\n                print(f\"{ip}: {count}\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script to harden the SSH daemon configuration by disabling root login, disabling empty passwords, and enforcing Protocol 2 to prevent unauthorized access.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Apply hardening configurations\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nsed -i 's/^#\\?PermitEmptyPasswords.*/PermitEmptyPasswords no/' $CONFIG_FILE\nsed -i 's/^#\\?Protocol.*/Protocol 2/' $CONFIG_FILE\nsed -i 's/^#\\?X11Forwarding.*/X11Forwarding no/' $CONFIG_FILE\n\n# Restart SSH service to apply changes\nif systemctl restart sshd; then\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Error restarting SSH. Restoring backup...\"\n    cp $BACKUP_FILE $CONFIG_FILE\n    systemctl restart sshd\nfi"}
{"instruction": "Write a Python utility to check if critical internal ports (22, 80, 443, 3306) are open on the localhost, useful for verifying firewall configurations or service availability.", "output": "import socket\n\ndef check_ports(ports):\n    print(f\"Scanning localhost for ports: {ports}\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex(('127.0.0.1', port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        else:\n            print(f\"Port {port}: CLOSED\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    target_ports = [22, 80, 443, 3306]\n    check_ports(target_ports)"}
{"instruction": "Generate a Bash script that reads a list of malicious IP addresses from a file named 'blacklist.txt' and adds an iptables DROP rule for each IP to block incoming traffic.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\n\nif [ ! -f \"$BLACKLIST_FILE\" ]; then\n    echo \"Blacklist file not found!\"\n    exit 1\nfi\n\necho \"Applying iptables DROP rules...\"\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    # Check if rule already exists to avoid duplicates\n    iptables -C INPUT -s \"$ip\" -j DROP 2>/dev/null\n    if [ $? -eq 1 ]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked: $ip\"\n    else\n        echo \"Already blocked: $ip\"\n    fi\ndone < \"$BLACKLIST_FILE\""}
{"instruction": "Create a Python script for File Integrity Monitoring (FIM) that calculates and prints the SHA-256 hash of specific system binaries (e.g., /bin/ls, /bin/ps) to detect potential tampering.", "output": "import hashlib\nimport os\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to handle large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\nfiles_to_monitor = ['/bin/ls', '/bin/ps', '/etc/passwd']\n\nprint(\"--- File Integrity Report ---\")\nfor file in files_to_monitor:\n    print(f\"{file}: {calculate_hash(file)}\")"}
{"instruction": "Write a Bash one-liner to parse /var/log/auth.log (or /var/log/secure) and list the top 10 IP addresses attempting failed SSH logins to identify brute-force sources.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{for(i=1;i<=NF;i++) if($i ~ /[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/) print $i}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Develop a Python script that generates a basic nftables configuration string allowing only SSH (port 22) and HTTP/HTTPS (80/443) traffic, dropping everything else by default.", "output": "def generate_nftables_config():\n    allowed_tcp_ports = [22, 80, 443]\n    ports_string = \", \".join(map(str, allowed_tcp_ports))\n    \n    config = f\"\"\"\n#!/usr/sbin/nft -f\n\nflush ruleset\n\ntable inet filter {{\n    chain input {{\n        type filter hook input priority 0; policy drop;\n        \n        # Accept localhost traffic\n        iifname \"lo\" accept\n        \n        # Accept traffic originated from us\n        ct state established,related accept\n        \n        # Allow specific TCP ports\n        tcp dport {{ {ports_string} }} accept\n        \n        # Allow ICMP (Ping)\n        ip protocol icmp accept\n    }}\n    chain forward {{\n        type filter hook forward priority 0; policy drop;\n    }}\n    chain output {{\n        type filter hook output priority 0; policy accept;\n    }}\n}}\n\"\"\"\n    return config\n\nif __name__ == \"__main__\":\n    print(generate_nftables_config())"}
{"instruction": "Write a Bash script to scan the /etc/shadow file and alert if any user account has an empty password field, which represents a critical security vulnerability.", "output": "#!/bin/bash\n\nif [ \"$(id -u)\" -ne 0 ]; then\n   echo \"This script must be run as root\"\n   exit 1\nfi\n\necho \"Scanning for accounts with empty passwords...\"\nawk -F: '($2 == \"\") {print \"WARNING: User \" $1 \" has an empty password!\"}' /etc/shadow\n\nif [ $? -eq 0 ]; then\n    echo \"Scan complete.\"\nfi"}
{"instruction": "Write a Python script to connect to a target server on a specified port and retrieve the service banner to identify the running software version for inventory and patch management purposes.", "output": "import socket\n\ndef grab_banner(ip, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(2)\n        s.connect((ip, port))\n        # Send a dummy byte to trigger a response if necessary\n        # s.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')\n        banner = s.recv(1024)\n        print(f\"Banner for {ip}:{port} -> {banner.decode('utf-8', errors='ignore').strip()}\")\n        s.close()\n    except Exception as e:\n        print(f\"Could not grab banner from {ip}:{port}. Error: {e}\")\n\nif __name__ == \"__main__\":\n    # Example: Check local SSH banner\n    grab_banner('127.0.0.1', 22)"}
{"instruction": "Create a Bash script to apply kernel-level network hardening by modifying sysctl settings to disable IP forwarding and ignore ICMP redirects, preventing Man-in-the-Middle attacks.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\necho \"Applying Kernel Hardening...\"\n\n# Define settings in an associative array\ndeclare -A settings\nsettings[\"net.ipv4.ip_forward\"]=\"0\"\nsettings[\"net.ipv4.conf.all.accept_redirects\"]=\"0\"\nsettings[\"net.ipv4.conf.default.accept_redirects\"]=\"0\"\nsettings[\"net.ipv4.conf.all.send_redirects\"]=\"0\"\nsettings[\"net.ipv4.icmp_echo_ignore_broadcasts\"]=\"1\"\n\nfor key in \"${!settings[@]}\"; do\n    value=\"${settings[$key]}\"\n    # Apply immediately\n    sysctl -w \"$key=$value\"\n    \n    # Persist in config file\n    if grep -q \"^$key\" \"$SYSCTL_CONF\"; then\n        sed -i \"s/^$key.*/$key = $value/\" \"$SYSCTL_CONF\"\n    else\n        echo \"$key = $value\" >> \"$SYSCTL_CONF\"\n    fi\ndone\n\necho \"Kernel parameters updated.\""}
{"instruction": "Create a Python script for Log Analysis that parses a web server log file (e.g., access.log) to identify IP addresses that have generated more than 100 requests, indicating potential bot activity or a DoS attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file_path, threshold=100):\n    ip_pattern = r'\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b'\n    ip_counter = Counter()\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                match = re.search(ip_pattern, line)\n                if match:\n                    ip_counter[match.group()] += 1\n        \n        print(f'IPs exceeding {threshold} requests:')\n        for ip, count in ip_counter.items():\n            if count > threshold:\n                print(f'{ip}: {count}')\n    except FileNotFoundError:\n        print('Log file not found.')\n\nif __name__ == '__main__':\n    analyze_logs('/var/log/nginx/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that locks down the SSH configuration by disabling root login and enforcing empty password checks.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"${SSHD_CONFIG}.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Prevent empty passwords\nif grep -q \"^PermitEmptyPasswords\" $SSHD_CONFIG; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\nelse\n    echo \"PermitEmptyPasswords no\" >> $SSHD_CONFIG\nfi\n\n# Restart SSH service\nsystemctl restart sshd\necho \"SSH Hardening applied.\""}
{"instruction": "Create a Python script for Vulnerability Scanning that checks the local system for listening ports and identifies if any non-standard or potentially insecure ports (like 21 or 23) are open.", "output": "import socket\n\ndef check_ports(target_ip, ports):\n    print(f'Scanning {target_ip} for insecure ports...')\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f'[!] Port {port} is OPEN (Potential Risk)')\n        else:\n            print(f'[-] Port {port} is closed')\n        sock.close()\n\nif __name__ == '__main__':\n    # Checking localhost for Telnet (23), FTP (21), and HTTP (80)\n    insecure_ports = [21, 23, 80]\n    check_ports('127.0.0.1', insecure_ports)"}
{"instruction": "Write a Bash script to generate IPTables Firewall rules that block a specific list of malicious IP addresses read from a text file called 'blacklist.txt'.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\n\nif [ ! -f \"$BLACKLIST_FILE\" ]; then\n    echo \"Blacklist file not found!\"\n    exit 1\nfi\n\necho \"Applying firewall rules...\"\n\nwhile IFS= read -r ip\ndo\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    # Drop traffic from IP\n    iptables -A INPUT -s \"$ip\" -j DROP\n    echo \"Blocked: $ip\"\ndone < \"$BLACKLIST_FILE\"\n\n# Save rules (Debian/Ubuntu based example)\nnetfilter-persistent save"}
{"instruction": "Create a Python script for File Integrity Monitoring (Hardening) that calculates SHA-256 hashes of critical system files to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/ssh/sshd_config']\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            for byte_block in iter(lambda: f.read(4096), b''):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\nprint('--- File Integrity Report ---')\nfor file in critical_files:\n    file_hash = calculate_hash(file)\n    if file_hash:\n        print(f'{file}: {file_hash}')\n    else:\n        print(f'{file}: ACCESS DENIED or NOT FOUND')"}
{"instruction": "Write a Bash script for Log Analysis using 'grep' and 'awk' to extract failed SSH login attempts from '/var/log/auth.log' and count the occurrences per user.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found.\"\n    exit 1\nfi\n\necho \"Failed SSH Login Attempts by User:\"\n\n# Filter for 'Failed password', extract the username (usually field 9 or 11 depending on format), sort and count\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | sort | uniq -c | sort -nr"}
{"instruction": "Create a Python script to automate NFTables firewall rule generation. The script should output a JSON configuration to allow SSH and HTTP, but drop everything else.", "output": "import json\n\ndef generate_nftables_config():\n    nft_config = {\n        \"nftables\": [\n            {\"flush\": {\"ruleset\": None}},\n            {\"table\": {\"family\": \"inet\", \"name\": \"filter\"}},\n            {\"chain\": {\"family\": \"inet\", \"table\": \"filter\", \"name\": \"input\", \"type\": \"filter\", \"hook\": \"input\", \"prio\": 0, \"policy\": \"drop\"}},\n            {\"rule\": {\"family\": \"inet\", \"table\": \"filter\", \"chain\": \"input\", \"expr\": [{\"match\": {\"op\": \"==\", \"left\": {\"meta\": {\"key\": \"ct state\"}}, \"right\": {\"set\": [\"established\", \"related\"]}}}, {\"accept\": None}]}},\n            {\"rule\": {\"family\": \"inet\", \"table\": \"filter\", \"chain\": \"input\", \"expr\": [{\"match\": {\"op\": \"==\", \"left\": {\"payload\": {\"protocol\": \"tcp\", \"field\": \"dport\"}}, \"right\": 22}}, {\"accept\": None}]}},\n            {\"rule\": {\"family\": \"inet\", \"table\": \"filter\", \"chain\": \"input\", \"expr\": [{\"match\": {\"op\": \"==\", \"left\": {\"payload\": {\"protocol\": \"tcp\", \"field\": \"dport\"}}, \"right\": 80}}, {\"accept\": None}]}}\n        ]\n    }\n    return json.dumps(nft_config, indent=4)\n\nif __name__ == '__main__':\n    print(generate_nftables_config())"}
{"instruction": "Write a Bash script for Server Hardening that searches for files with SUID or SGID bits set, which can be dangerous if misconfigured, and saves the list to a file.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_sgid_audit.txt\"\n\necho \"Scanning for SUID/SGID files...\"\necho \"Scan started at $(date)\" > \"$OUTPUT_FILE\"\n\n# Find files with SUID (4000) or SGID (2000) permissions\nfind / -type f \\( -perm -4000 -o -perm -2000 \\) -print 2>/dev/null >> \"$OUTPUT_FILE\"\n\necho \"Scan complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Create a Python script for SIEM-style analysis that detects basic SQL Injection patterns in a provided log string.", "output": "import re\n\ndef detect_sqli(log_line):\n    # Regex for common SQLi indicators (union select, OR 1=1, comment sequence)\n    sqli_patterns = [\n        r\"(?i)union\\s+select\",\n        r\"(?i)'\\s*or\\s*'1'='1\",\n        r\"(?i)'\\s*or\\s*1=1\",\n        r\"--\",\n        r\";\\s*DROP\\s+TABLE\"\n    ]\n    \n    detected = False\n    for pattern in sqli_patterns:\n        if re.search(pattern, log_line):\n            print(f\"[ALERT] SQL Injection pattern detected: {pattern}\")\n            detected = True\n            \n    if not detected:\n        print(\"[INFO] No obvious SQLi patterns found.\")\n\n# Example Usage\nsample_log = \"GET /login.php?user=admin' OR '1'='1 HTTP/1.1\"\ndetect_sqli(sample_log)"}
{"instruction": "Write a Bash script for Vulnerability Scanning (Audit) that checks if the system has any unapplied security updates (specifically for Debian/Ubuntu systems).", "output": "#!/bin/bash\n\necho \"Checking for available security updates...\"\n\n# Update package lists without upgrading\napt-get update > /dev/null 2>&1\n\n# Simulate an upgrade and grep for security specific repositories\nsecurity_updates=$(apt-get -s upgrade | grep -i \"security\")\n\nif [ ! -z \"$security_updates\" ]; then\n    echo \"[!] Security updates are available:\"\n    apt-listchanges --which=security --headers -f text $(apt-get -s -o Debug::NoLocking=true upgrade | grep \"^Inst\" | awk '{print $2}') 2>/dev/null\n    echo \"Run 'apt-get upgrade' to apply.\"\nelse\n    echo \"[OK] System appears to be up-to-date regarding security patches.\"\nfi"}
{"instruction": "Write a Python script to scan a specific target IP for open ports within a defined range (e.g., 20-1024) using the socket library. This is a basic network discovery task.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: Open\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example usage: scan localhost ports 20-80\n    scan_ports(\"127.0.0.1\", 20, 80)"}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and enforcing empty password checks on a Linux server.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Empty Passwords\nsed -i 's/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\nsed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\n\n# Reload SSH service to apply changes\nsystemctl reload sshd\n\necho \"SSH hardening complete. Root login disabled.\""}
{"instruction": "Develop a Python script for log analysis that parses a standard Linux auth.log file to identify and count the number of failed password attempts by IP address.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_auth_log(log_path):\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from lines containing 'Failed password'\n    # Example line: ... Failed password for invalid user root from 192.168.1.5 port ...\n    pattern = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(f\"Log file {log_path} not found.\")\n        return\n\n    print(\"Failed Login Attempts by IP:\")\n    for ip, count in sorted(failed_attempts.items(), key=lambda item: item[1], reverse=True):\n        print(f\"{ip}: {count}\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log('/var/log/auth.log')"}
{"instruction": "Write a Bash script to configure iptables firewall rules that flush existing rules, set default policies to DROP for Input/Forward, and allow established connections and SSH traffic.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default chain policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH (adjust port if necessary)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\n\necho \"Firewall rules configured.\""}
{"instruction": "Create a Python script to check the SSL/TLS certificate expiration date of a given domain name to ensure timely renewal.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    \n    # Set timeout for connection\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        # Parse the 'notAfter' date format: May 30 12:00:00 2025 GMT\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, r'%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.utcnow()).days\n        print(f\"Domain: {hostname}\")\n        print(f\"Expires on: {expire_date}\")\n        print(f\"Days remaining: {days_remaining}\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.google.com\")"}
{"instruction": "Write a Bash one-liner script to analyze an Nginx access log and output the top 10 IP addresses making requests, sorted by frequency.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [ -f \"$LOG_FILE\" ]; then\n    echo \"Top 10 Source IPs:\"\n    # Assuming standard Nginx log format where IP is the first field ($1)\n    awk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10\nelse\n    echo \"Log file not found.\"\nfi"}
{"instruction": "Develop a Python script to check if a list of websites implements basic security headers (X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security).", "output": "import requests\n\ndef check_security_headers(url):\n    required_headers = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        print(f\"Analyzing headers for: {url}\")\n        missing = []\n        for header in required_headers:\n            if header in response.headers:\n                print(f\"[OK] {header}: {response.headers[header]}\")\n            else:\n                print(f\"[MISSING] {header}\")\n                missing.append(header)\n        \n        if not missing:\n            print(\"All basic security headers present.\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to connect to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    check_security_headers(\"https://www.google.com\")"}
{"instruction": "Create a Bash script that uses 'nftables' to create a table and chain that drops all traffic from a specific blacklist of IP addresses.", "output": "#!/bin/bash\n\nBLACKLIST_IPS=(\"192.0.2.1\" \"198.51.100.5\")\n\n# Create table and chain if they don't exist\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add drop rules for blacklisted IPs\nfor ip in \"${BLACKLIST_IPS[@]}\"; do\n    echo \"Blocking IP: $ip\"\n    nft add rule inet filter input ip saddr $ip drop\ndone\n\n# List rules to verify\nnft list ruleset"}
{"instruction": "Write a Python script to audit file permissions of critical system files (e.g., /etc/shadow, /etc/passwd) and report if they are too permissive (e.g., world-writable).", "output": "import os\nimport stat\n\ndef check_permissions(file_path, max_perm_octal):\n    try:\n        st = os.stat(file_path)\n        # Get current permissions in octal\n        current_perm = oct(st.st_mode & 0o777)\n        \n        # Check if world writable\n        if st.st_mode & stat.S_IWOTH:\n            print(f\"[ALERT] {file_path} is World Writable! ({current_perm})\")\n        # Check if permissions exceed max allowed (simple octal comparison)\n        elif int(current_perm, 8) > int(str(max_perm_octal), 8):\n             print(f\"[WARN] {file_path} permissions {current_perm} are looser than recommended {max_perm_octal}\")\n        else:\n            print(f\"[OK] {file_path} ({current_perm})\")\n            \n    except FileNotFoundError:\n        print(f\"[ERROR] File {file_path} not found.\")\n\nif __name__ == \"__main__\":\n    # /etc/shadow should strictly be 600 or 640 depending on distro, 000 is strict baseline for logic check\n    check_permissions(\"/etc/shadow\", 600)\n    check_permissions(\"/etc/passwd\", 644)"}
{"instruction": "Create a Bash script to disable unused filesystems (like cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs) to reduce the attack surface of the server.", "output": "#!/bin/bash\n\nFILESYSTEMS=\"cramfs freevxfs jffs2 hfs hfsplus squashfs udf\"\n\necho \"Disabling unused filesystems...\"\n\nfor fs in $FILESYSTEMS; do\n    # Check if module is already disabled\n    if ! modprobe -n -v $fs | grep -q \"install /bin/true\"; then\n        echo \"install $fs /bin/true\" >> /etc/modprobe.d/disable-filesystems.conf\n        echo \"Disabled $fs\"\n    else\n        echo \"$fs already disabled\"\n    fi\ndone\n\necho \"Configuration updated. Unused filesystems prevent loading.\""}
{"instruction": "Create a Python script to scan a target IP address for open ports (20-1024) using the socket library. This is a basic vulnerability scanning task.", "output": "import socket\n\ntarget_ip = '192.168.1.10'\n\ndef scan_ports(ip):\n    print(f'Scanning {ip}...')\n    for port in range(20, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f'Port {port}: Open')\n        sock.close()\n\nif __name__ == '__main__':\n    scan_ports(target_ip)"}
{"instruction": "Write a Bash script to analyze '/var/log/auth.log' and identify IP addresses with more than 5 failed SSH login attempts. This is a SIEM/Log Analysis task.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"IPs with more than $THRESHOLD failed login attempts:\"\n\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"$ip - $count attempts\"\n    fi\ndone"}
{"instruction": "Generate a Bash script to configure iptables firewall rules that drop all incoming traffic by default, but allow SSH (port 22), HTTP (port 80), and HTTPS (port 443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, and HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional)\niptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Create a Python script that parses a web server access log (Common Log Format) to detect potential SQL injection attempts by looking for common patterns in the request URL.", "output": "import re\n\nlog_file_path = 'access.log'\nsqli_patterns = [r\"'\", r\"--\", r\"UNION\", r\"SELECT\", r\"SLEEP\", r\"1=1\"]\n\ndef detect_sqli(log_path):\n    with open(log_path, 'r') as file:\n        for line in file:\n            # Basic CLF parsing to extract the request\n            match = re.search(r'\"(GET|POST) (.*?) HTTP/', line)\n            if match:\n                request_url = match.group(2)\n                for pattern in sqli_patterns:\n                    if re.search(pattern, request_url, re.IGNORECASE):\n                        print(f\"[ALERT] Potential SQLi detected: {line.strip()}\")\n                        break\n\nif __name__ == '__main__':\n    detect_sqli(log_file_path)"}
{"instruction": "Write a Bash script for server hardening that disables root login via SSH, disables password authentication, and restarts the SSH service.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"$SSH_CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSH_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSH_CONFIG\n\n# Restart SSH service\nif command -v systemctl &> /dev/null; then\n    systemctl restart sshd\nelse\n    service ssh restart\nfi\n\necho \"SSH hardening applied.\""}
{"instruction": "Create a Python script to check the SSL/TLS certificate expiration date for a list of domains. This helps in vulnerability/configuration monitoring.", "output": "import ssl\nimport socket\nimport datetime\n\ndomains = ['google.com', 'github.com', 'example.com']\n\ndef check_ssl_expiry(domain):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    conn.settimeout(3.0)\n    try:\n        conn.connect((domain, 443))\n        cert = conn.getpeercert()\n        expiry_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n        days_left = (expiry_date - datetime.datetime.now()).days\n        print(f\"{domain}: Expires in {days_left} days ({expiry_date})\")\n    except Exception as e:\n        print(f\"{domain}: Error - {e}\")\n    finally:\n        conn.close()\n\nfor d in domains:\n    check_ssl_expiry(d)"}
{"instruction": "Generate a Bash script using nftables to block a specific list of malicious IP addresses read from a text file named 'blacklist.txt'.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\nSET_NAME=\"blocked_ips\"\n\n# Initialize nftables structure if not exists\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\nnft add set ip $TABLE_NAME $SET_NAME { type ipv4_addr \\; }\n\n# Add rule to drop traffic from IPs in the set\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr @$SET_NAME drop\n\n# Populate the set from file\nif [[ -f \"$BLACKLIST_FILE\" ]]; then\n    while read ip; do\n        # Skip comments and empty lines\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        nft add element ip $TABLE_NAME $SET_NAME { $ip }\n        echo \"Blocked: $ip\"\n    done < \"$BLACKLIST_FILE\"\nelse\n    echo \"Blacklist file not found.\"\nfi"}
{"instruction": "Write a Python script that calculates the SHA-256 hash of all files in a specific directory to establish a baseline for File Integrity Monitoring (FIM).", "output": "import os\nimport hashlib\nimport json\n\ndirectory_to_scan = '/etc/nginx'\noutput_file = 'fim_baseline.json'\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\nbaseline = {}\n\nfor root, dirs, files in os.walk(directory_to_scan):\n    for file in files:\n        path = os.path.join(root, file)\n        file_hash = calculate_hash(path)\n        if file_hash:\n            baseline[path] = file_hash\n\nwith open(output_file, 'w') as f:\n    json.dump(baseline, f, indent=4)\n\nprint(f\"Baseline generated for {len(baseline)} files.\")"}
{"instruction": "Create a Bash script to search for World-Writable files on the system, which is a common server hardening and vulnerability assessment task.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"world_writable_files.txt\"\n\necho \"Scanning for world-writable files...\"\n\n# Find files with write permission for 'others', excluding proc, sys, and dev directories to avoid errors\nfind / -xdev -type f -perm -0002 -print > \"$OUTPUT_FILE\" 2>/dev/null\n\nCOUNT=$(wc -l < \"$OUTPUT_FILE\")\n\necho \"Scan complete. Found $COUNT world-writable files.\"\necho \"List saved to $OUTPUT_FILE\""}
{"instruction": "Write a Python script using the 'requests' library to check if a website has security headers (X-Frame-Options, Content-Security-Policy, Strict-Transport-Security) enabled.", "output": "import requests\n\ntarget_url = 'https://example.com'\nsecurity_headers = [\n    'X-Frame-Options',\n    'Content-Security-Policy',\n    'Strict-Transport-Security',\n    'X-Content-Type-Options'\n]\n\ntry:\n    response = requests.get(target_url)\n    print(f\"Checking headers for {target_url}...\")\n    for header in security_headers:\n        if header in response.headers:\n            print(f\"[OK] {header}: {response.headers[header]}\")\n        else:\n            print(f\"[MISSING] {header}\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error connecting to target: {e}\")"}
{"instruction": "Write a Python script to perform a basic TCP port scan on a specific target IP address (e.g., localhost) for a range of ports (1-1024) to identify open services.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"[+] Port {port} is OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Scan localhost for demonstration\n    scan_ports(\"127.0.0.1\", 1, 1024)"}
{"instruction": "Create a Bash script to parse `/var/log/auth.log` and extract the top 10 IP addresses associated with failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Error: Log file $LOG_FILE not found.\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\n# Filter for 'Failed password', extract the IP (usually 4th from end), count unique, sort descending\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Bash script to configure `iptables` firewall rules that drop all incoming traffic by default, but allow loopback, established connections, SSH (port 22), and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies: Drop Input/Forward, Accept Output\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules configured successfully.\""}
{"instruction": "Write a Python script for server hardening that recursively checks a given directory for files that are world-writable and prints their paths.", "output": "import os\nimport stat\nimport sys\n\ndef check_world_writable(directory):\n    print(f\"Checking for world-writable files in: {directory}\")\n    for root, dirs, files in os.walk(directory):\n        for name in files:\n            filepath = os.path.join(root, name)\n            try:\n                file_stat = os.stat(filepath)\n                # Check if the 'others' write bit is set\n                if file_stat.st_mode & stat.S_IWOTH:\n                    print(f\"[WARNING] World-writable file found: {filepath}\")\n            except OSError as e:\n                print(f\"[ERROR] Could not access {filepath}: {e}\")\n\nif __name__ == \"__main__\":\n    target_dir = sys.argv[1] if len(sys.argv) > 1 else \"/tmp\"\n    check_world_writable(target_dir)"}
{"instruction": "Create a Bash script to harden the SSH configuration by ensuring `PermitRootLogin` is set to `no` in `/etc/ssh/sshd_config` and then reloading the SSH service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\n\n# Check if PermitRootLogin exists\nif grep -q \"^PermitRootLogin\" \"$SSHD_CONFIG\"; then\n    # Modify existing line\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nelse\n    # Append if not found\n    echo \"PermitRootLogin no\" >> \"$SSHD_CONFIG\"\nfi\n\necho \"PermitRootLogin set to 'no'. reloading sshd...\"\nsystemctl reload sshd"}
{"instruction": "Write a Python script to analyze an Apache access log file and identify IP addresses that have generated more than a specified threshold of 404 (Not Found) errors.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_apache_404(log_path, threshold=10):\n    ip_counts = defaultdict(int)\n    # Regex to match standard Apache log format\n    # Example: 127.0.0.1 - - [10/Oct/2023...] \"GET /...\" 404 ...\n    log_pattern = re.compile(r'^(\\S+) .*? \"\\S+ .*?\" 404 ')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = log_pattern.match(line)\n                if match:\n                    ip = match.group(1)\n                    ip_counts[ip] += 1\n        \n        print(f\"IPs with > {threshold} 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"{ip}: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_apache_404(\"/var/log/apache2/access.log\")"}
{"instruction": "Write a Bash script to verify if any user account in `/etc/passwd` has a UID of 0 other than the root user, which indicates a potential security breach or misconfiguration.", "output": "#!/bin/bash\n\necho \"Scanning for non-root users with UID 0...\"\n\nwhile IFS=: read -r username password userid groupid comment homedir shell; do\n    if [ \"$userid\" -eq 0 ]; then\n        if [ \"$username\" != \"root\" ]; then\n            echo \"[ALERT] User '$username' has UID 0!\"\n        fi\n    fi\ndone < /etc/passwd\n\necho \"Scan complete.\""}
{"instruction": "Write a Python function that generates a basic `nftables` configuration string. The function should accept a list of allowed TCP ports and default to dropping all other incoming traffic.", "output": "def generate_nftables_config(allowed_ports):\n    ports_str = \", \".join(map(str, allowed_ports))\n    config = f\"\"\"\n#!/usr/sbin/nft -f\n\nflush ruleset\n\ntable inet filter {{\n    chain input {{\n        type filter hook input priority 0; policy drop;\n        \n        # Allow loopback\n        iifname \"lo\" accept\n        \n        # Allow established/related\n        ct state established,related accept\n        \n        # Allow specific TCP ports\n        tcp dport {{ {ports_str} }} accept\n        \n        # Allow ICMP (Ping)\n        ip protocol icmp accept\n    }}\n    chain forward {{\n        type filter hook forward priority 0; policy drop;\n    }}\n    chain output {{\n        type filter hook output priority 0; policy accept;\n    }}\n}}\n\"\"\"\n    return config\n\nif __name__ == \"__main__\":\n    print(generate_nftables_config([22, 80, 443]))"}
{"instruction": "Write a Bash script that lists all available security updates for a Debian/Ubuntu system without installing them, useful for audit reporting.", "output": "#!/bin/bash\n\n# Update package lists\nsudo apt-get update > /dev/null 2>&1\n\necho \"Checking for available security updates...\"\n\n# Simulate an upgrade and grep for security repositories\napt-get -s dist-upgrade | grep \"^Inst\" | grep -i \"security\"\n\nif [ $? -ne 0 ]; then\n    echo \"No immediate security updates found.\"\nfi"}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a specific hostname and port, alerting if it expires within 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443, buffer_days=30):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port), timeout=3) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse date format: 'Oct 10 12:00:00 2024 GMT'\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                remaining = expire_date - datetime.datetime.utcnow()\n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                \n                if remaining.days < buffer_days:\n                    print(f\"[ALERT] Certificate expires in {remaining.days} days!\")\n                else:\n                    print(f\"[OK] Certificate is valid for {remaining.days} more days.\")\n    except Exception as e:\n        print(f\"Error checking SSL: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"example.com\")"}
{"instruction": "Create a Python script to check the SSL/TLS certificate expiration date of a specific domain to identify potential security lapses.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expiry_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n                days_left = (expiry_date - datetime.datetime.now()).days\n                return f\"Certificate for {hostname} expires in {days_left} days.\"\n    except Exception as e:\n        return f\"Error checking {hostname}: {str(e)}\"\n\nprint(check_ssl_expiry('example.com'))"}
{"instruction": "Write a Bash command using iptables to immediately block all incoming traffic from a specific malicious IP address (e.g., 192.0.2.100).", "output": "sudo iptables -A INPUT -s 192.0.2.100 -j DROP"}
{"instruction": "Develop a Python script to parse a standard Apache access log and identify IP addresses that have generated more than 10 '404 Not Found' errors (indicative of scanning).", "output": "import re\nfrom collections import defaultdict\n\nlog_file = '/var/log/apache2/access.log'\nip_counts = defaultdict(int)\n\n# Regex to extract IP and status code\nlog_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s404\\s')\n\ntry:\n    with open(log_file, 'r') as f:\n        for line in f:\n            match = log_pattern.search(line)\n            if match:\n                ip = match.group(1)\n                ip_counts[ip] += 1\n\n    for ip, count in ip_counts.items():\n        if count > 10:\n            print(f\"Suspicious activity: {ip} generated {count} 404 errors.\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Create a Bash script to harden an SSH server by disabling root login and password authentication, forcing key-based auth.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"${SSHD_CONFIG}.bak\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Reload SSH service to apply changes\nsystemctl reload sshd\necho \"SSH hardening applied.\""}
{"instruction": "Write a Python script for local vulnerability auditing that scans the system for files with the SUID bit set, which could be used for privilege escalation.", "output": "import os\nimport stat\n\ndef find_suid_files(start_path='/'):\n    suid_files = []\n    print(f\"Scanning {start_path} for SUID files...\")\n    try:\n        for root, dirs, files in os.walk(start_path):\n            for name in files:\n                filepath = os.path.join(root, name)\n                try:\n                    if not os.path.islink(filepath):\n                        file_stat = os.stat(filepath)\n                        # Check if SUID bit is set\n                        if file_stat.st_mode & stat.S_ISUID:\n                            print(f\"SUID Found: {filepath}\")\n                except PermissionError:\n                    continue\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == '__main__':\n    # Scan usually restricted to /usr or /bin for demo speed\n    find_suid_files('/usr/bin')"}
{"instruction": "Write a Bash command using nftables to create a rule that allows established and related traffic, ensuring the firewall is stateful.", "output": "sudo nft add rule ip filter input ct state established,related accept"}
{"instruction": "Create a Python script to calculate the SHA-256 hash of a critical system file to verify its integrity (File Integrity Monitoring).", "output": "import hashlib\n\ndef calculate_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            # Read file in chunks to avoid memory issues\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found.\"\n\nfile_path = \"/bin/ls\"\nprint(f\"SHA-256 for {file_path}: {calculate_file_hash(file_path)}\")"}
{"instruction": "Use Bash commands to analyze the Linux 'auth.log' and count the number of failed SSH login attempts per IP address.", "output": "grep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr"}
{"instruction": "Develop a Python script to audit local listening ports and identify which non-standard ports are open (simple vulnerability surface scan).", "output": "import socket\n\ndef scan_local_ports(ports_to_scan):\n    open_ports = []\n    target = '127.0.0.1'\n    \n    for port in ports_to_scan:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Common and some non-standard ports\nports = [21, 22, 23, 80, 443, 8080, 8443, 9000]\nfound = scan_local_ports(ports)\nprint(f\"Open ports on localhost: {found}\")"}
{"instruction": "Write a Bash script to secure Cron jobs by ensuring only the root user has write permissions to the system-wide crontab and cron directories.", "output": "#!/bin/bash\n\n# Secure /etc/crontab\nchown root:root /etc/crontab\nchmod 600 /etc/crontab\n\n# Secure cron directories\nchmod 700 /etc/cron.d\nchmod 700 /etc/cron.daily\nchmod 700 /etc/cron.hourly\nchmod 700 /etc/cron.weekly\nchmod 700 /etc/cron.monthly\n\necho \"Cron permissions hardened.\""}
{"instruction": "Write a Python script to parse a standard Apache access log file ('access.log') and identify IP addresses that have generated more than 10 '404 Not Found' errors. Print the offending IPs.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_counter = Counter()\n    log_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s404\\s')\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"IPs with > 10 404 errors:\")\n        for ip, count in ip_counter.items():\n            if count > 10:\n                print(f\"{ip}: {count}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('access.log')"}
{"instruction": "Create a Bash script using 'iptables' to implement a basic firewall policy: flush existing rules, set default policies to DROP for Input/Forward and ACCEPT for Output, allow loopback traffic, allow established connections, and allow incoming SSH (port 22).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Basic firewall rules applied.\""}
{"instruction": "Write a Python script to audit the local system for listening ports. Use the 'socket' library to check ports 1 through 1024 on '127.0.0.1' and report which ports are open.", "output": "import socket\n\ndef scan_local_ports():\n    target = '127.0.0.1'\n    print(f\"Scanning {target} for open ports (1-1024)...\")\n    \n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            print(f\"Port {port}: OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    scan_local_ports()"}
{"instruction": "Develop a Bash script for server hardening that searches for files with '777' permissions (world writable/executable) inside the '/var/www/html' directory and changes them to '644' to secure the web root.", "output": "#!/bin/bash\n\nTARGET_DIR=\"/var/www/html\"\n\nif [ -d \"$TARGET_DIR\" ]; then\n    echo \"Scanning $TARGET_DIR for 777 permissions...\"\n    # Find files with 777 permissions and change to 644\n    find \"$TARGET_DIR\" -type f -perm 0777 -print -exec chmod 644 {} \\;\n    echo \"Permissions corrected.\"\nelse\n    echo \"Directory $TARGET_DIR does not exist.\"\nfi"}
{"instruction": "Write a Python script to calculate the SHA-256 hash of a specific critical system file (e.g., '/etc/passwd') to monitor for unauthorized changes (File Integrity Monitoring).", "output": "import hashlib\n\ndef calculate_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to handle large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nfile_path = \"/etc/passwd\"\nfile_hash = calculate_file_hash(file_path)\n\nif file_hash:\n    print(f\"SHA-256 hash of {file_path}: {file_hash}\")\nelse:\n    print(f\"File {file_path} not found.\")"}
{"instruction": "Create a Bash script using 'nftables' to block a specific IP address passed as an argument from accessing the server.", "output": "#!/bin/bash\n\nBLOCK_IP=$1\n\nif [ -z \"$BLOCK_IP\" ]; then\n    echo \"Usage: $0 <IP_ADDRESS>\"\n    exit 1\nfi\n\n# Create table and chain if they don't exist (idempotent check often required in full scripts, assuming standard setup here)\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop traffic from the IP\nnft add rule inet filter input ip saddr $BLOCK_IP drop\n\necho \"Blocked IP: $BLOCK_IP\""}
{"instruction": "Write a Python script to parse a JSON-formatted application log file. The script should extract and print the timestamp and message for any log entry where the 'level' is 'CRITICAL'.", "output": "import json\n\ndef parse_json_logs(logfile_path):\n    try:\n        with open(logfile_path, 'r') as f:\n            data = json.load(f)\n            # Assuming data is a list of log records\n            for entry in data:\n                if entry.get('level') == 'CRITICAL':\n                    print(f\"Time: {entry.get('timestamp')} | Message: {entry.get('message')}\")\n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Error processing log file: {e}\")\n\n# Example usage assuming logs.json exists\nif __name__ == \"__main__\":\n    # Create a dummy file for demonstration\n    with open('logs.json', 'w') as f:\n        json.dump([{\"timestamp\": \"2023-10-01T10:00:00\", \"level\": \"INFO\", \"message\": \"Start\"}, {\"timestamp\": \"2023-10-01T10:05:00\", \"level\": \"CRITICAL\", \"message\": \"DB Crash\"}], f)\n    \n    parse_json_logs('logs.json')"}
{"instruction": "Create a Bash script to audit user accounts. It should list all users in '/etc/passwd' who have a User ID (UID) of 0, which grants root privileges, to ensure no unauthorized root accounts exist.", "output": "#!/bin/bash\n\necho \"Checking for users with UID 0 (Root Privileges)...\"\n\n# Parse /etc/passwd, looking for the 3rd field (UID) equal to 0\nawk -F: '($3 == 0) {print \"User: \" $1 \" | UID: \" $3}' /etc/passwd\n\necho \"Audit complete. Only 'root' should normally appear here.\""}
{"instruction": "Write a Python script using the 'requests' library to check the HTTP headers of a given URL. It should verify if security headers like 'X-Frame-Options' and 'Strict-Transport-Security' are present.", "output": "import requests\n\ndef check_security_headers(url):\n    required_headers = ['X-Frame-Options', 'Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options']\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        \n        print(f\"Scanning headers for: {url}\")\n        for h in required_headers:\n            if h in headers:\n                print(f\"[+] {h}: Present\")\n            else:\n                print(f\"[-] {h}: Missing\")\n                \n    except requests.exceptions.RequestException as e:\n        print(f\"Connection error: {e}\")\n\nif __name__ == \"__main__\":\n    check_security_headers('https://www.google.com')"}
{"instruction": "Develop a Bash script to harden SSH configuration. The script should back up '/etc/ssh/sshd_config', disable password authentication (enforcing key-based auth), and disable root login, then reload the sshd service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\n\n# Backup existing config\ncp $CONFIG_FILE $BACKUP_FILE\necho \"Backup created at $BACKUP_FILE\"\n\n# Disable Password Authentication\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Validate config syntax before restarting\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardened and service reloaded.\"\nelse\n    echo \"Configuration test failed. Restoring backup...\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python script for Security Operations that parses an Apache access log to identify and count IP addresses generating high volumes of 404 errors, which may indicate a directory enumeration attack.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file, threshold=10):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    status_pattern = r'\\\" 404 '\n    suspicious_ips = []\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if re.search(status_pattern, line):\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        suspicious_ips.append(match.group(1))\n\n        ip_counts = Counter(suspicious_ips)\n        print(f\"IPs with > {threshold} 404 errors:\")\n        for ip, count in ip_counts.items():\n            if count > threshold:\n                print(f\"{ip}: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script to harden a Linux server by setting up a basic stateful firewall using iptables. The policy should drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default chain policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow traffic on loopback interface\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow incoming SSH (adjust port if necessary)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (optional, rate limited)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\necho \"Basic firewall configured.\""}
{"instruction": "Write a Python script to check the integrity of critical system configuration files (e.g., /etc/passwd, /etc/shadow) by calculating their SHA-256 hashes and comparing them against a known baseline dictionary.", "output": "import hashlib\nimport os\n\n# Baseline dictionary (In production, this should be stored securely/remotely)\nBASELINE = {\n    '/etc/passwd': 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', # Example hash\n    '/etc/hosts': '87ac44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'  # Example hash\n}\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\ndef check_integrity():\n    print(\"Starting File Integrity Check...\")\n    for filepath, known_hash in BASELINE.items():\n        current_hash = calculate_sha256(filepath)\n        if current_hash is None:\n            print(f\"[!] MISSING: {filepath}\")\n        elif current_hash != known_hash:\n            print(f\"[!] MODIFIED: {filepath} (Hash mismatch)\")\n        else:\n            print(f\"[+] OK: {filepath}\")\n\nif __name__ == \"__main__\":\n    check_integrity()"}
{"instruction": "Generate a Bash script for server hardening that disables root login over SSH and enforces protocol version 2 in the sshd_config file.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Create backup\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nelse\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Enforce Protocol 2\nif grep -q \"^Protocol\" $CONFIG_FILE; then\n    sed -i 's/^Protocol.*/Protocol 2/' $CONFIG_FILE\nelse\n    echo \"Protocol 2\" >> $CONFIG_FILE\nfi\n\n# Validate config syntax before restart\nsshd -t\nif [ $? -eq 0 ]; then\n    echo \"Configuration valid. Restarting SSH service...\"\n    systemctl restart sshd\n    echo \"SSH Hardening complete.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Write a Python utility to perform a basic vulnerability assessment by checking installed pip packages against a list of known vulnerable package versions.", "output": "import subprocess\nimport json\n\n# Example database of known bad versions\nVULN_DB = {\n    'requests': ['2.0.0', '2.1.0'],\n    'flask': ['0.12']\n}\n\ndef check_pip_vulnerabilities():\n    try:\n        # Get installed packages in JSON format\n        result = subprocess.run(['pip', 'list', '--format=json'], capture_output=True, text=True)\n        installed_packages = json.loads(result.stdout)\n        \n        issues_found = False\n        print(\"Scanning installed pip packages for known vulnerabilities...\")\n        \n        for pkg in installed_packages:\n            name = pkg['name']\n            version = pkg['version']\n            \n            if name in VULN_DB:\n                if version in VULN_DB[name]:\n                    print(f\"[ALERT] Vulnerable package found: {name} version {version}\")\n                    issues_found = True\n        \n        if not issues_found:\n            print(\"No known vulnerabilities found in defined database.\")\n            \n    except Exception as e:\n        print(f\"Error running scan: {e}\")\n\nif __name__ == \"__main__\":\n    check_pip_vulnerabilities()"}
{"instruction": "Create a Bash script to analyze the Linux authentication log (/var/log/auth.log) and extract the top 5 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found at $LOG_FILE\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\n\n# Grep for 'Failed password', extract IP, sort, count unique, sort by count descending, head 5\ngrep \"Failed password for\" $LOG_FILE | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Write a Python script using the 'socket' library to act as a local port scanner/auditor. It should scan a defined range of ports on 'localhost' to verify which services are listening.", "output": "import socket\n\ndef audit_local_ports(start_port, end_port):\n    target = '127.0.0.1'\n    print(f\"Auditing open ports on {target} from {start_port} to {end_port}...\")\n    \n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    if open_ports:\n        print(f\"Open ports found: {open_ports}\")\n    else:\n        print(\"No open ports found in range.\")\n\nif __name__ == \"__main__\":\n    # Scan common ports range\n    audit_local_ports(20, 1024)"}
{"instruction": "Generate a Bash script using 'nftables' to block a specific malicious IP address and log any attempts by that IP to connect.", "output": "#!/bin/bash\n\nBLOCK_IP=\"192.168.1.100\" # Example Bad IP\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Ensure the table and chain exist (basic setup)\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\n# Add rule to log traffic from the IP\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr $BLOCK_IP log prefix \\\"NFT-Blocked: \\\"\n\n# Add rule to drop traffic from the IP\nnft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr $BLOCK_IP drop\n\necho \"Blocked and configured logging for IP: $BLOCK_IP\""}
{"instruction": "Write a Python script to parse a generic JSON-formatted application log file and alert if a specific error keyword (e.g., 'SQL_ERROR' or 'UNAUTHORIZED_ACCESS') appears.", "output": "import json\nimport sys\n\ndef parse_json_logs(logfile, keyword):\n    alerts = []\n    try:\n        with open(logfile, 'r') as f:\n            # Assuming one JSON object per line (JSONL)\n            for line_num, line in enumerate(f, 1):\n                try:\n                    entry = json.loads(line)\n                    # Convert whole entry to string to search for keyword\n                    if keyword in str(entry):\n                        alerts.append((line_num, entry))\n                except json.JSONDecodeError:\n                    continue\n        \n        if alerts:\n            print(f\"[ALERT] Found '{keyword}' {len(alerts)} times:\")\n            for ln, content in alerts:\n                print(f\"Line {ln}: {content}\")\n        else:\n            print(f\"No instances of '{keyword}' found.\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Usage: python script.py app.log SQL_ERROR\n    if len(sys.argv) < 3:\n        print(\"Usage: python scan_log.py <logfile> <keyword>\")\n    else:\n        parse_json_logs(sys.argv[1], sys.argv[2])"}
{"instruction": "Create a Bash script for server hardening that scans the file system for world-writable files and directories, which are a security risk, and saves the list to a report file.", "output": "#!/bin/bash\n\nREPORT_FILE=\"world_writable_report.txt\"\nSEARCH_PATH=\"/\"\n\necho \"Starting scan for world-writable files and directories...\"\necho \"Scan started at $(date)\" > $REPORT_FILE\n\n# Find files (-type f) that are world writable (-perm -0002)\n# Exclude /proc, /sys, and /dev to avoid virtual fs errors\necho \"--- World Writable Files ---\" >> $REPORT_FILE\nfind $SEARCH_PATH -xdev -type f -perm -0002 -print >> $REPORT_FILE 2>/dev/null\n\necho \"\" >> $REPORT_FILE\n\n# Find directories (-type d) that are world writable\necho \"--- World Writable Directories ---\" >> $REPORT_FILE\nfind $SEARCH_PATH -xdev -type d -perm -0002 -print >> $REPORT_FILE 2>/dev/null\n\necho \"Scan complete. Results saved to $REPORT_FILE\""}
{"instruction": "Create a Bash script to harden SSH configuration on a Linux server by disabling root login and enforcing key-based authentication (disabling password auth), then reloading the SSH service.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"$SSH_CONFIG.bak\"\n\n# Disable Root Login\nsed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' $SSH_CONFIG\n\n# Ensure PubkeyAuthentication is yes\nsed -i 's/^#*PubkeyAuthentication.*/PubkeyAuthentication yes/' $SSH_CONFIG\n\n# Validate syntax and reload\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp \"$SSH_CONFIG.bak\" $SSH_CONFIG\nfi"}
{"instruction": "Write a Python script to parse an Apache access log file and identify IP addresses that have generated more than 50 '404 Not Found' errors, potentially indicating a vulnerability scan.", "output": "import re\nfrom collections import Counter\n\nLOG_FILE = '/var/log/apache2/access.log'\nTHRESHOLD = 50\n\ndef analyze_logs():\n    ip_counter = Counter()\n    # Regex to capture IP and Status Code (Standard Combined Format)\n    log_pattern = re.compile(r'^(\\S+) .*? \"[A-Z]+ .*? HTTP/[0-9.]+\" (404) ')\n\n    try:\n        with open(LOG_FILE, 'r') as f:\n            for line in f:\n                match = log_pattern.match(line)\n                if match:\n                    ip = match.group(1)\n                    ip_counter[ip] += 1\n\n        print(f\"IPs with > {THRESHOLD} 404 errors:\")\n        for ip, count in ip_counter.items():\n            if count > THRESHOLD:\n                print(f\"{ip}: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs()"}
{"instruction": "Generate a Bash script to configure `iptables` firewall rules: set default policies to DROP, allow loopback, allow established connections, and allow incoming SSH (port 22) and HTTP (port 80).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Save rules (Debian/Ubuntu style)\nnetfilter-persistent save\n\necho \"Firewall rules configured.\""}
{"instruction": "Create a Python script to audit a list of internal servers to check if the insecure Telnet port (23) is open.", "output": "import socket\n\nservers = ['192.168.1.10', '192.168.1.11', '192.168.1.12']\nport = 23\n\ndef check_telnet(server_list):\n    print(\"Starting Telnet Audit...\")\n    for ip in server_list:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f\"[ALERT] Telnet (Port 23) is OPEN on {ip}\")\n        else:\n            print(f\"[OK] Telnet is closed on {ip}\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    check_telnet(servers)"}
{"instruction": "Write a Bash script to scan the `/etc` directory for files that are world-writable (a security risk) and remove the write permission for 'others'.", "output": "#!/bin/bash\n\necho \"Scanning /etc for world-writable files...\"\n\n# Find files in /etc that are writable by others (o+w)\n# -type f: files only\n# -perm -002: check for write bit on others\n\nfind /etc -type f -perm -002 -print | while read file; do\n    echo \"Fixing permissions on: $file\"\n    chmod o-w \"$file\"\ndone\n\necho \"Remediation complete.\""}
{"instruction": "Develop a Python script using `psutil` to verify that specific security agents (e.g., SplunkForwarder, CrowdStrike) are running, and alert if they are missing.", "output": "import psutil\n\nREQUIRED_PROCESSES = ['splunkd', 'falcon-sensor']\n\ndef check_security_agents():\n    running_procs = {p.name() for p in psutil.process_iter(['name'])}\n    \n    missing_agents = []\n    for agent in REQUIRED_PROCESSES:\n        if agent not in running_procs:\n            missing_agents.append(agent)\n    \n    if missing_agents:\n        print(f\"[CRITICAL] The following security agents are NOT running: {', '.join(missing_agents)}\")\n    else:\n        print(\"[OK] All security agents are active.\")\n\nif __name__ == \"__main__\":\n    check_security_agents()"}
{"instruction": "Create a Bash script using `nftables` to create a blacklist set and drop traffic from a specific list of malicious IP addresses.", "output": "#!/bin/bash\n\n# Initialize table and chain\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Create a set for blacklisted IPs\nnft add set ip filter blacklist { type ipv4_addr \\; }\n\n# Add rule to drop traffic from IPs in the blacklist set\nnft add rule ip filter input ip saddr @blacklist drop\n\n# Populate the set with malicious IPs\nBAD_IPS=(\"192.0.2.55\" \"198.51.100.23\" \"203.0.113.10\")\n\nfor ip in \"${BAD_IPS[@]}\"; do\n    nft add element ip filter blacklist { $ip }\n    echo \"Blocked $ip\"\ndone"}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a remote domain and warn if it expires in less than 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    \n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        # Parse end date (e.g., 'May 25 12:00:00 2024 GMT')\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.now()).days\n        \n        if days_remaining < 30:\n            print(f\"[WARNING] Certificate for {hostname} expires in {days_remaining} days!\")\n        else:\n            print(f\"[OK] Certificate for {hostname} is valid for {days_remaining} days.\")\n            \n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    check_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script to audit user accounts by listing any user with UID 0 (root privileges) other than 'root', and checking for accounts with empty password fields in `/etc/shadow`.", "output": "#!/bin/bash\n\necho \"--- Checking for non-root users with UID 0 ---\"\nawk -F: '($3 == 0) {print}' /etc/passwd | while read user_line; do\n    username=$(echo $user_line | cut -d: -f1)\n    if [ \"$username\" != \"root\" ]; then\n        echo \"[ALERT] User '$username' has UID 0!\"\n    fi\ndone\n\necho \"\\n--- Checking for accounts with empty passwords ---\"\n# Requires sudo/root to read /etc/shadow\nsudo awk -F: '($2 == \"\") {print $1}' /etc/shadow | while read user; do\n    echo \"[ALERT] User '$user' has no password set!\"\ndone"}
{"instruction": "Write a Python script to parse `/var/log/auth.log` (or secure log) to detect brute-force SSH attempts by counting failed password events per IP address.", "output": "import re\nfrom collections import defaultdict\n\nAUTH_LOG = '/var/log/auth.log'\nBRUTE_FORCE_LIMIT = 5\n\ndef detect_ssh_brute_force():\n    failed_attempts = defaultdict(int)\n    # Regex for standard sshd failed password entry\n    pattern = re.compile(r'Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\n\n    try:\n        with open(AUTH_LOG, 'r') as f:\n            for line in f:\n                if 'sshd' in line and 'Failed password' in line:\n                    match = pattern.search(line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] += 1\n\n        print(\"Potential Brute Force Sources:\")\n        for ip, count in failed_attempts.items():\n            if count >= BRUTE_FORCE_LIMIT:\n                print(f\"[ALERT] IP: {ip} - Failed Attempts: {count}\")\n\n    except PermissionError:\n        print(\"Error: Run as root to read auth logs.\")\n\nif __name__ == \"__main__\":\n    detect_ssh_brute_force()"}
{"instruction": "Create a Python script to scan a list of local IP addresses for open ports (specifically port 80 and 443) to identify potentially exposed web services.", "output": "import socket\n\ntargets = ['192.168.1.10', '192.168.1.11', '192.168.1.12']\nports = [80, 443]\n\nprint(f'Scanning targets: {targets}')\n\nfor ip in targets:\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f'[+] {ip}:{port} is OPEN')\n        else:\n            print(f'[-] {ip}:{port} is CLOSED')\n        sock.close()"}
{"instruction": "Write a Bash script to parse '/var/log/auth.log' and extract IP addresses that have failed SSH login attempts more than 5 times.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=5\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"IPs with more than $THRESHOLD failed SSH attempts:\"\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if (( count > THRESHOLD )); then\n        echo \"$ip ($count attempts)\"\n    fi\ndone"}
{"instruction": "Generate a Bash script to configure 'iptables' firewall rules that allow incoming SSH (port 22), HTTP (80), and HTTPS (443), while dropping all other incoming traffic by default.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules applied successfully.\""}
{"instruction": "Create a Python script for server hardening that audits specific critical files (like /etc/shadow and /etc/passwd) to ensure their permissions are set securely (e.g., 600 or 644).", "output": "import os\nimport stat\n\nfiles_to_check = {\n    '/etc/shadow': '600',\n    '/etc/passwd': '644',\n    '/etc/group': '644',\n    '/etc/gshadow': '600'\n}\n\ndef get_permissions(filepath):\n    try:\n        st = os.stat(filepath)\n        return oct(st.st_mode)[-3:]\n    except FileNotFoundError:\n        return None\n\nprint(\"Starting File Permission Audit...\")\nfor filepath, expected_perm in files_to_check.items():\n    current_perm = get_permissions(filepath)\n    if current_perm:\n        if current_perm != expected_perm:\n            print(f\"[ALERT] {filepath} has permissions {current_perm}, expected {expected_perm}\")\n        else:\n            print(f\"[OK] {filepath} is secure ({current_perm})\")\n    else:\n        print(f\"[MISSING] {filepath} not found\")"}
{"instruction": "Write a Bash script to harden a Linux server by disabling common unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs) to reduce the attack surface.", "output": "#!/bin/bash\n\nFILESYSTEMS=(\"cramfs\" \"freevxfs\" \"jffs2\" \"hfs\" \"hfsplus\" \"squashfs\")\nCONF_FILE=\"/etc/modprobe.d/hardening.conf\"\n\necho \"Disabling unused filesystems...\"\n\n# Create or clear the config file\n: > \"$CONF_FILE\"\n\nfor fs in \"${FILESYSTEMS[@]}\"; do\n    echo \"install $fs /bin/true\" >> \"$CONF_FILE\"\n    echo \"Disabled $fs\"\ndone\n\necho \"Configuration written to $CONF_FILE. Please reboot to apply changes.\""}
{"instruction": "Develop a Python script to parse a web server access log (Apache/Nginx format) and identify the top 5 IP addresses generating 404 Not Found errors, which might indicate scanning activity.", "output": "import re\nfrom collections import Counter\n\nlog_file_path = 'access.log'\nip_pattern = re.compile(r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})')\nstatus_pattern = re.compile(r'\\s404\\s')\n\nfailed_requests = []\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            if status_pattern.search(line):\n                match = ip_pattern.match(line)\n                if match:\n                    failed_requests.append(match.group(1))\n\n    print(\"Top 5 IPs with 404 errors:\")\n    for ip, count in Counter(failed_requests).most_common(5):\n        print(f\"{ip}: {count} requests\")\nexcept FileNotFoundError:\n    print(f\"Log file {log_file_path} not found.\")"}
{"instruction": "Create a Bash script using 'nftables' to limit incoming ICMP (ping) requests to 10 per second to mitigate potential ICMP flood attacks.", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create chain\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established connections\nnft add rule inet filter input ct state established,related accept\n\n# Rate limit ICMP echo requests\nnft add rule inet filter input ip protocol icmp icmp type echo-request limit rate 10/second accept\n\n# Drop excess ICMP (implicit by policy, but can be explicit)\nnft add rule inet filter input ip protocol icmp drop\n\necho \"nftables ICMP rate limiting applied.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date for a list of domains to ensure security compliance.", "output": "import ssl\nimport socket\nimport datetime\n\ndomains = ['google.com', 'github.com', 'example.com']\n\ndef check_ssl_expiry(domain):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    conn.settimeout(3.0)\n    try:\n        conn.connect((domain, 443))\n        cert = conn.getpeercert()\n        expiry_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n        days_left = (expiry_date - datetime.datetime.utcnow()).days\n        print(f\"{domain}: Expires in {days_left} days ({expiry_date})\")\n    except Exception as e:\n        print(f\"{domain}: Error checking SSL - {e}\")\n    finally:\n        conn.close()\n\nfor d in domains:\n    check_ssl_expiry(d)"}
{"instruction": "Generate a Bash script to secure the '/etc/sysctl.conf' file by appending network hardening parameters such as disabling IP forwarding and ignoring ICMP redirects.", "output": "#!/bin/bash\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\n# Backup existing config\ncp \"$SYSCTL_CONF\" \"${SYSCTL_CONF}.bak\"\n\necho \"Applying network hardening settings to $SYSCTL_CONF...\"\n\ncat <<EOF >> \"$SYSCTL_CONF\"\n\n# Security Hardening\n# Disable IP Packet Forwarding\nnet.ipv4.ip_forward = 0\n\n# Ignore ICMP Redirects\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\n\n# Disable ICMP Redirect Acceptance\nnet.ipv4.conf.all.secure_redirects = 0\nnet.ipv4.conf.default.secure_redirects = 0\n\n# Log Spoofed Packets, Source Routed Packets, Redirect Packets\nnet.ipv4.conf.all.log_martians = 1\nnet.ipv4.conf.default.log_martians = 1\nEOF\n\n# Apply changes\nsysctl -p\necho \"Hardening complete.\""}
{"instruction": "Create a Python script that acts as a simple file integrity monitor by calculating and storing SHA-256 hashes of files in a specified directory.", "output": "import os\nimport hashlib\nimport json\n\ndirectory_to_watch = \"./critical_config\"\nhash_db_file = \"file_hashes.json\"\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except IOError:\n        return None\n\ncurrent_hashes = {}\n\nprint(f\"Scanning directory: {directory_to_watch}\")\nfor root, dirs, files in os.walk(directory_to_watch):\n    for file in files:\n        filepath = os.path.join(root, file)\n        file_hash = calculate_hash(filepath)\n        if file_hash:\n            current_hashes[filepath] = file_hash\n\nwith open(hash_db_file, 'w') as f:\n    json.dump(current_hashes, f, indent=4)\n\nprint(f\"Baseline hashes saved to {hash_db_file}\")"}
{"instruction": "Create a Bash script to harden SSH configuration by disabling root login and password authentication in the sshd_config file.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Password Authentication\nif grep -q \"^PasswordAuthentication\" $SSHD_CONFIG; then\n    sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nelse\n    echo \"PasswordAuthentication no\" >> $SSHD_CONFIG\nfi\n\n# Restart SSH service\nsystemctl reload sshd\necho \"SSH Hardening complete. Root login and password auth disabled.\""}
{"instruction": "Write a Python script to parse a web server access log and identify IP addresses that have generated more than 50 '404 Not Found' errors (indicating potential vulnerability scanning).", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    found_ips = []\n    \n    with open(log_file, 'r') as f:\n        for line in f:\n            # Check for 404 status code\n            if ' 404 ' in line:\n                match = re.search(ip_pattern, line)\n                if match:\n                    found_ips.append(match.group(1))\n    \n    # Count occurrences\n    ip_counts = Counter(found_ips)\n    \n    print(\"Suspicious IPs (More than 50 404 errors):\")\n    for ip, count in ip_counts.items():\n        if count > 50:\n            print(f\"IP: {ip} - Count: {count}\")\n\nif __name__ == \"__main__\":\n    # Example usage: analyze_logs('/var/log/nginx/access.log')\n    pass"}
{"instruction": "Generate a Bash script using `iptables` to block a specific IP address, log the dropped attempt, and save the rules.", "output": "#!/bin/bash\n\nBLOCK_IP=\"192.168.1.100\"\nLOG_PREFIX=\"[IPTABLES-DROP]: \"\n\n# Log packets from the IP before dropping\niptables -A INPUT -s $BLOCK_IP -j LOG --log-prefix \"$LOG_PREFIX\" --log-level 4\n\n# Drop packets from the IP\niptables -A INPUT -s $BLOCK_IP -j DROP\n\n# Save rules (Debian/Ubuntu based path)\niptables-save > /etc/iptables/rules.v4\n\necho \"Blocked IP $BLOCK_IP and enabled logging.\""}
{"instruction": "Write a Python script to check for open ports on the local machine (localhost) for a defined list of critical ports (21, 22, 23, 80, 443, 3306) to identify potential exposure.", "output": "import socket\n\ndef scan_ports():\n    target = \"127.0.0.1\"\n    ports_to_check = [21, 22, 23, 80, 443, 3306, 8080]\n    \n    print(f\"Scanning critical ports on {target}...\")\n    \n    for port in ports_to_check:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target, port))\n        \n        if result == 0:\n            print(f\"[ALERT] Port {port} is OPEN\")\n        else:\n            print(f\"[SAFE] Port {port} is closed\")\n        \n        sock.close()\n\nif __name__ == \"__main__\":\n    scan_ports()"}
{"instruction": "Create a Bash script using `nftables` to configure a basic firewall that allows established traffic, allows SSH, and drops everything else by default.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow localhost traffic\nnft add rule inet filter input iif lo accept\n\n# Allow SSH (port 22)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"Nftables configuration applied: Default DROP, allow SSH/Established.\""}
{"instruction": "Write a Python script to verify the SSL/TLS certificate expiration date of a remote server to prevent service downtime due to expired certificates.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    \n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse expiration date\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                \n                days_remaining = (expire_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                \n                if days_remaining < 30:\n                    print(\"[WARNING] Certificate expires in less than 30 days!\")\n    except Exception as e:\n        print(f\"Error checking certificate: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Generate a Bash script to audit the `/etc/passwd` file and list any users (other than root) that have a User ID (UID) of 0, which indicates root privileges.", "output": "#!/bin/bash\n\necho \"Checking for non-root users with UID 0...\"\n\n# awk parses /etc/passwd using ':' delimiter.\n# Field 1 is username, Field 3 is UID.\nawk -F: '($3 == 0) {print $1, $3}' /etc/passwd | while read user uid; do\n    if [ \"$user\" != \"root\" ]; then\n        echo \"[CRITICAL ALERT] User '$user' has UID 0 (Root Privileges)!\"\n    else\n        echo \"User '$user' is correctly mapped to UID 0.\"\n    fi\ndone"}
{"instruction": "Write a Python script to calculate the SHA-256 checksum of a critical system file (e.g., /bin/ls) to detect potential file tampering (File Integrity Monitoring).", "output": "import hashlib\nimport sys\n\ndef calculate_hash(file_path):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            # Read file in chunks to avoid memory issues with large files\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nif __name__ == \"__main__\":\n    target_file = \"/bin/ls\"\n    checksum = calculate_hash(target_file)\n    \n    if checksum:\n        print(f\"File: {target_file}\")\n        print(f\"SHA-256: {checksum}\")\n        # In a real scenario, compare this against a known good database\n    else:\n        print(f\"File {target_file} not found.\")"}
{"instruction": "Create a Bash script to set secure file permissions on critical system configuration files (`/etc/shadow`, `/etc/passwd`, `/etc/group`) to prevent unauthorized access.", "output": "#!/bin/bash\n\necho \"Hardening file permissions...\"\n\n# /etc/shadow should only be readable by root (600 or 640)\nchmod 600 /etc/shadow\nchown root:root /etc/shadow\necho \"/etc/shadow set to 600\"\n\n# /etc/passwd must be readable by everyone but writable only by root (644)\nchmod 644 /etc/passwd\nchown root:root /etc/passwd\necho \"/etc/passwd set to 644\"\n\n# /etc/group must be readable by everyone but writable only by root (644)\nchmod 644 /etc/group\nchown root:root /etc/group\necho \"/etc/group set to 644\"\n\n# /etc/gshadow should be restricted (600)\nif [ -f /etc/gshadow ]; then\n    chmod 600 /etc/gshadow\n    chown root:root /etc/gshadow\n    echo \"/etc/gshadow set to 600\"\nfi"}
{"instruction": "Write a Python script to parse a Linux `auth.log` file and detect brute-force SSH attempts by counting failed password entries per IP address.", "output": "import re\n\ndef detect_bruteforce(log_path, threshold=5):\n    failed_attempts = {}\n    # Regex to capture IP from standard sshd failed password log line\n    ip_regex = r\"Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"sshd\" in line and \"Failed password\" in line:\n                    match = re.search(ip_regex, line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] = failed_attempts.get(ip, 0) + 1\n        \n        print(f\"--- IPs with > {threshold} failed login attempts ---\")\n        for ip, count in failed_attempts.items():\n            if count > threshold:\n                print(f\"IP: {ip} | Attempts: {count}\")\n                \n    except FileNotFoundError:\n        print(f\"Log file {log_path} not found.\")\n\nif __name__ == \"__main__\":\n    # Typical location on Debian/Ubuntu\n    detect_bruteforce(\"/var/log/auth.log\")"}
{"instruction": "Create a Python script to scan a target IP address for a defined list of common ports (e.g., 22, 80, 443) to check if they are open.", "output": "import socket\n\ndef scan_ports(target_ip, ports):\n    print(f\"Scanning {target_ip}...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"Port {port}: Open\")\n        else:\n            print(f\"Port {port}: Closed\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"\n    common_ports = [21, 22, 80, 443, 8080, 3306]\n    scan_ports(target, common_ports)"}
{"instruction": "Write a Bash script to analyze `/var/log/auth.log` and identify the top 10 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Generate a Bash script to configure `iptables` to allow SSH, HTTP, and HTTPS traffic, while dropping all other incoming connections (Default Deny policy).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP (Port 80)\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Allow HTTPS (Port 443)\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules updated.\""}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and enforcing key-based authentication (disabling passwords).", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Create a backup\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Check syntax and restart service\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp \"$BACKUP\" \"$SSHD_CONFIG\"\nfi"}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a specific domain name.", "output": "import ssl\nimport socket\nimport datetime\n\ndef get_ssl_expiry_date(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(\n        socket.socket(socket.AF_INET),\n        server_hostname=hostname,\n    )\n    \n    # Set timeout\n    conn.settimeout(3.0)\n\n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        # Parse the expiration date\n        expire_date_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_date_str, r'%b %d %H:%M:%S %Y %Z')\n        \n        print(f\"Domain: {hostname}\")\n        print(f\"Expires on: {expire_date}\")\n        \n        remaining = expire_date - datetime.datetime.utcnow()\n        print(f\"Days remaining: {remaining.days}\")\n        \n    except Exception as e:\n        print(f\"Error connecting to {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    get_ssl_expiry_date(\"www.example.com\")"}
{"instruction": "Develop a Python script to parse a web server access log (Common Log Format) and identify requests containing potential SQL Injection patterns.", "output": "import re\n\ndef analyze_logs(log_file):\n    # Simple regex for common SQLi keywords (educational example)\n    sqli_pattern = re.compile(r\"(UNION\\s+SELECT|OR\\s+1=1|DROP\\s+TABLE|--|')\", re.IGNORECASE)\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if sqli_pattern.search(line):\n                    # Extract IP (assuming standard log format)\n                    ip = line.split()[0]\n                    print(f\"[ALERT] Potential SQLi detected from {ip}: {line.strip()[:100]}...\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Replace with path to actual access log\n    analyze_logs(\"access.log\")"}
{"instruction": "Write a Bash script to initialize a basic `nftables` firewall configuration that drops invalid traffic and allows established connections.", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Drop invalid traffic\nnft add rule inet filter input ct state invalid drop\n\n# Allow Loopback\nnft add rule inet filter input iif lo accept\n\n# Allow SSH\nnft add rule inet filter input tcp dport 22 accept\n\necho \"Nftables configuration applied.\""}
{"instruction": "Create a Bash script to recursively find and list all files in a specific directory that have world-writable permissions (777), which is a security risk.", "output": "#!/bin/bash\n\nSEARCH_DIR=\"/var/www/html\"\n\nif [ -d \"$SEARCH_DIR\" ]; then\n    echo \"Scanning $SEARCH_DIR for world-writable files (777)...\"\n    find \"$SEARCH_DIR\" -type f -perm 0777 -print\nelse\n    echo \"Directory $SEARCH_DIR does not exist.\"\nfi"}
{"instruction": "Write a Python script to calculate SHA-256 hashes of all files in a directory to create a baseline for File Integrity Monitoring.", "output": "import hashlib\nimport os\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef baseline_directory(directory):\n    print(f\"Generating baseline for: {directory}\")\n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            filepath = os.path.join(root, file)\n            file_hash = calculate_hash(filepath)\n            if file_hash:\n                print(f\"{file_hash}  {filepath}\")\n\nif __name__ == \"__main__\":\n    baseline_directory(\"/etc/nginx\")"}
{"instruction": "Create a Bash script to audit user accounts by checking for users with UID 0 (non-root root equivalents) and accounts with empty password fields.", "output": "#!/bin/bash\n\necho \"--- Auditing UID 0 Users ---\"\n# Check for users with UID 0 other than root\nawk -F: '($3 == 0) {print $1}' /etc/passwd\n\necho \"\\n--- Auditing Empty Password Fields ---\"\n# Check for users with no password set in shadow file (requires root)\nif [ \"$(id -u)\" -eq 0 ]; then\n    awk -F: '($2 == \"\" ) {print $1 \" has no password!\"}' /etc/shadow\nelse\n    echo \"Run as root to check /etc/shadow for empty passwords.\"\nfi"}
{"instruction": "Create a Python script that performs a basic port scan on a specified IP address to identify open ports (range 1-1024) for vulnerability assessment.", "output": "import socket\nimport sys\n\ndef scan_ports(target_ip):\n    print(f\"Scanning target: {target_ip}\")\n    open_ports = []\n    for port in range(1, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python scanner.py <IP>\")\n        sys.exit(1)\n    \n    target = sys.argv[1]\n    ports = scan_ports(target)\n    if ports:\n        print(f\"Open ports found: {ports}\")\n    else:\n        print(\"No open ports found in range 1-1024.\")"}
{"instruction": "Write a Bash script to analyze an Apache access log file and extract the top 10 IP addresses with the highest number of requests, useful for identifying potential DoS attacks.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/apache2/access.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 Source IPs by Request Count:\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Develop a Python script for File Integrity Monitoring (FIM) that calculates and stores SHA-256 hashes of critical system files to detect unauthorized modifications.", "output": "import hashlib\nimport os\n\nCRITICAL_FILES = ['/etc/passwd', '/etc/shadow', '/etc/hosts']\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\ndef main():\n    print(\"--- File Integrity Monitor ---\")\n    for file_path in CRITICAL_FILES:\n        file_hash = calculate_hash(file_path)\n        print(f\"{file_path}: {file_hash}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"instruction": "Write a Bash script to harden an SSH server configuration by disabling root login, disabling password authentication, and changing the default port to 2222.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP\n\necho \"Hardening SSH configuration...\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Change Port\nsed -i 's/^#Port 22/Port 2222/' $SSHD_CONFIG\nsed -i 's/^Port 22/Port 2222/' $SSHD_CONFIG\n\necho \"Configuration updated. Please restart SSH service to apply changes.\""}
{"instruction": "Create a Python script that parses `/var/log/auth.log` to identify and count failed SSH login attempts by username.", "output": "import re\nfrom collections import Counter\n\nLOG_FILE = '/var/log/auth.log'\n\ndef parse_failed_logins():\n    failed_users = []\n    # Regex to capture user from 'Failed password for <user>'\n    pattern = re.compile(r\"Failed password for (?:invalid user )?(\\w+)\")\n    \n    try:\n        with open(LOG_FILE, 'r') as f:\n            for line in f:\n                if \"sshd\" in line and \"Failed password\" in line:\n                    match = pattern.search(line)\n                    if match:\n                        failed_users.append(match.group(1))\n        \n        counts = Counter(failed_users)\n        print(\"Failed SSH Login Attempts by User:\")\n        for user, count in counts.most_common():\n            print(f\"{user}: {count}\")\n            \n    except FileNotFoundError:\n        print(f\"Log file {LOG_FILE} not found.\")\n    except PermissionError:\n        print(\"Permission denied. Run with sudo.\")\n\nif __name__ == \"__main__\":\n    parse_failed_logins()"}
{"instruction": "Write a Bash script to configure `iptables` rules that drop all incoming traffic by default, but allow loopback, established connections, and incoming SSH (port 22) and HTTP (port 80).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\necho \"Iptables firewall configured successfully.\""}
{"instruction": "Create a Python script to check for SSL/TLS certificate expiration dates for a list of domains to prevent security warnings or downtime.", "output": "import ssl\nimport socket\nimport datetime\n\ndomains = ['google.com', 'github.com', 'example.com']\n\ndef get_ssl_expiry(domain):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((domain, 443))\n        cert = conn.getpeercert()\n        expiry_date = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n        return expiry_date\n    except Exception as e:\n        return str(e)\n    finally:\n        conn.close()\n\nfor d in domains:\n    expiry = get_ssl_expiry(d)\n    if isinstance(expiry, datetime.datetime):\n        days_left = (expiry - datetime.datetime.utcnow()).days\n        print(f\"{d}: Expires on {expiry} ({days_left} days remaining)\")\n    else:\n        print(f\"{d}: Error - {expiry}\")"}
{"instruction": "Write a Bash script to scan the system for files with the SUID bit set, which can be potential privilege escalation vectors if misconfigured.", "output": "#!/bin/bash\n\necho \"Scanning for SUID binaries...\"\n# Find files with SUID bit set (-perm -4000)\nfind / -type f -perm -4000 -exec ls -l {} \\; 2>/dev/null > suid_files.txt\n\necho \"Scan complete. Results saved to suid_files.txt.\"\necho \"Top 5 findings:\"\nhead -n 5 suid_files.txt"}
{"instruction": "Develop a Python script that uses the `subprocess` module to list outdated pip packages, aiding in vulnerability management.", "output": "import subprocess\nimport json\n\ndef check_outdated_packages():\n    print(\"Checking for outdated Python packages...\")\n    try:\n        # Run pip list --outdated with json format\n        result = subprocess.run(\n            ['pip', 'list', '--outdated', '--format=json'],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        packages = json.loads(result.stdout)\n        \n        if not packages:\n            print(\"All packages are up to date.\")\n            return\n\n        print(f\"{'Package':<20} {'Current':<10} {'Latest':<10}\")\n        print(\"-\" * 40)\n        for pkg in packages:\n            print(f\"{pkg['name']:<20} {pkg['version']:<10} {pkg['latest_version']:<10}\")\n            \n    except subprocess.CalledProcessError:\n        print(\"Failed to run pip command.\")\n    except json.JSONDecodeError:\n        print(\"Failed to parse pip output.\")\n\nif __name__ == \"__main__\":\n    check_outdated_packages()"}
{"instruction": "Write a Bash script using `nftables` to create a new table and chain, and add a rule to drop traffic from a specific malicious IP address.", "output": "#!/bin/bash\n\nMALICIOUS_IP=\"192.168.1.100\"\n\n# Create table ip filter\nnft add table ip filter\n\n# Create input chain\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule to drop traffic from the malicious IP\nnft add rule ip filter input ip saddr $MALICIOUS_IP drop\n\necho \"Nftables rule added: Dropping traffic from $MALICIOUS_IP\""}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file to identify IP addresses causing excessive 404 errors (potential directory brute-forcing).", "output": "import re\nfrom collections import Counter\n\ndef analyze_404_errors(log_file_path, threshold=10):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    ips = []\n    \n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                # Check for 404 status code\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        ips.append(match.group(1))\n        \n        counts = Counter(ips)\n        print(f'IPs with more than {threshold} 404 errors:')\n        for ip, count in counts.items():\n            if count > threshold:\n                print(f'{ip}: {count}')\n                \n    except FileNotFoundError:\n        print('Log file not found.')\n\nif __name__ == '__main__':\n    analyze_404_errors('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script using 'iptables' to implement a basic firewall strategy: Allow loopback, allow established connections, allow SSH (port 22), and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\n# netfilter-persistent save\n\necho \"Basic firewall rules applied.\""}
{"instruction": "Write a Python script for Server Hardening that checks the permissions of critical system files (like /etc/shadow and /etc/passwd) to ensure they are secure.", "output": "import os\nimport stat\n\nfiles_to_check = {\n    '/etc/shadow': '600',\n    '/etc/passwd': '644',\n    '/etc/group': '644',\n    '/etc/gshadow': '600'\n}\n\ndef check_permissions():\n    print('Checking file permissions...')\n    for filepath, expected_octal in files_to_check.items():\n        if not os.path.exists(filepath):\n            print(f'[MISSING] {filepath}')\n            continue\n            \n        # Get current file mode\n        file_stat = os.stat(filepath)\n        current_octal = oct(stat.S_IMODE(file_stat.st_mode))[2:]\n        \n        if current_octal != expected_octal:\n            print(f'[ALERT] {filepath} is {current_octal}, expected {expected_octal}')\n        else:\n            print(f'[OK] {filepath}')\n\nif __name__ == '__main__':\n    check_permissions()"}
{"instruction": "Create a Bash script for Server Hardening that disables root login via SSH and changes the default SSH port to 2222.", "output": "#!/bin/bash\n\nSSH_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSH_CONFIG \"$SSH_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSH_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSH_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSH_CONFIG\nfi\n\n# Change Port\nif grep -q \"^Port\" $SSH_CONFIG; then\n    sed -i 's/^Port.*/Port 2222/' $SSH_CONFIG\nelse\n    echo \"Port 2222\" >> $SSH_CONFIG\nfi\n\n# Validate syntax before restart\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH hardened: Root login disabled, Port set to 2222.\"\nelse\n    echo \"Configuration error. Reverting...\"\n    cp \"$SSH_CONFIG.bak\" $SSH_CONFIG\nfi"}
{"instruction": "Write a Python script for Vulnerability Scanning that performs a simple banner grab on a list of target IPs to identify running services on port 80.", "output": "import socket\n\ntargets = ['192.168.1.10', '192.168.1.11']  # Example IPs\nport = 80\n\ndef banner_grab(ip, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(2)\n        s.connect((ip, port))\n        # Send a simple HTTP request to trigger a response\n        s.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')\n        banner = s.recv(1024).decode().strip()\n        print(f'[+] {ip}:{port} Banner: \\n{banner}')\n        s.close()\n    except Exception as e:\n        print(f'[-] {ip}:{port} Error: {e}')\n\nif __name__ == '__main__':\n    for target in targets:\n        banner_grab(target, port)"}
{"instruction": "Create a Bash script using 'nftables' to block traffic from a specific list of malicious IP addresses defined in a text file.", "output": "#!/bin/bash\n\nBLOCKLIST=\"malicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Check if nftables is installed\nif ! command -v nft &> /dev/null; then\n    echo \"nftables could not be found\"\n    exit 1\nfi\n\n# Ensure the table and chain exist\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\nif [ -f \"$BLOCKLIST\" ]; then\n    while IFS= read -r ip\n    do\n        # Skip empty lines or comments\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        \n        echo \"Blocking $ip\"\n        nft add rule ip $TABLE_NAME $CHAIN_NAME ip saddr $ip drop\n    done < \"$BLOCKLIST\"\nelse\n    echo \"Blocklist file not found.\"\nfi"}
{"instruction": "Write a Python script for SIEM/Log Analysis that monitors '/var/log/auth.log' in real-time for failed SSH login attempts.", "output": "import time\nimport re\n\ndef follow(file):\n    file.seek(0, 2) # Go to the end of the file\n    while True:\n        line = file.readline()\n        if not line:\n            time.sleep(0.1)\n            continue\n        yield line\n\ndef monitor_ssh_fails(logfile_path):\n    fail_pattern = re.compile(r'Failed password for (.*) from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n    \n    try:\n        with open(logfile_path, 'r') as logfile:\n            print(f'Monitoring {logfile_path} for failed SSH logins...')\n            for line in follow(logfile):\n                if 'Failed password' in line:\n                    match = fail_pattern.search(line)\n                    if match:\n                        user = match.group(1)\n                        ip = match.group(2)\n                        print(f'[ALERT] Failed SSH login for user: {user} from IP: {ip}')\n    except PermissionError:\n        print('Permission denied. Run with sudo.')\n\nif __name__ == '__main__':\n    monitor_ssh_fails('/var/log/auth.log')"}
{"instruction": "Create a Bash script for Vulnerability Management that lists all installed packages with available security updates (Debian/Ubuntu specific).", "output": "#!/bin/bash\n\n# Update package lists\nsudo apt-get update -q\n\necho \"Checking for security updates...\"\n\n# List upgrades, filter for security repositories\n# Note: This looks for lines containing 'security' in the policy output\napt-get -s dist-upgrade | grep \"^Inst\" | grep -i \"security\"\n\nif [ $? -ne 0 ]; then\n    echo \"No immediate security updates found.\"\nelse\n    echo \"WARNING: Security updates are available. Run 'apt-get upgrade' soon.\"\nfi"}
{"instruction": "Write a Python script for File Integrity Monitoring (Hardening) that calculates SHA-256 hashes of files in a specific directory to detect unauthorized changes.", "output": "import hashlib\nimport os\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, 'rb') as f:\n            for byte_block in iter(lambda: f.read(4096), b''):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef scan_directory(directory):\n    print(f'Scanning directory: {directory}')\n    results = {}\n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            filepath = os.path.join(root, file)\n            file_hash = calculate_hash(filepath)\n            if file_hash:\n                results[filepath] = file_hash\n                print(f'{filepath}: {file_hash}')\n    return results\n\nif __name__ == '__main__':\n    # Example: scanning /bin directory (requires read permissions)\n    scan_directory('/bin')"}
{"instruction": "Create a Bash script for Server Hardening that searches for users with empty password fields in /etc/shadow and locks those accounts.", "output": "#!/bin/bash\n\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"This script must be run as root\"\n    exit 1\nfi\n\necho \"Scanning for accounts with empty passwords...\"\n\n# awk parses /etc/shadow. Field 2 is the password hash. If empty or '!', check it.\n# Note: This specifically looks for truly empty fields (::)\n\nawk -F: '($2 == \"\") {print $1}' /etc/shadow | while read -r user; do\n    echo \"[ALERT] User $user has no password set! Locking account...\"\n    passwd -l \"$user\"\n    echo \"Account $user locked.\"\ndone\n\necho \"Scan complete.\""}
{"instruction": "Create a Python script using the `socket` library to perform a simple port scan on a local server to identify if insecure services (Telnet port 23, FTP port 21) are listening.", "output": "import socket\n\ndef check_insecure_ports(target_ip, ports=[21, 23]):\n    print(f\"Scanning {target_ip} for insecure ports...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            print(f\"[!] Port {port} is OPEN (Potential Vulnerability)\")\n        else:\n            print(f\"[+] Port {port} is Closed\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Scan localhost for demonstration\n    check_insecure_ports('127.0.0.1')"}
{"instruction": "Write a Bash script to parse Nginx access logs and identify IP addresses that have generated more than 50 HTTP 404 errors, which may indicate a directory enumeration scanning attempt.", "output": "#!/bin/bash\nLOG_FILE=\"/var/log/nginx/access.log\"\nTHRESHOLD=50\n\necho \"Scanning log for potential enumeration attempts...\"\n\n# Extract IPs with 404 status codes, count occurrences, and filter by threshold\ngrep \" 404 \" \"$LOG_FILE\" | awk '{print $1}' | sort | uniq -c | sort -rn | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"[ALERT] IP $ip has generated $count 404 errors.\"\n    fi\ndone"}
{"instruction": "Generate a Python script to analyze a Linux `auth.log` file for failed SSH login attempts and identify the usernames being targeted.", "output": "import re\nfrom collections import Counter\n\ndef analyze_ssh_failures(log_path):\n    user_counter = Counter()\n    # Regex to capture user from failed password attempts\n    regex = r\"Failed password for (invalid user )?(\\w+) from\"\n    \n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = re.search(regex, line)\n                if match:\n                    # Group 2 contains the username\n                    user_counter[match.group(2)] += 1\n        \n        print(\"Top targeted users for SSH Brute Force:\")\n        for user, count in user_counter.most_common(5):\n            print(f\"User: {user}, Failed Attempts: {count}\")\n            \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_ssh_failures('/var/log/auth.log')"}
{"instruction": "Create a Bash script using `iptables` to implement a basic firewall policy: drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default chain policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\necho \"Firewall rules applied successfully.\""}
{"instruction": "Write a Python script to check the expiration date of an SSL certificate for a specific domain to ensure it hasn't expired.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                # Parse expiration date\n                expire_date_str = cert['notAfter']\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_remaining = (expire_date - datetime.datetime.now()).days\n                \n                print(f\"Certificate for {hostname} expires on: {expire_date}\")\n                print(f\"Days remaining: {days_remaining}\")\n                \n                if days_remaining < 30:\n                    print(\"[WARNING] Certificate expires in less than 30 days!\")\n    except Exception as e:\n        print(f\"Error checking SSL: {e}\"\n\nif __name__ == \"__main__\":\n    check_ssl_expiry('www.example.com')"}
{"instruction": "Create a Bash script to harden an SSH server configuration by disabling root login and password authentication in `/etc/ssh/sshd_config`.", "output": "#!/bin/bash\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Create backup\ncp $CONFIG_FILE $BACKUP_FILE\n\necho \"Hardening SSH configuration...\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $CONFIG_FILE; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nelse\n    echo \"PermitRootLogin no\" >> $CONFIG_FILE\nfi\n\n# Disable Password Authentication\nif grep -q \"^PasswordAuthentication\" $CONFIG_FILE; then\n    sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nelse\n    echo \"PasswordAuthentication no\" >> $CONFIG_FILE\nfi\n\n# Validate syntax and reload SSH\nsshd -t && systemctl reload sshd\necho \"SSH Hardening complete. Root login and Password Auth disabled.\""}
{"instruction": "Write a Python script to calculate the SHA-256 hash of critical system files (File Integrity Monitoring) and compare them against a known baseline dictionary.", "output": "import hashlib\nimport os\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\n# Baseline dictionary (Example hashes)\nbaseline = {\n    '/etc/passwd': 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', # Example placeholder\n    '/etc/hosts': '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'\n}\n\ndef check_integrity():\n    print(\"Starting File Integrity Check...\")\n    for filepath, known_hash in baseline.items():\n        current_hash = calculate_sha256(filepath)\n        if current_hash is None:\n            print(f\"[MISSING] File {filepath} not found.\")\n        elif current_hash != known_hash:\n            print(f\"[ALERT] Integrity mismatch for {filepath}!\\nExpected: {known_hash}\\nActual:   {current_hash}\")\n        else:\n            print(f\"[OK] {filepath} verified.\")\n\nif __name__ == \"__main__\":\n    check_integrity()"}
{"instruction": "Generate a Bash script using `nftables` to rate-limit incoming SSH connections to prevent brute-force attacks (allow max 10 connections per minute).", "output": "#!/bin/bash\n\n# Create table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; }\n\n# Allow established traffic\nnft add rule inet filter input ct state established,related accept\n\n# Rate limit SSH: Accept new SSH connections only if < 10 per minute from same IP\necho \"Applying SSH rate limiting...\"\nnft add rule inet filter input tcp dport 22 ct state new limit rate 10/minute accept\n\n# Drop excess SSH connection attempts (optional explicit drop or rely on policy)\nnft add rule inet filter input tcp dport 22 drop\n\necho \"NFTables rules configured.\""}
{"instruction": "Create a Python script that parses a JSON-formatted application log file and alerts on any log entries with a severity level of \"CRITICAL\".", "output": "import json\nimport sys\n\ndef scan_json_logs(log_file):\n    print(f\"Scanning {log_file} for CRITICAL events...\")\n    try:\n        with open(log_file, 'r') as f:\n            for line_num, line in enumerate(f, 1):\n                try:\n                    entry = json.loads(line)\n                    # Check severity key (case-insensitive)\n                    if entry.get('severity', '').upper() == 'CRITICAL':\n                        print(f\"[ALERT] Line {line_num}: {entry.get('message', 'No message provided')}\")\n                        print(f\"        Timestamp: {entry.get('timestamp', 'Unknown')}\")\n                except json.JSONDecodeError:\n                    continue # Skip malformed lines\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # usage: python scan.py app.json.log\n    if len(sys.argv) > 1:\n        scan_json_logs(sys.argv[1])"}
{"instruction": "Write a Bash script to audit permissions of sensitive files (`/etc/shadow`, `/etc/passwd`) to ensure they are not world-writable.", "output": "#!/bin/bash\n\nFILES=(\"/etc/passwd\" \"/etc/shadow\" \"/etc/group\" \"/etc/gshadow\")\n\necho \"Starting Permission Audit...\"\n\nfor file in \"${FILES[@]}\"; do\n    if [ -f \"$file\" ]; then\n        # Check if world writable bit is set\n        if [ -w \"$file\" ] && [ \"$(stat -c %a \"$file\" | grep '.[2367]$')\" ]; then\n             echo \"[FAIL] $file is world-writable!\"\n        else\n             perms=$(stat -c %a \"$file\")\n             owner=$(stat -c %U \"$file\")\n             echo \"[PASS] $file: Perms $perms, Owner $owner\"\n        fi\n    else\n        echo \"[INFO] $file does not exist.\"\n    fi\ndone"}
{"instruction": "Create a Python script that performs a basic port scan on a specified IP address to identify open ports within a common range (1-1024). This is a foundational task for vulnerability assessment.", "output": "import socket\nimport sys\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"\n    ports = scan_ports(target, 1, 1024)\n    if ports:\n        print(f\"Open ports found: {ports}\")\n    else:\n        print(\"No open ports found.\")"}
{"instruction": "Write a Bash script for log analysis that parses an Apache access log file to identify and count the top 10 IP addresses making requests. This helps in identifying potential botnets or DoS sources.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/apache2/access.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IP addresses by request count:\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Develop a Python script to analyze a Linux authentication log (e.g., /var/log/auth.log) and detect potential brute-force attacks by identifying IP addresses with more than 5 failed login attempts.", "output": "import re\nfrom collections import defaultdict\n\nLOG_FILE = '/var/log/auth.log'\nTHRESHOLD = 5\n\ndef detect_bruteforce(log_path):\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from sshd failed password lines\n    ip_pattern = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(f\"Error: {log_path} not found.\")\n        return\n\n    print(\"Potential Brute-Force Sources:\")\n    for ip, count in failed_attempts.items():\n        if count > THRESHOLD:\n            print(f\"IP: {ip} - Failed Attempts: {count}\")\n\nif __name__ == \"__main__\":\n    detect_bruteforce(LOG_FILE)"}
{"instruction": "Create a Bash script using `iptables` to implement a basic firewall strategy: allow established connections, allow SSH and Web traffic, and drop everything else.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP (80) and HTTPS (443)\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional)\niptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules configured successfully.\""}
{"instruction": "Write a Python script to check the SSL/TLS certificate expiration date of a given domain. This is a proactive measure to prevent security warnings and downtime.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    try:\n        with socket.create_connection((hostname, port)) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                expire_date_str = cert['notAfter']\n                # Parse the date format: May 30 12:00:00 2025 GMT\n                expire_date = datetime.datetime.strptime(expire_date_str, '%b %d %H:%M:%S %Y %Z')\n                days_left = (expire_date - datetime.datetime.utcnow()).days\n                \n                print(f\"Domain: {hostname}\")\n                print(f\"Expires on: {expire_date}\")\n                print(f\"Days remaining: {days_left}\")\n                \n                if days_left < 30:\n                    print(\"WARNING: Certificate expires in less than 30 days!\")\n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Create a Bash script for server hardening that disables root login via SSH and changes the default SSH port to 2222.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Backup the config file\ncp \"$SSHD_CONFIG\" \"$BACKUP_CONFIG\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" \"$SSHD_CONFIG\"; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nelse\n    echo \"PermitRootLogin no\" >> \"$SSHD_CONFIG\"\nfi\n\n# Change Port to 2222\nif grep -q \"^Port\" \"$SSHD_CONFIG\"; then\n    sed -i 's/^Port.*/Port 2222/' \"$SSHD_CONFIG\"\nelse\n    echo \"Port 2222\" >> \"$SSHD_CONFIG\"\nfi\n\n# Restart SSH service (checks for systemd)\nif systemctl list-units --full -all | grep -Fq \"ssh.service\"; then\n    systemctl restart ssh\n    echo \"SSH hardening applied. Root login disabled, Port set to 2222.\"\nelse\n    echo \"SSH service not found or systemd not in use.\"\nfi"}
{"instruction": "Write a Python script to audit file permissions of sensitive system files (like /etc/passwd and /etc/shadow) to ensure they are not world-writable.", "output": "import os\nimport stat\n\nSENSITIVE_FILES = ['/etc/passwd', '/etc/shadow', '/etc/group', '/etc/sudoers']\n\ndef check_permissions(file_path):\n    if not os.path.exists(file_path):\n        print(f\"[MISSING] {file_path}\")\n        return\n\n    st = os.stat(file_path)\n    mode = st.st_mode\n\n    # Check if world writable (Others have Write permission)\n    if mode & stat.S_IWOTH:\n        print(f\"[ALERT] {file_path} is World-Writable! ({oct(mode)[-3:]})\")\n    else:\n        print(f\"[OK] {file_path} permissions seem safe ({oct(mode)[-3:]})\")\n\nif __name__ == \"__main__\":\n    print(\"Starting File Permission Audit...\")\n    for f in SENSITIVE_FILES:\n        check_permissions(f)"}
{"instruction": "Develop a Bash script using `nftables` to drop all incoming traffic from a specific blocklist of IP addresses contained in a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"bad_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Check if nftables is installed\nif ! command -v nft &> /dev/null; then\n    echo \"nftables is not installed.\"\n    exit 1\nfi\n\n# Create the table and chain if they don't exist\nnft add table ip $TABLE_NAME\nnft add chain ip $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\n\nif [[ -f \"$BLOCKLIST_FILE\" ]]; then\n    while IFS= read -r ip; do\n        # Skip empty lines or comments\n        [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n        \n        echo \"Blocking IP: $ip\"\n        nft add rule ip $TABLE_NAME $CHAIN_NAME saddr \"$ip\" drop\n    done < \"$BLOCKLIST_FILE\"\nelse\n    echo \"Blocklist file not found.\"\nfi"}
{"instruction": "Create a Bash script to apply kernel parameter hardening via `sysctl` to protect against IP spoofing and SYN floods.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.d/99-security.conf\"\n\necho \"Applying kernel hardening settings...\"\n\ncat <<EOF > \"$SYSCTL_CONF\"\n# IP Spoofing protection\nnet.ipv4.conf.all.rp_filter = 1\nnet.ipv4.conf.default.rp_filter = 1\n\n# Ignore ICMP broadcast requests\nnet.ipv4.icmp_echo_ignore_broadcasts = 1\n\n# Disable source packet routing\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv6.conf.all.accept_source_route = 0\n\n# SYN Flood protection\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_max_syn_backlog = 2048\nnet.ipv4.tcp_synack_retries = 2\nEOF\n\n# Apply changes\nsysctl -p \"$SYSCTL_CONF\"\necho \"Kernel hardening applied.\""}
{"instruction": "Write a Python script that parses a generic JSON-formatted application log file and alerts on any entries with a severity level of 'CRITICAL'.", "output": "import json\nimport sys\n\nLOG_FILE = 'application.json.log'\n\ndef analyze_json_logs(file_path):\n    try:\n        with open(file_path, 'r') as f:\n            for line_number, line in enumerate(f, 1):\n                try:\n                    entry = json.loads(line)\n                    severity = entry.get('level', '').upper()\n                    \n                    if severity == 'CRITICAL':\n                        timestamp = entry.get('timestamp', 'Unknown Time')\n                        message = entry.get('message', 'No message provided')\n                        print(f\"[ALERT] Critical error found at line {line_number}!\")\n                        print(f\"  Time: {timestamp}\")\n                        print(f\"  Message: {message}\")\n                except json.JSONDecodeError:\n                    continue # Skip malformed lines\n    except FileNotFoundError:\n        print(f\"Log file {file_path} not found.\")\n\nif __name__ == \"__main__\":\n    # Create a dummy log file for demonstration\n    with open(LOG_FILE, 'w') as f:\n        f.write('{\"timestamp\": \"2023-10-01T10:00:00\", \"level\": \"INFO\", \"message\": \"System started\"}\\n')\n        f.write('{\"timestamp\": \"2023-10-01T10:05:00\", \"level\": \"CRITICAL\", \"message\": \"Database connection failed\"}\\n')\n    \n    analyze_json_logs(LOG_FILE)"}
{"instruction": "Create a Python script using the `requests` library to check a list of URLs for the presence of security headers (X-Frame-Options, X-Content-Type-Options, Content-Security-Policy).", "output": "import requests\n\nurls = ['https://example.com', 'https://test.com']\nsecurity_headers = ['X-Frame-Options', 'X-Content-Type-Options', 'Content-Security-Policy']\n\nfor url in urls:\n    try:\n        response = requests.get(url, timeout=5)\n        print(f'Scanning {url}...')\n        for header in security_headers:\n            if header in response.headers:\n                print(f'  [+] {header}: Present')\n            else:\n                print(f'  [-] {header}: Missing')\n    except requests.exceptions.RequestException as e:\n        print(f'Error scanning {url}: {e}')"}
{"instruction": "Write a Bash script to parse `/var/log/auth.log` (or `/var/log/secure`) to identify and count the top 10 IP addresses responsible for failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IPs with failed SSH login attempts:\"\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Generate a Bash script to configure `iptables` rules that drop all incoming traffic by default, allow loopback, allow established connections, and allow incoming SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\n\necho \"Firewall rules applied.\""}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling Root Login and Password Authentication in `/etc/ssh/sshd_config`, then reload the service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\n\n# Disable Password Authentication\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\n# Check syntax and reload SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH hardening applied successfully.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp \"$BACKUP_FILE\" \"$CONFIG_FILE\"\nfi"}
{"instruction": "Write a Python script to scan a local subnet (e.g., 192.168.1.0/24) for active hosts using ICMP ping requests.", "output": "import subprocess\nimport platform\n\ndef ping_sweep(subnet_prefix):\n    # Determine parameter based on OS\n    param = '-n' if platform.system().lower() == 'windows' else '-c'\n    \n    print(f\"Scanning subnet {subnet_prefix}.0/24...\")\n    \n    for ip in range(1, 255):\n        address = f\"{subnet_prefix}.{ip}\"\n        command = ['ping', param, '1', address]\n        \n        response = subprocess.call(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        \n        if response == 0:\n            print(f\"[+] Host Active: {address}\")\n\nif __name__ == \"__main__\":\n    # Example usage: 192.168.1\n    ping_sweep(\"192.168.1\")"}
{"instruction": "Create a Bash script using `nftables` to create a table and chain that blocks a specific list of malicious IP addresses.", "output": "#!/bin/bash\n\n# Create table and chain\nnft add table ip filter\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# List of IPs to block\nBLOCK_IPS=(\"192.0.2.10\" \"198.51.100.45\" \"203.0.113.12\")\n\nfor ip in \"${BLOCK_IPS[@]}\"; do\n    echo \"Blocking $ip\"\n    nft add rule ip filter input ip saddr $ip drop\ndone\n\necho \"nftables rules updated.\""}
{"instruction": "Write a Python script to analyze a web server log file (Apache/Nginx) and detect requests attempting SQL Injection (looking for keywords like UNION, SELECT, OR 1=1).", "output": "import re\n\nlog_file_path = '/var/log/apache2/access.log'\nsqli_patterns = [r\"UNION\", r\"SELECT\", r\"OR\\s+1=1\", r\"--\", r\"INSERT\", r\"DROP\"]\n\ndef detect_sqli(line):\n    for pattern in sqli_patterns:\n        if re.search(pattern, line, re.IGNORECASE):\n            return True, pattern\n    return False, None\n\ntry:\n    with open(log_file_path, 'r') as f:\n        for line in f:\n            is_suspicious, match = detect_sqli(line)\n            if is_suspicious:\n                print(f\"[ALERT] Potential SQLi detected (Pattern: {match}):\")\n                print(f\"  Log: {line.strip()}\")\nexcept FileNotFoundError:\n    print(\"Log file not found.\")"}
{"instruction": "Generate a Bash script to search the entire filesystem for files with the SUID bit set, which can be a security risk for privilege escalation.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"suid_files_report.txt\"\n\necho \"Scanning for SUID files...\"\necho \"Report generated at $(date)\" > \"$OUTPUT_FILE\"\n\n# Find files with SUID bit set (perm -4000)\nfind / -type f -perm -4000 -exec ls -ld {} \\; 2>/dev/null >> \"$OUTPUT_FILE\"\n\necho \"Scan complete. Results saved to $OUTPUT_FILE\""}
{"instruction": "Create a Python script to verify the integrity of critical system files (like /etc/passwd or /bin/ls) by calculating their SHA-256 hash.", "output": "import hashlib\nimport sys\n\nfiles_to_check = ['/etc/passwd', '/etc/shadow', '/bin/ls', '/bin/bash']\n\ndef get_file_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n    except PermissionError:\n        return \"Permission denied\"\n\nprint(\"File Integrity Check (SHA-256):\")\nfor file in files_to_check:\n    print(f\"{file}: {get_file_hash(file)}\")"}
{"instruction": "Write a Bash script to apply kernel hardening parameters by appending configurations to `/etc/sysctl.conf` (e.g., disable IP forwarding, ignore ICMP broadcasts).", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.conf\"\n\n# Parameters to append\ndeclare -A params\nparams[\"net.ipv4.ip_forward\"]=\"0\"\nparams[\"net.ipv4.conf.all.accept_redirects\"]=\"0\"\nparams[\"net.ipv4.icmp_echo_ignore_broadcasts\"]=\"1\"\nparams[\"net.ipv4.conf.all.log_martians\"]=\"1\"\n\necho \"Applying kernel hardening...\"\n\nfor key in \"${!params[@]}\"; do\n    # Check if param exists, if not append it\n    if grep -q \"^$key\" \"$SYSCTL_CONF\"; then\n        sed -i \"s/^$key.*/$key = ${params[$key]}/\" \"$SYSCTL_CONF\"\n    else\n        echo \"$key = ${params[$key]}\" >> \"$SYSCTL_CONF\"\n    fi\ndone\n\n# Apply changes\nsysctl -p\necho \"Kernel parameters updated.\""}
{"instruction": "Create a Python script to check the expiration date of an SSL/TLS certificate for a given domain to ensure it is not expired.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(domain, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n    \n    # Set a timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((domain, port))\n        ssl_info = conn.getpeercert()\n        # Parse the expiration date\n        expire_date = datetime.datetime.strptime(ssl_info['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n        days_remaining = (expire_date - datetime.datetime.now()).days\n        \n        print(f\"Domain: {domain}\")\n        print(f\"Expires on: {expire_date}\")\n        print(f\"Days remaining: {days_remaining}\")\n        \n        if days_remaining < 30:\n            print(\"WARNING: Certificate expires in less than 30 days.\")\n        else:\n            print(\"Certificate status: OK\")\n            \n    except Exception as e:\n        print(f\"Error connecting to {domain}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    target_domain = input(\"Enter domain to check: \")\n    check_ssl_expiry(target_domain)"}
{"instruction": "Write a Bash script to analyze an Nginx access log and extract the top 10 IP addresses with the highest number of requests.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [[ ! -f \"$LOG_FILE\" ]]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IP addresses by request count:\"\n\n# Assumes default Nginx log format where IP is the first field\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -rn | head -n 10"}
{"instruction": "Develop a Python script to parse a Linux authentication log (auth.log) and identify IP addresses that have failed SSH login attempts more than 5 times.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_auth_log(log_path):\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from 'Failed password' lines\n    # Example: Failed password for invalid user root from 192.168.1.5 port 22 ssh2\n    pattern = re.compile(r'Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                match = pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n    except FileNotFoundError:\n        print(f\"File {log_path} not found.\")\n        return\n\n    print(\"IPs with > 5 failed login attempts:\")\n    for ip, count in failed_attempts.items():\n        if count > 5:\n            print(f\"{ip}: {count} failures\")\n\nif __name__ == \"__main__\":\n    analyze_auth_log('/var/log/auth.log')"}
{"instruction": "Write a Bash script to apply basic server hardening by setting strict permissions on critical system configuration files.", "output": "#!/bin/bash\n\necho \"Starting file permission hardening...\"\n\n# Secure shadow file (contains password hashes)\nchown root:shadow /etc/shadow\nchmod 640 /etc/shadow\necho \"Secured /etc/shadow\"\n\n# Secure passwd file\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\necho \"Secured /etc/passwd\"\n\n# Secure sshd_config\nchown root:root /etc/ssh/sshd_config\nchmod 600 /etc/ssh/sshd_config\necho \"Secured /etc/ssh/sshd_config\"\n\n# Secure cron directories\nchmod 700 /etc/cron.d\nchmod 700 /etc/cron.daily\nchmod 700 /etc/cron.hourly\nchmod 700 /etc/cron.weekly\nchmod 700 /etc/cron.monthly\necho \"Secured cron directories\"\n\necho \"Hardening complete.\""}
{"instruction": "Create a Python script that generates an nftables configuration file to drop traffic from a list of known malicious IP addresses.", "output": "def generate_nftables_blocklist(ip_list, output_file=\"nftables_blocklist.conf\"):\n    header = \"table inet filter {\\n    chain input {\\n\"\n    footer = \"    }\\n}\\n\"\n    \n    with open(output_file, 'w') as f:\n        f.write(header)\n        for ip in ip_list:\n            # Add rule to drop traffic from specific IP\n            f.write(f\"        ip saddr {ip} drop\\n\")\n        f.write(footer)\n    \n    print(f\"nftables configuration written to {output_file}\")\n\nif __name__ == \"__main__\":\n    # Example list of malicious IPs\n    malicious_ips = [\"192.0.2.1\", \"198.51.100.45\", \"203.0.113.12\"]\n    generate_nftables_blocklist(malicious_ips)"}
{"instruction": "Write a Bash script to search the entire filesystem for world-writable files, which are a security risk.", "output": "#!/bin/bash\n\necho \"Scanning for world-writable files...\"\n\n# find / -type f -perm -0002 -ls\n# -xdev prevents crossing filesystem boundaries (e.g., /proc, /sys)\n# 2>/dev/null suppresses permission denied errors\n\nfind / -xdev -type f -perm -0002 -print 2>/dev/null > world_writable_report.txt\n\ncount=$(wc -l < world_writable_report.txt)\n\necho \"Scan complete. Found $count world-writable files.\"\necho \"List saved to world_writable_report.txt\""}
{"instruction": "Develop a Python script to audit the local SSH server configuration (sshd_config) to ensure Root Login is disabled.", "output": "def audit_sshd_config(config_path='/etc/ssh/sshd_config'):\n    secure = True\n    try:\n        with open(config_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                # Ignore comments\n                if line.startswith('#') or not line:\n                    continue\n                \n                # Check PermitRootLogin directive\n                if line.lower().startswith('permitrootlogin'):\n                    parts = line.split()\n                    if len(parts) >= 2:\n                        value = parts[1].lower()\n                        if value != 'no':\n                            print(f\"[SECURITY RISK] PermitRootLogin is set to '{value}' (expected 'no').\")\n                            secure = False\n                        else:\n                            print(\"[OK] PermitRootLogin is disabled.\")\n                            \n        if secure:\n            print(\"SSH Configuration Audit: PASSED\")\n        else:\n            print(\"SSH Configuration Audit: FAILED\")\n            \n    except FileNotFoundError:\n        print(f\"Could not find configuration file at {config_path}\")\n\nif __name__ == \"__main__\":\n    audit_sshd_config()"}
{"instruction": "Write a Bash script using iptables to implement a basic firewall that drops all incoming traffic by default but allows SSH, HTTP, and HTTPS.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP for Input/Forward, ACCEPT for Output\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP (Port 80)\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\n\n# Allow HTTPS (Port 443)\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Basic firewall rules applied.\""}
{"instruction": "Create a Python script to scan a list of local IP addresses to check if a specific port (e.g., 80) is open (Service Availability/Audit).", "output": "import socket\n\ndef scan_port(ip_list, port):\n    print(f\"Scanning port {port} on provided IPs...\")\n    for ip in ip_list:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1) # 1 second timeout\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f\"[OPEN] {ip}:{port}\")\n        else:\n            print(f\"[CLOSED] {ip}:{port}\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example list of internal servers\n    servers = [\"192.168.1.10\", \"192.168.1.11\", \"192.168.1.12\"]\n    target_port = 80\n    scan_port(servers, target_port)"}
{"instruction": "Write a Bash script to search for files with the SUID bit set, which allows users to execute the file with the permissions of the file owner (often root).", "output": "#!/bin/bash\n\necho \"Searching for SUID binaries...\"\n\n# -perm /4000 looks for the SUID bit\nfind / -type f -perm /4000 -ls 2>/dev/null > suid_files.txt\n\necho \"Search complete. Results saved to suid_files.txt.\"\necho \"Review this list to ensure only necessary binaries have SUID permissions.\""}
{"instruction": "Write a Python script for Log Analysis that parses an Apache access log file to identify IP addresses that have generated more than 10 '404 Not Found' errors, potentially indicating a vulnerability scan.", "output": "import re\nfrom collections import defaultdict\n\ndef analyze_logs(log_file_path):\n    ip_404_count = defaultdict(int)\n    # Regex to capture IP and Status Code (Standard Apache Format)\n    log_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*?\"\\s(\\d{3})\\s')\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    status = match.group(2)\n                    if status == '404':\n                        ip_404_count[ip] += 1\n\n        print(\"Suspicious IPs (More than 10 404s):\")\n        for ip, count in ip_404_count.items():\n            if count > 10:\n                print(f\"IP: {ip} - 404 Count: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Create a Bash script to harden an SSH server configuration by disabling root login and password authentication, enforcing key-based auth only.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Check if running as root\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"This script must be run as root\"\n    exit 1\nfi\n\n# Backup existing config\ncp $SSHD_CONFIG $BACKUP_CONFIG\necho \"Backup created at $BACKUP_CONFIG\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Disable Password Authentication\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' $SSHD_CONFIG\n\n# Ensure PubkeyAuthentication is yes\nsed -i 's/^#\\?PubkeyAuthentication.*/PubkeyAuthentication yes/' $SSHD_CONFIG\n\n# Validate syntax and restart service\nif sshd -t; then\n    systemctl restart sshd\n    echo \"SSH hardening applied and service restarted.\"\nelse\n    echo \"Configuration syntax error. Reverting...\"\n    cp $BACKUP_CONFIG $SSHD_CONFIG\nfi"}
{"instruction": "Write a Python script to audit critical system file permissions. The script should check if /etc/shadow is readable by anyone other than root.", "output": "import os\nimport stat\n\ndef audit_shadow_file():\n    file_path = '/etc/shadow'\n    \n    try:\n        file_stat = os.stat(file_path)\n        file_mode = file_stat.st_mode\n\n        # Check if file is owned by root (uid 0)\n        if file_stat.st_uid != 0:\n            print(f\"[FAIL] {file_path} is not owned by root.\")\n        else:\n            print(f\"[PASS] {file_path} is owned by root.\")\n\n        # Check for world readable bit (Others Read)\n        if bool(file_mode & stat.S_IROTH):\n            print(f\"[FAIL] {file_path} is world-readable!\")\n        else:\n            print(f\"[PASS] {file_path} is not world-readable.\")\n            \n        # Check for group readable bit (Group Read) - usually should be shadow group or 0\n        if bool(file_mode & stat.S_IRGRP):\n             print(f\"[WARN] {file_path} is readable by group.\")\n\n    except FileNotFoundError:\n        print(f\"Error: {file_path} does not exist.\")\n    except PermissionError:\n        print(\"Error: Insufficient permissions to check file stats.\")\n\nif __name__ == \"__main__\":\n    audit_shadow_file()"}
{"instruction": "Generate a Bash script using 'iptables' to implement a basic firewall strategy: Drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH on port 22.", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH (Port 22)\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Log dropped packets (limit to prevent log flooding)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \" --log-level 7\n\necho \"Firewall rules applied successfully.\""}
{"instruction": "Write a Python script for vulnerability scanning that checks a list of servers to see if their SSL/TLS certificates are expiring within the next 30 days.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname, port=443):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\n    \n    # Set timeout\n    conn.settimeout(3.0)\n\n    try:\n        conn.connect((hostname, port))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date\n        # Format usually: 'May 15 12:00:00 2025 GMT'\n        expire_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_str, '%b %d %H:%M:%S %Y %Z')\n        \n        days_remaining = (expire_date - datetime.datetime.now()).days\n        \n        if days_remaining < 30:\n            return f\"[ALERT] {hostname}: Expires in {days_remaining} days\"\n        else:\n            return f\"[OK] {hostname}: Expires in {days_remaining} days\"\n    except Exception as e:\n        return f\"[ERROR] {hostname}: {str(e)}\"\n    finally:\n        conn.close()\n\nservers = ['example.com', 'google.com', 'expired.badssl.com']\nfor server in servers:\n    print(check_ssl_expiry(server))"}
{"instruction": "Create a Bash script for Log Analysis that extracts and counts the number of failed SSH login attempts per user from /var/log/auth.log.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found: $LOG_FILE\"\n    exit 1\nfi\n\necho \"Failed SSH Login Attempts by User:\"\necho \"----------------------------------\"\n\n# Grep for 'Failed password', extract the username (usually field before 'from' or at specific index)\n# Adjusting awk field based on standard log format: \"Failed password for [invalid user] <user> from ...\"\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{ \n    if ($9 == \"invalid\") { print $11 } \n    else { print $9 } \n}' | sort | uniq -c | sort -nr"}
{"instruction": "Write a Python script using 'nftables' (via subprocess) to block a specific IP address provided as an argument.", "output": "import subprocess\nimport sys\nimport ipaddress\n\ndef block_ip(ip_address):\n    # Validate IP address format\n    try:\n        ipaddress.ip_address(ip_address)\n    except ValueError:\n        print(\"Invalid IP address format.\")\n        return\n\n    # Construct nftables command\n    # Assumes a table 'inet filter' and chain 'input' exist.\n    # Command: nft add rule inet filter input ip saddr <IP> drop\n    cmd = [\"nft\", \"add\", \"rule\", \"inet\", \"filter\", \"input\", \"ip\", \"saddr\", ip_address, \"drop\"]\n\n    try:\n        subprocess.run(cmd, check=True)\n        print(f\"Successfully blocked IP: {ip_address}\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Failed to add rule: {e}\")\n    except FileNotFoundError:\n        print(\"nft command not found. Ensure nftables is installed.\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python3 block_ip.py <IP_ADDRESS>\")\n    else:\n        block_ip(sys.argv[1])"}
{"instruction": "Generate a Bash script for Server Hardening that searches for SUID (Set User ID) binaries on the system, which can be potential privilege escalation vectors, and saves the list to a file.", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"/root/suid_audit_$(date +%F).txt\"\n\necho \"Starting SUID binary scan...\"\n\n# Find files with SUID bit set (perm -4000)\n# -type f: only files\n# -perm -4000: look for SUID bit\n# 2>/dev/null: suppress permission denied errors for directories scan\nfind / -type f -perm -4000 -ls 2>/dev/null > \"$OUTPUT_FILE\"\n\necho \"Scan complete. Results saved to $OUTPUT_FILE\"\n\n# Optional: Display count\nCOUNT=$(wc -l < \"$OUTPUT_FILE\")\necho \"Found $COUNT SUID binaries.\""}
{"instruction": "Write a Python script to scan local ports. The script should identify which ports between 1 and 1024 are open on 'localhost' to audit exposed services.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    open_ports = []\n\n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)  # Short timeout for speed\n        result = sock.connect_ex((target_ip, port))\n        \n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n\n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"\n    ports = scan_ports(target, 1, 1024)\n    \n    if ports:\n        print(f\"Open ports found: {ports}\")\n    else:\n        print(\"No open ports found in range.\")"}
{"instruction": "Create a Bash script for Incident Response/Forensics to capture a snapshot of currently running processes, open network connections, and logged-in users, saving the data to a timestamped directory.", "output": "#!/bin/bash\n\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nEVIDENCE_DIR=\"/var/log/forensics/snapshot_$TIMESTAMP\"\n\nmkdir -p \"$EVIDENCE_DIR\"\necho \"Collecting system snapshot to $EVIDENCE_DIR...\"\n\n# 1. Running Processes\nps aux > \"$EVIDENCE_DIR/process_list.txt\"\n\n# 2. Open Network Connections (ports)\nss -tulnp > \"$EVIDENCE_DIR/open_ports.txt\"\n\n# 3. Active Network Connections\nnetstat -antup > \"$EVIDENCE_DIR/active_connections.txt\"\n\n# 4. Logged in Users\nw > \"$EVIDENCE_DIR/logged_in_users.txt\"\nlast -n 20 > \"$EVIDENCE_DIR/last_logins.txt\"\n\n# 5. Open Files\nlsof > \"$EVIDENCE_DIR/open_files.txt\"\n\necho \"Snapshot complete.\""}
{"instruction": "Write a Python script to analyze an Apache access log file and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\nimport sys\n\ndef analyze_logs(logfile_path):\n    ip_counter = Counter()\n    log_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) - - \\[.*\\] \"(GET|POST|HEAD) .*\" 404')\n\n    try:\n        with open(logfile_path, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"IPs with > 10 404 errors:\")\n        for ip, count in ip_counter.items():\n            if count > 10:\n                print(f\"{ip}: {count}\")\n\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python scan_404.py <logfile>\")\n    else:\n        analyze_logs(sys.argv[1])"}
{"instruction": "Create a Bash script using iptables to implement a 'Default Deny' policy. It should drop all incoming traffic by default, allow loopback traffic, allow established connections, and specifically allow SSH (port 22) and HTTP/HTTPS (80/443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional)\niptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \"\n\necho \"Firewall rules applied.\""}
{"instruction": "Write a Python script to audit the security headers of a given URL. It should check for the presence of 'X-Frame-Options', 'X-Content-Type-Options', and 'Strict-Transport-Security'.", "output": "import requests\nimport sys\n\ndef check_headers(url):\n    required_headers = [\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Strict-Transport-Security',\n        'Content-Security-Policy'\n    ]\n    \n    try:\n        response = requests.get(url, timeout=5)\n        headers = response.headers\n        print(f\"Scanning headers for: {url}\\n\")\n        \n        for header in required_headers:\n            if header in headers:\n                print(f\"[+] {header}: Present ({headers[header]})\")\n            else:\n                print(f\"[-] {header}: Missing\")\n                \n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to URL: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python header_audit.py <url>\")\n    else:\n        check_headers(sys.argv[1])"}
{"instruction": "Generate a Bash script to harden a Linux server by disabling common unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs, udf) to reduce the attack surface.", "output": "#!/bin/bash\n\nFILESYSTEMS=(\"cramfs\" \"freevxfs\" \"jffs2\" \"hfs\" \"hfsplus\" \"squashfs\" \"udf\")\nCONFIG_FILE=\"/etc/modprobe.d/cis_hardening.conf\"\n\necho \"Disabling unused filesystems...\"\n\nfor fs in \"${FILESYSTEMS[@]}\"; do\n    # Check if already disabled\n    if ! grep -q \"install $fs /bin/true\" \"$CONFIG_FILE\"; then\n        echo \"install $fs /bin/true\" >> \"$CONFIG_FILE\"\n        echo \"Disabled $fs\"\n    else\n        echo \"$fs is already disabled.\"\n    fi\n    # Unload module if currently loaded\n    modprobe -r \"$fs\" 2>/dev/null\ndone\n\necho \"Filesystem hardening complete.\""}
{"instruction": "Write a Python script that parses `/var/log/auth.log` (or a provided log file) to detect brute-force SSH attempts. It should alert if an IP fails authentication more than 5 times in 1 minute.", "output": "import re\nimport time\nfrom datetime import datetime\n\ndef parse_auth_log(log_path):\n    # Regex for standard syslog timestamp and SSH failure\n    # Example: Oct 10 12:00:01 hostname sshd[123]: Failed password for root from 192.168.1.5 port 22 ssh2\n    pattern = re.compile(r'^(\\w{3}\\s+\\d+\\s\\d{2}:\\d{2}:\\d{2}).*Failed password.*from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n    \n    failed_attempts = []\n    current_year = datetime.now().year\n\n    with open(log_path, 'r') as f:\n        for line in f:\n            match = pattern.search(line)\n            if match:\n                timestamp_str = f\"{current_year} {match.group(1)}\"\n                ip = match.group(2)\n                try:\n                    dt = datetime.strptime(timestamp_str, \"%Y %b %d %H:%M:%S\")\n                    failed_attempts.append({'time': dt, 'ip': ip})\n                except ValueError:\n                    continue\n\n    # Analyze for brute force (naive approach: sliding window)\n    # In a real agent, this would run real-time or tail the log\n    print(\"Analyzing for brute force patterns...\")\n    # Group by IP\n    ip_times = {}\n    for entry in failed_attempts:\n        ip_times.setdefault(entry['ip'], []).append(entry['time'])\n\n    for ip, times in ip_times.items():\n        times.sort()\n        for i in range(len(times)):\n            count = 0\n            start_time = times[i]\n            for j in range(i, len(times)):\n                if (times[j] - start_time).total_seconds() <= 60:\n                    count += 1\n                else:\n                    break\n            if count > 5:\n                print(f\"ALERT: Potential Brute Force from {ip} - {count} failures in 1 minute starting at {start_time}\")\n                break # Alert once per burst\n\nif __name__ == '__main__':\n    # Note: Requires read permissions on auth.log\n    try:\n        parse_auth_log('/var/log/auth.log')\n    except PermissionError:\n        print(\"Permission denied: Run as root\")"}
{"instruction": "Create a Bash script using `nftables` to mitigate DDoS attacks by limiting the rate of incoming ICMP (ping) packets.", "output": "#!/bin/bash\n\n# Create table if it doesn't exist\nnft add table ip filter\n\n# Create chain if it doesn't exist\nnft add chain ip filter input { type filter hook input priority 0 \\; }\n\n# Add rule: Limit ICMP echo-request to 10 per second, drop excess\necho \"Applying ICMP rate limiting...\"\nnft add rule ip filter input ip protocol icmp icmp type echo-request limit rate 10/second accept\nnft add rule ip filter input ip protocol icmp icmp type echo-request drop\n\necho \"NFTables rule applied: ICMP limited to 10/sec.\""}
{"instruction": "Write a Python script to verify file permissions on critical system configuration files (e.g., /etc/shadow, /etc/passwd) to ensure they comply with security best practices.", "output": "import os\nimport stat\n\ndef check_permissions(file_path, max_perm_octal):\n    if not os.path.exists(file_path):\n        print(f\"[?] {file_path} does not exist.\")\n        return\n\n    st = os.stat(file_path)\n    # Get octal permission (e.g., 644)\n    current_perm = oct(st.st_mode & 0o777)\n    current_perm_int = int(current_perm, 8)\n    max_perm_int = int(str(max_perm_octal), 8)\n\n    if current_perm_int > max_perm_int:\n        print(f\"[FAIL] {file_path}: Current {current_perm}, Max Allowed {max_perm_octal}\")\n    else:\n        print(f\"[PASS] {file_path}: Current {current_perm}\")\n\nfiles_to_check = [\n    {\"/etc/shadow\": 600},   # Should be rw------- or 000\n    {\"/etc/passwd\": 644},   # Should be rw-r--r--\n    {\"/etc/group\": 644},\n    {\"/etc/gshadow\": 600},\n    {\"/etc/ssh/sshd_config\": 600}\n]\n\nfor entry in files_to_check:\n    for fpath, max_perm in entry.items():\n        check_permissions(fpath, max_perm)"}
{"instruction": "Generate a Bash script to automate the hardening of the SSH daemon configuration (`/etc/ssh/sshd_config`). It should disable root login, disable password authentication, and change the default port.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP=\"/etc/ssh/sshd_config.bak.$(date +%F)\"\nNEW_PORT=2222\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP\"\necho \"Backup created at $BACKUP\"\n\n# Apply Hardening\n# 1. Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# 2. Disable Password Authentication (Force Key-based)\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# 3. Change Port\nsed -i \"s/^#Port 22/Port $NEW_PORT/\" \"$SSHD_CONFIG\"\nsed -i \"s/^Port 22/Port $NEW_PORT/\" \"$SSHD_CONFIG\"\n\n# 4. Disable Empty Passwords\nsed -i 's/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/' \"$SSHD_CONFIG\"\nsed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' \"$SSHD_CONFIG\"\n\necho \"Configuration updated. Validate config with 'sshd -t' before restarting service.\""}
{"instruction": "Write a Python script that acts as a simple port scanner to identify open ports on a local server (localhost) for inventory purposes.", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n\n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"127.0.0.1\"\n    # Scanning common ports range\n    ports = scan_ports(target, 1, 1024)\n    \n    if ports:\n        print(f\"Open ports on {target}: {ports}\")\n    else:\n        print(f\"No open ports found in range on {target}.\")"}
{"instruction": "Create a Bash script to search through all logs in `/var/log` for a specific suspicious string (IOC) provided as an argument, and output the filename and line number.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <search_term>\"\n    echo \"Example: $0 'malicious_user_agent'\"\n    exit 1\nfi\n\nSEARCH_TERM=$1\nLOG_DIR=\"/var/log\"\n\necho \"Searching for '$SEARCH_TERM' in $LOG_DIR...\"\n\n# grep recursively, ignoring binary files, with line numbers\n# 2>/dev/null suppresses permission denied errors\ngrep -rnI \"$SEARCH_TERM\" \"$LOG_DIR\" 2>/dev/null\n\necho \"Search complete.\""}
{"instruction": "Create a Bash script to harden SSH configuration by disabling root login and enforcing empty password checks, then reloading the service.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\n# Backup config\ncp $SSHD_CONFIG \"$SSHD_CONFIG.bak\"\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" $SSHD_CONFIG; then\n    sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nelse\n    echo \"PermitRootLogin no\" >> $SSHD_CONFIG\nfi\n\n# Disable Empty Passwords\nif grep -q \"^PermitEmptyPasswords\" $SSHD_CONFIG; then\n    sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' $SSHD_CONFIG\nelse\n    echo \"PermitEmptyPasswords no\" >> $SSHD_CONFIG\nfi\n\n# Reload SSHD\nsystemctl reload sshd\necho \"SSH Hardening applied.\""}
{"instruction": "Write a Python script to parse a web server access log (Common Log Format) and identify IP addresses that have generated more than 10 '404 Not Found' errors, indicating potential scanning activity.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_pattern = r'^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    status_pattern = r'\\s404\\s'\n    \n    found_ips = []\n    \n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                if re.search(status_pattern, line):\n                    match = re.match(ip_pattern, line)\n                    if match:\n                        found_ips.append(match.group(1))\n        \n        counts = Counter(found_ips)\n        print(\"Suspicious IPs (More than 10 404s):\")\n        for ip, count in counts.items():\n            if count > 10:\n                print(f\"{ip}: {count} attempts\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('/var/log/apache2/access.log')"}
{"instruction": "Generate a Bash script using 'iptables' to implement a basic firewall policy: Drop all incoming traffic by default, allow loopback, allow established connections, and allow SSH (port 22).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set Default Policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow Loopback\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow Established and Related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Save rules (Debian/Ubuntu based)\nnetfilter-persistent save\necho \"Firewall rules updated.\""}
{"instruction": "Write a Python script for file integrity monitoring that calculates the SHA-256 hash of critical system binaries (e.g., /bin/ls, /bin/ps) to detect potential tampering.", "output": "import hashlib\nimport os\n\ncritical_files = ['/bin/ls', '/bin/ps', '/bin/netstat', '/usr/bin/whoami']\n\ndef calculate_hash(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read file in chunks to avoid memory issues\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return \"File not found\"\n\nprint(\"--- File Integrity Report ---\")\nfor file in critical_files:\n    file_hash = calculate_hash(file)\n    print(f\"{file}: {file_hash}\")"}
{"instruction": "Create a Bash script to scan for world-writable files in the '/home' and '/var/www' directories and save the list to a report file for auditing.", "output": "#!/bin/bash\n\nREPORT_FILE=\"/var/log/security_audit_world_writable.txt\"\nDIRECTORIES=\"/home /var/www\"\n\necho \"Starting World-Writable File Scan at $(date)\" > $REPORT_FILE\n\nfor dir in $DIRECTORIES; do\n    if [ -d \"$dir\" ]; then\n        find \"$dir\" -type f -perm -0002 -print >> $REPORT_FILE 2>/dev/null\n    fi\ndone\n\necho \"Scan complete. Report saved to $REPORT_FILE\""}
{"instruction": "Write a Python script using the 'socket' library to perform a local port audit, checking if specific critical ports (21, 22, 23, 80, 443, 3306) are open/listening on localhost.", "output": "import socket\n\ntarget = \"127.0.0.1\"\nports_to_check = [21, 22, 23, 80, 443, 3306]\n\ndef scan_ports(ip, ports):\n    print(f\"Scanning localhost ({ip})...\")\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            print(f\"[ALERT] Port {port} is OPEN\")\n        else:\n            print(f\"[INFO] Port {port} is closed\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    scan_ports(target, ports_to_check)"}
{"instruction": "Generate a Bash script using 'nftables' to block a list of known malicious IP addresses stored in a text file.", "output": "#!/bin/bash\n\nBLOCKLIST_FILE=\"malicious_ips.txt\"\nTABLE_NAME=\"filter\"\nCHAIN_NAME=\"input\"\n\n# Ensure nftables is running\nif ! nft list table inet $TABLE_NAME > /dev/null 2>&1; then\n    nft add table inet $TABLE_NAME\n    nft add chain inet $TABLE_NAME $CHAIN_NAME { type filter hook input priority 0 \\; }\nfi\n\n# Loop through file and add drop rules\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    echo \"Blocking $ip\"\n    nft add rule inet $TABLE_NAME $CHAIN_NAME ip saddr $ip drop\ndone < \"$BLOCKLIST_FILE\"\n\necho \"Blocklist applied.\""}
{"instruction": "Write a Python script to analyze Linux authentication logs (/var/log/auth.log) and detect SSH brute-force attacks by counting failed password attempts per IP address.", "output": "import re\n\ndef detect_bruteforce(log_path, threshold=5):\n    failed_attempts = {}\n    # Regex for standard SSH failed password log entry\n    regex = r\"Failed password for .* from (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if \"sshd\" in line and \"Failed password\" in line:\n                    match = re.search(regex, line)\n                    if match:\n                        ip = match.group(1)\n                        failed_attempts[ip] = failed_attempts.get(ip, 0) + 1\n\n        print(f\"--- IPs with > {threshold} Failed Login Attempts ---\")\n        for ip, count in failed_attempts.items():\n            if count > threshold:\n                print(f\"IP: {ip} | Count: {count}\")\n\n    except PermissionError:\n        print(\"Error: Run as root to read auth.log\")\n    except FileNotFoundError:\n        print(\"Error: Log file not found\")\n\nif __name__ == \"__main__\":\n    detect_bruteforce('/var/log/auth.log')"}
{"instruction": "Create a Bash script to audit user accounts: verify that the root account uses UID 0 and check for any other accounts that might have been assigned UID 0 (a sign of compromise).", "output": "#!/bin/bash\n\necho \"Checking for UID 0 accounts...\"\n\nwhile IFS=: read -r username password uid gid info home shell; do\n    if [ \"$uid\" -eq 0 ]; then\n        if [ \"$username\" != \"root\" ]; then\n            echo \"[WARNING] Non-root account found with UID 0: $username\"\n        else\n            echo \"[OK] Root account verified as UID 0.\"\n        fi\n    fi\ndone < /etc/passwd\n\necho \"Audit complete.\""}
{"instruction": "Write a Python script to check the expiration dates of SSL/TLS certificates for a list of domains to prevent security lapses due to expired certificates.", "output": "import ssl\nimport socket\nimport datetime\n\ndomains = ['google.com', 'github.com', 'example.com']\n\ndef check_ssl_expiry(domain_list):\n    print(\"{:<20} {:<30} {:<10}\".format(\"Domain\", \"Expiry Date\", \"Days Left\"))\n    print(\"-\"*60)\n    \n    for domain in domain_list:\n        context = ssl.create_default_context()\n        conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)\n        \n        try:\n            conn.connect((domain, 443))\n            cert = conn.getpeercert()\n            expiry_date = datetime.datetime.strptime(cert['notAfter'], r'%b %d %H:%M:%S %Y %Z')\n            days_left = (expiry_date - datetime.datetime.utcnow()).days\n            \n            print(\"{:<20} {:<30} {:<10}\".format(domain, str(expiry_date), days_left))\n            conn.close()\n        except Exception as e:\n            print(f\"{domain}: Error retrieving certificate - {e}\")\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(domains)"}
{"instruction": "Create a Python script for Log Analysis that parses an Apache access log file to identify and count IP addresses associated with '404 Not Found' errors, which may indicate a scanning attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_404_errors(log_file_path):\n    ip_pattern = r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n    found_ips = []\n\n    try:\n        with open(log_file_path, 'r') as file:\n            for line in file:\n                if ' 404 ' in line:\n                    match = re.search(ip_pattern, line)\n                    if match:\n                        found_ips.append(match.group(1))\n        \n        ip_counts = Counter(found_ips)\n        print(f'--- 404 Error Analysis for {log_file_path} ---')\n        for ip, count in ip_counts.most_common(10):\n            print(f'IP: {ip} | Count: {count}')\n            \n    except FileNotFoundError:\n        print('Error: Log file not found.')\n\nif __name__ == '__main__':\n    # Example usage\n    analyze_404_errors('/var/log/apache2/access.log')"}
{"instruction": "Write a Bash script for Server Hardening that disables root login over SSH and changes the default SSH port to 2222 to reduce automated attacks.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Please run as root\"\n  exit\nfi\n\n# Backup config\ncp $SSHD_CONFIG $BACKUP_CONFIG\necho \"Backup created at $BACKUP_CONFIG\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $SSHD_CONFIG\n\n# Change Port to 2222\nsed -i 's/^#Port 22/Port 2222/' $SSHD_CONFIG\nsed -i 's/^Port 22/Port 2222/' $SSHD_CONFIG\n\n# Validate syntax before restarting\nsshd -t\nif [ $? -eq 0 ]; then\n    echo \"Configuration syntax is valid. Restarting SSH...\"\n    systemctl restart sshd\n    echo \"Hardening complete: Root login disabled, Port set to 2222.\"\nelse\n    echo \"Syntax error detected. Reverting changes...\"\n    cp $BACKUP_CONFIG $SSHD_CONFIG\nfi"}
{"instruction": "Generate a Python script for a simple internal Vulnerability Scan that checks if specific sensitive ports (21, 23, 3389) are open on the localhost.", "output": "import socket\n\ndef check_ports():\n    target = \"127.0.0.1\"\n    # Ports to check: FTP (21), Telnet (23), RDP (3389)\n    ports_to_check = [21, 23, 3389]\n    \n    print(f\"Scanning localhost ({target}) for risky open ports...\")\n    \n    for port in ports_to_check:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target, port))\n        \n        if result == 0:\n            print(f\"[WARNING] Port {port} is OPEN. Investigate immediately.\")\n        else:\n            print(f\"[OK] Port {port} is closed.\")\n        sock.close()\n\nif __name__ == '__main__':\n    check_ports()"}
{"instruction": "Create a Bash script using 'iptables' to block a specific malicious IP address and log any attempts made by that IP before dropping the packet.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <IP_ADDRESS_TO_BLOCK>\"\n    exit 1\nfi\n\nBLOCK_IP=$1\n\n# Check root\nif [ \"$EUID\" -ne 0 ]; then \n    echo \"Please run as root\"\n    exit 1\nfi\n\n# Log the packet with a prefix\niptables -A INPUT -s $BLOCK_IP -j LOG --log-prefix \"IP Blocked: \" --log-level 4\n\n# Drop the packet\niptables -A INPUT -s $BLOCK_IP -j DROP\n\necho \"IP $BLOCK_IP has been blocked and logging enabled.\""}
{"instruction": "Write a Python script for Server Hardening that audits file permissions, specifically checking if critical system files (like /etc/shadow or /etc/passwd) are world-writable.", "output": "import os\nimport stat\n\ndef check_file_permissions(file_path):\n    try:\n        file_stat = os.stat(file_path)\n        mode = file_stat.st_mode\n        \n        # Check if world writable (Others have Write permission)\n        if mode & stat.S_IWOTH:\n            print(f\"[CRITICAL] {file_path} is WORLD WRITABLE! ({oct(mode)[-3:]})\")\n        else:\n            print(f\"[OK] {file_path} permissions seem safe ({oct(mode)[-3:]}).\")\n            \n    except FileNotFoundError:\n        print(f\"[ERROR] File {file_path} not found.\")\n\ncritical_files = ['/etc/passwd', '/etc/shadow', '/etc/hosts', '/etc/ssh/sshd_config']\n\nif __name__ == '__main__':\n    print(\"--- Starting Permission Audit ---\")\n    for f in critical_files:\n        check_file_permissions(f)"}
{"instruction": "Create a Bash script for SIEM/Log Analysis that monitors `/var/log/auth.log` in real-time for failed SSH password attempts and alerts to the console.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\necho \"Monitoring $LOG_FILE for failed SSH login attempts...\"\n\n# Use tail -f to follow the log, grep for Failed password\ntail -Fn0 $LOG_FILE | while read line ; do\n    echo \"$line\" | grep \"Failed password\" > /dev/null\n    if [ $? = 0 ]; then\n        # Extract IP (assuming standard format)\n        IP=$(echo \"$line\" | grep -oE \"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\")\n        TIMESTAMP=$(date)\n        echo \"[ALERT] Failed SSH Login Detected at $TIMESTAMP from IP: $IP\"\n    fi\ndone"}
{"instruction": "Write a Python script that calculates the SHA-256 hash of a file to verify its integrity, a common task in Incident Response and vulnerability management.", "output": "import hashlib\nimport sys\n\ndef calculate_sha256(file_path):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError:\n        return None\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <file_path>\")\n    else:\n        file_path = sys.argv[1]\n        file_hash = calculate_sha256(file_path)\n        if file_hash:\n            print(f\"File: {file_path}\")\n            print(f\"SHA-256: {file_hash}\")\n        else:\n            print(\"File not found.\")"}
{"instruction": "Create a Bash script using 'nftables' to implement a default deny firewall policy, allowing only established traffic, loopback, and SSH.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Define the table and chain\nnft add table inet filter\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback traffic\nnft add rule inet filter input iif lo accept\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH (Port 22)\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configured: Default DROP, Allowed: Loopback, Established, SSH, ICMP.\""}
{"instruction": "Generate a Bash script for Hardening that sets critical kernel parameters via `sysctl` to prevent IP spoofing and disable ICMP redirects.", "output": "#!/bin/bash\n\nSYSCTL_CONF=\"/etc/sysctl.d/99-security-hardening.conf\"\n\necho \"Applying kernel hardening settings...\"\n\ncat <<EOF > $SYSCTL_CONF\n# IP Spoofing protection\nnet.ipv4.conf.all.rp_filter = 1\nnet.ipv4.conf.default.rp_filter = 1\n\n# Ignore ICMP broadcast requests\nnet.ipv4.icmp_echo_ignore_broadcasts = 1\n\n# Disable source packet routing\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv4.conf.default.accept_source_route = 0\n\n# Ignore send redirects\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.default.send_redirects = 0\n\n# Block SYN attacks\nnet.ipv4.tcp_syncookies = 1\nEOF\n\n# Apply changes\nsysctl -p $SYSCTL_CONF\necho \"Kernel parameters updated.\""}
{"instruction": "Write a Python script for SIEM integration that parses a JSON-formatted application log and alerts if a specific 'event_type' (e.g., 'admin_login') occurs outside of business hours.", "output": "import json\nfrom datetime import datetime\n\ndef audit_log_events(json_log_file):\n    # Business hours: 09:00 to 18:00\n    start_hour = 9\n    end_hour = 18\n    \n    with open(json_log_file, 'r') as f:\n        for line in f:\n            try:\n                log_entry = json.loads(line)\n                event_type = log_entry.get('event_type')\n                timestamp_str = log_entry.get('timestamp') # ISO 8601 format expected\n                \n                if event_type == 'admin_login':\n                    dt = datetime.fromisoformat(timestamp_str)\n                    if not (start_hour <= dt.hour < end_hour):\n                        print(f\"[ALERT] After-hours Admin Login detected!\")\n                        print(f\"User: {log_entry.get('username')}, Time: {dt}\")\n                        \n            except json.JSONDecodeError:\n                continue\n            except ValueError:\n                continue\n\nif __name__ == '__main__':\n    # Takes a file with one JSON object per line\n    # Example line: {\"event_type\": \"admin_login\", \"username\": \"root\", \"timestamp\": \"2023-10-27T23:00:00\"}\n    audit_log_events('app_events.json')"}
{"instruction": "Create a Python script to parse an Apache access log file ('access.log') and identify IP addresses that have generated more than 10 '404 Not Found' errors, which may indicate a vulnerability scanner or forced browsing attempt.", "output": "import re\nfrom collections import Counter\n\ndef analyze_logs(log_file):\n    ip_counter = Counter()\n    log_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) .* \"(GET|POST) .*\" 404')\n\n    try:\n        with open(log_file, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n        \n        print(\"Suspicious IPs (More than 10 404s):\")\n        for ip, count in ip_counter.items():\n            if count > 10:\n                print(f\"{ip}: {count} attempts\")\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    analyze_logs('access.log')"}
{"instruction": "Write a Bash script to harden an SSH server by disabling root login and password authentication in the /etc/ssh/sshd_config file, then reloading the service.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Backup config\ncp $CONFIG_FILE $BACKUP_FILE\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' $CONFIG_FILE\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' $CONFIG_FILE\n\n# Validate syntax and restart SSH\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl reload sshd\n    echo \"SSH Hardening applied successfully.\"\nelse\n    echo \"Configuration test failed. Reverting...\"\n    cp $BACKUP_FILE $CONFIG_FILE\nfi"}
{"instruction": "Develop a Python script to audit file permissions of critical system files (e.g., /etc/shadow, /etc/passwd). It should alert if /etc/shadow is world-readable or if /etc/passwd is world-writable.", "output": "import os\nimport stat\n\ndef check_permissions():\n    critical_files = [\n        '/etc/shadow',\n        '/etc/passwd'\n    ]\n\n    for filepath in critical_files:\n        if not os.path.exists(filepath):\n            continue\n        \n        st = os.stat(filepath)\n        mode = st.st_mode\n\n        # Check /etc/shadow for world-readability (other read)\n        if filepath == '/etc/shadow':\n            if mode & stat.S_IROTH:\n                print(f\"[ALERT] {filepath} is world-readable! (Unsafe)\")\n            else:\n                print(f\"[OK] {filepath} permissions are safe.\")\n\n        # Check /etc/passwd for world-writability (other write)\n        if filepath == '/etc/passwd':\n            if mode & stat.S_IWOTH:\n                print(f\"[ALERT] {filepath} is world-writable! (Unsafe)\")\n            else:\n                print(f\"[OK] {filepath} permissions are safe.\")\n\nif __name__ == \"__main__\":\n    check_permissions()"}
{"instruction": "Create a Bash script that reads a list of malicious IP addresses from a file named 'blacklist.txt' and creates iptables rules to drop all incoming traffic from those IPs.", "output": "#!/bin/bash\n\nBLACKLIST_FILE=\"blacklist.txt\"\n\nif [ ! -f \"$BLACKLIST_FILE\" ]; then\n    echo \"Blacklist file not found.\"\n    exit 1\nfi\n\necho \"Applying iptables rules from $BLACKLIST_FILE...\"\n\nwhile IFS= read -r ip; do\n    # Skip empty lines or comments\n    [[ \"$ip\" =~ ^#.*$ ]] || [[ -z \"$ip\" ]] && continue\n    \n    # Check if rule exists to avoid duplicates\n    iptables -C INPUT -s \"$ip\" -j DROP 2>/dev/null\n    if [ $? -ne 0 ]; then\n        iptables -A INPUT -s \"$ip\" -j DROP\n        echo \"Blocked: $ip\"\n    else\n        echo \"Already blocked: $ip\"\n    fi\ndone < \"$BLACKLIST_FILE\""}
{"instruction": "Write a Python script that performs a basic local port scan on '127.0.0.1' to identify listening services on common ports (20-1024) for auditing purposes.", "output": "import socket\n\ndef audit_local_ports():\n    target = '127.0.0.1'\n    print(f\"Scanning localhost ({target}) for open ports...\")\n    \n    open_ports = []\n    \n    # Scan common privileged ports\n    for port in range(20, 1025):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.1)\n        result = sock.connect_ex((target, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n\n    if open_ports:\n        print(f\"Open ports found: {open_ports}\")\n    else:\n        print(\"No open ports found in range 20-1024.\")\n\nif __name__ == \"__main__\":\n    audit_local_ports()"}
{"instruction": "Generate a Bash script to configure 'nftables' as a stateful firewall. It should allow established connections, loopback traffic, and SSH (port 22), while dropping all other incoming traffic by default.", "output": "#!/bin/bash\n\n# Flush existing rules\nnft flush ruleset\n\n# Create table\nnft add table inet filter\n\n# Create chains\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\nnft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\nnft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH\nnft add rule inet filter input tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configuration applied.\""}
{"instruction": "Write a Python script for SIEM-like functionality that monitors a specified log file (e.g., /var/log/syslog) in real-time and prints an alert if the keyword 'segfault' or 'panic' is detected.", "output": "import time\nimport os\n\ndef tail_monitor(logfile):\n    keywords = ['segfault', 'panic']\n    \n    try:\n        f = open(logfile, 'r')\n        # Go to the end of the file\n        f.seek(0, os.SEEK_END)\n        \n        print(f\"Monitoring {logfile} for keywords: {keywords}\")\n        \n        while True:\n            line = f.readline()\n            if not line:\n                time.sleep(0.5)\n                continue\n            \n            if any(keyword in line.lower() for keyword in keywords):\n                print(f\"[ALERT] Critical Error Detected: {line.strip()}\")\n                \n    except FileNotFoundError:\n        print(\"Log file not found.\")\n    except KeyboardInterrupt:\n        print(\"Stopping monitor.\")\n        f.close()\n\nif __name__ == \"__main__\":\n    # Note: Requires read permissions on the log file\n    tail_monitor('/var/log/syslog')"}
{"instruction": "Create a Bash script to check for specific binary files often associated with rootkits or unauthorized tools (e.g., netcat, nmap) in standard binary directories, alerting if found.", "output": "#!/bin/bash\n\nSUSPICIOUS_TOOLS=(\"nc\" \"netcat\" \"nmap\" \"tcpdump\" \"wireshark\")\nSEARCH_DIRS=(\"/bin\" \"/sbin\" \"/usr/bin\" \"/usr/sbin\")\n\necho \"Starting audit for restricted tools...\"\n\nfor tool in \"${SUSPICIOUS_TOOLS[@]}\"; do\n    for dir in \"${SEARCH_DIRS[@]}\"; do\n        if [ -f \"$dir/$tool\" ]; then\n            echo \"[WARNING] Restricted tool found: $dir/$tool\"\n        fi\n    done\ndone\n\necho \"Audit complete.\""}
{"instruction": "Develop a Python script to verify the integrity of a specific configuration file by calculating its SHA-256 hash and comparing it against a known good hash.", "output": "import hashlib\nimport sys\n\ndef verify_integrity(filepath, expected_hash):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            # Read and update hash string value in blocks of 4K\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        \n        calculated_hash = sha256_hash.hexdigest()\n        \n        if calculated_hash == expected_hash:\n            print(f\"[PASS] Integrity verified for {filepath}.\")\n            return True\n        else:\n            print(f\"[FAIL] Hash mismatch for {filepath}!\")\n            print(f\"Expected: {expected_hash}\")\n            print(f\"Found:    {calculated_hash}\")\n            return False\n            \n    except FileNotFoundError:\n        print(f\"File {filepath} not found.\")\n        return False\n\nif __name__ == \"__main__\":\n    # Example usage\n    target_file = \"/etc/hosts\"\n    known_hash = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" # Example empty hash\n    verify_integrity(target_file, known_hash)"}
{"instruction": "Write a Bash script to analyze the '/var/log/auth.log' file and extract the top 5 IP addresses that have failed SSH login attempts.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Auth log not found at $LOG_FILE\"\n    exit 1\nfi\n\necho \"Top 5 IPs with failed SSH login attempts:\"\n\n# Grep for 'Failed password', extract IPv4, sort, count unique, sort by count desc, head 5\ngrep \"Failed password\" \"$LOG_FILE\" | \\\ngrep -oE \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\" | \\\nsort | \\\nuniq -c | \\\nsort -nr | \\\nhead -n 5"}
{"instruction": "Write a Python script to parse a standard Apache access log file ('access.log'). The script should identify and print any IP addresses that have generated more than 10 '404 Not Found' errors, which may indicate a vulnerability scanner or forced browsing attempt.", "output": "import re\nfrom collections import Counter\n\ndef detect_404_scanners(log_file_path):\n    ip_counter = Counter()\n    log_pattern = re.compile(r'(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}).*\"\\s404\\s')\n\n    try:\n        with open(log_file_path, 'r') as f:\n            for line in f:\n                match = log_pattern.search(line)\n                if match:\n                    ip_counter[match.group(1)] += 1\n    except FileNotFoundError:\n        print(f\"Error: File {log_file_path} not found.\")\n        return\n\n    print(\"IPs with > 10 404 errors:\")\n    for ip, count in ip_counter.items():\n        if count > 10:\n            print(f\"{ip}: {count}\")\n\nif __name__ == \"__main__\":\n    detect_404_scanners('access.log')"}
{"instruction": "Create a Bash script using `iptables` to implement a basic host-based firewall. The policy should default to DROP for incoming traffic, allow loopback traffic, allow established/related connections, and explicitly allow SSH (port 22) and HTTP/HTTPS (80, 443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\n\n# Set default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related incoming connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Allow HTTP and HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Log dropped packets (optional, rate limited)\niptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix \"IPTables-Dropped: \"\n\nprint \"Firewall rules applied.\""}
{"instruction": "Write a Python script to audit the local SSH configuration file (`/etc/ssh/sshd_config`). The script should verify that 'PermitRootLogin' is set to 'no' and 'PasswordAuthentication' is set to 'no' to enforce key-based authentication.", "output": "def audit_ssh_config(config_path='/etc/ssh/sshd_config'):\n    compliance = {\n        'PermitRootLogin': 'no',\n        'PasswordAuthentication': 'no'\n    }\n    \n    issues = []\n    \n    try:\n        with open(config_path, 'r') as f:\n            lines = f.readlines()\n            \n        config_map = {}\n        for line in lines:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            parts = line.split()\n            if len(parts) >= 2:\n                config_map[parts[0]] = parts[1]\n        \n        for key, expected_val in compliance.items():\n            actual_val = config_map.get(key)\n            if actual_val != expected_val:\n                issues.append(f\"VIOLATION: {key} is set to '{actual_val}' (Expected: '{expected_val}')\")\n            else:\n                print(f\"PASS: {key} is correctly set to '{expected_val}'\")\n                \n    except IOError:\n        print(\"Error: Could not read sshd_config. Run as root?\")\n        return\n\n    if issues:\n        print(\"\\nAudit Failed:\")\n        for issue in issues:\n            print(issue)\n    else:\n        print(\"\\nAudit Passed.\")\n\nif __name__ == \"__main__\":\n    audit_ssh_config()"}
{"instruction": "Write a Bash script to perform server hardening by setting secure permissions and ownership on critical system files (`/etc/passwd`, `/etc/shadow`, `/etc/group`, `/etc/gshadow`) based on CIS benchmarks.", "output": "#!/bin/bash\n\n# /etc/passwd: root:root 644\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\necho \"Secured /etc/passwd\"\n\n# /etc/shadow: root:shadow 640 (or 000 depending on strictness, usually 640)\nchown root:shadow /etc/shadow\nchmod 640 /etc/shadow\necho \"Secured /etc/shadow\"\n\n# /etc/group: root:root 644\nchown root:root /etc/group\nchmod 644 /etc/group\necho \"Secured /etc/group\"\n\n# /etc/gshadow: root:shadow 640\nchown root:shadow /etc/gshadow\nchmod 640 /etc/gshadow\necho \"Secured /etc/gshadow\"\n\necho \"Critical file permissions hardening complete.\""}
{"instruction": "Write a Python script using the `socket` library to perform a simple port scan on `localhost` to identify listening services on common ports (21, 22, 23, 25, 53, 80, 443, 3306, 8080).", "output": "import socket\n\ndef scan_localhost():\n    target = \"127.0.0.1\"\n    ports_to_scan = [21, 22, 23, 25, 53, 80, 443, 3306, 8080]\n    \n    print(f\"Scanning {target} for common open ports...\")\n    \n    for port in ports_to_scan:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target, port))\n        \n        if result == 0:\n            try:\n                service = socket.getservbyport(port)\n            except:\n                service = \"unknown\"\n            print(f\"[OPEN] Port {port} ({service})\")\n        else:\n            # Port is closed or filtered\n            pass\n        \n        sock.close()\n\nif __name__ == \"__main__\":\n    scan_localhost()"}
{"instruction": "Generate a Bash one-liner to analyze Nginx access logs and extract the top 5 IP addresses generating the most requests, useful for identifying potential DoS sources or heavy scrapers.", "output": "cat /var/log/nginx/access.log | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 5"}
{"instruction": "Write a Python script to check for SSL/TLS certificate expiration. The script should connect to a specified hostname on port 443 and print the number of days remaining until the certificate expires.", "output": "import ssl\nimport socket\nimport datetime\n\ndef check_ssl_expiry(hostname):\n    context = ssl.create_default_context()\n    conn = context.wrap_socket(socket.socket(socket.AF_INET),\n                               server_hostname=hostname)\n    \n    # 3 second timeout\n    conn.settimeout(3.0)\n    \n    try:\n        conn.connect((hostname, 443))\n        ssl_info = conn.getpeercert()\n        \n        # Parse expiration date\n        # Format usually: 'May 28 12:00:00 2025 GMT'\n        expire_str = ssl_info['notAfter']\n        expire_date = datetime.datetime.strptime(expire_str, '%b %d %H:%M:%S %Y %Z')\n        \n        remaining = expire_date - datetime.datetime.utcnow()\n        print(f\"Certificate for {hostname} expires in {remaining.days} days.\")\n        \n    except Exception as e:\n        print(f\"Error checking {hostname}: {e}\")\n    finally:\n        conn.close()\n\nif __name__ == \"__main__\":\n    check_ssl_expiry(\"www.example.com\")"}
{"instruction": "Write a Bash script to harden the system by disabling unused filesystems (cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs, udf, vfat) to reduce the attack surface. It should create a config file in `/etc/modprobe.d/`.", "output": "#!/bin/bash\n\nFILESYSTEMS=\"cramfs freevxfs jffs2 hfs hfsplus squashfs udf vfat\"\nCONFIG_FILE=\"/etc/modprobe.d/cis_hardening.conf\"\n\necho \"# Hardening unused filesystems\" > \"$CONFIG_FILE\"\n\nfor fs in $FILESYSTEMS; do\n    echo \"install $fs /bin/true\" >> \"$CONFIG_FILE\"\n    echo \"Disabled filesystem: $fs\"\ndone\n\necho \"Configuration written to $CONFIG_FILE. Reboot required to take full effect.\""}
{"instruction": "Write a Python script that parses `/var/log/auth.log` (or `secure`) to detect brute-force SSH attempts. It should count the number of 'Failed password' events per user and alert if the count exceeds 5.", "output": "import re\nfrom collections import defaultdict\n\ndef check_bruteforce(log_path='/var/log/auth.log'):\n    failures = defaultdict(int)\n    # Regex for standard SSH failure log\n    # Example: Failed password for invalid user admin from 192.168.1.5 port ...\n    pattern = re.compile(r'Failed password for (?:invalid user )?(\\S+) from')\n\n    try:\n        with open(log_path, 'r') as f:\n            for line in f:\n                if 'sshd' in line and 'Failed password' in line:\n                    match = pattern.search(line)\n                    if match:\n                        user = match.group(1)\n                        failures[user] += 1\n    except FileNotFoundError:\n        print(f\"Log file {log_path} not found.\")\n        return\n\n    print(\"Potential Brute Force Targets (>5 failures):\")\n    for user, count in failures.items():\n        if count > 5:\n            print(f\"User: {user} | Failures: {count}\")\n\nif __name__ == \"__main__\":\n    check_bruteforce()"}
{"instruction": "Generate a Bash script using `nftables` to configure a simple firewall. It should define a table `inet filter`, add a chain for input handling, allow established connections, drop invalid connections, allow SSH from a specific management subnet (10.0.0.0/24), and drop everything else.", "output": "#!/bin/bash\n\n# Create table\nnft add table inet filter\n\n# Create input chain with default drop policy\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow established and related traffic\nnft add rule inet filter input ct state established,related accept\n\n# Drop invalid packets\nnft add rule inet filter input ct state invalid drop\n\n# Allow loopback\nnft add rule inet filter input iif lo accept\n\n# Allow SSH only from management subnet\nnft add rule inet filter input ip saddr 10.0.0.0/24 tcp dport 22 accept\n\n# Allow ICMP (Ping)\nnft add rule inet filter input ip protocol icmp accept\n\necho \"nftables configuration applied.\""}
{"instruction": "Write a Python script to check a given website URL for the presence of critical security headers (X-Frame-Options, Content-Security-Policy, Strict-Transport-Security).", "output": "import requests\n\ndef check_headers(url):\n    try:\n        response = requests.get(url)\n        headers = response.headers\n        security_headers = [\n            'X-Frame-Options',\n            'Content-Security-Policy',\n            'Strict-Transport-Security',\n            'X-Content-Type-Options',\n            'Referrer-Policy'\n        ]\n        \n        print(f\"Scanning headers for: {url}\")\n        for header in security_headers:\n            if header in headers:\n                print(f\"[+] {header}: Present\")\n            else:\n                print(f\"[-] {header}: Missing\")\n                \n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    target_url = input(\"Enter URL (e.g., https://example.com): \")\n    check_headers(target_url)"}
{"instruction": "Create a Bash script using 'awk' to parse an Apache/Nginx access log and list the top 10 IP addresses by request count.", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/nginx/access.log\"\n\nif [ ! -f \"$LOG_FILE\" ]; then\n    echo \"Log file not found!\"\n    exit 1\nfi\n\necho \"Top 10 IP addresses by request count:\"\nawk '{print $1}' \"$LOG_FILE\" | sort | uniq -c | sort -nr | head -n 10"}
{"instruction": "Write a Bash script that takes an IP address as an argument and adds an iptables rule to drop all incoming traffic from that IP.", "output": "#!/bin/bash\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 <IP_ADDRESS>\"\n    exit 1\nfi\n\nIP_TO_BLOCK=\"$1\"\n\n# Check if valid IP format (basic regex)\nif [[ $IP_TO_BLOCK =~ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n    echo \"Blocking IP: $IP_TO_BLOCK\"\n    iptables -A INPUT -s \"$IP_TO_BLOCK\" -j DROP\n    echo \"Rule added successfully.\"\nelse\n    echo \"Invalid IP address format.\"\n    exit 1\nfi"}
{"instruction": "Create a Python script that parses a Linux 'auth.log' file to detect potential brute-force SSH attacks by identifying IPs with more than 5 failed login attempts.", "output": "import re\nfrom collections import defaultdict\n\nLOG_FILE = '/var/log/auth.log'\nTHRESHOLD = 5\n\ndef detect_brute_force():\n    failed_attempts = defaultdict(int)\n    # Regex to capture IP from sshd failed password lines\n    ip_pattern = re.compile(r'sshd\\[\\d+\\]: Failed password for .* from (\\d+\\.\\d+\\.\\d+\\.\\d+)')\n\n    try:\n        with open(LOG_FILE, 'r') as f:\n            for line in f:\n                match = ip_pattern.search(line)\n                if match:\n                    ip = match.group(1)\n                    failed_attempts[ip] += 1\n\n        print(f\"IPs with > {THRESHOLD} failed attempts:\")\n        for ip, count in failed_attempts.items():\n            if count > THRESHOLD:\n                print(f\"{ip}: {count} failures\")\n\n    except FileNotFoundError:\n        print(f\"File {LOG_FILE} not found.\")\n    except PermissionError:\n        print(\"Permission denied. Try running with sudo.\")\n\nif __name__ == \"__main__\":\n    detect_brute_force()"}
{"instruction": "Write a Bash script to harden SSH configuration by disabling root login and password authentication in '/etc/ssh/sshd_config'.", "output": "#!/bin/bash\n\nCONFIG_FILE=\"/etc/ssh/sshd_config\"\nBACKUP_FILE=\"/etc/ssh/sshd_config.bak\"\n\n# Create backup\ncp \"$CONFIG_FILE\" \"$BACKUP_FILE\"\necho \"Backup created at $BACKUP_FILE\"\n\n# Disable Root Login\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\nsed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$CONFIG_FILE\"\n\n# Disable Password Authentication\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\nsed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' \"$CONFIG_FILE\"\n\necho \"SSH Hardening applied. Verifying syntax...\"\nsshd -t\n\nif [ $? -eq 0 ]; then\n    echo \"Syntax OK. Restarting SSH service...\"\n    systemctl restart sshd\nelse\n    echo \"Syntax error detected. Reverting changes...\"\n    cp \"$BACKUP_FILE\" \"$CONFIG_FILE\"\nfi"}
{"instruction": "Generate a Python script that uses the 'socket' library to perform a simple scan on a local subnet to identify active hosts on port 80.", "output": "import socket\nimport ipaddress\n\ndef scan_subnet(subnet):\n    network = ipaddress.ip_network(subnet)\n    print(f\"Scanning {subnet} for active hosts on port 80...\")\n    \n    for ip in network.hosts():\n        ip_str = str(ip)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((ip_str, 80))\n        \n        if result == 0:\n            print(f\"[+] {ip_str}: Port 80 OPEN\")\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Example subnet\n    target_subnet = \"192.168.1.0/24\"\n    scan_subnet(target_subnet)"}
{"instruction": "Write a Bash script to generate a basic 'nftables' ruleset that flushes existing rules, allows established traffic, allows SSH (port 22), and drops everything else.", "output": "#!/bin/bash\n\necho \"Applying basic nftables hardening rules...\"\n\n# Create table\nnft add table inet filter\n\n# Flush existing chain\nnft flush chain inet filter input\n\n# Create base chain with default policy DROP\nnft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n\n# Allow loopback interface\nnft add rule inet filter input iif lo accept\n\n# Allow established and related connections\nnft add rule inet filter input ct state established,related accept\n\n# Allow SSH\nnft add rule inet filter input tcp dport 22 accept\n\necho \"Rules applied. Current ruleset:\"\nnft list ruleset"}
{"instruction": "Create a Python script that generates 'iptables' commands to whitelist a specific list of trusted IP addresses for port 443 access.", "output": "trusted_ips = [\n    \"192.168.1.10\",\n    \"10.0.0.5\",\n    \"172.16.0.20\"\n]\n\ndef generate_whitelist_rules(ips, port):\n    print(f\"# Generating Whitelist for Port {port}\")\n    # Create new chain\n    print(f\"iptables -N WHITELIST_{port}\")\n    \n    # Add IPs to chain\n    for ip in ips:\n        print(f\"iptables -A WHITELIST_{port} -s {ip} -p tcp --dport {port} -j ACCEPT\")\n    \n    # Link chain to INPUT and drop others for this port (optional strategy)\n    print(f\"iptables -A INPUT -p tcp --dport {port} -j WHITELIST_{port}\")\n    print(f\"iptables -A INPUT -p tcp --dport {port} -j DROP\")\n\nif __name__ == \"__main__\":\n    generate_whitelist_rules(trusted_ips, 443)"}
{"instruction": "Write a Bash script to search for world-writable files in the '/home' directory and save the list to a report file for security auditing.", "output": "#!/bin/bash\n\nSEARCH_DIR=\"/home\"\nREPORT_FILE=\"/var/log/world_writable_audit.txt\"\n\necho \"Starting audit for world-writable files in $SEARCH_DIR...\"\n\n# Find files with write permission for 'others'\nfind \"$SEARCH_DIR\" -type f -perm -o+w -print > \"$REPORT_FILE\" 2>/dev/null\n\nCOUNT=$(wc -l < \"$REPORT_FILE\")\n\necho \"Audit complete. Found $COUNT world-writable files.\"\necho \"Report saved to $REPORT_FILE\""}
{"instruction": "Create a Python script to check the permission bits of critical system files (e.g., /etc/shadow, /etc/passwd) and alert if they are compliant with security best practices.", "output": "import os\nimport stat\n\nfiles_to_check = {\n    \"/etc/shadow\": \"600\", # Owner read/write only\n    \"/etc/passwd\": \"644\", # Owner rw, others r\n    \"/etc/group\": \"644\",\n    \"/etc/gshadow\": \"600\"\n}\n\ndef check_permissions():\n    print(\"Checking critical file permissions...\")\n    for filepath, expected_octal in files_to_check.items():\n        if not os.path.exists(filepath):\n            print(f\"[!] {filepath} does not exist.\")\n            continue\n            \n        # Get file mode\n        st = os.stat(filepath)\n        # Convert to octal string (last 3 digits)\n        actual_octal = oct(st.st_mode)[-3:]\n        \n        if actual_octal == expected_octal:\n            print(f\"[OK] {filepath}: {actual_octal}\")\n        else:\n            print(f\"[ALERT] {filepath}: Expected {expected_octal}, found {actual_octal}\")\n\nif __name__ == \"__main__\":\n    check_permissions()"}
{"instruction": "Write a Python script to scan a specific IP address for open ports within a defined range (basic vulnerability scanning).", "output": "import socket\n\ndef scan_ports(target_ip, start_port, end_port):\n    print(f\"Scanning {target_ip} from port {start_port} to {end_port}...\")\n    open_ports = []\n    \n    for port in range(start_port, end_port + 1):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(0.5)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    \n    return open_ports\n\nif __name__ == \"__main__\":\n    target = \"192.168.1.10\"  # Example Target\n    ports = scan_ports(target, 20, 100)\n    if ports:\n        print(f\"Open ports found: {ports}\")\n    else:\n        print(\"No open ports found in range.\")"}
{"instruction": "Create a Bash script to analyze `/var/log/auth.log` and list IP addresses with more than 10 failed SSH login attempts (SIEM/Log Analysis).", "output": "#!/bin/bash\n\nLOG_FILE=\"/var/log/auth.log\"\nTHRESHOLD=10\n\necho \"Analyzing $LOG_FILE for failed SSH login attempts...\"\n\n# Extract IPs from 'Failed password' lines, count occurrences, and filter by threshold\ngrep \"Failed password\" \"$LOG_FILE\" | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | while read count ip; do\n    if [ \"$count\" -gt \"$THRESHOLD\" ]; then\n        echo \"Suspicious IP: $ip (Attempts: $count)\"\n    fi\ndone"}
{"instruction": "Write a Python script that checks a website's HTTP response headers for missing security headers like X-Frame-Options and Content-Security-Policy.", "output": "import requests\n\ndef check_security_headers(url):\n    required_headers = [\n        \"X-Frame-Options\",\n        \"X-XSS-Protection\",\n        \"Content-Security-Policy\",\n        \"Strict-Transport-Security\",\n        \"X-Content-Type-Options\"\n    ]\n    \n    try:\n        response = requests.get(url)\n        print(f\"Checking headers for: {url}\")\n        headers = response.headers\n        \n        for header in required_headers:\n            if header in headers:\n                print(f\"[OK] {header} is present.\")\n            else:\n                print(f\"[MISSING] {header} is not set.\")\n                \n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to {url}: {e}\")\n\nif __name__ == \"__main__\":\n    check_security_headers(\"http://example.com\")"}
{"instruction": "Generate a Bash script to configure `iptables` to drop all incoming traffic by default, but allow SSH (port 22), HTTP (port 80), and HTTPS (port 443).", "output": "#!/bin/bash\n\n# Flush existing rules\niptables -F\niptables -X\n\n# Set default policies to DROP\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow loopback traffic\niptables -A INPUT -i lo -j ACCEPT\n\n# Allow established and related connections\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH, HTTP, and HTTPS\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\necho \"Firewall rules applied successfully.\""}
{"instruction": "Write a Python script to parse an Apache access log file and identify requests that contain common SQL injection patterns.", "output": "import re\n\ndef detect_sqli(log_path):\n    sqli_patterns = [\n        r\"UNION SELECT\",\n        r\"' OR '1'='1\",\n        r\"--\",\n        r\"WAITFOR DELAY\",\n        r\"SELECT .* FROM\"\n    ]\n    \n    print(f\"Scanning {log_path} for SQL Injection patterns...\")\n    try:\n        with open(log_path, 'r') as file:\n            for line in file:\n                for pattern in sqli_patterns:\n                    if re.search(pattern, line, re.IGNORECASE):\n                        print(f\"[ALERT] Potential SQLi detected: {line.strip()}\")\n                        break\n    except FileNotFoundError:\n        print(\"Log file not found.\")\n\nif __name__ == \"__main__\":\n    detect_sqli(\"/var/log/apache2/access.log\")"}
{"instruction": "Create a Bash script to harden the SSH configuration by disabling root login and password authentication in `/etc/ssh/sshd_config`.", "output": "#!/bin/bash\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\nBACKUP_CONFIG=\"/etc/ssh/sshd_config.bak\"\n\n# Backup existing config\ncp \"$SSHD_CONFIG\" \"$BACKUP_CONFIG\"\necho \"Backup created at $BACKUP_CONFIG\"\n\n# Disable Root Login\nsed -i 's/^#\\?PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\n\n# Disable Password Authentication\nsed -i 's/^#\\?PasswordAuthentication.*/PasswordAuthentication no/' \"$SSHD_CONFIG\"\n\n# Check for syntax errors\nsshd -t\nif [ $? -eq 0 ]; then\n    systemctl restart sshd\n    echo \"SSH hardening applied and service restarted.\"\nelse\n    echo \"Configuration error. Reverting changes.\"\n    cp \"$BACKUP_CONFIG\" \"$SSHD_CONFIG\"\nfi"}
{"instruction": "Write a Python script that reads a list of malicious IP addresses from a text file and generates an `nftables` configuration to block them.", "output": "def generate_nftables_blocklist(ip_file, output_file):\n    try:\n        with open(ip_file, 'r') as f:\n            ips = [line.strip() for line in f if line.strip()]\n        \n        if not ips:\n            print(\"No IPs found to block.\")\n            return\n\n        nft_config = \"table inet filter {\\n\"\n        nft_config += \"    chain input {\\n\"\n        nft_config += \"        type filter hook input priority 0; policy accept;\\n\"\n        \n        # Add rules for each IP\n        for ip in ips:\n            nft_config += f\"        ip saddr {ip} drop\\n\"\n            \n        nft_config += \"    }\\n}\"\n\n        with open(output_file, 'w') as f:\n            f.write(nft_config)\n            \n        print(f\"nftables configuration generated at {output_file}\")\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    # Assume blocklist.txt contains one IP per line\n    generate_nftables_blocklist(\"blocklist.txt\", \"nftables_block.conf\")"}
{"instruction": "Generate a Bash script to ensure critical system files like `/etc/passwd`, `/etc/shadow`, and `/etc/group` have the correct permissions and ownership (Hardening).", "output": "#!/bin/bash\n\necho \"Hardening file permissions...\"\n\n# /etc/passwd: root:root, 644\nchown root:root /etc/passwd\nchmod 644 /etc/passwd\necho \"/etc/passwd permissions set.\"\n\n# /etc/group: root:root, 644\nchown root:root /etc/group\nchmod 644 /etc/group\necho \"/etc/group permissions set.\"\n\n# /etc/shadow: root:shadow, 640 (More restrictive)\nchown root:shadow /etc/shadow\nchmod 640 /etc/shadow\necho \"/etc/shadow permissions set.\"\n\n# /etc/gshadow: root:shadow, 640\nchown root:shadow /etc/gshadow\nchmod 640 /etc/gshadow\necho \"/etc/gshadow permissions set.\""}
{"instruction": "Write a Python script for File Integrity Monitoring (FIM) that calculates and stores SHA-256 hashes of files in a specified directory.", "output": "import hashlib\nimport os\nimport json\n\ndef calculate_sha256(filepath):\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(filepath, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    except (IOError, OSError):\n        return None\n\ndef monitor_directory(directory, output_file):\n    file_hashes = {}\n    print(f\"Calculating hashes for files in {directory}...\")\n    \n    for root, _, files in os.walk(directory):\n        for file in files:\n            filepath = os.path.join(root, file)\n            file_hash = calculate_sha256(filepath)\n            if file_hash:\n                file_hashes[filepath] = file_hash\n    \n    with open(output_file, 'w') as f:\n        json.dump(file_hashes, f, indent=4)\n    print(f\"Baseline saved to {output_file}\")\n\nif __name__ == \"__main__\":\n    monitor_directory(\"/etc/\", \"fim_baseline.json\")"}
{"instruction": "Create a Bash script to search the entire filesystem for world-writable files and save the list to a report (Vulnerability Assessment/Hardening).", "output": "#!/bin/bash\n\nOUTPUT_FILE=\"world_writable_files.txt\"\n\necho \"Scanning for world-writable files... This may take a while.\"\n\n# Find files with write permission for 'others' (-perm -0002)\n# Exclude /proc, /sys, and /dev to avoid false positives and errors\nfind / -xdev -type f -perm -0002 -print 2>/dev/null > \"$OUTPUT_FILE\"\n\necho \"Scan complete. Results saved to $OUTPUT_FILE\"\n\n# Display count\nCOUNT=$(wc -l < \"$OUTPUT_FILE\")\necho \"Found $COUNT world-writable files.\""}
